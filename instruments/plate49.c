/* Automatically generated file. Do not edit. 
 * Format:     ANSI C source code
 * Creator:    McXtrace <http://www.mcxtrace.org>
 * Instrument: instruments/plate49.instr (AthenaModule)
 * Date:       Sat Nov  4 04:11:55 2017
 * File:       instruments/plate49.c
 * Compile:    cc -o AthenaModule.out instruments/plate49.c 
 * CFLAGS=
 */


#define MCCODE_STRING "McXtrace 1.4 - Jun. 09, 2017"
#define FLAVOR "mcxtrace"
#define FLAVOR_UPPER "MCXTRACE"
#define MC_USE_DEFAULT_MAIN
#define MC_EMBEDDED_RUNTIME

#line 1 "mccode-r.h"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McXtrace 1.4
* Version: $Revision$
*
* Runtime system header for McStas/McXtrace.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas/McXtrace version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCCODE_R_H
#define MCCODE_R_H "$Revision$"

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <time.h>
#include <float.h>
#include <inttypes.h>

/* If the runtime is embedded in the simulation program, some definitions can
   be made static. */

#ifdef MC_EMBEDDED_RUNTIME
#define mcstatic static
#else
#define mcstatic
#endif

#ifdef __dest_os
#if (__dest_os == __mac_os)
#define MAC
#endif
#endif

#ifdef __FreeBSD__
#define NEED_STAT_H
#endif

#if defined(__APPLE__) && defined(__GNUC__)
#define NEED_STAT_H
#endif

#ifdef NEED_STAT_H
#include <sys/stat.h>
#endif

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !WIN32 */
#endif /* MC_PATHSEP_C */



/* the version string is replaced when building distribution with mkdist */
#ifndef MCCODE_STRING
#define MCCODE_STRING "McXtrace 1.4 - Jun. 09, 2017"
#endif

#ifndef MCCODE_DATE
#define MCCODE_DATE "Jun. 09, 2017"
#endif

#ifndef MCCODE_VERSION
#define MCCODE_VERSION "1.4"
#endif

#ifndef MCCODE_NAME
#define MCCODE_NAME "McXtrace"
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE "xray"
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV "MCXTRACE"
#endif

#ifndef FLAVOR_UPPER
#define FLAVOR_UPPER MCCODE_NAME
#endif

#ifdef MC_PORTABLE
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#ifdef MAC
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (USE_MPI == 0)
#undef USE_MPI
#endif

#ifdef USE_MPI  /* default is to disable signals with MPI, as MPICH uses them to communicate */
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (NOSIGNALS == 0)
#undef NOSIGNALS
#endif

/* Note: the enum instr_formal_types definition MUST be kept
   synchronized with the one in mccode.h and with the
   instr_formal_type_names array in cogen.c. */
enum instr_formal_types
  {
    instr_type_double, instr_type_int, instr_type_string
  };
struct mcinputtable_struct { /* defines instrument parameters */
  char *name; /* name of parameter */
  void *par;  /* pointer to instrument parameter (variable) */
  enum instr_formal_types type;
  char *val;  /* default value */
};

typedef double MCNUM;
typedef struct {MCNUM x, y, z;} Coords;
typedef MCNUM Rotation[3][3];

/* the following variables are defined in the McStas generated C code
   but should be defined externally in case of independent library usage */
#ifndef DANSE
extern struct mcinputtable_struct mcinputtable[]; /* list of instrument parameters */
extern int    mcnumipar;                          /* number of instrument parameters */
extern char   mcinstrument_name[], mcinstrument_source[]; /* instrument name and filename */
extern char  *mcinstrument_exe;                           /* executable path = argv[0] or NULL */
extern MCNUM  mccomp_storein[]; /* 11 coords * number of components in instrument */
extern MCNUM  mcAbsorbProp[];
extern MCNUM  mcScattered;      /* number of SCATTER calls in current component */
extern MCNUM  mcRestore;        /* Flag to indicate if neutron needs to be restored */
#ifndef MC_ANCIENT_COMPATIBILITY
extern int mctraceenabled, mcdefaultmain;
#endif
#endif


/* Useful macros ============================================================ */

/* MPI stuff */

#ifdef USE_MPI
#include "mpi.h"

#ifdef OMPI_MPI_H  /* openmpi does not use signals: we may install our sighandler */
#undef NOSIGNALS
#endif

/*
 * MPI_MASTER(i):
 * execution of i only on master node
 */
#define MPI_MASTER(statement) { \
  if(mpi_node_rank == mpi_node_root)\
  { statement; } \
}

#ifndef MPI_REDUCE_BLOCKSIZE
#define MPI_REDUCE_BLOCKSIZE 1000
#endif

int mc_MPI_Sum(double* buf, long count);
int mc_MPI_Send(void *sbuf, long count, MPI_Datatype dtype, int dest);
int mc_MPI_Recv(void *rbuf, long count, MPI_Datatype dtype, int source);

/* MPI_Finalize exits gracefully and should be preferred to MPI_Abort */
#define exit(code) do {                                   \
    MPI_Finalize();                                       \
    exit(code);                                           \
  } while(0)

#else /* !USE_MPI */
#define MPI_MASTER(instr) instr
#endif /* USE_MPI */

#ifdef USE_MPI
static int mpi_node_count;
#endif

#ifdef USE_THREADS  /* user want threads */
#error Threading (USE_THREADS) support has been removed for very poor efficiency. Use MPI/SSH grid instead.
#endif


void   mcset_ncount(unsigned long long count);    /* wrapper to get mcncount */
unsigned long long int mcget_ncount(void);            /* wrapper to set mcncount */
unsigned long long mcget_run_num(void);           /* wrapper to get mcrun_num=0:mcncount */


/* Following part is only embedded when not redundant with mccode.h ========= */

#ifndef MCCODE_H

#ifndef NOSIGNALS
#include <signal.h>
#define SIG_MESSAGE(msg) strcpy(mcsig_message, msg);
#else
#define SIG_MESSAGE(msg)
#endif /* !NOSIGNALS */

/* Useful macros and constants ============================================== */

#ifndef FLT_MAX
#define FLT_MAX         3.40282347E+38F /* max decimal value of a "float" */
#endif

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif
#ifndef SQR
#define SQR(x) ( (x) * (x) )
#endif
#ifndef SIGN
#define SIGN(x) (((x)>0.0)?(1):(-1))
#endif

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
#  define PI 3.14159265358979323846
# endif
#endif

#define RAD2MIN  ((180*60)/PI)
#define MIN2RAD  (PI/(180*60))
#define DEG2RAD  (PI/180)
#define RAD2DEG  (180/PI)
#define FWHM2RMS 0.424660900144    /* Convert between full-width-half-max and */
#define RMS2FWHM 2.35482004503     /* root-mean-square (standard deviation) */
#define HBAR     1.05457168e-34    /* [Js] h bar Planck constant CODATA 2002 */
#define MNEUTRON 1.67492728e-27    /* [kg] mass of neutron CODATA 2002 */
#define GRAVITY  9.81              /* [m/s^2] gravitational acceleration */
#define NA       6.02214179e23     /* [#atoms/g .mole] Avogadro's number*/


/* wrapper to get absolute and relative position of comp */
/* mccomp_posa and mccomp_posr are defined in McStas generated C code */
#define POS_A_COMP_INDEX(index) \
    (mccomp_posa[index])
#define POS_R_COMP_INDEX(index) \
    (mccomp_posr[index])
/* number of SCATTER calls in current comp: mcScattered defined in generated C code */
#define SCATTERED mcScattered
/* Flag to indicate if neutron needs to be restored: mcRestore defined in generated C code */
#define RESTORE mcRestore


/* Retrieve component information from the kernel */
/* Name, position and orientation (both absolute and relative)  */
/* Any component: For "redundancy", see comment by KN */
#define tmp_name_comp(comp) #comp
#define NAME_COMP(comp) tmp_name_comp(comp)
#define tmp_pos_a_comp(comp) (mcposa ## comp)
#define POS_A_COMP(comp) tmp_pos_a_comp(comp)
#define tmp_pos_r_comp(comp) (mcposr ## comp)
#define POS_R_COMP(comp) tmp_pos_r_comp(comp)
#define tmp_rot_a_comp(comp) (mcrota ## comp)
#define ROT_A_COMP(comp) tmp_rot_a_comp(comp)
#define tmp_rot_r_comp(comp) (mcrotr ## comp)
#define ROT_R_COMP(comp) tmp_rot_r_comp(comp)

/* Current component name, index, position and orientation */
#define NAME_CURRENT_COMP  NAME_COMP(mccompcurname)
#define INDEX_CURRENT_COMP mccompcurindex
#define POS_A_CURRENT_COMP POS_A_COMP(mccompcurname)
#define POS_R_CURRENT_COMP POS_R_COMP(mccompcurname)
#define ROT_A_CURRENT_COMP ROT_A_COMP(mccompcurname)
#define ROT_R_CURRENT_COMP ROT_R_COMP(mccompcurname)

/* Note: The two-stage approach to MC_GETPAR is NOT redundant; without it,
* after #define C sample, MC_GETPAR(C,x) would refer to component C, not to
* component sample. Such are the joys of ANSI C.

* Anyway the usage of MCGETPAR requires that we use sometimes bare names...
*/
#define MC_GETPAR2(comp, par) (mcc ## comp ## _ ## par)
#define MC_GETPAR(comp, par) MC_GETPAR2(comp,par)

/* MCDISPLAY/trace and debugging message sent to stdout */
#ifdef MC_TRACE_ENABLED
#define DEBUG
#endif

#ifdef DEBUG
#define mcDEBUG_INSTR() if(!mcdotrace); else { printf("INSTRUMENT:\n"); printf("Instrument '%s' (%s)\n", mcinstrument_name, mcinstrument_source); }
#define mcDEBUG_COMPONENT(name,c,t) if(!mcdotrace); else {\
  printf("COMPONENT: \"%s\"\n" \
         "POS: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         name, c.x, c.y, c.z, t[0][0], t[0][1], t[0][2], \
         t[1][0], t[1][1], t[1][2], t[2][0], t[2][1], t[2][2]); \
  mcAccumulatedILength += coords_len(coords_sub(mcLastComp,c)); \
  printf("Component %30s AT (%g,%g,%g)    %g m from origin\n", name, c.x, c.y, c.z, mcAccumulatedILength); \
  mcLastComp=c;\
  }
#define mcDEBUG_INSTR_END() if(!mcdotrace); else printf("INSTRUMENT END:\n");
#define mcDEBUG_ENTER() if(!mcdotrace); else printf("ENTER:\n");
#define mcDEBUG_COMP(c) if(!mcdotrace); else printf("COMP: \"%s\"\n", c);
#define mcDEBUG_LEAVE() if(!mcdotrace); else printf("LEAVE:\n");
#define mcDEBUG_ABSORB() if(!mcdotrace); else printf("ABSORB:\n");
#else
#define mcDEBUG_INSTR()
#define mcDEBUG_COMPONENT(name,c,t)
#define mcDEBUG_INSTR_END()
#define mcDEBUG_ENTER()
#define mcDEBUG_COMP(c)
#define mcDEBUG_LEAVE()
#define mcDEBUG_ABSORB()
#endif

// mcDEBUG_STATE and mcDEBUG_SCATTER are defined by mcstas-r.h and mcxtrace-r.h



#ifdef TEST
#define test_printf printf
#else
#define test_printf while(0) printf
#endif

/* send MCDISPLAY message to stdout to show gemoetry */
void mcdis_magnify(char *what);
void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2);
void mcdis_dashed_linemcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n);
void mcdis_multiline(int count, ...);
void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height);
void mcdis_box(double x, double y, double z,
	       double width, double height, double length);
void mcdis_circle(char *plane, double x, double y, double z, double r);

/* selection of random number generator. default is MT */
#ifndef MC_RAND_ALG
#define MC_RAND_ALG 1
#endif

#if MC_RAND_ALG == 0
   /* Use system random() (not recommended). */
#  define MC_RAND_MAX RAND_MAX
#elif MC_RAND_ALG == 1
   /* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
#  define MC_RAND_MAX ((unsigned long)0xffffffff)
#  define random mt_random
#  define srandom mt_srandom
#elif MC_RAND_ALG == 2
   /* Algorithm used in McStas CVS-080208 and earlier (not recommended). */
#  define MC_RAND_MAX 0x7fffffff
#  define random mc_random
#  define srandom mc_srandom
#else
#  error "Bad value for random number generator choice."
#endif

typedef int mc_int32_t;
mc_int32_t mc_random(void);
void mc_srandom (unsigned int x);
unsigned long mt_random(void);
void mt_srandom (unsigned long x);

double rand01();
double randpm1();
double rand0max(double max);
double randminmax(double min, double max);

double randnorm(void);
double randtriangle(void);

#ifndef DANSE
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);
#endif

/* simple vector algebra ==================================================== */
#define vec_prod(x, y, z, x1, y1, z1, x2, y2, z2) \
	vec_prod_func(&x, &y, &z, x1, y1, z1, x2, y2, z2)
mcstatic inline void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1, double x2, double y2, double z2);

mcstatic inline double scalar_prod(
		double x1, double y1, double z1, double x2, double y2, double z2);

#define NORM(x,y,z) \
	norm_func(&x, &y, &z)
mcstatic inline void norm_func(double *x, double *y, double *z) {
	double temp = (*x * *x) + (*y * *y) + (*z * *z);
	if (temp != 0) {
		temp = sqrt(temp);
		*x /= temp;
		*y /= temp;
		*z /= temp;
	}
}
#define normal_vec(nx, ny, nz, x, y, z) \
    normal_vec_func(&(nx), &(ny), &(nz), x, y, z)
mcstatic inline void normal_vec_func(double *nx, double *ny, double *nz,
    double x, double y, double z);

/**
 * Rotate the vector vx,vy,vz psi radians around the vector ax,ay,az
 * and put the result in x,y,z.
 */
#define rotate(x, y, z, vx, vy, vz, phi, ax, ay, az) \
  do { \
    double mcrt_tmpx = (ax), mcrt_tmpy = (ay), mcrt_tmpz = (az); \
    double mcrt_vp, mcrt_vpx, mcrt_vpy, mcrt_vpz; \
    double mcrt_vnx, mcrt_vny, mcrt_vnz, mcrt_vn1x, mcrt_vn1y, mcrt_vn1z; \
    double mcrt_bx, mcrt_by, mcrt_bz; \
    double mcrt_cos, mcrt_sin; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vp = scalar_prod((vx), (vy), (vz), mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vpx = mcrt_vp*mcrt_tmpx; \
    mcrt_vpy = mcrt_vp*mcrt_tmpy; \
    mcrt_vpz = mcrt_vp*mcrt_tmpz; \
    mcrt_vnx = (vx) - mcrt_vpx; \
    mcrt_vny = (vy) - mcrt_vpy; \
    mcrt_vnz = (vz) - mcrt_vpz; \
    vec_prod(mcrt_bx, mcrt_by, mcrt_bz, \
             mcrt_tmpx, mcrt_tmpy, mcrt_tmpz, mcrt_vnx, mcrt_vny, mcrt_vnz); \
    mcrt_cos = cos((phi)); mcrt_sin = sin((phi)); \
    mcrt_vn1x = mcrt_vnx*mcrt_cos + mcrt_bx*mcrt_sin; \
    mcrt_vn1y = mcrt_vny*mcrt_cos + mcrt_by*mcrt_sin; \
    mcrt_vn1z = mcrt_vnz*mcrt_cos + mcrt_bz*mcrt_sin; \
    (x) = mcrt_vpx + mcrt_vn1x; \
    (y) = mcrt_vpy + mcrt_vn1y; \
    (z) = mcrt_vpz + mcrt_vn1z; \
  } while(0)

/**
 * Mirror (xyz) in the plane given by the point (rx,ry,rz) and normal (nx,ny,nz)
 *
 * TODO: This define is seemingly never used...
 */
#define mirror(x,y,z,rx,ry,rz,nx,ny,nz) \
  do { \
    double mcrt_tmpx= (nx), mcrt_tmpy = (ny), mcrt_tmpz = (nz); \
    double mcrt_tmpt; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_tmpt=scalar_prod((rx),(ry),(rz),mcrt_tmpx,mcrt_tmpy,mcrt_tmpz); \
    (x) = rx -2 * mcrt_tmpt*mcrt_rmpx; \
    (y) = ry -2 * mcrt_tmpt*mcrt_rmpy; \
    (z) = rz -2 * mcrt_tmpt*mcrt_rmpz; \
  } while (0)

Coords coords_set(MCNUM x, MCNUM y, MCNUM z);
Coords coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z);
Coords coords_add(Coords a, Coords b);
Coords coords_sub(Coords a, Coords b);
Coords coords_neg(Coords a);
Coords coords_scale(Coords b, double scale);
double coords_sp(Coords a, Coords b);
Coords coords_xp(Coords b, Coords c);
double coords_len(Coords a);
void   coords_print(Coords a);
mcstatic inline void coords_norm(Coords* c);

void rot_set_rotation(Rotation t, double phx, double phy, double phz);
int  rot_test_identity(Rotation t);
void rot_mul(Rotation t1, Rotation t2, Rotation t3);
void rot_copy(Rotation dest, Rotation src);
void rot_transpose(Rotation src, Rotation dst);
Coords rot_apply(Rotation t, Coords a);

void mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
    double *vx, double *vy, double *vz, double *sx, double *sy, double *sz);
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz);

double mcestimate_error(double N, double p1, double p2);
void mcreadparams(void);

/* this is now in mcstas-r.h and mcxtrace-r.h as the number of state parameters is no longer equal*/
/* void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);
*/
void mcgenstate(void);

/* trajectory/shape intersection routines */
int inside_rectangle(double, double, double, double);
int box_intersect(double *dt_in, double *dt_out, double x, double y, double z,
    double vx, double vy, double vz, double dx, double dy, double dz);
int cylinder_intersect(double *t0, double *t1, double x, double y, double z,
    double vx, double vy, double vz, double r, double h);
int sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r);
/* second order equation roots */
int solve_2nd_order(double *t1, double *t2,
    double A,  double B,  double C);

/* random vector generation to shape */
void randvec_target_circle(double *xo, double *yo, double *zo,
    double *solid_angle, double xi, double yi, double zi, double radius);
#define randvec_target_sphere randvec_target_circle
void randvec_target_rect_angular(double *xo, double *yo, double *zo,
    double *solid_angle,
               double xi, double yi, double zi, double height, double width, Rotation A);
#define randvec_target_rect(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)  randvec_target_rect_real(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,0,0,0,1)
void randvec_target_rect_real(double *xo, double *yo, double *zo,
    double *solid_angle,
	       double xi, double yi, double zi, double height, double width, Rotation A,
			 double lx, double ly, double lz, int order);

/* this is the main() */
int mccode_main(int argc, char *argv[]);


#endif /* !MCCODE_H */

#ifndef MCCODE_R_IO_H
#define MCCODE_R_IO_H "$Revision$"

#if (USE_NEXUS == 0)
#undef USE_NEXUS
#endif

#ifndef CHAR_BUF_LENGTH
#define CHAR_BUF_LENGTH 1024
#endif

/* I/O section part ========================================================= */

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */


/* main DETECTOR structure which stores most information to write to data files */
struct mcdetector_struct {
  char   filename[CHAR_BUF_LENGTH];   /* file name of monitor */
  char   position[CHAR_BUF_LENGTH];   /* position of detector component */
  char   component[CHAR_BUF_LENGTH];  /* component instance name */
  char   instrument[CHAR_BUF_LENGTH]; /* instrument name */
  char   type[CHAR_BUF_LENGTH];       /* data type, e.g. 0d, 1d, 2d, 3d */
  char   user[CHAR_BUF_LENGTH];       /* user name, e.g. HOME */
  char   date[CHAR_BUF_LENGTH];       /* date of simulation end/write time */
  char   title[CHAR_BUF_LENGTH];      /* title of detector */
  char   xlabel[CHAR_BUF_LENGTH];     /* X axis label */
  char   ylabel[CHAR_BUF_LENGTH];     /* Y axis label */
  char   zlabel[CHAR_BUF_LENGTH];     /* Z axis label */
  char   xvar[CHAR_BUF_LENGTH];       /* X variable name */
  char   yvar[CHAR_BUF_LENGTH];       /* Y variable name */
  char   zvar[CHAR_BUF_LENGTH];       /* Z variable name */
  char   ncount[CHAR_BUF_LENGTH];     /* number of events initially generated */
  char   limits[CHAR_BUF_LENGTH];     /* X Y Z limits, e.g. [xmin xmax ymin ymax zmin zmax] */
  char   variables[CHAR_BUF_LENGTH];  /* variables written into data block */
  char   statistics[CHAR_BUF_LENGTH]; /* center, mean and half width along axis */
  char   signal[CHAR_BUF_LENGTH];     /* min max and mean of signal (data block) */
  char   values[CHAR_BUF_LENGTH];     /* integrated values e.g. [I I_err N] */
  double xmin,xmax;                   /* min max of axes */
  double ymin,ymax;
  double zmin,zmax;
  double intensity;                   /* integrated values for data block */
  double error;
  double events;
  double min;                         /* statistics for data block */
  double max;
  double mean;
  double centerX;                     /* statistics for axes */
  double halfwidthX;
  double centerY;
  double halfwidthY;
  int    rank;                        /* dimensionaly of monitor, e.g. 0 1 2 3 */
  char   istransposed;                /* flag to transpose matrix for some formats */

  long   m,n,p;                       /* dimensions of data block and along axes */
  long   date_l;                      /* same as date, but in sec since 1970 */

  double *p0, *p1, *p2;               /* pointers to saved data, NULL when freed */
  char   format[CHAR_BUF_LENGTH];    /* format for file generation */
};

typedef struct mcdetector_struct MCDETECTOR;

static   char *mcdirname             = NULL;      /* name of output directory */
static   char *mcsiminfo_name        = "mccode";  /* default output sim file name */
char    *mcformat                    = NULL;      /* NULL (default) or a specific format */

/* file I/O definitions and function prototypes */

#ifndef MC_EMBEDDED_RUNTIME /* the mcstatic variables (from mccode-r.c) */
extern FILE * mcsiminfo_file;     /* handle to the output siminfo file */
extern int    mcgravitation;      /* flag to enable gravitation */
extern int    mcdotrace;          /* flag to print MCDISPLAY messages */
#else
mcstatic FILE *mcsiminfo_file        = NULL;
#endif

/* I/O function prototypes ================================================== */

/* output functions */
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2, char *c, Coords pos);
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
                  char *xvar, double x1, double x2, long n,
                  double *p0, double *p1, double *p2, char *f, char *c, Coords pos);
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2, long m,
                  long n, double *p0, double *p1, double *p2, char *f,
                  char *c, Coords pos);
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa);

/* wrappers to output functions, that automatically set NAME and POSITION */
#define DETECTOR_OUT(p0,p1,p2) mcdetector_out_0D(NAME_CURRENT_COMP,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_0D(t,p0,p1,p2) mcdetector_out_0D(t,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f) \
     mcdetector_out_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f) \
     mcdetector_out_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)

#ifdef USE_NEXUS
#include "napi.h"
NXhandle nxhandle;
#endif

#endif /* ndef MCCODE_R_IO_H */

#endif /* MCCODE_R_H */
/* End of file "mccode-r.h". */

#line 690 "instruments/plate49.c"

#line 1 "mcxtrace-r.h"
/*******************************************************************************
*
* McXtrace, X-ray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcxtrace-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McXtrace X.Y
* Version: $Revision$
*
* Runtime system header for McXtrace.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McXtrace version"
*
* Usage: Automatically embbeded in the c code.
*
*******************************************************************************/

#ifndef MCXTRACE_R_H
#define MCXTRACE_R_H "$Revision$"

/* Following part is only embedded when not redundant with mcstas.h ========= */

#ifndef MCCODE_H

#define CELE     1.602176487e-19   /* [C] Elementary charge CODATA 2006*/
#define M_C      299792458         /* [m/s] speed of light CODATA 2006*/
#define E2K      0.506773091264796 /* Convert k[1/AA] to E [keV] (CELE/(HBAR*M_C)*1e-10)*1e3 */
#define K2E      1.97326972808327  /*Convert E[keV] to k[1/AA] (1e10*M_C*HBAR/CELE)/1e3 */
#define RE       2.8179402894e-5   /*[AA] Thomson scattering length*/

#define SCATTER do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlkx, mcnlky, mcnlkz, \
    mcnlphi, mcnlt, mcnlEx,mcnlEy,mcnlEz, mcnlp); mcScattered++;} while(0)
#define ABSORB do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlkx, mcnlky, mcnlkz, \
    mcnlphi, mcnlt, mcnlEx,mcnlEy,mcnlEz, mcnlp); mcDEBUG_ABSORB(); goto mcabsorb;} while(0)

#define STORE_XRAY(index, x,y,z, kx,ky,kz, phi, t, Ex,Ey,Ez, p) \
  mcstore_xray(mccomp_storein,index, x,y,z, kx,ky,kz, phi, t, Ex,Ey,Ez, p);
#define RESTORE_XRAY(index, x,y,z, kx,ky,kz, phi, t, Ex,Ey,Ez, p) \
  mcrestore_xray(mccomp_storein,index, &x,&y,&z, &kx,&ky,&kz, &phi, &t, &Ex,&Ey,&Ez, &p);

/*magnet stuff is probably redundant*/
#define MAGNET_ON \
  do { \
    mcMagnet = 1; \
  } while(0)

#define MAGNET_OFF \
  do { \
    mcMagnet = 0; \
  } while(0)

#define ALLOW_BACKPROP \
  do { \
    mcallowbackprop = 1; \
  } while(0)

#define DISALLOW_BACKPROP \
  do { \
    mcallowbackprop = 0; \
  } while(0)

#define PROP_MAGNET(dt) \
  do { \
    /* change coordinates from local system to magnet system */ \
    Rotation rotLM, rotTemp; \
    Coords   posLM = coords_sub(POS_A_CURRENT_COMP, mcMagnetPos); \
    rot_transpose(ROT_A_CURRENT_COMP, rotTemp); \
    rot_mul(rotTemp, mcMagnetRot, rotLM); \
    mcMagnetPrecession(mcnlx, mcnly, mcnlz, mcnlt, mcnlvx, mcnlvy, mcnlvz, \
	   	       &mcnlsx, &mcnlsy, &mcnlsz, dt, posLM, rotLM); \
  } while(0)

#define mcPROP_DT(dt) \
  do { \
    if (mcMagnet && dt > 0) PROP_MAGNET(dt);\
    mcnlx += mcnlvx*(dt); \
    mcnly += mcnlvy*(dt); \
    mcnlz += mcnlvz*(dt); \
    mcnlt += (dt); \
    if (isnan(p) || isinf(p)) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
  } while(0)

/*An interrupt a'la mcMagnet should be inserted below if there's non-zero permeability*/
/*perhaps some kind of PROP_POL*/

#define mcPROP_DL(dl) \
  do { \
    MCNUM k=sqrt( scalar_prod(mcnlkx,mcnlky,mcnlkz,mcnlkx,mcnlky,mcnlkz));\
    mcnlx += (dl)*mcnlkx/k;\
    mcnly += (dl)*mcnlky/k;\
    mcnlz += (dl)*mcnlkz/k;\
    mcnlphi += 1e10*k*(dl);\
    mcnlt += (dl)/((double)M_C);\
  }while (0)

/*gravity not an issue with x-rays*/
/* ADD: E. Farhi, Aug 6th, 2001 PROP_GRAV_DT propagation with acceleration. */
#define PROP_GRAV_DT(dt, Ax, Ay, Az) \
  do { \
    if(dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
    if (mcMagnet) printf("Spin precession gravity\n"); \
    mcnlx  += mcnlvx*(dt) + (Ax)*(dt)*(dt)/2; \
    mcnly  += mcnlvy*(dt) + (Ay)*(dt)*(dt)/2; \
    mcnlz  += mcnlvz*(dt) + (Az)*(dt)*(dt)/2; \
    mcnlvx += (Ax)*(dt); \
    mcnlvy += (Ay)*(dt); \
    mcnlvz += (Az)*(dt); \
    mcnlt  += (dt); \
    DISALLOW_BACKPROP;\
  } while(0)

/*adapted from PROP_DT(dt)*//*{{{*/
#define PROP_DL(dl) \
  do{ \
    if( dl <0 && mcallowbackprop == 0) { (mcAbsorbProp[INDEX_CURRENT_COMP])++; ABSORB; }; \
    mcPROP_DL(dl); \
    DISALLOW_BACKPROP;\
  } while (0)

#define PROP_DT(dt) \
  do { \
    if(dt < 0 ) { RESTORE=1; goto mcabsorbComp; };		    \
    if (mcgravitation) { Coords mcLocG; double mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    PROP_GRAV_DT(dt, mc_gx, mc_gy, mc_gz); } \
    else mcPROP_DT(dt); \
    DISALLOW_BACKPROP;\
  } while(0)/*}}}*/

#define PROP_Z0 \
  mcPROP_P0(z)

#define PROP_X0 \
  mcPROP_P0(x)

#define PROP_Y0 \
  mcPROP_P0(y)

#define mcPROP_P0(P) \
  do { \
    MCNUM mc_dl,mc_k; \
    if(mcnlk ## P == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_k=sqrt(scalar_prod(mcnlkx,mcnlky,mcnlkz,mcnlkx,mcnlky,mcnlkz));\
    mc_dl= -mcnl ## P * mc_k / mcnlk ## P;\
    if(mc_dl<0 && mcallowbackprop==0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; };\
    PROP_DL(mc_dl);\
  } while(0)

void mcsetstate(double x, double y, double z, double kx, double ky, double kz,
    double phi, double t, double Ex, double Ey, double Ez, double p);


#endif /* !MCCODE_H */


#ifdef DEBUG

#define mcDEBUG_STATE(x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) if(!mcdotrace); else \
  printf("STATE: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
      x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p);
#define mcDEBUG_SCATTER(x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) if(!mcdotrace); else \
  printf("SCATTER: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
      x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p);

#else

#define mcDEBUG_STATE(x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p)
#define mcDEBUG_SCATTER(x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p)

#endif


#endif /* MCXTRACE_R_H */
/* End of file "mcxtrace-r.h". */

#line 885 "instruments/plate49.c"

#line 1 "mccode-r.c"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y/McXtrace X.Y
* Version: $Revision$
*
* Runtime system for McStas and McXtrace.
* Embedded within instrument in runtime mode.
* Contains SECTIONS:
*   MPI handling (sum, send, recv)
*   format definitions
*   I/O
*   mcdisplay support
*   random numbers
*   coordinates handling
*   vectors math (solve 2nd order, normals, randvec...)
*   parameter handling
*   signal and main handlers
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/


/** Include header files to avoid implicit declarations (not allowed on LLVM) */
#include <ctype.h>
#include <sys/types.h>

// UNIX specific headers (non-Windows)
#if defined(__unix__) || defined(__APPLE__)
#include <unistd.h>
#include <sys/stat.h>
#endif


#ifndef DANSE
#ifdef MC_ANCIENT_COMPATIBILITY
int mctraceenabled = 0;
int mcdefaultmain  = 0;
#endif
/* else defined directly in the McCode generated C code */

static   long mcseed                 = 0; /* seed for random generator */
static   long mcstartdate            = 0; /* start simulation time */
static   int  mcdisable_output_files = 0; /* --no-output-files */
mcstatic int  mcgravitation          = 0; /* use gravitation flag, for PROP macros */
int      mcMagnet                    = 0; /* magnet stack flag */
mcstatic int  mcdotrace              = 0; /* flag for --trace and messages for DISPLAY */
int      mcallowbackprop             = 0;         /* flag to enable negative/backprop */

/* Number of particle histories to simulate. */
#ifdef NEUTRONICS
mcstatic unsigned long long int mcncount             = 1;
mcstatic unsigned long long int mcrun_num            = 0;
#else
mcstatic unsigned long long int mcncount             = 1000000;
mcstatic unsigned long long int mcrun_num            = 0;
#endif /* NEUTRONICS */

#else
#include "mcstas-globals.h"
#endif /* !DANSE */

/* SECTION: MPI handling ==================================================== */

#ifdef USE_MPI
/* MPI rank */
static int mpi_node_rank;
static int mpi_node_root = 0;


/*******************************************************************************
* mc_MPI_Reduce: Gathers arrays from MPI nodes using Reduce function.
*******************************************************************************/
int mc_MPI_Sum(double *sbuf, long count)
{
  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to reduce */
  else {
    /* we must cut the buffer into blocks not exceeding the MPI max buffer size of 32000 */
    long   offset=0;
    double *rbuf=NULL;
    int    length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */
    int    i=0;
    rbuf = calloc(count, sizeof(double));
    if (!rbuf)
      exit(-fprintf(stderr, "Error: Out of memory %li (mc_MPI_Sum)\n", count*sizeof(double)));
    while (offset < count) {
      if (!length || offset+length > count-1) length=count-offset;
      else length=MPI_REDUCE_BLOCKSIZE;
      if (MPI_Allreduce((double*)(sbuf+offset), (double*)(rbuf+offset),
              length, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD) != MPI_SUCCESS)
        return MPI_ERR_COUNT;
      offset += length;
    }

    for (i=0; i<count; i++) sbuf[i] = rbuf[i];
    free(rbuf);
  }
  return MPI_SUCCESS;
} /* mc_MPI_Sum */

/*******************************************************************************
* mc_MPI_Send: Send array to MPI node by blocks to avoid buffer limit
*******************************************************************************/
int mc_MPI_Send(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int dest)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to send */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Send((void*)(sbuf+offset*dsize), length, dtype, dest, tag++, MPI_COMM_WORLD) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Send */

/*******************************************************************************
* mc_MPI_Recv: Receives arrays from MPI nodes by blocks to avoid buffer limit
*             the buffer must have been allocated previously.
*******************************************************************************/
int mc_MPI_Recv(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int source)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to recv */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Recv((void*)(sbuf+offset*dsize), length, dtype, source, tag++,
            MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Recv */

#endif /* USE_MPI */

/* SECTION: parameters handling ============================================= */

/* Instrument input parameter type handling. */
/*******************************************************************************
* mcparm_double: extract double value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_double(char *s, void *vptr)
{
  char *p;
  double *v = (double *)vptr;

  if (!s) { *v = 0; return(1); }
  *v = strtod(s, &p);
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_double: display parameter type double
*******************************************************************************/
static char *
mcparminfo_double(char *parmname)
{
  return "double";
}

/*******************************************************************************
* mcparmerror_double: display error message when failed extract double
*******************************************************************************/
static void
mcparmerror_double(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for floating point parameter %s (mcparmerror_double)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_double: convert double to string
*******************************************************************************/
static void
mcparmprinter_double(char *f, void *vptr)
{
  double *v = (double *)vptr;
  sprintf(f, "%g", *v);
}

/*******************************************************************************
* mcparm_int: extract int value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_int(char *s, void *vptr)
{
  char *p;
  int *v = (int *)vptr;
  long x;

  if (!s) { *v = 0; return(1); }
  *v = 0;
  x = strtol(s, &p, 10);
  if(x < INT_MIN || x > INT_MAX)
    return 0;                        /* Under/overflow */
  *v = x;
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_int: display parameter type int
*******************************************************************************/
static char *
mcparminfo_int(char *parmname)
{
  return "int";
}

/*******************************************************************************
* mcparmerror_int: display error message when failed extract int
*******************************************************************************/
static void
mcparmerror_int(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for integer parameter %s (mcparmerror_int)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_int: convert int to string
*******************************************************************************/
static void
mcparmprinter_int(char *f, void *vptr)
{
  int *v = (int *)vptr;
  sprintf(f, "%d", *v);
}

/*******************************************************************************
* mcparm_string: extract char* value from 's' into 'vptr' (copy)
*******************************************************************************/
static int
mcparm_string(char *s, void *vptr)
{
  char **v = (char **)vptr;
  if (!s) { *v = NULL; return(1); }
  *v = (char *)malloc(strlen(s) + 1);
  if(*v == NULL)
  {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcparm_string).\n", (long)strlen(s) + 1));
  }
  strcpy(*v, s);
  return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_string: display parameter type string
*******************************************************************************/
static char *
mcparminfo_string(char *parmname)
{
  return "string";
}

/*******************************************************************************
* mcparmerror_string: display error message when failed extract string
*******************************************************************************/
static void
mcparmerror_string(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for string parameter %s (mcparmerror_string)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_string: convert string to string (including esc chars)
*******************************************************************************/
static void
mcparmprinter_string(char *f, void *vptr)
{
  char **v = (char **)vptr;
  char *p;

  if (!*v) { *f='\0'; return; }
  strcpy(f, "");
  for(p = *v; *p != '\0'; p++)
  {
    switch(*p)
    {
      case '\n':
        strcat(f, "\\n");
        break;
      case '\r':
        strcat(f, "\\r");
        break;
      case '"':
        strcat(f, "\\\"");
        break;
      case '\\':
        strcat(f, "\\\\");
        break;
      default:
        strncat(f, p, 1);
    }
  }
  /* strcat(f, "\""); */
} /* mcparmprinter_string */

/* now we may define the parameter structure, using previous functions */
static struct
  {
    int (*getparm)(char *, void *);
    char * (*parminfo)(char *);
    void (*error)(char *, char *);
    void (*printer)(char *, void *);
} mcinputtypes[] = {
  {
    mcparm_double, mcparminfo_double, mcparmerror_double,
    mcparmprinter_double
  }, {
    mcparm_int, mcparminfo_int, mcparmerror_int,
    mcparmprinter_int
  }, {
    mcparm_string, mcparminfo_string, mcparmerror_string,
    mcparmprinter_string
  }
};

/*******************************************************************************
* mcestimate_error: compute sigma from N,p,p2 in Gaussian large numbers approx
*******************************************************************************/
double mcestimate_error(double N, double p1, double p2)
{
  double pmean, n1;
  if(N <= 1)
    return p1;
  pmean = p1 / N;
  n1 = N - 1;
  /* Note: underflow may cause p2 to become zero; the fabs() below guards
     against this. */
  return sqrt((N/n1)*fabs(p2 - pmean*pmean));
}

double (*mcestimate_error_p)
  (double V2, double psum, double p2sum)=mcestimate_error;

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */

#ifndef MCCODE_R_IO_C
#define MCCODE_R_IO_C "$Revision$"

/* SECTION: file i/o handling ================================================ */

#ifndef HAVE_STRCASESTR
// from msysgit: https://code.google.com/p/msysgit/source/browse/compat/strcasestr.c
char *strcasestr(const char *haystack, const char *needle)
{
  int nlen = strlen(needle);
  int hlen = strlen(haystack) - nlen + 1;
  int i;

  for (i = 0; i < hlen; i++) {
    int j;
    for (j = 0; j < nlen; j++) {
            unsigned char c1 = haystack[i+j];
            unsigned char c2 = needle[j];
            if (toupper(c1) != toupper(c2))
                    goto next;
    }
    return (char *) haystack + i;
  next:
    ;
  }
  return NULL;
}


#endif
#ifndef HAVE_STRCASECMP
int strcasecmp( const char *s1, const char *s2 )
{
  int c1, c2;
  do {
    c1 = tolower( (unsigned char) *s1++ );
    c2 = tolower( (unsigned char) *s2++ );
  } while (c1 == c2 && c1 != 0);
  return c2 > c1 ? -1 : c1 > c2;
}
#endif

/*******************************************************************************
* mcfull_file: allocates a full file name=mcdirname+file. Catenate extension if missing.
*******************************************************************************/
char *mcfull_file(char *name, char *ext)
{
  int   dirlen=0;
  char *mem   =NULL;

  dirlen = mcdirname ? strlen(mcdirname) : 0;
  mem = (char*)malloc(dirlen + strlen(name) + CHAR_BUF_LENGTH);
  if(!mem) {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcfull_file)\n", (long)(dirlen + strlen(name) + 256)));
  }
  strcpy(mem, "");

  /* prepend directory name to path if name does not contain a path */
  if (dirlen > 0 && !strchr(name, MC_PATHSEP_C)) {
    strcat(mem, mcdirname);
    strcat(mem, MC_PATHSEP_S);
  } /* dirlen */

  strcat(mem, name);
  if (!strchr(name, '.') && ext && strlen(ext))
  { /* add extension if not in file name already */
    strcat(mem, ".");
    strcat(mem, ext);
  }
  return(mem);
} /* mcfull_file */

/*******************************************************************************
* mcnew_file: opens a new file within mcdirname if non NULL
*             the file is opened in "a" (append, create if does not exist)
*             the extension 'ext' is added if the file name does not include one.
*             the last argument is set to 0 if file did not exist, else to 1.
*******************************************************************************/
FILE *mcnew_file(char *name, char *ext, int *exists)
{
  char *mem;
  FILE *file=NULL;

  if (!name || strlen(name) == 0 || mcdisable_output_files) return(NULL);
  
  mem  = mcfull_file(name, ext); /* create mcdirname/name.ext */
  
  /* check for existence */
  file = fopen(mem, "r"); /* for reading -> fails if does not exist */
  if (file) {
    fclose(file);
    *exists=1;
  } else
    *exists=0;
  
  /* open the file for writing/appending */
#ifdef USE_NEXUS
  if (mcformat && strcasestr(mcformat, "NeXus")) {
    /* NXhandle nxhandle is defined in the .h with USE_NEXUS */
    NXaccess mode = (*exists ? NXACC_CREATE5 | NXACC_RDWR : NXACC_CREATE5);
      
    if (NXopen(mem, mode, &nxhandle) != NX_OK)
      file = NULL;
    else
      file = (FILE*)&nxhandle; /* to make it non NULL */
  } else
#endif
    file = fopen(mem, "a+"); 
    
  if(!file)
    fprintf(stderr, "Warning: could not open output file '%s' for %s (mcnew_file)\n", 
      mem, *exists ? "append" : "create");
  free(mem);

  return file;
} /* mcnew_file */

/*******************************************************************************
* mcdetector_statistics: compute detector statistics, error bars, [x I I_err N] 1D
* RETURN:            updated detector structure
* Used by: mcdetector_import
*******************************************************************************/
MCDETECTOR mcdetector_statistics(
  MCDETECTOR detector)
{

  if (!detector.p1 || !detector.m || !detector.filename)
    return(detector);
  
  /* compute statistics and update MCDETECTOR structure ===================== */
  double sum_z  = 0, min_z  = 0, max_z  = 0;
  double fmon_x =0,  smon_x = 0, fmon_y =0, smon_y=0, mean_z=0;
  double Nsum=0, P2sum=0;

  double sum_xz = 0, sum_yz = 0, sum_x = 0, sum_y = 0, sum_x2z = 0, sum_y2z = 0;
  int    i,j;
  char   hasnan=0, hasinf=0;
  char   israw = ((char*)strcasestr(detector.format,"raw") != NULL);
  double *this_p1=NULL; /* new 1D McCode array [x I E N]. Freed after writing data */

  /* if McCode/PGPLOT and rank==1 we create a new m*4 data block=[x I E N] */
  if (detector.rank == 1 && strcasestr(detector.format,"McCode")) {
    this_p1 = (double *)calloc(detector.m*detector.n*detector.p*4, sizeof(double));
    if (!this_p1)
      exit(-fprintf(stderr, "Error: Out of memory creating %li 1D " MCCODE_STRING " data set for file '%s' (mcdetector_import)\n",
        detector.m*detector.n*detector.p*4*sizeof(double*), detector.filename));
  }

  max_z = min_z = detector.p1[0];
  
  /* compute sum and moments (not for lists) */
  if (!strcasestr(detector.format,"list") && detector.m)
  for(j = 0; j < detector.n*detector.p; j++)
  {
    for(i = 0; i < detector.m; i++)
    {
      double x,y,z;
      double N, E;
      long   index= !detector.istransposed ? i*detector.n*detector.p + j : i+j*detector.m;
      char   hasnaninf=0;

      if (detector.m) 
        x = detector.xmin + (i + 0.5)/detector.m*(detector.xmax - detector.xmin); 
      else x = 0;
      if (detector.n && detector.p) 
        y = detector.ymin + (j + 0.5)/detector.n/detector.p*(detector.ymax - detector.ymin); 
      else y = 0;
      z = detector.p1[index];
      N = detector.p0 ? detector.p0[index] : 1;
      E = detector.p2 ? detector.p2[index] : 0;
      if (detector.p2 && !israw) 
        detector.p2[index] = (*mcestimate_error_p)(detector.p0[index],detector.p1[index],detector.p2[index]); /* set sigma */
      
      if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
        /* fill-in 1D McCode array [x I E N] */
        this_p1[index*4]   = x;
        this_p1[index*4+1] = z;
        this_p1[index*4+2] = detector.p2 ? detector.p2[index] : 0;
        this_p1[index*4+3] = N;
      }
      
      if (isnan(z) || isnan(E) || isnan(N)) hasnaninf=hasnan=1;
      if (isinf(z) || isinf(E) || isinf(N)) hasnaninf=hasinf=1;

      /* compute stats integrals */
      if (!hasnaninf) {
        sum_xz += x*z;
        sum_yz += y*z;
        sum_x  += x;
        sum_y  += y;
        sum_z  += z;
        sum_x2z += x*x*z;
        sum_y2z += y*y*z;
        if (z > max_z) max_z = z;
        if (z < min_z) min_z = z;

        Nsum += N;
        P2sum += E;
      }

    }
  } /* for j */

  /* compute 1st and 2nd moments. For lists, sum_z=0 so this is skipped. */
  if (sum_z && detector.n*detector.m*detector.p)
  {
    fmon_x = sum_xz/sum_z;
    fmon_y = sum_yz/sum_z;
    smon_x = sum_x2z/sum_z-fmon_x*fmon_x; smon_x = smon_x > 0 ? sqrt(smon_x) : 0;
    smon_y = sum_y2z/sum_z-fmon_y*fmon_y; smon_y = smon_y > 0 ? sqrt(smon_y) : 0;
    mean_z = sum_z/detector.n/detector.m/detector.p;
  }
  /* store statistics into detector */
  detector.intensity = sum_z;
  detector.error     = Nsum ? (*mcestimate_error_p)(Nsum, sum_z, P2sum) : 0;
  detector.events    = Nsum;
  detector.min       = min_z;
  detector.max       = max_z;
  detector.mean      = mean_z;
  detector.centerX   = fmon_x;
  detector.halfwidthX= smon_x;
  detector.centerY   = fmon_y;
  detector.halfwidthY= smon_y;

  /* if McCode/PGPLOT and rank==1 replace p1 with new m*4 1D McCode and clear others */
  if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
    
    detector.p1 = this_p1;
    detector.n  = detector.m; detector.m  = 4;
    detector.p0 = detector.p2 = NULL;
    detector.istransposed = 1;
  }

  if (detector.n*detector.m*detector.p > 1)
    snprintf(detector.signal, CHAR_BUF_LENGTH, 
      "Min=%g; Max=%g; Mean=%g;", detector.min, detector.max, detector.mean);
  else
    strcpy(detector.signal, "None");
  snprintf(detector.values, CHAR_BUF_LENGTH,
    "%g %g %g", detector.intensity, detector.error, detector.events);

  switch (detector.rank) {
    case 1:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g;",
      detector.centerX, detector.halfwidthX); break;
    case 2:
    case 3:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g; Y0=%g; dY=%g;",
      detector.centerX, detector.halfwidthX, detector.centerY, detector.halfwidthY);
      break;
    default: strcpy(detector.statistics, "None");
  }
  
  if (hasnan)
    printf("WARNING: Nan detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  if (hasinf)
    printf("WARNING: Inf detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  
  return(detector);
  
} /* mcdetector_statistics */

/*******************************************************************************
* mcdetector_import: build detector structure, merge non-lists from MPI
*                    compute basic stat, write "Detector:" line
* RETURN:            detector structure. Invalid data if detector.p1 == NULL
*                    Invalid detector sets m=0 and filename=""
*                    Simulation data  sets m=0 and filename=mcsiminfo_name
* This function is equivalent to the old 'mcdetector_out', returning a structure
*******************************************************************************/
MCDETECTOR mcdetector_import(
  char *format,
  char *component, char *title,
  long m, long n,  long p,
  char *xlabel, char *ylabel, char *zlabel,
  char *xvar, char *yvar, char *zvar,
  double x1, double x2, double y1, double y2, double z1, double z2,
  char *filename,
  double *p0, double *p1, double *p2,
  Coords position)
{
  time_t t;       /* for detector.date */
  long   date_l;  /* date as a long number */
  char   istransposed=0;
  char   c[CHAR_BUF_LENGTH]; /* temp var for signal label */

  MCDETECTOR detector;

  /* build MCDETECTOR structure ============================================= */
  /* make sure we do not have NULL for char fields */

  /* these also apply to simfile */
  strncpy (detector.filename,  filename ? filename : "",        CHAR_BUF_LENGTH);
  strncpy (detector.format,    format   ? format   : "McCode" , CHAR_BUF_LENGTH);
  /* add extension if missing */
  if (strlen(detector.filename) && !strchr(detector.filename, '.'))
  { /* add extension if not in file name already */
    strcat(detector.filename, ".dat");
  }
  strncpy (detector.component, component ? component : MCCODE_STRING " component", CHAR_BUF_LENGTH);

  snprintf(detector.instrument, CHAR_BUF_LENGTH, "%s (%s)", mcinstrument_name, mcinstrument_source);
  snprintf(detector.user, CHAR_BUF_LENGTH,      "%s on %s",
        getenv("USER") ? getenv("USER") : MCCODE_NAME,
        getenv("HOST") ? getenv("HOST") : "localhost");
  time(&t);         /* get current write time */
  date_l = (long)t; /* same but as a long */
  snprintf(detector.date, CHAR_BUF_LENGTH, "%s", ctime(&t));
  if (strlen(detector.date))   detector.date[strlen(detector.date)-1] = '\0'; /* remove last \n in date */
  detector.date_l = date_l;

  if (!mcget_run_num() || mcget_run_num() >= mcget_ncount())
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%llu", mcget_ncount()
#ifdef USE_MPI
*mpi_node_count
#endif
  );
  else
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%g/%g", (double)mcget_run_num(), (double)mcget_ncount());

  detector.p0         = p0;
  detector.p1         = p1;
  detector.p2         = p2;

  /* handle transposition (not for NeXus) */
  if (!strcasestr(detector.format, "NeXus")) {
    if (m<0 || n<0 || p<0)             istransposed = !istransposed;
    if (strcasestr(detector.format, "transpose")) istransposed = !istransposed;
    if (istransposed) { /* do the swap once for all */
      long i=m; m=n; n=i;
    }
  }

  m=abs(m); n=abs(n); p=abs(p); /* make sure dimensions are positive */
  detector.istransposed = istransposed;

  /* determine detector rank (dimensionality) */
  if (!m || !n || !p || !p1) detector.rank = 4; /* invalid: exit with m=0 filename="" */
  else if (m*n*p == 1)       detector.rank = 0; /* 0D */
  else if (n == 1 || m == 1) detector.rank = 1; /* 1D */
  else if (p == 1)           detector.rank = 2; /* 2D */
  else                       detector.rank = 3; /* 3D */

  /* from rank, set type */
  switch (detector.rank) {
    case 0:  strcpy(detector.type,  "array_0d"); m=n=p=1; break;
    case 1:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_1d(%ld)", m*n*p); m *= n*p; n=p=1; break;
    case 2:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_2d(%ld, %ld)", m, n*p); n *= p; p=1; break;
    case 3:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_3d(%ld, %ld, %ld)", m, n, p); break;
    default: m=0; strcpy(detector.type, ""); strcpy(detector.filename, "");/* invalid */
  }

  detector.m    = m;
  detector.n    = n;
  detector.p    = p;

  /* these only apply to detector files ===================================== */

  snprintf(detector.position, CHAR_BUF_LENGTH, "%g %g %g", position.x, position.y, position.z);
  /* may also store actual detector orientation in the future */

  strncpy(detector.title,      title && strlen(title) ? title : component,       CHAR_BUF_LENGTH);
  strncpy(detector.xlabel,     xlabel && strlen(xlabel) ? xlabel : "X", CHAR_BUF_LENGTH); /* axis labels */
  strncpy(detector.ylabel,     ylabel && strlen(ylabel) ? ylabel : "Y", CHAR_BUF_LENGTH);
  strncpy(detector.zlabel,     zlabel && strlen(zlabel) ? zlabel : "Z", CHAR_BUF_LENGTH);
  strncpy(detector.xvar,       xvar && strlen(xvar) ? xvar :       "x", CHAR_BUF_LENGTH); /* axis variables */
  strncpy(detector.yvar,       yvar && strlen(yvar) ? yvar :       detector.xvar, CHAR_BUF_LENGTH);
  strncpy(detector.zvar,       zvar && strlen(zvar) ? zvar :       detector.yvar, CHAR_BUF_LENGTH);

  /* set "variables" as e.g. "I I_err N" */
  strcpy(c, "I ");
  if (strlen(detector.zvar))      strncpy(c, detector.zvar,32);
  else if (strlen(detector.yvar)) strncpy(c, detector.yvar,32);
  else if (strlen(detector.xvar)) strncpy(c, detector.xvar,32);

  if (detector.rank == 1)
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s %s_err N", detector.xvar, c, c);
  else
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s_err N", c, c);

  /* limits */
  detector.xmin = x1;
  detector.xmax = x2;
  detector.ymin = y1;
  detector.ymax = y2;
  detector.zmin = z1;
  detector.zmax = z2;
  if (abs(detector.rank) == 1)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g", x1, x2);
  else if (detector.rank == 2)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g", x1, x2, y1, y2);
  else
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g %g %g", x1, x2, y1, y2, z1, z2);

  /* if MPI and nodes_nb > 1: reduce data sets when using MPI =============== */
#ifdef USE_MPI
  if (!strcasestr(detector.format,"list") && mpi_node_count > 1 && m) {
    /* we save additive data: reduce everything into mpi_node_root */
    if (p0) mc_MPI_Sum(p0, m*n*p);
    if (p1) mc_MPI_Sum(p1, m*n*p);
    if (p2) mc_MPI_Sum(p2, m*n*p);
    if (!p0) {  /* additive signal must be then divided by the number of nodes */
      int i;
      for (i=0; i<m*n*p; i++) {
        p1[i] /= mpi_node_count;
        if (p2) p2[i] /= mpi_node_count;
      }
    }
  }
#endif /* USE_MPI */

  /* compute statistics, Nsum, intensity, Error bars */
  detector = mcdetector_statistics(detector);

#ifdef USE_MPI
  /* slaves are done */
  if(mpi_node_rank != mpi_node_root) {
    return detector;
  }
#endif

  /* output "Detector:" line ================================================ */
  /* when this is a detector written by a component (not the SAVE from instrument),
     not an event lists */
  if (!m) return(detector);
  if (!strcasestr(detector.format,"list")) {
    if (!strcmp(detector.component, mcinstrument_name)) {
      if (strlen(detector.filename))  /* we name it from its filename, or from its title */
        strncpy(c, detector.filename, CHAR_BUF_LENGTH);
      else
        snprintf(c, CHAR_BUF_LENGTH, "%s", mcinstrument_name);
    } else
      strncpy(c, detector.component, CHAR_BUF_LENGTH);  /* usual detectors written by components */

    printf("Detector: %s_I=%g %s_ERR=%g %s_N=%g",
           c, detector.intensity,
           c, detector.error,
           c, detector.events);
    printf(" \"%s\"\n", strlen(detector.filename) ? detector.filename : detector.component);
  }
  

  return(detector);
} /* mcdetector_import */

/* end MCDETECTOR import section ============================================ */

















/* ========================================================================== */

/*                               ASCII output                                 */
/*     The SIM file is YAML based, the data files have '#' headers            */

/* ========================================================================== */


/*******************************************************************************
* mcinfo_out: output instrument tags/info (only in SIM)
* Used in: mcsiminfo_init (ascii), mcinfo(stdout)
*******************************************************************************/
static void mcinfo_out(char *pre, FILE *f)
{
  char Parameters[CHAR_BUF_LENGTH] = "";
  int  i;

  if (!f || mcdisable_output_files) return;

  /* create parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++)
  {
    char ThisParam[CHAR_BUF_LENGTH];
    if (strlen(mcinputtable[i].name) > CHAR_BUF_LENGTH) break;
    snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
            (*mcinputtypes[mcinputtable[i].type].parminfo)
                (mcinputtable[i].name));
    strcat(Parameters, ThisParam);
    if (strlen(Parameters) >= CHAR_BUF_LENGTH-64) break;
  }

  /* output data ============================================================ */
  if (f != stdout)
    fprintf(f, "%sFile: %s%c%s\n",    pre, mcdirname, MC_PATHSEP_C, mcsiminfo_name);
  else
    fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);

  fprintf(f, "%sSource: %s\n",   pre, mcinstrument_source);
  fprintf(f, "%sParameters: %s\n",    pre, Parameters);
  
  fprintf(f, "%sTrace_enabled: %s\n", pre, mctraceenabled ? "yes" : "no");
  fprintf(f, "%sDefault_main: %s\n",  pre, mcdefaultmain ?  "yes" : "no");
  fprintf(f, "%sEmbedded_runtime: %s\n", pre, 
#ifdef MC_EMBEDDED_RUNTIME
         "yes"
#else
         "no"
#endif
         );

  fflush(f);
} /* mcinfo_out */

/*******************************************************************************
* mcruninfo_out: output simulation tags/info (both in SIM and data files)
* Used in: mcsiminfo_init (ascii case), mcdetector_out_xD_ascii
*******************************************************************************/
static void mcruninfo_out(char *pre, FILE *f)
{
  int i;
  char Parameters[CHAR_BUF_LENGTH];

  if (!f || mcdisable_output_files) return;

  fprintf(f, "%sFormat: %s%s\n",      pre, 
    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME,
    mcformat && strcasestr(mcformat,"McCode") ? " with text headers" : "");
  fprintf(f, "%sURL: %s\n",         pre, "http://www.mccode.org");
  fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);
  fprintf(f, "%sInstrument: %s\n", pre, mcinstrument_source);
  fprintf(f, "%sNcount: %llu\n",        pre, mcget_ncount());
  fprintf(f, "%sTrace: %s\n",       pre, mcdotrace ? "yes" : "no");
  fprintf(f, "%sGravitation: %s\n", pre, mcgravitation ? "yes" : "no");
  snprintf(Parameters, CHAR_BUF_LENGTH, "%ld", mcseed);
  fprintf(f, "%sSeed: %s\n",        pre, Parameters);
  fprintf(f, "%sDirectory: %s\n",        pre, mcdirname ? mcdirname : ".");
#ifdef USE_MPI
  if (mpi_node_count > 1)
    fprintf(f, "%sNodes: %i\n",        pre, mpi_node_count);
#endif

  /* output parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++) {
    if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
      if (mcinputtable[i].par == NULL)
        strncpy(Parameters, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
      else
        (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);

      fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
    }
  }
  fflush(f);
} /* mcruninfo_out */

/*******************************************************************************
* mcsiminfo_out:    wrapper to fprintf(mcsiminfo_file)
*******************************************************************************/
void mcsiminfo_out(char *format, ...)
{
  va_list ap;

  if(mcsiminfo_file && !mcdisable_output_files)
  {
    va_start(ap, format);
    vfprintf(mcsiminfo_file, format, ap);
    va_end(ap);
  }
} /* mcsiminfo_out */


/*******************************************************************************
* mcdatainfo_out: output detector header
*   mcdatainfo_out(prefix, file_handle, detector) writes info to data file
*******************************************************************************/
static void
mcdatainfo_out(char *pre, FILE *f, MCDETECTOR detector)
{
  if (!f || !detector.m || mcdisable_output_files) return;
  
  /* output data ============================================================ */
  fprintf(f, "%sDate: %s (%li)\n",       pre, detector.date, detector.date_l);
  fprintf(f, "%stype: %s\n",       pre, detector.type);
  fprintf(f, "%sSource: %s\n",     pre, detector.instrument);
  fprintf(f, "%scomponent: %s\n",  pre, detector.component);
  fprintf(f, "%sposition: %s\n",   pre, detector.position);

  fprintf(f, "%stitle: %s\n",      pre, detector.title);
  fprintf(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
             "%sNcount: %s\n" : 
             "%sratio: %s\n",  pre, detector.ncount);

  if (strlen(detector.filename)) {
    fprintf(f, "%sfilename: %s\n", pre, detector.filename);
  }

  fprintf(f, "%sstatistics: %s\n", pre, detector.statistics);
  fprintf(f, "%ssignal: %s\n",     pre, detector.signal);
  fprintf(f, "%svalues: %s\n",     pre, detector.values);

  if (detector.rank >= 1)
  {
    fprintf(f, "%sxvar: %s\n",     pre, detector.xvar);
    fprintf(f, "%syvar: %s\n",     pre, detector.yvar);
    fprintf(f, "%sxlabel: %s\n",   pre, detector.xlabel);
    fprintf(f, "%sylabel: %s\n",   pre, detector.ylabel);
    if (detector.rank > 1) {
      fprintf(f, "%szvar: %s\n",   pre, detector.zvar);
      fprintf(f, "%szlabel: %s\n", pre, detector.zlabel);
    }
  }

  fprintf(f, 
    abs(detector.rank)==1 ?
             "%sxlimits: %s\n" : 
             "%sxylimits: %s\n", pre, detector.limits);
  fprintf(f, "%svariables: %s\n", pre, 
    strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
    
  fflush(f);

} /* mcdatainfo_out */

/* mcdetector_out_array_ascii: output a single array to a file
 *   m: columns
 *   n: rows
 *   p: array
 *   f: file handle (already opened)
 */
static void mcdetector_out_array_ascii(long m, long n, double *p, FILE *f, char istransposed)
{
  if(f)
  {
    int i,j;
    for(j = 0; j < n; j++)
    {
      for(i = 0; i < m; i++)
      {
          fprintf(f, "%.10g ", p[!istransposed ? i*n + j : j*m+i]);
      }
      fprintf(f,"\n");
    }
  }
} /* mcdetector_out_array_ascii */

/*******************************************************************************
* mcdetector_out_0D_ascii: called by mcdetector_out_0D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_0D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  /* Write data set information to simulation description file. */
  MPI_MASTER(
    mcsiminfo_out("\nbegin data\n"); // detector.component
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.component, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* write I I_err N */
      fprintf(outfile, "%g %g %g\n", 
        detector.intensity, detector.error, detector.events);
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
} /* mcdetector_out_0D_ascii */

/*******************************************************************************
* mcdetector_out_1D_ascii: called by mcdetector_out_1D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_1D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;

  MPI_MASTER(
    /* Write data set information to simulation description file. */
    mcsiminfo_out("\nbegin data\n"); // detector.filename
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* output the 1D array columns */
      mcdetector_out_array_ascii(detector.m, detector.n, detector.p1, outfile, detector.istransposed);
      
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
  
}  /* mcdetector_out_1D_ascii */

/*******************************************************************************
* mcdetector_out_2D_ascii: called by mcdetector_out_2D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_2D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  MPI_MASTER(
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write header only if file has just been created (not appending) */
      if (!exists) {
        /* Write data set information to simulation description file. */
        mcsiminfo_out("\nbegin data\n"); // detector.filename
        mcdatainfo_out("  ", mcsiminfo_file, detector);
        mcsiminfo_out("end data\n");
      
        mcruninfo_out( "# ", outfile);
        mcdatainfo_out("# ", outfile,   detector);
        fprintf(outfile, "# Data [%s/%s] %s:\n", detector.component, detector.filename, detector.zvar);
      }
      mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
        outfile, detector.istransposed);
      if (detector.p2) {
        fprintf(outfile, "# Errors [%s/%s] %s_err:\n", detector.component, detector.filename, detector.zvar);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p2, 
          outfile, detector.istransposed);
      }
      if (detector.p0) {
        fprintf(outfile, "# Events [%s/%s] N:\n", detector.component, detector.filename);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p0, 
          outfile, detector.istransposed);
      }
      fclose(outfile);
      
      if (!exists) {
        if (strcasestr(detector.format, "list"))
          printf("Events:   \"%s\"\n",  
            strlen(detector.filename) ? detector.filename : detector.component);
      }
    } /* if outfile */
  ); /* MPI_MASTER */
#ifdef USE_MPI
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    int node_i=0;
    /* loop along MPI nodes to write sequentially */
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      /* MPI: slaves wait for the master to write its block, then append theirs */
      MPI_Barrier(MPI_COMM_WORLD);
      if (node_i != mpi_node_root && node_i == mpi_node_rank) {
        if(strlen(detector.filename) && !mcdisable_output_files)	/* Don't write if filename is NULL */
          outfile = mcnew_file(detector.filename, "dat", &exists);
        if (!exists)
          fprintf(stderr, "Warning: [MPI node %i] file '%s' does not exist yet, "
                          "MASTER should have opened it before.\n",
            mpi_node_rank, detector.filename);
        if(outfile) {
          mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
            outfile, detector.istransposed);
          fclose(outfile);
        }
      }
    }
  } /* if strcasestr list */
#endif
  return(detector);
} /* mcdetector_out_2D_ascii */

/*******************************************************************************
* strcpy_valid: makes a valid string for variable names.
*   copy 'original' into 'valid', replacing invalid characters by '_'
*   char arrays must be pre-allocated
*******************************************************************************/
static char *strcpy_valid(char *valid, char *original)
{
  long i;
  int  n=32; /* max length of valid names */

  if (original == NULL || !strlen(original)) return(NULL);

  if (n > strlen(original)) n = strlen(original);
  else original += strlen(original)-n;
  strncpy(valid, original, n);

  for (i=0; i < n; i++)
  {
    if ( (valid[i] > 122)
      || (valid[i] < 32)
      || (strchr("!\"#$%&'()*+,-.:;<=>?@[\\]^`/ \n\r\t", valid[i]) != NULL) )
    {
      if (i) valid[i] = '_'; else valid[i] = 'm';
    }
  }
  valid[i] = '\0';

  return(valid);
} /* strcpy_valid */

/* end ascii output section ================================================= */







#ifdef USE_NEXUS

/* ========================================================================== */

/*                               NeXus output                                 */

/* ========================================================================== */

#define nxprintf(...)    nxstr('d', __VA_ARGS__)
#define nxprintattr(...) nxstr('a', __VA_ARGS__)

/*******************************************************************************
* nxstr: output a tag=value data set (char) in NeXus/current group
*   when 'format' is larger that 1024 chars it is used as value for the 'tag'
*   else the value is assembled with format and following arguments.
*   type='d' -> data set
*        'a' -> attribute for current data set
*******************************************************************************/
static int nxstr(char type, NXhandle *f, char *tag, char *format, ...)
{
  va_list ap;
  char value[CHAR_BUF_LENGTH];
  int  i;
  int  ret=NX_OK;
  
  if (!tag || !format || !strlen(tag) || !strlen(format)) return(NX_OK);
  
  /* assemble the value string */
  if (strlen(format) < CHAR_BUF_LENGTH) {
    va_start(ap, format);
    ret = vsnprintf(value, CHAR_BUF_LENGTH, format, ap);
    va_end(ap);
  
    i = strlen(value);
  } else {
    i = strlen(format);
  }

  if (type == 'd') {
    /* open/put/close data set */
    if (NXmakedata (f, tag, NX_CHAR, 1, &i) != NX_OK) return(NX_ERROR);
    NXopendata (f, tag);
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputdata  (f, value);
    else
      ret = NXputdata  (f, format);
    NXclosedata(f);
  } else {
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputattr  (f, tag, value, strlen(value), NX_CHAR);
    else
      ret = NXputattr  (f, tag, format, strlen(format), NX_CHAR);
  }
  
  return(ret);
  
} /* nxstr */

/*******************************************************************************
* mcinfo_readfile: read a full file into a string buffer which is allocated
*   Think to free the buffer after use.
* Used in: mcinfo_out_nexus (nexus)
*******************************************************************************/
char *mcinfo_readfile(char *filename)
{
  FILE *f = fopen(filename, "r");
  if (!f) return(NULL);
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  rewind(f);
  char *string = malloc(fsize + 1);
  if (string) {
    int n = fread(string, fsize, 1, f);
    fclose(f);

    string[fsize] = 0;
  }
  return(string);
}

/*******************************************************************************
* mcinfo_out: output instrument/simulation groups in NeXus file
* Used in: mcsiminfo_init (nexus)
*******************************************************************************/
static void mcinfo_out_nexus(NXhandle f)
{
  FILE  *fid;     /* for intrument source code/C/IDF */
  char  *buffer=NULL;
  time_t t     =time(NULL); /* for date */
  char   entry0[CHAR_BUF_LENGTH];
  int    count=0;
  char   name[CHAR_BUF_LENGTH];
  char   class[CHAR_BUF_LENGTH];
  
  if (!f || mcdisable_output_files) return;
  
  /* write NeXus NXroot attributes */
  /* automatically added: file_name, HDF5_Version, file_time, NeXus_version */ 
  nxprintattr(f, "creator",   "%s generated with " MCCODE_STRING, mcinstrument_name);
  
  /* count the number of existing NXentry and create the next one */
  NXgetgroupinfo(f, &count, name, class);
  sprintf(entry0, "entry%i", count+1);

  /* create the main NXentry (mandatory in NeXus) */
  if (NXmakegroup(f, entry0, "NXentry") == NX_OK) 
  if (NXopengroup(f, entry0, "NXentry") == NX_OK) {
    
    nxprintf(nxhandle, "program_name", MCCODE_STRING);
    nxprintf(f, "start_time", ctime(&t));
    nxprintf(f, "title", "%s%s%s simulation generated by instrument %s", 
      mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name,
      mcinstrument_name);
    nxprintattr(f, "program_name", MCCODE_STRING);
    nxprintattr(f, "instrument",   mcinstrument_name);
    nxprintattr(f, "simulation",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);

    /* write NeXus instrument group */
    if (NXmakegroup(f, "instrument", "NXinstrument") == NX_OK)
    if (NXopengroup(f, "instrument", "NXinstrument") == NX_OK) {
      int   i;
      char *string=NULL;

      /* write NeXus parameters(types) data =================================== */
      string = (char*)malloc(CHAR_BUF_LENGTH);
      if (string) {
        strcpy(string, "");
        for(i = 0; i < mcnumipar; i++)
        {
          char ThisParam[CHAR_BUF_LENGTH];
          snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
                  (*mcinputtypes[mcinputtable[i].type].parminfo)
                      (mcinputtable[i].name));
          if (strlen(string) + strlen(ThisParam) < CHAR_BUF_LENGTH)
            strcat(string, ThisParam);
        }
        nxprintattr(f, "Parameters",    string);
        free(string);
      }
        
      nxprintattr(f, "name",          mcinstrument_name);
      nxprintf   (f, "name",          mcinstrument_name);
      nxprintattr(f, "Source",        mcinstrument_source);
      
      nxprintattr(f, "Trace_enabled", mctraceenabled ? "yes" : "no");
      nxprintattr(f, "Default_main",  mcdefaultmain ?  "yes" : "no");
      nxprintattr(f, "Embedded_runtime",  
  #ifdef MC_EMBEDDED_RUNTIME
           "yes"
  #else
           "no"
  #endif
           );
           
      /* add instrument source code when available */
      buffer = mcinfo_readfile(mcinstrument_source);
      if (buffer && strlen(buffer)) {
        long length=strlen(buffer);
        nxprintf (f, "description", buffer);
        NXopendata(f,"description");
        nxprintattr(f, "file_name", mcinstrument_source);
        nxprintattr(f, "file_size", "%li", length);
        nxprintattr(f, "MCCODE_STRING", MCCODE_STRING);
        NXclosedata(f);
        nxprintf (f,"instrument_source", "%s " MCCODE_NAME " " MCCODE_PARTICLE " Monte Carlo simulation", mcinstrument_name);
        free(buffer);
      } else
        nxprintf (f, "description", "File %s not found (instrument description %s is missing)", 
          mcinstrument_source, mcinstrument_name);
      
      /* add Mantid/IDF.xml when available */
      char *IDFfile=NULL;
      IDFfile = (char*)malloc(CHAR_BUF_LENGTH);
      sprintf(IDFfile,"%s%s",mcinstrument_source,".xml");
      buffer = mcinfo_readfile(IDFfile);
      if (buffer && strlen(buffer)) {
        NXmakegroup (nxhandle, "instrument_xml", "NXnote");
        NXopengroup (nxhandle, "instrument_xml", "NXnote");
        nxprintf(f, "data", buffer);
        nxprintf(f, "description", "IDF.xml file found with instrument %s", mcinstrument_source);
        nxprintf(f, "type", "text/xml");
        NXclosegroup(f); /* instrument_xml */
        free(buffer);
      }
      free(IDFfile);
      NXclosegroup(f); /* instrument */
    } /* NXinstrument */

    /* write NeXus simulation group */
    if (NXmakegroup(f, "simulation", "NXnote") == NX_OK)
    if (NXopengroup(f, "simulation", "NXnote") == NX_OK) {

      nxprintattr(f, "name",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);
      
      nxprintf   (f, "name",      "%s",     mcsiminfo_name);
      nxprintattr(f, "Format",    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME);
      nxprintattr(f, "URL",       "http://www.mccode.org");
      nxprintattr(f, "program",   MCCODE_STRING);
      nxprintattr(f, "Instrument",mcinstrument_source);
      nxprintattr(f, "Trace",     mcdotrace ?     "yes" : "no");
      nxprintattr(f, "Gravitation",mcgravitation ? "yes" : "no");
      nxprintattr(f, "Seed",      "%li", mcseed);
      nxprintattr(f, "Directory", mcdirname);
    #ifdef USE_MPI
      if (mpi_node_count > 1)
        nxprintf(f, "Nodes", "%i",        mpi_node_count);
    #endif
    
      /* output parameter string ================================================ */
      if (NXmakegroup(f, "Param", "NXparameters") == NX_OK)
      if (NXopengroup(f, "Param", "NXparameters") == NX_OK) {
        int i;
        char string[CHAR_BUF_LENGTH];
        for(i = 0; i < mcnumipar; i++) {
          if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
            if (mcinputtable[i].par == NULL)
              strncpy(string, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
            else
              (*mcinputtypes[mcinputtable[i].type].printer)(string, mcinputtable[i].par);

            nxprintf(f,  mcinputtable[i].name, "%s", string);
            nxprintattr(f, mcinputtable[i].name, string);
          }
        }
        NXclosegroup(f); /* Param */
      } /* NXparameters */
      
      NXclosegroup(f); /* simulation */
    } /* NXsimulation */
    
    /* create a group to hold all monitors */
    NXmakegroup(f, "data", "NXdetector");

    /* leave the NXentry opened (closed at exit) */
  } /* NXentry */
} /* mcinfo_out_nexus */

/*******************************************************************************
* mcdatainfo_out_nexus: output detector header
*   mcdatainfo_out_nexus(detector) create group and write info to NeXus data file
*   open data:NXdetector then filename:NXdata and write headers/attributes
*   requires: NXentry to be opened
*******************************************************************************/
static void
mcdatainfo_out_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  if (!f || !detector.m || mcdisable_output_files) return;
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* create and open the data group */
    /* this may fail when appending to list -> ignore/skip */
    NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
    
    if (NXmakegroup(f, data_name, "NXdata") == NX_OK)
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
    
      /* output metadata (as attributes) ======================================== */
      nxprintattr(f, "Date",       detector.date);
      nxprintattr(f, "type",       detector.type);
      nxprintattr(f, "Source",     detector.instrument);
      nxprintattr(f, "component",  detector.component);
      nxprintattr(f, "position",   detector.position);

      nxprintattr(f, "title",      detector.title);
      nxprintattr(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
                 "Ncount" : 
                 "ratio",  detector.ncount);

      if (strlen(detector.filename)) {
        nxprintattr(f, "filename", detector.filename);
      }

      nxprintattr(f, "statistics", detector.statistics);
      nxprintattr(f, "signal",     detector.signal);
      nxprintattr(f, "values",     detector.values);

      if (detector.rank >= 1)
      {
        nxprintattr(f, "xvar",     detector.xvar);
        nxprintattr(f, "yvar",     detector.yvar);
        nxprintattr(f, "xlabel",   detector.xlabel);
        nxprintattr(f, "ylabel",   detector.ylabel);
        if (detector.rank > 1) {
          nxprintattr(f, "zvar",   detector.zvar);
          nxprintattr(f, "zlabel", detector.zlabel);
        }
      }

      nxprintattr(f, abs(detector.rank)==1 ?
                 "xlimits" : 
                 "xylimits", detector.limits);
      nxprintattr(f, "variables", 
        strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
      nxprintf(f, "distance", detector.position);
      nxprintf(f, "acquisition_mode",
        strcasestr(detector.format, "list") ? "event" : "summed");
        
      NXclosegroup(f);
    } /* NXdata (filename) */
    NXMEnableErrorReporting();  /* re-enable NeXus error messages */
    NXclosegroup(f);
  } /* NXdetector (data) */
  
} /* mcdatainfo_out_nexus */

/*******************************************************************************
* mcdetector_out_axis_nexus: write detector axis into current NXdata
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_axis_nexus(NXhandle f, char *label, char *var, int rank, long length, double min, double max)
{
  if (!f || length <= 1 || mcdisable_output_files || max == min) return(NX_OK);
  else {
    double axis[length];
    char valid[32];
    int dim=(int)length;
    int i;
    int nprimary=1;
    /* create an axis from [min:max] */
    for(i = 0; i < length; i++)
      axis[i] = min+(max-min)*(i+0.5)/length;
    /* create the data set */
    strcpy_valid(valid, label);
    NXcompmakedata(f, valid, NX_FLOAT64, 1, &dim, NX_COMP_LZW, &dim);
    /* open it */
    if (NXopendata(f, valid) != NX_OK) {
      fprintf(stderr, "Warning: could not open axis rank %i '%s' (NeXus)\n",
        rank, valid);
      return(NX_ERROR);
    }
    /* put the axis and its attributes */
    NXputdata  (f, axis);
    nxprintattr(f, "long_name",  label);
    nxprintattr(f, "short_name", var);
    NXputattr  (f, "axis",       &rank,     1, NX_INT32);
    nxprintattr(f, "units",      var);
    NXputattr  (f, "primary",    &nprimary, 1, NX_INT32);
    NXclosedata(f);
    
    return(NX_OK);
  }
} /* mcdetector_out_axis_nexus */

/*******************************************************************************
* mcdetector_out_array_nexus: write detector array into current NXdata (1D,2D)
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_array_nexus(NXhandle f, char *part, double *data, MCDETECTOR detector)
{
  
  int dims[3]={detector.m,detector.n,detector.p};  /* number of elements to write */
  int signal=1;
  int exists=0;
  int current_dims[3]={0,0,0};
  int ret=NX_OK;
  
  if (!f || !data || !detector.m || mcdisable_output_files) return(NX_OK);
  
  /* when this is a list, we set 1st dimension to NX_UNLIMITED for creation */
  if (strcasestr(detector.format, "list")) dims[0] = NX_UNLIMITED;
  
  /* create the data set in NXdata group */
  NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
  /* NXcompmakedata fails with NX_UNLIMITED */
  if (strcasestr(detector.format, "list"))
    ret = NXmakedata(    f, part, NX_FLOAT64, detector.rank, dims);
  else
    ret = NXcompmakedata(f, part, NX_FLOAT64, detector.rank, dims, NX_COMP_LZW, dims);
  if (ret != NX_OK) {
    /* failed: data set already exists */
    int datatype=0;
    int rank=0;
    exists=1;
    /* inquire current size of data set (nb of events stored) */
    NXopendata(f, part);
    NXgetinfo(f, &rank, current_dims, &datatype);
    NXclosedata(f);
  }
  NXMEnableErrorReporting();  /* re-enable NeXus error messages */
  dims[0] = detector.m; /* restore actual dimension from data writing */
  
  /* open the data set */
  if (NXopendata(f, part) == NX_ERROR) {
    fprintf(stderr, "Warning: could not open DataSet %s '%s' (NeXus)\n",
      part, detector.title);
    return(NX_ERROR);
  }
  if (strcasestr(detector.format, "list")) {
    current_dims[1] = current_dims[2] = 0; /* set starting location for writing slab */
    NXputslab(f, data, current_dims, dims);
    if (!exists)
      printf("Events:   \"%s\"\n",  
        strlen(detector.filename) ? detector.filename : detector.component);
  } else {
    NXputdata (f, data);
  }
  
  if (strstr(part,"data") || strstr(part, "events")) {
    NXputattr(f, "signal", &signal, 1, NX_INT32);
    nxprintattr(f, "short_name", detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);
  }
  nxprintattr(f, "long_name", "%s '%s'", part, detector.title);
  NXclosedata(f);
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

/*******************************************************************************
* mcdetector_out_data_nexus: write detector axes+data into current NXdata
*   The data:NXdetector is opened, then filename:NXdata
*   requires: NXentry to be opened
*******************************************************************************/
int mcdetector_out_data_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  
  if (!f || !detector.m || mcdisable_output_files) return(NX_OK);
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* the NXdata group has been created in mcdatainfo_out_nexus */
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
  
      /* write axes, for histogram data sets, not for lists */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_axis_nexus(f, detector.xlabel, detector.xvar, 
          1, detector.m, detector.xmin, detector.xmax);
          
        mcdetector_out_axis_nexus(f, detector.ylabel, detector.yvar, 
          2, detector.n, detector.ymin, detector.ymax);
          
        mcdetector_out_axis_nexus(f, detector.zlabel, detector.zvar, 
          3, detector.p, detector.zmin, detector.zmax);

      } /* !list */
      
      /* write the actual data (appended if already exists) */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_array_nexus(f, "data", detector.p1, detector);
        mcdetector_out_array_nexus(f, "errors", detector.p2, detector);
        mcdetector_out_array_nexus(f, "ncount", detector.p0, detector);
      } else
        mcdetector_out_array_nexus(  f, "events", detector.p1, detector);
      
      NXclosegroup(f);
    } /* NXdata */
    NXclosegroup(f);
  } /* NXdetector */
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

#ifdef USE_MPI
/*******************************************************************************
* mcdetector_out_list_slaves: slaves send their list data to master which writes
*   requires: NXentry to be opened
* WARNING: this method has a flaw: it requires all nodes to flush the lists
*   the same number of times. In case one node is just below the buffer size
*   when finishing (e.g. monitor_nd), it may not trigger save but others may. 
*   Then the number of recv/send is not constant along nodes, and simulation stalls.  
*******************************************************************************/
MCDETECTOR mcdetector_out_list_slaves(MCDETECTOR detector)
{
  int     node_i=0;
  MPI_MASTER(
	     printf("\n** MPI master gathering slave node list data ** \n");
  );
  
  if (mpi_node_rank != mpi_node_root) {
    /* MPI slave: slaves send their data to master: 2 MPI_Send calls */
    /* m, n, p must be sent first, since all slaves do not have the same number of events */
    int mnp[3]={detector.m,detector.n,detector.p};

    if (mc_MPI_Send(mnp, 3, MPI_INT, mpi_node_root)!= MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send mnp list error (mcdetector_out_list_slaves)\n", mpi_node_rank);
    if (!detector.p1
     || mc_MPI_Send(detector.p1, mnp[0]*mnp[1]*mnp[2], MPI_DOUBLE, mpi_node_root) != MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send p1 list error: mnp=%i (mcdetector_out_list_slaves)\n", mpi_node_rank, abs(mnp[0]*mnp[1]*mnp[2]));
    /* slaves are done: sent mnp and p1 */
    return (detector);
  } /* end slaves */

  /* MPI master: receive data from slaves sequentially: 2 MPI_Recv calls */

  if (mpi_node_rank == mpi_node_root) {
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      double *this_p1=NULL;                               /* buffer to hold the list from slaves */
      int     mnp[3]={0,0,0};  /* size of this buffer */
      if (node_i != mpi_node_root) { /* get data from slaves */
	if (mc_MPI_Recv(mnp, 3, MPI_INT, node_i) != MPI_SUCCESS)
	  fprintf(stderr, "Warning: master from proc %i: "
		  "MPI_Recv mnp list error (mcdetector_write_data)\n", node_i);
	if (mnp[0]*mnp[1]*mnp[2]) {
	  this_p1 = (double *)calloc(mnp[0]*mnp[1]*mnp[2], sizeof(double));
	  if (!this_p1 || mc_MPI_Recv(this_p1, abs(mnp[0]*mnp[1]*mnp[2]), MPI_DOUBLE, node_i)!= MPI_SUCCESS)
	    fprintf(stderr, "Warning: master from proc %i: "
		    "MPI_Recv p1 list error: mnp=%i (mcdetector_write_data)\n", node_i, mnp[0]*mnp[1]*mnp[2]);
	  else {
	    printf(". MPI master writing data for slave node %i\n",node_i);
	    detector.p1 = this_p1;
	    detector.m  = mnp[0]; detector.n  = mnp[1]; detector.p  = mnp[2];
	    
	    mcdetector_out_data_nexus(nxhandle, detector);
	  }
	}
      } /* if not master */
    } /* for */
  MPI_MASTER(
	     printf("\n** Done ** \n");
  );   
  }
}
#endif

MCDETECTOR mcdetector_out_0D_nexus(MCDETECTOR detector)
{
  /* Write data set information to NeXus file. */
  MPI_MASTER(
    mcdatainfo_out_nexus(nxhandle, detector);
  );
  
  return(detector);
} /* mcdetector_out_0D_ascii */

MCDETECTOR mcdetector_out_1D_nexus(MCDETECTOR detector)
{
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  return(detector);
} /* mcdetector_out_1D_ascii */

MCDETECTOR mcdetector_out_2D_nexus(MCDETECTOR detector)
{
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  
#ifdef USE_MPI // and USE_NEXUS
  /* NeXus: slave nodes have master write their lists */
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    mcdetector_out_list_slaves(detector);
  }
#endif /* USE_MPI */

  return(detector);
} /* mcdetector_out_2D_nexus */

#endif /* USE_NEXUS*/








/* ========================================================================== */

/*                            Main input functions                            */
/*            DETECTOR_OUT_xD function calls -> ascii or NeXus                */

/* ========================================================================== */

/*******************************************************************************
* mcsiminfo_init:   open SIM and write header
*******************************************************************************/
FILE *mcsiminfo_init(FILE *f)
{
  int exists=0;
  int index;
  
  /* check format */      
  if (!mcformat || !strlen(mcformat) 
   || !strcasecmp(mcformat, "MCSTAS") || !strcasecmp(mcformat, "MCXTRACE") 
   || !strcasecmp(mcformat, "PGPLOT") || !strcasecmp(mcformat, "GNUPLOT") || !strcasecmp(mcformat, "MCCODE")
   || !strcasecmp(mcformat, "MATLAB")) {
    mcformat="McCode";
#ifdef USE_NEXUS
  } else if (strcasestr(mcformat, "NeXus")) {
    /* Do nothing */
#endif
  } else {
    fprintf(stderr,
	    "Warning: You have requested the output format %s which is unsupported by this binary. Resetting to standard %s format.\n",mcformat ,"McCode");
    mcformat="McCode";
  }
  
  /* open the SIM file if not defined yet */
  if (mcsiminfo_file || mcdisable_output_files) 
    return (mcsiminfo_file);
    
#ifdef USE_NEXUS
  /* only master writes NeXus header: calls NXopen(nxhandle) */
  if (mcformat && strcasestr(mcformat, "NeXus")) {
	  MPI_MASTER(
	  mcsiminfo_file = mcnew_file(mcsiminfo_name, "h5", &exists);
    if(!mcsiminfo_file)
      fprintf(stderr,
	      "Warning: could not open simulation description file '%s'\n",
	      mcsiminfo_name);
	  else
	    mcinfo_out_nexus(nxhandle);
	  );
    return(mcsiminfo_file); /* points to nxhandle */
  }
#endif
  
  /* write main description file (only MASTER) */
  MPI_MASTER(

  mcsiminfo_file = mcnew_file(mcsiminfo_name, "sim", &exists);
  if(!mcsiminfo_file)
    fprintf(stderr,
	    "Warning: could not open simulation description file '%s'\n",
	    mcsiminfo_name);
  else
  {
    /* write SIM header */
    time_t t=time(NULL);
    mcsiminfo_out("%s simulation description file for %s.\n", 
      MCCODE_NAME, mcinstrument_name);
    mcsiminfo_out("Date:    %s", ctime(&t)); /* includes \n */
    mcsiminfo_out("Program: %s\n\n", MCCODE_STRING);
    
    mcsiminfo_out("begin instrument: %s\n", mcinstrument_name);
    mcinfo_out(   "  ", mcsiminfo_file);
    mcsiminfo_out("end instrument\n");

    mcsiminfo_out("\nbegin simulation: %s\n", mcdirname);
    mcruninfo_out("  ", mcsiminfo_file);
    mcsiminfo_out("end simulation\n");

  }
  return (mcsiminfo_file);
  
  ); /* MPI_MASTER */
  
} /* mcsiminfo_init */

/*******************************************************************************
*   mcsiminfo_close:  close SIM
*******************************************************************************/
void mcsiminfo_close()
{
  MPI_MASTER(
  if(mcsiminfo_file && !mcdisable_output_files) {
#ifdef USE_NEXUS
    if (mcformat && strcasestr(mcformat, "NeXus")) {
      time_t t=time(NULL);
      nxprintf(nxhandle, "end_time", ctime(&t));
      nxprintf(nxhandle, "duration", "%li", (long)t-mcstartdate);
      NXclosegroup(nxhandle); /* NXentry */
      NXclose(&nxhandle);
    } else
#endif
      fclose(mcsiminfo_file);
    );
    mcsiminfo_file = NULL;
  }
} /* mcsiminfo_close */

/*******************************************************************************
* mcdetector_out_0D: wrapper for 0D (single value).
*   Output single detector/monitor data (p0, p1, p2).
*   Title is t, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2,
                         char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " data"),
    1, 1, 1,
    "I", "", "",
    "I", "", "",
    0, 0, 0, 0, 0, 0, "",
    &p0, &p1, &p2, posa); /* write Detector: line */

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_0D_nexus(detector));
  else
#endif
    return(mcdetector_out_0D_ascii(detector));
    
} /* mcdetector_out_0D */



/*******************************************************************************
* mcdetector_out_1D: wrapper for 1D.
*   Output 1d detector data (p0, p1, p2) for n bins linearly
*   distributed across the range x1..x2 (x1 is lower limit of first
*   bin, x2 is upper limit of last bin). Title is t, axis labels are xl
*   and yl. File name is f, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
        char *xvar, double x1, double x2,
        long n,
        double *p0, double *p1, double *p2, char *f,
        char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " 1D data"),
    n, 1, 1,
    xl, yl, (n > 1 ? "Signal per bin" : " Signal"),
    xvar, "(I,I_err)", "I",
    x1, x2, 0, 0, 0, 0, f,
    p0, p1, p2, posa); /* write Detector: line */
  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_1D_nexus(detector));
  else
#endif
    return(mcdetector_out_1D_ascii(detector));
  
} /* mcdetector_out_1D */

/*******************************************************************************
* mcdetector_out_2D: wrapper for 2D.
*   special case for list: master creates file first, then slaves append their blocks without header
*******************************************************************************/
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2,
                  long m, long n,
                  double *p0, double *p1, double *p2, char *f,
                  char *c, Coords posa)
{
  char xvar[CHAR_BUF_LENGTH];
  char yvar[CHAR_BUF_LENGTH];
  
  /* create short axes labels */
  if (xl && strlen(xl)) { strncpy(xvar, xl, CHAR_BUF_LENGTH); xvar[2]='\0'; }
  else strcpy(xvar, "x");
  if (yl && strlen(yl)) { strncpy(yvar, yl, CHAR_BUF_LENGTH); yvar[2]='\0'; }
  else strcpy(yvar, "y");

  MCDETECTOR detector;

  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  if (abs(m) == 1) {/* n>1 on Y, m==1 on X: 1D, no X axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      n, 1, 1,
      yl, "", "Signal per bin",
      yvar, "(I,Ierr)", "I",
      y1, y2, x1, x2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  } else if (abs(n)==1) {/* m>1 on X, n==1 on Y: 1D, no Y axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      m, 1, 1,
      xl, "", "Signal per bin",
      xvar, "(I,Ierr)", "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }else {
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 2D data"),
      m, n, 1,
      xl, yl, "Signal per bin",
      xvar, yvar, "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }

  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_2D_nexus(detector));
  else
#endif
    return(mcdetector_out_2D_ascii(detector));
  
} /* mcdetector_out_2D */

/*******************************************************************************
* mcdetector_out_list: wrapper for list output (calls out_2D with mcformat+"list").
*   m=number of events, n=size of each event
*******************************************************************************/
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa)
{
  char       format_new[CHAR_BUF_LENGTH];
  char      *format_org;
  MCDETECTOR detector;
  
  format_org = mcformat;
  strcpy(format_new, mcformat);
  strcat(format_new, " list");
  mcformat = format_new;

  detector = mcdetector_out_2D(t, xl, yl,
                  1,abs(m),1,abs(n),
                  m,n,
                  NULL, p1, NULL, f,
                  c, posa);
  
  mcformat = format_org;
  return(detector);
}

/*******************************************************************************
 * mcuse_dir: set data/sim storage directory and create it,
 * or exit with error if exists
 ******************************************************************************/
static void
mcuse_dir(char *dir)
{
  if (!dir || !strlen(dir)) return;
#ifdef MC_PORTABLE
  fprintf(stderr, "Error: "
          "Directory output cannot be used with portable simulation (mcuse_dir)\n");
  exit(1);
#else  /* !MC_PORTABLE */
  /* handle file://directory URL type */
  if (strncmp(dir, "file://", strlen("file://")))
    mcdirname = dir;
  else
    mcdirname = dir+strlen("file://");
  
  
  
  MPI_MASTER(
    if(mkdir(mcdirname, 0777)) {
#ifndef DANSE
      fprintf(stderr, "Error: unable to create directory '%s' (mcuse_dir)\n", dir);
      fprintf(stderr, "(Maybe the directory already exists?)\n");
#endif
#ifdef USE_MPI
    MPI_Abort(MPI_COMM_WORLD, -1);
#endif
    exit(-1);
    }
  ); /* MPI_MASTER */
  
  /* remove trailing PATHSEP (if any) */
  while (strlen(mcdirname) && mcdirname[strlen(mcdirname) - 1] == MC_PATHSEP_C)
    mcdirname[strlen(mcdirname) - 1]='\0';
#endif /* !MC_PORTABLE */
} /* mcuse_dir */

/*******************************************************************************
* mcinfo: display instrument simulation info to stdout and exit
*******************************************************************************/
static void
mcinfo(void)
{
  fprintf(stdout, "begin instrument: %s\n", mcinstrument_name);
  mcinfo_out("  ", stdout);
  fprintf(stdout, "end instrument\n");
  fprintf(stdout, "begin simulation: %s\n", mcdirname ? mcdirname : ".");
  mcruninfo_out("  ", stdout);
  fprintf(stdout, "end simulation\n");
  exit(0); /* includes MPI_Finalize in MPI mode */
} /* mcinfo */

#endif /* ndef MCCODE_R_IO_C */

/* end of the I/O section =================================================== */







/*******************************************************************************
* mcset_ncount: set total number of rays to generate
*******************************************************************************/
void mcset_ncount(unsigned long long int count)
{
  mcncount = count;
}

/* mcget_ncount: get total number of rays to generate */
unsigned long long int mcget_ncount(void)
{
  return mcncount;
}

/* mcget_run_num: get curent number of rays in TRACE */
unsigned long long int mcget_run_num(void)
{
  return mcrun_num;
}

/* mcsetn_arg: get ncount from a string argument */
static void
mcsetn_arg(char *arg)
{
  mcset_ncount((long long int) strtod(arg, NULL));
}

/* mcsetseed: set the random generator seed from a string argument */
static void
mcsetseed(char *arg)
{
  mcseed = atol(arg);
  if(mcseed) {
    srandom(mcseed);
  } else {
    fprintf(stderr, "Error: seed must not be zero (mcsetseed)\n");
    exit(1);
  }
}

/* Following part is only embedded when not redundent with mccode-r.h ========= */

#ifndef MCCODE_H

/* SECTION: MCDISPLAY support. =============================================== */

/*******************************************************************************
* Just output MCDISPLAY keywords to be caught by an external plotter client.
*******************************************************************************/

void mcdis_magnify(char *what){
  printf("MCDISPLAY: magnify('%s')\n", what);
}

void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2){
  printf("MCDISPLAY: multiline(2,%g,%g,%g,%g,%g,%g)\n",
         x1,y1,z1,x2,y2,z2);
}

void mcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n){
  int i;
  const double dx = (x2-x1)/(2*n+1);
  const double dy = (y2-y1)/(2*n+1);
  const double dz = (z2-z1)/(2*n+1);

  for(i = 0; i < n+1; i++)
    mcdis_line(x1 + 2*i*dx,     y1 + 2*i*dy,     z1 + 2*i*dz,
	       x1 + (2*i+1)*dx, y1 + (2*i+1)*dy, z1 + (2*i+1)*dz);
}

void mcdis_multiline(int count, ...){
  va_list ap;
  double x,y,z;

  printf("MCDISPLAY: multiline(%d", count);
  va_start(ap, count);
  while(count--)
    {
    x = va_arg(ap, double);
    y = va_arg(ap, double);
    z = va_arg(ap, double);
    printf(",%g,%g,%g", x, y, z);
    }
  va_end(ap);
  printf(")\n");
}

void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height){
  /* draws a rectangle in the plane           */
  /* x is ALWAYS width and y is ALWAYS height */
  if (strcmp("xy", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y - height/2, z,
		    x + width/2, y - height/2, z,
		    x + width/2, y + height/2, z,
		    x - width/2, y + height/2, z,
		    x - width/2, y - height/2, z);
  } else if (strcmp("xz", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y, z - height/2,
		    x + width/2, y, z - height/2,
		    x + width/2, y, z + height/2,
		    x - width/2, y, z + height/2,
		    x - width/2, y, z - height/2);
  } else if (strcmp("yz", plane)==0) {
    mcdis_multiline(5,
		    x, y - height/2, z - width/2,
		    x, y - height/2, z + width/2,
		    x, y + height/2, z + width/2,
		    x, y + height/2, z - width/2,
		    x, y - height/2, z - width/2);
  } else {

    fprintf(stderr, "Error: Definition of plane %s unknown\n", plane);
    exit(1);
  }
}

/*  draws a box with center at (x, y, z) and
    width (deltax), height (deltay), length (deltaz) */
void mcdis_box(double x, double y, double z,
	       double width, double height, double length){

  mcdis_rectangle("xy", x, y, z-length/2, width, height);
  mcdis_rectangle("xy", x, y, z+length/2, width, height);
  mcdis_line(x-width/2, y-height/2, z-length/2,
	     x-width/2, y-height/2, z+length/2);
  mcdis_line(x-width/2, y+height/2, z-length/2,
	     x-width/2, y+height/2, z+length/2);
  mcdis_line(x+width/2, y-height/2, z-length/2,
	     x+width/2, y-height/2, z+length/2);
  mcdis_line(x+width/2, y+height/2, z-length/2,
	     x+width/2, y+height/2, z+length/2);
}

void mcdis_circle(char *plane, double x, double y, double z, double r){
  printf("MCDISPLAY: circle('%s',%g,%g,%g,%g)\n", plane, x, y, z, r);
}

/* SECTION: coordinates handling ============================================ */

/*******************************************************************************
* Since we use a lot of geometric calculations using Cartesian coordinates,
* we collect some useful routines here. However, it is also permissible to
* work directly on the underlying struct coords whenever that is most
* convenient (that is, the type Coords is not abstract).
*
* Coordinates are also used to store rotation angles around x/y/z axis.
*
* Since coordinates are used much like a basic type (such as double), the
* structure itself is passed and returned, rather than a pointer.
*
* At compile-time, the values of the coordinates may be unknown (for example
* a motor position). Hence coordinates are general expressions and not simple
* numbers. For this we used the type Coords_exp which has three CExp
* fields. For runtime (or calculations possible at compile time), we use
* Coords which contains three double fields.
*******************************************************************************/

/* coords_set: Assign coordinates. */
Coords
coords_set(MCNUM x, MCNUM y, MCNUM z)
{
  Coords a;

  a.x = x;
  a.y = y;
  a.z = z;
  return a;
}

/* coords_get: get coordinates. Required when 'x','y','z' are #defined as ray pars */
Coords
coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z)
{
  *x = a.x;
  *y = a.y;
  *z = a.z;
  return a;
}

/* coords_add: Add two coordinates. */
Coords
coords_add(Coords a, Coords b)
{
  Coords c;

  c.x = a.x + b.x;
  c.y = a.y + b.y;
  c.z = a.z + b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_sub: Subtract two coordinates. */
Coords
coords_sub(Coords a, Coords b)
{
  Coords c;

  c.x = a.x - b.x;
  c.y = a.y - b.y;
  c.z = a.z - b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_neg: Negate coordinates. */
Coords
coords_neg(Coords a)
{
  Coords b;

  b.x = -a.x;
  b.y = -a.y;
  b.z = -a.z;
  return b;
}

/* coords_scale: Scale a vector. */
Coords coords_scale(Coords b, double scale) {
  Coords a;

  a.x = b.x*scale;
  a.y = b.y*scale;
  a.z = b.z*scale;
  return a;
}

/* coords_sp: Scalar product: a . b */
double coords_sp(Coords a, Coords b) {
  double value;

  value = a.x*b.x + a.y*b.y + a.z*b.z;
  return value;
}

/* coords_xp: Cross product: a = b x c. */
Coords coords_xp(Coords b, Coords c) {
  Coords a;

  a.x = b.y*c.z - c.y*b.z;
  a.y = b.z*c.x - c.z*b.x;
  a.z = b.x*c.y - c.x*b.y;
  return a;
}

/* coords_len: Gives length of coords set. */
double coords_len(Coords a) {
  return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

/* coords_mirror: Mirror a in plane (through the origin) defined by normal n*/
Coords coords_mirror(Coords a, Coords n) {
  double t = scalar_prod(n.x, n.y, n.z, n.x, n.y, n.z);
  Coords b;
  if (t!=1) {
    t = sqrt(t);
    n.x /= t;
    n.y /= t;
    n.z /= t;
  }
  t=scalar_prod(a.x, a.y, a.z, n.x, n.y, n.z);
  b.x = a.x-2*t*n.x;
  b.y = a.y-2*t*n.y;
  b.z = a.z-2*t*n.z;
  return b;
}

/* coords_print: Print out vector values. */
void coords_print(Coords a) {

  fprintf(stdout, "(%f, %f, %f)\n", a.x, a.y, a.z);
  return;
}

mcstatic inline void coords_norm(Coords* c) {
	double temp = coords_sp(*c,*c);

	// Skip if we will end dividing by zero
	if (temp == 0) return;

	temp = sqrt(temp);

	c->x /= temp;
	c->y /= temp;
	c->z /= temp;
}

/*******************************************************************************
* The Rotation type implements a rotation transformation of a coordinate
* system in the form of a double[3][3] matrix.
*
* Contrary to the Coords type in coords.c, rotations are passed by
* reference. Functions that yield new rotations do so by writing to an
* explicit result parameter; rotations are not returned from functions. The
* reason for this is that arrays cannot by returned from functions (though
* structures can; thus an alternative would have been to wrap the
* double[3][3] array up in a struct). Such are the ways of C programming.
*
* A rotation represents the tranformation of the coordinates of a vector when
* changing between coordinate systems that are rotated with respect to each
* other. For example, suppose that coordinate system Q is rotated 45 degrees
* around the Z axis with respect to coordinate system P. Let T be the
* rotation transformation representing a 45 degree rotation around Z. Then to
* get the coordinates of a vector r in system Q, apply T to the coordinates
* of r in P. If r=(1,0,0) in P, it will be (sqrt(1/2),-sqrt(1/2),0) in
* Q. Thus we should be careful when interpreting the sign of rotation angles:
* they represent the rotation of the coordinate systems, not of the
* coordinates (which has opposite sign).
*******************************************************************************/

/*******************************************************************************
* rot_set_rotation: Get transformation for rotation first phx around x axis,
* then phy around y, then phz around z.
*******************************************************************************/
void
rot_set_rotation(Rotation t, double phx, double phy, double phz)
{
  if ((phx == 0) && (phy == 0) && (phz == 0)) {
    t[0][0] = 1.0;
    t[0][1] = 0.0;
    t[0][2] = 0.0;
    t[1][0] = 0.0;
    t[1][1] = 1.0;
    t[1][2] = 0.0;
    t[2][0] = 0.0;
    t[2][1] = 0.0;
    t[2][2] = 1.0;
  } else {
    double cx = cos(phx);
    double sx = sin(phx);
    double cy = cos(phy);
    double sy = sin(phy);
    double cz = cos(phz);
    double sz = sin(phz);

    t[0][0] = cy*cz;
    t[0][1] = sx*sy*cz + cx*sz;
    t[0][2] = sx*sz - cx*sy*cz;
    t[1][0] = -cy*sz;
    t[1][1] = cx*cz - sx*sy*sz;
    t[1][2] = sx*cz + cx*sy*sz;
    t[2][0] = sy;
    t[2][1] = -sx*cy;
    t[2][2] = cx*cy;
  }
}

/*******************************************************************************
* rot_test_identity: Test if rotation is identity
*******************************************************************************/
int
rot_test_identity(Rotation t)
{
  return (t[0][0] + t[1][1] + t[2][2] == 3);
}

/*******************************************************************************
* rot_mul: Matrix multiplication of transformations (this corresponds to
* combining transformations). After rot_mul(T1, T2, T3), doing T3 is
* equal to doing first T2, then T1.
* Note that T3 must not alias (use the same array as) T1 or T2.
*******************************************************************************/
void
rot_mul(Rotation t1, Rotation t2, Rotation t3)
{
  if (rot_test_identity(t1)) {
    rot_copy(t3, t2);
  } else if (rot_test_identity(t2)) {
    rot_copy(t3, t1);
  } else {
    int i,j;
    for(i = 0; i < 3; i++)
      for(j = 0; j < 3; j++)
	t3[i][j] = t1[i][0]*t2[0][j] + t1[i][1]*t2[1][j] + t1[i][2]*t2[2][j];
  }
}

/*******************************************************************************
* rot_copy: Copy a rotation transformation (arrays cannot be assigned in C).
*******************************************************************************/
void
rot_copy(Rotation dest, Rotation src)
{
  int i,j;
  for(i = 0; i < 3; i++)
    for(j = 0; j < 3; j++)
      dest[i][j] = src[i][j];
}

/*******************************************************************************
* rot_transpose: Matrix transposition, which is inversion for Rotation matrices
*******************************************************************************/
void
rot_transpose(Rotation src, Rotation dst)
{
  dst[0][0] = src[0][0];
  dst[0][1] = src[1][0];
  dst[0][2] = src[2][0];
  dst[1][0] = src[0][1];
  dst[1][1] = src[1][1];
  dst[1][2] = src[2][1];
  dst[2][0] = src[0][2];
  dst[2][1] = src[1][2];
  dst[2][2] = src[2][2];
}

/*******************************************************************************
* rot_apply: returns t*a
*******************************************************************************/
Coords
rot_apply(Rotation t, Coords a)
{
  Coords b;
  if (rot_test_identity(t)) {
    return a;
  } else {
    b.x = t[0][0]*a.x + t[0][1]*a.y + t[0][2]*a.z;
    b.y = t[1][0]*a.x + t[1][1]*a.y + t[1][2]*a.z;
    b.z = t[2][0]*a.x + t[2][1]*a.y + t[2][2]*a.z;
    return b;
  }
}

/**
 * Pretty-printing of rotation matrices.
 */
void rot_print(Rotation rot) {
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[0][0], rot[0][1], rot[0][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[1][0], rot[1][1], rot[1][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n\n",
			rot[2][0], rot[2][1], rot[2][2]);
}

/**
 * Vector product: used by vec_prod (mccode-r.h). Use coords_xp for Coords.
 */
mcstatic inline void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
    *x = (y1)*(z2) - (y2)*(z1);
    *y = (z1)*(x2) - (z2)*(x1);
    *z = (x1)*(y2) - (x2)*(y1);
}

/**
 * Scalar product: use coords_sp for Coords.
 */
mcstatic inline double scalar_prod(
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
	return ((x1 * x2) + (y1 * y2) + (z1 * z2));
}

/*******************************************************************************
* mccoordschange: applies rotation to (x y z) and (vx vy vz) and Spin (sx,sy,sz)
*******************************************************************************/
void
mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *x;
  b.y = *y;
  b.z = *z;
  c = rot_apply(t, b);
  b = coords_add(c, a);
  *x = b.x;
  *y = b.y;
  *z = b.z;

  if ( (vz && vy  && vx) && (*vz != 0.0 || *vx != 0.0 || *vy != 0.0) ) mccoordschange_polarisation(t, vx, vy, vz);

  if ( (sz && sy  && sx) && (*sz != 0.0 || *sx != 0.0 || *sy != 0.0) ) mccoordschange_polarisation(t, sx, sy, sz);

}

/*******************************************************************************
* mccoordschange_polarisation: applies rotation to vector (sx sy sz)
*******************************************************************************/
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *sx;
  b.y = *sy;
  b.z = *sz;
  c = rot_apply(t, b);
  *sx = c.x;
  *sy = c.y;
  *sz = c.z;
}

/* SECTION: vector math  ==================================================== */

/* normal_vec_func: Compute normal vector to (x,y,z). */
mcstatic inline void normal_vec_func(double *nx, double *ny, double *nz,
                double x, double y, double z)
{
  double ax = fabs(x);
  double ay = fabs(y);
  double az = fabs(z);
  double l;
  if(x == 0 && y == 0 && z == 0)
  {
    *nx = 0;
    *ny = 0;
    *nz = 0;
    return;
  }
  if(ax < ay)
  {
    if(ax < az)
    {                           /* Use X axis */
      l = sqrt(z*z + y*y);
      *nx = 0;
      *ny = z/l;
      *nz = -y/l;
      return;
    }
  }
  else
  {
    if(ay < az)
    {                           /* Use Y axis */
      l = sqrt(z*z + x*x);
      *nx = z/l;
      *ny = 0;
      *nz = -x/l;
      return;
    }
  }
  /* Use Z axis */
  l = sqrt(y*y + x*x);
  *nx = y/l;
  *ny = -x/l;
  *nz = 0;
} /* normal_vec */

/*******************************************************************************
 * solve_2nd_order: second order equation solve: A*t^2 + B*t + C = 0
 * solve_2nd_order(&t1, NULL, A,B,C)
 *   returns 0 if no solution was found, or set 't1' to the smallest positive
 *   solution.
 * solve_2nd_order(&t1, &t2, A,B,C)
 *   same as with &t2=NULL, but also returns the second solution.
 * EXAMPLE usage for intersection of a trajectory with a plane in gravitation
 * field (gx,gy,gz):
 * The neutron starts at point r=(x,y,z) with velocityv=(vx vy vz). The plane
 * has a normal vector n=(nx,ny,nz) and contains the point W=(wx,wy,wz).
 * The problem consists in solving the 2nd order equation:
 *      1/2.n.g.t^2 + n.v.t + n.(r-W) = 0
 * so that A = 0.5 n.g; B = n.v; C = n.(r-W);
 * Without acceleration, t=-n.(r-W)/n.v
 ******************************************************************************/
int solve_2nd_order(double *t1, double *t2,
                  double A,  double B,  double C)
{
  int ret=0;

  if (!t1) return 0;
  *t1 = 0;
  if (t2) *t2=0;

  if (fabs(A) < 1E-10) /* approximate to linear equation: A ~ 0 */
  {
    if (B) {  *t1 = -C/B; ret=1; if (t2) *t2=*t1; }
    /* else no intersection: A=B=0 ret=0 */
  }
  else
  {
    double D;
    D = B*B - 4*A*C;
    if (D >= 0) /* Delta > 0: two solutions */
    {
      double sD, dt1, dt2;
      sD = sqrt(D);
      dt1 = (-B + sD)/2/A;
      dt2 = (-B - sD)/2/A;
      /* we identify very small values with zero */
      if (fabs(dt1) < 1e-10) dt1=0.0;
      if (fabs(dt2) < 1e-10) dt2=0.0;

      /* now we choose the smallest positive solution */
      if      (dt1<=0.0 && dt2>0.0) ret=2; /* dt2 positive */
      else if (dt2<=0.0 && dt1>0.0) ret=1; /* dt1 positive */
      else if (dt1> 0.0 && dt2>0.0)
      {  if (dt1 < dt2) ret=1; else ret=2; } /* all positive: min(dt1,dt2) */
      /* else two solutions are negative. ret=-1 */
      if (ret==1) { *t1 = dt1;  if (t2) *t2=dt2; }
      else        { *t1 = dt2;  if (t2) *t2=dt1; }
      ret=2;  /* found 2 solutions and t1 is the positive one */
    } /* else Delta <0: no intersection. ret=0 */
  }
  return(ret);
} /* solve_2nd_order */

/*******************************************************************************
 * randvec_target_circle: Choose random direction towards target at (x,y,z)
 * with given radius.
 * If radius is zero, choose random direction in full 4PI, no target.
 ******************************************************************************/
void
randvec_target_circle(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double radius)
{
  double l2, phi, theta, nx, ny, nz, xt, yt, zt, xu, yu, zu;

  if(radius == 0.0)
  {
    /* No target, choose uniformly a direction in full 4PI solid angle. */
    theta = acos (1 - rand0max(2));
    phi = rand0max(2 * PI);
    if(solid_angle)
      *solid_angle = 4*PI;
    nx = 1;
    ny = 0;
    nz = 0;
    yi = sqrt(xi*xi+yi*yi+zi*zi);
    zi = 0;
    xi = 0;
  }
  else
  {
    double costheta0;
    l2 = xi*xi + yi*yi + zi*zi; /* sqr Distance to target. */
    costheta0 = sqrt(l2/(radius*radius+l2));
    if (radius < 0) costheta0 *= -1;
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
        *solid_angle = 2*PI*(1 - costheta0);
    }

    /* Now choose point uniformly on circle surface within angle theta0 */
    theta = acos (1 - rand0max(1 - costheta0)); /* radius on circle */
    phi = rand0max(2 * PI); /* rotation on circle at given radius */
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around a
       perpendicular axis u=i x n and then angle phi around i. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, xu, yu, zu);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xi, yi, zi);
} /* randvec_target_circle */

/*******************************************************************************
 * randvec_target_rect_angular: Choose random direction towards target at
 * (xi,yi,zi) with given ANGULAR dimension height x width. height=phi_x=[0,PI],
 * width=phi_y=[0,2*PI] (radians)
 * If height or width is zero, choose random direction in full 4PI, no target.
 *******************************************************************************/
void
randvec_target_rect_angular(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double width, double height, Rotation A)
{
  double theta, phi, nx, ny, nz, xt, yt, zt, xu, yu, zu;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
      *solid_angle = 2*fabs(width*sin(height/2));
    }

    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Now choose point uniformly on the unit sphere segment with angle theta/phi */
    phi   = width*randpm1()/2.0;
    theta = asin(randpm1()*sin(height/2.0));
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around
       n, and then phi around u. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, nx, ny, nz);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xu,  yu,  zu);

  /* Go back to local coordinate system */
  tmp = coords_set(*xo, *yo, *zo);
  tmp = rot_apply(A, tmp);
  coords_get(tmp, &*xo, &*yo, &*zo);

} /* randvec_target_rect_angular */

/*******************************************************************************
 * randvec_target_rect_real: Choose random direction towards target at (xi,yi,zi)
 * with given dimension height x width (in meters !).
 *
 * Local emission coordinate is taken into account and corrected for 'order' times.
 * (See remarks posted to mcstas-users by George Apostolopoulus <gapost@ipta.demokritos.gr>)
 *
 * If height or width is zero, choose random direction in full 4PI, no target.
 *
 * Traditionally, this routine had the name randvec_target_rect - this is now a
 * a define (see mcstas-r.h) pointing here. If you use the old rouine, you are NOT
 * taking the local emmission coordinate into account.
*******************************************************************************/

void
randvec_target_rect_real(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi,
               double width, double height, Rotation A,
               double lx, double ly, double lz, int order)
{
  double dx, dy, dist, dist_p, nx, ny, nz, mx, my, mz, n_norm, m_norm;
  double cos_theta;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {

    /* Now choose point uniformly on rectangle within width x height */
    dx = width*randpm1()/2.0;
    dy = height*randpm1()/2.0;

    /* Determine distance to target plane*/
    dist = sqrt(xi*xi + yi*yi + zi*zi);
    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Determine vector normal to trajectory axis (z) and gravity [0 1 0] */
    vec_prod(nx, ny, nz, xi, yi, zi, 0, 1, 0);

    /* This now defines the x-axis, normalize: */
    n_norm=sqrt(nx*nx + ny*ny + nz*nz);
    nx = nx/n_norm;
    ny = ny/n_norm;
    nz = nz/n_norm;

    /* Now, determine our y-axis (vertical in many cases...) */
    vec_prod(mx, my, mz, xi, yi, zi, nx, ny, nz);
    m_norm=sqrt(mx*mx + my*my + mz*mz);
    mx = mx/m_norm;
    my = my/m_norm;
    mz = mz/m_norm;

    /* Our output, random vector can now be defined by linear combination: */

    *xo = xi + dx * nx + dy * mx;
    *yo = yi + dx * ny + dy * my;
    *zo = zi + dx * nz + dy * mz;

    /* Go back to local coordinate system */
    tmp = coords_set(*xo, *yo, *zo);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &*xo, &*yo, &*zo);

    /* Go back to local coordinate system */
    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    if (solid_angle) {
      /* Calculate vector from local point to remote random point */
      lx = *xo - lx;
      ly = *yo - ly;
      lz = *zo - lz;
      dist_p = sqrt(lx*lx + ly*ly + lz*lz);

      /* Adjust the 'solid angle' */
      /* 1/r^2 to the chosen point times cos(\theta) between the normal */
      /* vector of the target rectangle and direction vector of the chosen point. */
      cos_theta = (xi * lx + yi * ly + zi * lz) / (dist * dist_p);
      *solid_angle = width * height / (dist_p * dist_p);
      int counter;
      for (counter = 0; counter < order; counter++) {
	*solid_angle = *solid_angle * cos_theta;
      }
    }
  }
} /* randvec_target_rect_real */

/* SECTION: random numbers ================================================== */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * This is derived from the Berkeley source:
 *        @(#)random.c        5.5 (Berkeley) 7/6/88
 * It was reworked for the GNU C Library by Roland McGrath.
 * Rewritten to use reentrant functions by Ulrich Drepper, 1995.
 */

/*******************************************************************************
* Modified for McStas from glibc 2.0.7pre1 stdlib/random.c and
* stdlib/random_r.c.
*
* This way random() is more than four times faster compared to calling
* standard glibc random() on ix86 Linux, probably due to multithread support,
* ELF shared library overhead, etc. It also makes McStas generated
* simulations more portable (more likely to behave identically across
* platforms, important for parrallel computations).
*******************************************************************************/


#define        TYPE_3                3
#define        BREAK_3                128
#define        DEG_3                31
#define        SEP_3                3

static mc_int32_t randtbl[DEG_3 + 1] =
  {
    TYPE_3,

    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,
    1627687941, -179304937, -2073333483, 1780058412, -1989503057,
    -615974602, 344556628, 939512070, -1249116260, 1507946756,
    -812545463, 154635395, 1388815473, -1926676823, 525320961,
    -1009028674, 968117788, -123449607, 1284210865, 435012392,
    -2017506339, -911064859, -370259173, 1132637927, 1398500161,
    -205601318,
  };

static mc_int32_t *fptr = &randtbl[SEP_3 + 1];
static mc_int32_t *rptr = &randtbl[1];
static mc_int32_t *state = &randtbl[1];
#define rand_deg DEG_3
#define rand_sep SEP_3
static mc_int32_t *end_ptr = &randtbl[sizeof (randtbl) / sizeof (randtbl[0])];

mc_int32_t
mc_random (void)
{
  mc_int32_t result;

  *fptr += *rptr;
  /* Chucking least random bit.  */
  result = (*fptr >> 1) & 0x7fffffff;
  ++fptr;
  if (fptr >= end_ptr)
  {
    fptr = state;
    ++rptr;
  }
  else
  {
    ++rptr;
    if (rptr >= end_ptr)
      rptr = state;
  }
  return result;
}

void
mc_srandom (unsigned int x)
{
  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
  state[0] = x ? x : 1;
  {
    long int i;
    for (i = 1; i < rand_deg; ++i)
    {
      /* This does:
         state[i] = (16807 * state[i - 1]) % 2147483647;
         but avoids overflowing 31 bits.  */
      long int hi = state[i - 1] / 127773;
      long int lo = state[i - 1] % 127773;
      long int test = 16807 * lo - 2836 * hi;
      state[i] = test + (test < 0 ? 2147483647 : 0);
    }
    fptr = &state[rand_sep];
    rptr = &state[0];
    for (i = 0; i < 10 * rand_deg; ++i)
      random ();
  }
}

/* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
/* See http://www.math.keio.ac.jp/~matumoto/emt.html for original source. */


/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using mt_srandom(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.keio.ac.jp/matumoto/emt.html
   email: matumoto@math.keio.ac.jp
*/

#include <stdio.h>

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void mt_srandom(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] =
            (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
void init_by_array(unsigned long init_key[], unsigned long key_length)
{
    int i, j, k;
    mt_srandom(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long mt_random(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if mt_srandom() has not been called, */
            mt_srandom(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }

    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

#undef N
#undef M
#undef MATRIX_A
#undef UPPER_MASK
#undef LOWER_MASK

/* End of "Mersenne Twister". */

/* End of McCode random number routine. */

/* randnorm: generate a random number from normal law */
double
randnorm(void)
{
  static double v1, v2, s;
  static int phase = 0;
  double X, u1, u2;

  if(phase == 0)
  {
    do
    {
      u1 = rand01();
      u2 = rand01();
      v1 = 2*u1 - 1;
      v2 = 2*u2 - 1;
      s = v1*v1 + v2*v2;
    } while(s >= 1 || s == 0);

    X = v1*sqrt(-2*log(s)/s);
  }
  else
  {
    X = v2*sqrt(-2*log(s)/s);
  }

  phase = 1 - phase;
  return X;
}

/**
 * Generate a random number from -1 to 1 with triangle distribution
 */
double randtriangle(void) {
	double randnum = rand01();
	if (randnum>0.5) return(1-sqrt(2*(randnum-0.5)));
	else return(sqrt(2*randnum)-1);
}

/**
 * Random number between 0.0 and 1.0 (including?)
 */
double rand01() {
	double randnum;
	randnum = (double) random();
	randnum /= (double) MC_RAND_MAX + 1;
	return randnum;
}

/**
 * Return a random number between 1 and -1
 */
double randpm1() {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / 2;
	randnum -= 1;
	return randnum;
}

/**
 * Return a random number between 0 and max.
 */
double rand0max(double max) {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / max;
	return randnum;
}

/**
 * Return a random number between min and max.
 */
double randminmax(double min, double max) {
	return rand0max(max - min) + max;
}

/* SECTION: main and signal handlers ======================================== */

/*******************************************************************************
* mchelp: displays instrument executable help with possible options
*******************************************************************************/
static void
mchelp(char *pgmname)
{
  int i;

  fprintf(stderr, "%s (%s) instrument simulation, generated with " MCCODE_STRING " (" MCCODE_DATE ")\n", mcinstrument_name, mcinstrument_source);
  fprintf(stderr, "Usage: %s [options] [parm=value ...]\n", pgmname);
  fprintf(stderr,
"Options are:\n"
"  -s SEED   --seed=SEED      Set random seed (must be != 0)\n"
"  -n COUNT  --ncount=COUNT   Set number of " MCCODE_PARTICLE "s to simulate.\n"
"  -d DIR    --dir=DIR        Put all data files in directory DIR.\n"
"  -t        --trace          Enable trace of " MCCODE_PARTICLE "s through instrument.\n"
"  -g        --gravitation    Enable gravitation for all trajectories.\n"
"  --no-output-files          Do not write any data files.\n"
"  -h        --help           Show this help message.\n"
"  -i        --info           Detailed instrument information.\n"
"  --format=FORMAT            Output data files using FORMAT="
   FLAVOR_UPPER
#ifdef USE_NEXUS
   " NEXUS"
#endif
"\n\n"
);
#ifdef USE_MPI
  fprintf(stderr,
  "This instrument has been compiled with MPI support.\n  Use 'mpirun %s [options] [parm=value ...]'.\n", pgmname);
#endif
  if(mcnumipar > 0)
  {
    fprintf(stderr, "Instrument parameters are:\n");
    for(i = 0; i < mcnumipar; i++)
      if (mcinputtable[i].val && strlen(mcinputtable[i].val))
        fprintf(stderr, "  %-16s(%s) [default='%s']\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name),
        mcinputtable[i].val);
      else
        fprintf(stderr, "  %-16s(%s)\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name));
  }

#ifndef NOSIGNALS
  fprintf(stderr, "Known signals are: "
#ifdef SIGUSR1
  "USR1 (status) "
#endif
#ifdef SIGUSR2
  "USR2 (save) "
#endif
#ifdef SIGBREAK
  "BREAK (save) "
#endif
#ifdef SIGTERM
  "TERM (save and exit)"
#endif
  "\n");
#endif /* !NOSIGNALS */
} /* mchelp */


/* mcshowhelp: show help and exit with 0 */
static void
mcshowhelp(char *pgmname)
{
  mchelp(pgmname);
  exit(0);
}

/* mcusage: display usage when error in input arguments and exit with 1 */
static void
mcusage(char *pgmname)
{
  fprintf(stderr, "Error: incorrect command line arguments\n");
  mchelp(pgmname);
  exit(1);
}

/* mcenabletrace: enable trace/mcdisplay or error if requires recompile */
static void
mcenabletrace(void)
{
 if(mctraceenabled)
  mcdotrace = 1;
 else
 {
   fprintf(stderr,
           "Error: trace not enabled (mcenabletrace)\n"
           "Please re-run the " MCCODE_NAME " compiler "
                   "with the --trace option, or rerun the\n"
           "C compiler with the MC_TRACE_ENABLED macro defined.\n");
   exit(1);
 }
}

/*******************************************************************************
* mcreadparams: request parameters from the prompt (or use default)
*******************************************************************************/
void
mcreadparams(void)
{
  int i,j,status;
  static char buf[CHAR_BUF_LENGTH];
  char *p;
  int len;

  MPI_MASTER(printf("Instrument parameters for %s (%s)\n",
                    mcinstrument_name, mcinstrument_source));

  for(i = 0; mcinputtable[i].name != 0; i++)
  {
    do
    {
      MPI_MASTER(
                 if (mcinputtable[i].val && strlen(mcinputtable[i].val))
                   printf("Set value of instrument parameter %s (%s) [default='%s']:\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name), mcinputtable[i].val);
                 else
                   printf("Set value of instrument parameter %s (%s):\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name));
                 fflush(stdout);
                 );
#ifdef USE_MPI
      if(mpi_node_rank == mpi_node_root)
        {
          p = fgets(buf, CHAR_BUF_LENGTH, stdin);
          if(p == NULL)
            {
              fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
              exit(1);
            }
        }
      else
        p = buf;
      MPI_Bcast(buf, CHAR_BUF_LENGTH, MPI_CHAR, mpi_node_root, MPI_COMM_WORLD);
#else /* !USE_MPI */
      p = fgets(buf, CHAR_BUF_LENGTH, stdin);
      if(p == NULL)
        {
          fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
          exit(1);
        }
#endif /* USE_MPI */
      len = strlen(buf);
      if (!len || (len == 1 && (buf[0] == '\n' || buf[0] == '\r')))
      {
        if (mcinputtable[i].val && strlen(mcinputtable[i].val)) {
          strncpy(buf, mcinputtable[i].val, CHAR_BUF_LENGTH);  /* use default value */
          len = strlen(buf);
        }
      }
      for(j = 0; j < 2; j++)
      {
        if(len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
        {
          len--;
          buf[len] = '\0';
        }
      }

      status = (*mcinputtypes[mcinputtable[i].type].getparm)
                   (buf, mcinputtable[i].par);
      if(!status)
      {
        (*mcinputtypes[mcinputtable[i].type].error)(mcinputtable[i].name, buf);
        if (!mcinputtable[i].val || strlen(mcinputtable[i].val)) {
          fprintf(stderr, "       Change %s default value in instrument definition.\n", mcinputtable[i].name);
          exit(1);
        }
      }
    } while(!status);
  }
} /* mcreadparams */

/*******************************************************************************
* mcparseoptions: parse command line arguments (options, parameters)
*******************************************************************************/
void
mcparseoptions(int argc, char *argv[])
{
  int i, j;
  char *p;
  int paramset = 0, *paramsetarray;
  char *usedir=NULL;

  /* Add one to mcnumipar to avoid allocating zero size memory block. */
  paramsetarray = (int*)malloc((mcnumipar + 1)*sizeof(*paramsetarray));
  if(paramsetarray == NULL)
  {
    fprintf(stderr, "Error: insufficient memory (mcparseoptions)\n");
    exit(1);
  }
  for(j = 0; j < mcnumipar; j++)
    {
      paramsetarray[j] = 0;
      if (mcinputtable[j].val != NULL && strlen(mcinputtable[j].val))
      {
        int  status;
        char buf[CHAR_BUF_LENGTH];
        strncpy(buf, mcinputtable[j].val, CHAR_BUF_LENGTH);
        status = (*mcinputtypes[mcinputtable[j].type].getparm)
                   (buf, mcinputtable[j].par);
        if(!status) fprintf(stderr, "Invalid '%s' default value %s in instrument definition (mcparseoptions)\n", mcinputtable[j].name, buf);
        else paramsetarray[j] = 1;
      } else {
        (*mcinputtypes[mcinputtable[j].type].getparm)
          (NULL, mcinputtable[j].par);
        paramsetarray[j] = 0;
      }
    }
  for(i = 1; i < argc; i++)
  {
    if(!strcmp("-s", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("-s", argv[i], 2))
      mcsetseed(&argv[i][2]);
    else if(!strcmp("--seed", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("--seed=", argv[i], 7))
      mcsetseed(&argv[i][7]);
    else if(!strcmp("-n", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("-n", argv[i], 2))
      mcsetn_arg(&argv[i][2]);
    else if(!strcmp("--ncount", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("--ncount=", argv[i], 9))
      mcsetn_arg(&argv[i][9]);
    else if(!strcmp("-d", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];  /* will create directory after parsing all arguments (end of this function)*/
    else if(!strncmp("-d", argv[i], 2))
      usedir=&argv[i][2];
    else if(!strcmp("--dir", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];
    else if(!strncmp("--dir=", argv[i], 6))
      usedir=&argv[i][6];
    else if(!strcmp("-h", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("--help", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("-i", argv[i])) {
      mcformat=FLAVOR_UPPER;
      mcinfo();
    }
    else if(!strcmp("--info", argv[i]))
      mcinfo();
    else if(!strcmp("-t", argv[i]))
      mcenabletrace();
    else if(!strcmp("--trace", argv[i]))
      mcenabletrace();
    else if(!strcmp("--gravitation", argv[i]))
      mcgravitation = 1;
    else if(!strcmp("-g", argv[i]))
      mcgravitation = 1;
    else if(!strncmp("--format=", argv[i], 9)) {
      mcformat=&argv[i][9];
    }
    else if(!strcmp("--format", argv[i]) && (i + 1) < argc) {
      mcformat=argv[++i];
    }
    else if(!strcmp("--no-output-files", argv[i]))
      mcdisable_output_files = 1;
    else if(argv[i][0] != '-' && (p = strchr(argv[i], '=')) != NULL)
    {
      *p++ = '\0';

      for(j = 0; j < mcnumipar; j++)
        if(!strcmp(mcinputtable[j].name, argv[i]))
        {
          int status;
          status = (*mcinputtypes[mcinputtable[j].type].getparm)(p,
                        mcinputtable[j].par);
          if(!status || !strlen(p))
          {
            (*mcinputtypes[mcinputtable[j].type].error)
              (mcinputtable[j].name, p);
            exit(1);
          }
          paramsetarray[j] = 1;
          paramset = 1;
          break;
        }
      if(j == mcnumipar)
      {                                /* Unrecognized parameter name */
        fprintf(stderr, "Error: unrecognized parameter %s (mcparseoptions)\n", argv[i]);
        exit(1);
      }
    }
    else if(argv[i][0] == '-') {
      fprintf(stderr, "Error: unrecognized option argument %s (mcparseoptions). Ignored.\n", argv[i++]);
    }
    else {
      fprintf(stderr, "Error: unrecognized argument %s (mcparseoptions). Aborting.\n", argv[i]);
      mcusage(argv[0]);
    }
  }
  if(!paramset)
    mcreadparams();                /* Prompt for parameters if not specified. */
  else
  {
    for(j = 0; j < mcnumipar; j++)
      if(!paramsetarray[j])
      {
        fprintf(stderr, "Error: Instrument parameter %s left unset (mcparseoptions)\n",
                mcinputtable[j].name);
        exit(1);
      }
  }
  free(paramsetarray);
#ifdef USE_MPI
  if (mcdotrace) mpi_node_count=1; /* disable threading when in trace mode */
#endif
  if (usedir && strlen(usedir)) mcuse_dir(usedir);
} /* mcparseoptions */

#ifndef NOSIGNALS
mcstatic char  mcsig_message[256];


/*******************************************************************************
* sighandler: signal handler that makes simulation stop, and save results
*******************************************************************************/
void sighandler(int sig)
{
  /* MOD: E. Farhi, Sep 20th 2001: give more info */
  time_t t1, t0;
#define SIG_SAVE 0
#define SIG_TERM 1
#define SIG_STAT 2
#define SIG_ABRT 3

  printf("\n# " MCCODE_STRING ": [pid %i] Signal %i detected", getpid(), sig);
#ifdef USE_MPI
  printf(" [proc %i]", mpi_node_rank);
#endif
#if defined(SIGUSR1) && defined(SIGUSR2) && defined(SIGKILL)
  if (!strcmp(mcsig_message, "sighandler") && (sig != SIGUSR1) && (sig != SIGUSR2))
  {
    printf("\n# Fatal : unrecoverable loop ! Suicide (naughty boy).\n");
    kill(0, SIGKILL); /* kill myself if error occurs within sighandler: loops */
  }
#endif
  switch (sig) {
#ifdef SIGINT
    case SIGINT : printf(" SIGINT (interrupt from terminal, Ctrl-C)"); sig = SIG_TERM; break;
#endif
#ifdef SIGILL
    case SIGILL  : printf(" SIGILL (Illegal instruction)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGFPE
    case SIGFPE  : printf(" SIGFPE (Math Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGSEGV
    case SIGSEGV : printf(" SIGSEGV (Mem Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGTERM
    case SIGTERM : printf(" SIGTERM (Termination)"); sig = SIG_TERM; break;
#endif
#ifdef SIGABRT
    case SIGABRT : printf(" SIGABRT (Abort)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGQUIT
    case SIGQUIT : printf(" SIGQUIT (Quit from terminal)"); sig = SIG_TERM; break;
#endif
#ifdef SIGTRAP
    case SIGTRAP : printf(" SIGTRAP (Trace trap)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGPIPE
    case SIGPIPE : printf(" SIGPIPE (Broken pipe)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGUSR1
    case SIGUSR1 : printf(" SIGUSR1 (Display info)"); sig = SIG_STAT; break;
#endif
#ifdef SIGUSR2
    case SIGUSR2 : printf(" SIGUSR2 (Save simulation)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGHUP
    case SIGHUP  : printf(" SIGHUP (Hangup/update)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGBUS
    case SIGBUS  : printf(" SIGBUS (Bus error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGURG
    case SIGURG  : printf(" SIGURG (Urgent socket condition)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGBREAK
    case SIGBREAK: printf(" SIGBREAK (Break signal, Ctrl-Break)"); sig = SIG_SAVE; break;
#endif
    default : printf(" (look at signal list for signification)"); sig = SIG_ABRT; break;
  }
  printf("\n");
  printf("# Simulation: %s (%s) \n", mcinstrument_name, mcinstrument_source);
  printf("# Breakpoint: %s ", mcsig_message);
  if (strstr(mcsig_message, "Save") && (sig == SIG_SAVE))
    sig = SIG_STAT;
  SIG_MESSAGE("sighandler");
  if (mcget_ncount() == 0)
    printf("(0 %%)\n" );
  else
  {
    printf("%.2f %% (%10.1f/%10.1f)\n", 100.0*mcget_run_num()/mcget_ncount(), 1.0*mcget_run_num(), 1.0*mcget_ncount());
  }
  t0 = (time_t)mcstartdate;
  t1 = time(NULL);
  printf("# Date:      %s", ctime(&t1));
  printf("# Started:   %s", ctime(&t0));

  if (sig == SIG_STAT)
  {
    printf("# " MCCODE_STRING ": Resuming simulation (continue)\n");
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_SAVE)
  {
    printf("# " MCCODE_STRING ": Saving data and resume simulation (continue)\n");
    mcsave(NULL);
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_TERM)
  {
    printf("# " MCCODE_STRING ": Finishing simulation (save results and exit)\n");
    mcfinally();
    exit(0);
  }
  else
  {
    fflush(stdout);
    perror("# Last I/O Error");
    printf("# " MCCODE_STRING ": Simulation stop (abort).\n");
// This portion of the signal handling only works on UNIX
#if defined(__unix__) || defined(__APPLE__)
    signal(sig, SIG_DFL); /* force to use default sighandler now */
    kill(getpid(), sig);  /* and trigger it with the current signal */
#endif
    exit(-1);
  }
#undef SIG_SAVE
#undef SIG_TERM
#undef SIG_STAT
#undef SIG_ABRT

} /* sighandler */
#endif /* !NOSIGNALS */

/*******************************************************************************
* mccode_main: McCode main() function.
*******************************************************************************/
int mccode_main(int argc, char *argv[])
{
/*  double run_num = 0; */
  time_t  t;
#ifdef USE_MPI
  char mpi_node_name[MPI_MAX_PROCESSOR_NAME];
  int  mpi_node_name_len;
#endif /* USE_MPI */

#ifdef MAC
  argc = ccommand(&argv);
#endif

#ifdef USE_MPI
  MPI_Init(&argc,&argv);
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_node_count); /* get number of nodes */
  MPI_Comm_rank(MPI_COMM_WORLD, &mpi_node_rank);
  MPI_Comm_set_name(MPI_COMM_WORLD, mcinstrument_name);
  MPI_Get_processor_name(mpi_node_name, &mpi_node_name_len);
#endif /* USE_MPI */

t = time(NULL);
mcseed = (long)t+(long)getpid();

#ifdef USE_MPI
/* *** print number of nodes *********************************************** */
  if (mpi_node_count > 1) {
    MPI_MASTER(
    printf("Simulation '%s' (%s): running on %i nodes (master is '%s', MPI version %i.%i).\n",
      mcinstrument_name, mcinstrument_source, mpi_node_count, mpi_node_name, MPI_VERSION, MPI_SUBVERSION);
    );
  }
#endif /* USE_MPI */
  
  mcstartdate = (long)t;  /* set start date before parsing options and creating sim file */

/* *** parse options ******************************************************* */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;
  mcinstrument_exe = argv[0]; /* store the executable path */
  /* read simulation parameters and options */
  mcparseoptions(argc, argv); /* sets output dir and format */
  
#ifdef USE_MPI
  if (mpi_node_count > 1) {
    /* share the same seed, then adapt random seed for each node */
    MPI_Bcast(&mcseed, 1, MPI_LONG, 0, MPI_COMM_WORLD); /* root sends its seed to slaves */
    mcseed += mpi_node_rank; /* make sure we use different seeds per node */
  }
#endif
  srandom(mcseed);

/* *** install sig handler, but only once !! after parameters parsing ******* */
#ifndef NOSIGNALS
#ifdef SIGQUIT
  if (signal( SIGQUIT ,sighandler) == SIG_IGN)
    signal( SIGQUIT,SIG_IGN);   /* quit (ASCII FS) */
#endif
#ifdef SIGABRT
  if (signal( SIGABRT ,sighandler) == SIG_IGN)
    signal( SIGABRT,SIG_IGN);   /* used by abort, replace SIGIOT in the future */
#endif
#ifdef SIGTERM
  if (signal( SIGTERM ,sighandler) == SIG_IGN)
    signal( SIGTERM,SIG_IGN);   /* software termination signal from kill */
#endif
#ifdef SIGUSR1
  if (signal( SIGUSR1 ,sighandler) == SIG_IGN)
    signal( SIGUSR1,SIG_IGN);   /* display simulation status */
#endif
#ifdef SIGUSR2
  if (signal( SIGUSR2 ,sighandler) == SIG_IGN)
    signal( SIGUSR2,SIG_IGN);
#endif
#ifdef SIGHUP
  if (signal( SIGHUP ,sighandler) == SIG_IGN)
    signal( SIGHUP,SIG_IGN);
#endif
#ifdef SIGILL
  if (signal( SIGILL ,sighandler) == SIG_IGN)
    signal( SIGILL,SIG_IGN);    /* illegal instruction (not reset when caught) */
#endif
#ifdef SIGFPE
  if (signal( SIGFPE ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* floating point exception */
#endif
#ifdef SIGBUS
  if (signal( SIGBUS ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* bus error */
#endif
#ifdef SIGSEGV
  if (signal( SIGSEGV ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);   /* segmentation violation */
#endif
#endif /* !NOSIGNALS */
  mcsiminfo_init(NULL); /* open SIM */
  SIG_MESSAGE("main (Init)");
  mcinit();
#ifndef NOSIGNALS
#ifdef SIGINT
  if (signal( SIGINT ,sighandler) == SIG_IGN)
    signal( SIGINT,SIG_IGN);    /* interrupt (rubout) only after INIT */
#endif
#endif /* !NOSIGNALS */

/* ================ main particle generation/propagation loop ================ */
#if defined (USE_MPI)
  /* sliced Ncount on each MPI node */
  mcncount = mpi_node_count > 1 ?
    floor(mcncount / mpi_node_count) :
    mcncount; /* number of rays per node */
#endif

/* main particle event loop */
while(mcrun_num < mcncount || mcrun_num < mcget_ncount())
  {
#ifndef NEUTRONICS
    mcgenstate();
#endif
    /* old init: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
    mcraytrace();
    mcrun_num++;
  }

#ifdef USE_MPI
 /* merge run_num from MPI nodes */
  if (mpi_node_count > 1) {
  double mcrun_num_double = (double)mcrun_num;
  mc_MPI_Sum(&mcrun_num_double, 1);
  mcrun_num = (unsigned long long)mcrun_num_double;
  }
#endif

/* save/finally executed by master node/thread */
  mcfinally();

#ifdef USE_MPI
  MPI_Finalize();
#endif /* USE_MPI */

  return 0;
} /* mccode_main */

#ifdef NEUTRONICS
/*Main neutronics function steers the McStas calls, initializes parameters etc */
/* Only called in case NEUTRONICS = TRUE */
void neutronics_main_(float *inx, float *iny, float *inz, float *invx, float *invy, float *invz, float *intime, float *insx, float *insy, float *insz, float *inw, float *outx, float *outy, float *outz, float *outvx, float *outvy, float *outvz, float *outtime, float *outsx, float *outsy, float *outsz, float *outwgt)
{

  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  /* External code governs iteration - McStas is iterated once per call to neutronics_main. I.e. below counter must be initiancated for each call to neutronics_main*/
  mcrun_num=0;

  time_t t;
  t = (time_t)mcstartdate;
  mcstartdate = t;  /* set start date before parsing options and creating sim file */
  mcinit();

  /* *** parse options *** */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;

  /* Set neutron state based on input from neutronics code */
  mcsetstate(*inx,*iny,*inz,*invx,*invy,*invz,*intime,*insx,*insy,*insz,*inw);

  /* main neutron event loop - runs only one iteration */

  //mcstas_raytrace(&mcncount); /* prior to McStas 1.12 */

  mcallowbackprop = 1; //avoid absorbtion from negative dt
  int argc=1;
  char *argv[0];
  int dummy = mccode_main(argc, argv);

  *outx =  mcnx;
  *outy =  mcny;
  *outz =  mcnz;
  *outvx =  mcnvx;
  *outvy =  mcnvy;
  *outvz =  mcnvz;
  *outtime =  mcnt;
  *outsx =  mcnsx;
  *outsy =  mcnsy;
  *outsz =  mcnsz;
  *outwgt =  mcnp;

  return;
} /* neutronics_main */

#endif /*NEUTRONICS*/

#endif /* !MCCODE_H */
/* End of file "mccode-r.c". */
/* End of file "mccode-r.c". */

#line 4817 "instruments/plate49.c"

#line 1 "mcxtrace-r.c"
/*******************************************************************************
*
* McXtrace, X-ray tracing package
*           Copyright (C) 1997-2009, All rights reserved
*           Risoe National Laboratory, Roskilde, Denmark
*           Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcxtrace-r.c
*
* %Identification
* Edited by: EK
* Date:    May 29, 2009
* Release: McXtrace X.Y
* Version: $Revision$
*
* Runtime system for McXtrace.
* Embedded within instrument in runtime mode.
*
* Usage: Automatically embedded in the c code whenever required.
*
*******************************************************************************/

#ifndef MCXTRACE_H

/*******************************************************************************
* mcstore_xray: stores neutron coodinates into global array (per component)
*******************************************************************************/
void
mcstore_xray(MCNUM *s, int index, double x, double y, double z,
               double kx, double ky, double kz, double phi, double t,
               double Ex, double Ey, double Ez, double p)
{
    double *dptr = &s[12*index];
    *dptr++  = x;
    *dptr++  = y ;
    *dptr++  = z ;
    *dptr++  = kx;
    *dptr++  = ky;
    *dptr++  = kz;
    *dptr++  = phi;
    *dptr++  = t;
    *dptr++  = Ex;
    *dptr++  = Ey;
    *dptr++  = Ez;
    *dptr    = p ;
}

/*******************************************************************************
* mcrestore_xray: restores neutron coodinates from global array
*******************************************************************************/
void
mcrestore_xray(MCNUM *s, int index, double *x, double *y, double *z,
               double *kx, double *ky, double *kz, double *phi, double *t,
               double *Ex, double *Ey, double *Ez, double *p)
{
    double *dptr = &s[12*index];
    *x  =  *dptr++;
    *y  =  *dptr++;
    *z  =  *dptr++;
    *kx =  *dptr++;
    *ky =  *dptr++;
    *kz =  *dptr++;
    *phi=  *dptr++;
    *t  =  *dptr++;
    *Ex =  *dptr++;
    *Ey =  *dptr++;
    *Ez =  *dptr++;
    *p  =  *dptr;
} /* mcrestore_xray */

/*******************************************************************************
* mcsetstate: transfer parameters into global McXtrace variables 
*******************************************************************************/
void
mcsetstate(double x, double y, double z, double kx, double ky, double kz,
           double phi, double t, double Ex, double Ey, double Ez, double p)
{
  extern double mcnx, mcny, mcnz, mcnkx, mcnky, mcnkz;
  extern double mcnphi, mcnt, mcnEx, mcnEy, mcnEz, mcnp;

  mcnx = x;
  mcny = y;
  mcnz = z;
  mcnkx = kx;
  mcnky = ky;
  mcnkz = kz;
  mcnphi = phi;
  mcnt = t;
  mcnEx = Ex;
  mcnEy = Ey;
  mcnEz = Ez;
  mcnp = p;
} /* mcsetstate */

/*******************************************************************************
* mcgenstate: set default xray parameters 
*******************************************************************************/
void
mcgenstate(void)
{
  mcsetstate(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
  /* old initialisation: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
}

/* intersection routines ==================================================== */

/*******************************************************************************
* inside_rectangle: Check if (x,y) is inside rectangle (xwidth, yheight) 
* return 0 if outside and 1 if inside 
*******************************************************************************/
int inside_rectangle(double x, double y, double xwidth, double yheight)
{
  if (x>-xwidth/2 && x<xwidth/2 && y>-yheight/2 && y<yheight/2)
    return 1;
  else
    return 0;
}

/*******************************************************************************
 * box_intersect: compute length intersection with a box
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting travelling lengths dl_in and dl_out
*******************************************************************************/
int box_intersect(double *dl_in, double *dl_out,
                  double x, double y, double z,
                  double kx, double ky, double kz,
                  double dx, double dy, double dz)
{

  double k, l,xf,yf,zf, l_[6],dx_2,dy_2,dz_2;
  double ab[2];
  unsigned int count=0;
  k=sqrt(scalar_prod(kx,ky,kz,kx,ky,kz));
  dx_2=dx/2.0;dy_2=dy/2.0;dz_2=dz/2.0; 
  /*we really don't need to store the 6 intersects as only two are possible. i.e. should remove that.*/
  if (kx) {
    l=(-dx_2-x)/kx*k;
    yf=l*ky/k+y;zf=l*kz/k+z;
    if(yf > -dy_2 && yf<dy_2 && zf > -dz_2 && zf<dz_2){
      l_[0]=l;
      ab[count++]=l_[0];
    }else{
      l_[0]=0;
    }
    l=(dx_2-x)/kx*k;
    yf=l*ky/k+y;zf=l*kz/k+z;
    if(yf > -dy_2 && yf<dy_2 && zf > -dz_2 && zf<dz_2){
      l_[1]=l;
      ab[count++]=l_[1];
    }else{
      l_[1]=0;
    }
  }
  if (ky) {
    l=(-dy_2-y)/ky*k;
    xf=l*kx/k+x;zf=l*kz/k+z;
    if(xf > -dx_2 && xf<dx_2 && zf > -dz_2 && zf<dz_2){
      l_[2]=l;
      ab[count++]=l_[2];
    }else{
      l_[2]=0;
    } 
    l=(dy_2-y)/ky*k;
    xf=l*kx/k+x;zf=l*kz/k+z;
    if(xf > -dx_2 && xf<dx_2 && zf > -dz_2 && zf<dz_2){
      l_[3]=l;
      ab[count++]=l_[3];
    }else{
      l_[3]=0;
    }
  }
  if (kz) {
    l=(-dz_2-z)/kz*k;
    xf=l*kx/k+x; yf=l*ky/k+y;
    if(xf > -dx_2 && xf<dx_2 && yf > -dy_2 && yf<dy_2){
      l_[4]=l;
      ab[count++]=l_[4];
    }else{
      l_[4]=0;
    }
    l=(dz_2-z)/kz*k;
    xf=l*kx/k+x; yf=l*ky/k+y;
    if(xf > -dx_2 && xf<dx_2 && yf > -dy_2 && yf<dy_2){
      l_[5]=l;
      ab[count++]=l_[5];
    }else{
      l_[5]=0;
    }
  }
  /*check validity of intersects*/
  if (count>2){
    fprintf(stderr,"box_instersect: xray hitting box more than twice\n");
  }
  if (!count){
    *dl_in=0;*dl_out=0;
    return 0;
  }

  if (ab[0]<ab[1]){
    *dl_in=ab[0];*dl_out=ab[1];
    return 1;
  }else{
    *dl_in=ab[1];*dl_out=ab[0];
    return 1;
  }
} /* box_intersect */

/*******************************************************************************
 * cylinder_intersect: compute intersection with a cylinder
 * returns 0 when no intersection is found
 *      or 1/2/4/8/16 bits depending on intersection,
 *     and resulting times l0 and l1
 * Written by: EK 11.6.09 
 *******************************************************************************/
int
cylinder_intersect(double *l0, double *l1, double x, double y, double z,
                   double kx, double ky, double kz, double r, double h)
{
  double A,B,C,D,k2,k;
  double dl1p=0,dl0p=0,dl1c=0,dl0c=0,y0,y1;
  int ret=1,stat=0,plane_stat=0;
  enum {HIT_CYL=01,ENTER_TOP=02,ENTER_BOT=04,EXIT_TOP=010,EXIT_BOT=020,ENTER_MASK=06,EXIT_MASK=030};
  k2=(kx*kx + ky*ky + kz*kz);
  k=sqrt(k2);

  /*check for prop. vector 0*/
  if(!k2) return 0;

  A= (k2 - ky*ky);
  B= 2*(x*kx + z*kz);
  C=(x*x + z*z - r*r);
  D=B*B-4*A*C;
  if(D>=0){
    if (kx || kz){
      stat|=HIT_CYL;
    /*propagation not parallel to y-axis*/
    /*hit infinitely high cylinder?*/
      D=sqrt(D);
      dl0c=k*(-B-D)/(2*A);
      dl1c=k*(-B+D)/(2*A);
      y0=dl0c*ky/k+y;
      y1=dl1c*ky/k+y;
      if ( (y0<-h/2 && y1<-h/2) || (y0>h/2 && y1>h/2) ){
        /*ray passes above or below cylinder*/
        return 0;
      }
    }
    /*now check top and bottom planes*/
    if (ky){
      dl0p = k*(-h/2-y)/ky;
      dl1p = k*(h/2-y)/ky;
      /*switch solutions?*/
      if (dl0p<dl1p){
        plane_stat|=(ENTER_BOT|EXIT_TOP);
      }else{
        double tmp=dl1p;
        dl1p=dl0p;dl0p=tmp;
        plane_stat|=(ENTER_TOP|EXIT_BOT);
      }
    }
  }
  if (stat & HIT_CYL){
    if (ky && dl0p>dl0c){
      *l0=dl0p;/*1st top/bottom plane intersection happens after 1st cylinder intersect*/
      stat|= plane_stat & ENTER_MASK;
    } else
      *l0=dl0c;
    if(ky && dl1p<dl1c){
      *l1=dl1p;/*2nd top/bottom plane intersection happens before 2nd cylinder intersect*/
      stat|= plane_stat & EXIT_MASK;
    }else
      *l1=dl1c;
  }
  return stat;
} /* cylinder_intersect */

/*******************************************************************************
 * sphere_intersect: Calculate intersection between a line and a sphere.
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting lengths l0 and l1 
 *******************************************************************************/
int
sphere_intersect(double *l0, double *l1, double x, double y, double z,
                 double kx, double ky, double kz, double r)
{
  double B, C, D, k;

  k = kx*kx + ky*ky + kz*kz;
  B = (x*kx + y*ky + z*kz);
  C = x*x + y*y + z*z - r*r;
  D = B*B - k*C;
  if(D < 0)
    return 0;
  D = sqrt(D);
  *l0 = (-B - D) / sqrt(k);
  *l1 = (-B + D) / sqrt(k);
  return 1;
} /* sphere_intersect */

/******************************************************************************
 * ellipsoid_intersect: Calculate intersection between a line and an ellipsoid.
 * They ellisoid is fixed by a set of half-axis (a,b,c) and a matrix Q, with the
 * columns of Q being the (orthogonal) vectors along which the half-axis lie.
 * This allows for complete freedom in orienting th eellipsoid.
 * returns 0 when no intersection is found
 *      or 1 when they are found with resulting lemngths l0 and l1.
 *****************************************************************************/
int
ellipsoid_intersect(double *l0, double *l1, double x, double y, double z,
    double kx, double ky, double kz, double a, double b, double c,
    Rotation Q)
{
  Rotation A,Gamma,Q_t,Tmp;
  double u,v,w;

  Gamma[0][0]=Gamma[0][1]=Gamma[0][2]=0;
  Gamma[1][1]=Gamma[1][0]=Gamma[1][2]=0;
  Gamma[2][2]=Gamma[2][0]=Gamma[2][1]=0;
  /*now set diagonal to ellipsoid half axis if non-zero.
   * This way a zero value mean the sllipsoid extends infinitely along that axis,
   * which is useful for objects only curved in one direction*/ 
  if (a!=0){
    Gamma[0][0]=1/(a*a);
  }
  if (b!=0){
    Gamma[1][1]=1/(b*b);
  }
  if (c!=0){
    Gamma[2][2]=1/(c*c);
  }

  if (Q!=NULL){
    rot_transpose(Q,Q_t);
    rot_mul(Gamma,Q_t,Tmp);
    rot_mul(Q,Tmp,A);
  }else{
    rot_copy(A,Gamma);
  }

  /*to get the solutions as lengths in m use unit vector along k*/
  double ex,ey,ez,k;
  k=sqrt(kx*kx+ky*ky+kz*kz);
  ex=kx/k;
  ey=ky/k;
  ez=kz/k;

  u=ex*(A[0][0]*ex + A[1][0]*ey + A[2][0]*ez) + ey*( A[0][1]*ex + A[1][1]*ey + A[2][1]*ez) + ez*(A[0][2]*ex + A[1][2]*ey + A[2][2]*ez);
  v=x *(A[0][0]*ex + A[1][0]*ey + A[2][0]*ez) + ex*(A[0][0]*x + A[1][0]*y + A[2][0]*z) +
    y *(A[0][1]*ex + A[1][1]*ey + A[2][1]*ez) + ey*(A[0][1]*x + A[1][1]*y + A[2][1]*z) +
    z *(A[0][2]*ex + A[1][2]*ey + A[2][2]*ez) + ez*(A[0][2]*x + A[1][2]*y + A[2][2]*z);
  w=x*(A[0][0]*x + A[1][0]*y + A[2][0]*z) + y*(A[0][1]*x + A[1][1]*y + A[2][1]*z) + z*(A[0][2]*x + A[1][2]*y + A[2][2]*z);

  double D=v*v-4*u*w+4*u;
  if (D<0) return 0;

  D=sqrt(D);

  *l0=(-v-D) / (2*u);
  *l1=(-v+D) / (2*u);
  return 1;
}


/*******************************************************************************
 * plane_intersect: Calculate intersection between a plane (with normal n including the point w)
 * and a line through x along the direction k.
 * returns 0 when no intersection is found (i.e. line is parallel to the plane)
 * returns 1 or -1 when intersection length is positive and negative, respectively
 *******************************************************************************/
int
plane_intersect(double *l, double x, double y, double z,
                 double kx, double ky, double kz, double nx, double ny, double nz, double wx, double wy, double wz)
{
  double s,k2;
  k2=scalar_prod(kx,ky,kz,kx,ky,kz);
  s=scalar_prod(kx,ky,kz,nx,ny,nz);
  if (k2<FLT_EPSILON || fabs(s)<FLT_EPSILON) return 0;
  *l = - sqrt(k2)*scalar_prod(nx,ny,nz,x-wx,y-wy,z-wz)/s;
  if (*l<0) return -1;
  else return 1;
} /* plane_intersect */

#endif /* !MCXTRACE_H */
/* End of file "mcxtrace-r.c". */

#line 5205 "instruments/plate49.c"
#ifdef MC_TRACE_ENABLED
int mctraceenabled = 1;
#else
int mctraceenabled = 0;
#endif
#define MCSTAS "/usr/share/mcxtrace/1.4/"
int mcdefaultmain = 1;
char mcinstrument_name[] = "AthenaModule";
char mcinstrument_source[] = "instruments/plate49.instr";
char *mcinstrument_exe=NULL; /* will be set to argv[0] in main */
int main(int argc, char *argv[]){return mccode_main(argc, argv);}
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);

/* Shared user declarations for all components 'Source_div'. */
#line 64 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions.
*
* This library may be used directly as an external library. It has no dependency
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#define READ_TABLE_LIB_H "$Revision$"

#define READ_TABLE_STEPTOL  0.04 /* tolerancy for constant step approx */

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#ifdef MAC
#define MC_PATHSEP_C ':'
#define MC_PATHSEP_S ":"
#else  /* !MAC */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MC_PATHSEP_C */

#ifndef MCSTAS
#ifdef WIN32
#define MCSTAS "C:\\mcstas\\lib"
#else  /* !WIN32 */
#ifdef MAC
#define MCSTAS ":mcstas:lib" /* ToDo: What to put here? */
#else  /* !MAC */
#define MCSTAS "/usr/local/lib/mcstas"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MCSTAS */

#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

  typedef struct struct_table
  {
    char    filename[1024];
    long    filesize;
    char   *header;  /* text header, e.g. comments */
    double *data;    /* vector { x[0], y[0], ... x[n-1], y[n-1]... } */
    double  min_x;   /* min value of first column */
    double  max_x;   /* max value of first column */
    double  step_x;  /* minimal step value of first column */
    long    rows;    /* number of rows in matrix block */
    long    columns; /* number of columns in matrix block */

    long    begin;   /* start fseek index of block */
    long    end;     /* stop  fseek index of block */
    long    block_number;  /* block index. 0 is catenation of all */
    long    array_length;  /* number of elements in the t_Table array */
    char    monotonic;     /* true when 1st column/vector data is monotonic */
    char    constantstep;  /* true when 1st column/vector data has constant step */
    char    method[32];    /* interpolation method: nearest, linear */
  } t_Table;

typedef struct t_Read_table_file_item {
    int ref_count;
    t_Table *table_ref;
} t_Read_table_file_item;

typedef enum enum_Read_table_file_actions {STORE,FIND,GC}  t_Read_table_file_actions;

/* read_table-lib function prototypes */
/* ========================================================================= */

/* 'public' functions */
long     Table_Read              (t_Table *Table, char *File, long block_number);
long     Table_Read_Offset       (t_Table *Table, char *File, long block_number,
                                  long *offset, long max_lines);
long     Table_Read_Offset_Binary(t_Table *Table, char *File, char *Type,
                                  long *Offset, long Rows, long Columns);
long     Table_Rebin(t_Table *Table); /* rebin table with regular 1st column and interpolate all columns 2:end */
long     Table_Info (t_Table Table);
double   Table_Index(t_Table Table,   long i, long j); /* get indexed value */
double   Table_Value(t_Table Table, double X, long j); /* search X in 1st column and return interpolated value in j-column */
t_Table *Table_Read_Array(char *File, long *blocks);
void     Table_Free_Array(t_Table *Table);
long     Table_Info_Array(t_Table *Table);
int      Table_SetElement(t_Table *Table, long i, long j, double value);
long     Table_Init(t_Table *Table, long rows, long columns); /* create a Table */
double   Table_Value2d(t_Table Table, double X, double Y);    /* same as Table_Index with non-integer indices and 2d interpolation */
MCDETECTOR Table_Write(t_Table Table, char*file, char*xl, char*yl, 
           double x1, double x2, double y1, double y2); /* write Table to disk */
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier);
t_Table *Table_File_List_find(char *name, int block, int offset);
int Table_File_List_gc(t_Table *tab);
void *Table_File_List_store(t_Table *tab);

#define Table_ParseHeader(header, ...) \
  Table_ParseHeader_backend(header,__VA_ARGS__,NULL);

char **Table_ParseHeader_backend(char *header, ...);

/* private functions */
void Table_Free(t_Table *Table);
long Table_Read_Handle(t_Table *Table, FILE *fid, long block_number, long max_lines, char *name);
static void Table_Stat(t_Table *Table);
double Table_Interp1d(double x, double x1, double y1, double x2, double y2);
double Table_Interp1d_nearest(double x, double x1, double y1, double x2, double y2);
double Table_Interp2d(double x, double y, double x1, double y1, double x2, double y2,
double z11, double z12, double z21, double z22);

#endif

/* end of read_table-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas CVS_090504
* Version: $Revision: 5052 $
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#endif


/*******************************************************************************
 * void *Table_File_List_Handler(action, item, item_modifier)
 *   ACTION: handle file entries in the read_table-lib file list. If a file is read - it is supposed to be
 *   stored in a list such that we can avoid reading the same file many times.
 *   input  action: FIND, STORE, GC. check if file exists in the list, store an item in the list, or check if it can be garbage collected.
 *   input item: depends on the action.
 *    FIND)  item is a filename, and item_modifier is the block number
 *    STORE) item is the Table to store - item_modifier is ignored
 *    GC)    item is the Table to check. If it has a ref_count >1 then this is simply decremented.
 *   return  depends on the action
 *    FIND)  return a reference to a table+ref_count item if found - NULL otherwise. I.e. NULL means the file has not been read before and must be read again.
 *    STORE) return NULL always
 *    GC)    return NULL if no garbage collection is needed, return an adress to the t_Table which should be garbage collected. 0x1 is returned if
 *           the item is not found in the list
*******************************************************************************/
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier){

    /* logic here is Read_Table should include a call to FIND. If found the return value shoud just be used as
     * if the table had been read. If not found then read the table and STORE.
     * Table_Free should include a call to GC. If this returns non-NULL then we shoudl proceed with freeing the memory
     * associated with the table item - otherwise do nothing since there are more references that may need it.*/ 

    static t_Read_table_file_item read_table_file_list[1024];  
    static int read_table_file_count=0;

    t_Read_table_file_item *tr;
    switch(action){
        case FIND:
            /*interpret data item as a filename, if it is found return a pointer to the table and increment refcount.
             * if not found return the item itself*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                int i=*((int*) item_modifier);
                int j=*( ((int*) item_modifier)+1);
                if ( !strcmp(tr->table_ref->filename,(char *) item) &&
                        tr->table_ref->block_number==i && tr->table_ref->begin==j ){
                    tr->ref_count++;
                    return (void *) tr;
                }
                tr++;
            }
            return NULL;
        case STORE:
            /*find an available slot and store references to table there*/
            tr=&(read_table_file_list[read_table_file_count++]);
            tr->table_ref=(t_Table *)calloc(1,sizeof(t_Table));
            /*copy the contents of the table handle*/
            *(tr->table_ref)= *((t_Table *) item);
            tr->ref_count++;
            return NULL;
        case GC:
            /* Should this item be garbage collected (freed) - if so scratch the entry and return the address of the item - 
             * else decrement ref_count and return NULL.
             * A non-NULL return expects the item to actually be freed afterwards.*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                if ( tr->table_ref->data ==((t_Table *)item)->data && 
                        tr->table_ref->block_number == ((t_Table *)item)->block_number){
                    /*matching item found*/
                    if (tr->ref_count>1){
                        /*the item is found - no garbage collection needed*/
                        tr->ref_count--;
                        return NULL;
                    }else{
                        /* The item is found - move remaining list items up one slot,
                         * and return the table for garbage collection by caller*/
                        while (tr->table_ref!=NULL){
                            *tr=*(tr+1);
                            tr++;
                        }
                        read_table_file_count--;
                        return (t_Table *) item;
                    }
                }
                tr++;
            }
            return (void *)0x1 ;/*item not found*/ 
    } 

}

/* Access functions to the handler*/

/********************************************
 * t_Table *Table_File_List_find(char *name, int block, int offset)
 * input name: filename to search for in the file list
 * input block: data block in the file as each file may contain more than 1 data block.
 * return a ref. to a table if it is found (you may use this pointer and skip reading the file), NULL otherwise (i.e. go ahead and read the file)
*********************************************/
t_Table *Table_File_List_find(char *name, int block, int offset){
    int vars[2]={block,offset};
    t_Read_table_file_item *item = Table_File_List_Handler(FIND,name, vars);
    if (item == NULL){
        return NULL;
    }else{
        return item->table_ref;
    }
}
/********************************************
 * int Table_File_List_gc(t_Table *tab)
 * input tab: the table to check for references.
 * return 0: no garbage collection needed
 *        1: Table's data and header (at least) should be freed.
*********************************************/
int Table_File_List_gc(t_Table *tab){
    void *rval=Table_File_List_Handler(GC,tab,0);
    if (rval==NULL) return 0;
    else return 1;
}


/*****************************************************************************
 * void *Table_File_List_store(t_Table *tab)
 * input tab: pointer to table to store.
 * return None. 
*******************************************************************************/
void *Table_File_List_store(t_Table *tab){
    Table_File_List_Handler(STORE,tab,0);
}


/*******************************************************************************
* FILE *Open_File(char *name, char *Mode, char *path)
*   ACTION: search for a file and open it. Optionally return the opened path.
*   input   name:  file name from which table should be extracted
*           mode: "r", "w", "a" or any valid fopen mode
*           path:  NULL or a pointer to at least 1024 allocated chars
*   return  initialized file handle or NULL in case of error
*******************************************************************************/

  FILE *Open_File(char *File, const char *Mode, char *Path)
  {
    char path[1024];
    FILE *hfile = NULL;
    
    if (!File || File[0]=='\0')                     return(NULL);
    if (!strcmp(File,"NULL") || !strcmp(File,"0"))  return(NULL);
    
    /* search in current or full path */
    strncpy(path, File, 1024);
    hfile = fopen(path, Mode);
    if(!hfile)
    {
      char dir[1024];

      if (!hfile && mcinstrument_source && strlen(mcinstrument_source)) /* search in instrument source location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_source, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_source;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_source, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile && mcinstrument_exe && strlen(mcinstrument_exe)) /* search in PWD instrument executable location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_exe, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_exe;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_exe, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile) /* search in HOME or . */
      {
        strcpy(dir, getenv("HOME") ? getenv("HOME") : ".");
        snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MCSTAS/data */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "data", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MVCSTAS/contrib */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "contrib", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if(!hfile)
      {
        fprintf(stderr, "Error: Could not open input file '%s' (Open_File)\n", File);
        return (NULL);
      }
    }
    if (Path) strncpy(Path, path, 1024);
    return(hfile);
  } /* end Open_File */

/*******************************************************************************
* long Read_Table(t_Table *Table, char *name, int block_number)
*   ACTION: read a single Table from a text file
*   input   Table: pointer to a t_Table structure
*           name:  file name from which table should be extracted
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* File is opened, read and closed
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebinned with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read(t_Table *Table, char *File, long block_number)
  { /* reads all or a single data block from 'file' and returns a Table structure  */
    return(Table_Read_Offset(Table, File, block_number, NULL, 0));
  } /* end Table_Read */

/*******************************************************************************
* long Table_Read_Offset(t_Table *Table, char *name, int block_number, long *offset
*                        long max_rows)
*   ACTION: read a single Table from a text file, starting at offset
*     Same as Table_Read(..) except:
*   input   offset:    pointer to an offset (*offset should be 0 at start)
*           max_rows: max number of data rows to read from file (0 means all)
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset(t_Table *Table, char *File,
                         long block_number, long *offset,
                         long max_rows)
  { /* reads all/a data block in 'file' and returns a Table structure  */
    FILE *hfile;
    long  nelements=0;
    long  begin=0;
    long  filesize=0;
    char  name[1024];
    char  path[1024];
    struct stat stfile;

    /*Need to be able to store the pointer*/
    if (!Table) return(-1);
    
    //if (offset && *offset) snprintf(name, 1024, "%s@%li", File, *offset);
    //else                   
    strncpy(name, File, 1024);
    if(offset && *offset){
        begin=*offset;
    }
    /* Check if the table has already been read from file.
     * If so just reuse the table, if not (this is flagged by returning NULL
     * set up a new table and read the data into it */
    t_Table *tab_p= Table_File_List_find(name,block_number,begin);
    if ( tab_p!=NULL ){
        /*table was found in the Table_File_List*/
        printf("Reusing input file '%s' (Table_Read_Offset)\n", name);
        *Table=*tab_p;
        return Table->rows*Table->columns;
    }

    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read_Offset)\n", path);
      );
    }
    
    /* read file state */
    stat(path,&stfile); filesize = stfile.st_size;
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    
    Table_Init(Table, 0, 0);

    /* read file content and set the Table */
    nelements = Table_Read_Handle(Table, hfile, block_number, max_rows, name);
    Table->begin = begin;
    Table->end   = ftell(hfile);
    Table->filesize = (filesize>0 ? filesize : 0);
    Table_Stat(Table);
    
    Table_File_List_store(Table);

    if (offset) *offset=Table->end;
    fclose(hfile);
    return(nelements);

  } /* end Table_Read_Offset */

/*******************************************************************************
* long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
*                               long *offset, long rows, long columns)
*   ACTION: read a single Table from a binary file, starting at offset
*     Same as Table_Read_Offset(..) except that it handles binary files.
*   input   type: may be "float"/NULL or "double"
*           offset: pointer to an offset (*offset should be 0 at start)
*           rows   : number of rows (0 means read all)
*           columns: number of columns
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
                                long *offset, long rows, long columns)
  { /* reads all/a data block in binary 'file' and returns a Table structure  */
    long    nelements, sizeofelement;
    long    filesize;
    FILE   *hfile;
    char    path[1024];
    struct stat stfile;
    double *data;
    long    i;
    long    begin;

    if (!Table) return(-1);

    Table_Init(Table, 0, 0);
    
    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read, Binary)\n", path);
      );
    }
    
    /* read file state */
    stat(File,&stfile);
    filesize = stfile.st_size;
    Table->filesize=filesize;
    
    /* read file content */
    if (type && !strcmp(type,"double")) sizeofelement = sizeof(double);
    else  sizeofelement = sizeof(float);
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    if (rows && filesize > sizeofelement*columns*rows)
      nelements = columns*rows;
    else nelements = (long)(filesize/sizeofelement);
    if (!nelements || filesize <= *offset) return(0);
    data    = (double*)malloc(nelements*sizeofelement);
    if (!data) {
      fprintf(stderr,"Error: allocating %ld elements for %s file '%s'. Too big (Table_Read_Offset_Binary).\n", nelements, type, File);
      exit(-1);
    }
    nelements = fread(data, sizeofelement, nelements, hfile);

    if (!data || !nelements)
    {
      fprintf(stderr,"Error: reading %ld elements from %s file '%s' (Table_Read_Offset_Binary)\n", nelements, type, File);
      exit(-1);
    }
    Table->begin   = begin;
    Table->end     = ftell(hfile);
    if (offset) *offset=Table->end;
    fclose(hfile);
    data = (double*)realloc(data, (double)nelements*sizeofelement);
    /* copy file data into Table */
    if (type && !strcmp(type,"double")) Table->data = data;
    else {
      float  *s;
      double *dataf;
      s     = (float*)data;
      dataf = (double*)malloc(sizeof(double)*nelements);
      for (i=0; i<nelements; i++)
        dataf[i]=s[i];
      free(data);
      Table->data = dataf;
    }
    strncpy(Table->filename, File, 1024);
    Table->rows    = nelements/columns;
    Table->columns = columns;
    Table->array_length = 1;
    Table->block_number = 1;

    Table_Stat(Table);

    return(nelements);
  } /* end Table_Read_Offset_Binary */

/*******************************************************************************
* long Table_Read_Handle(t_Table *Table, FILE *fid, int block_number, long max_rows, char *name)
*   ACTION: read a single Table from a text file handle (private)
*   input   Table:pointer to a t_Table structure
*           fid:  pointer to FILE handle
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*           max_rows: if non 0, only reads that number of lines
*   return  initialized single Table t_Table structure containing data, header, ...
*           modified Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebined with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read_Handle(t_Table *Table, FILE *hfile,
                         long block_number, long max_rows, char *name)
  { /* reads all/a data block from 'file' handle and returns a Table structure  */
    double *Data;
    char *Header              = NULL;
    long  malloc_size         = CHAR_BUF_LENGTH;
    long  malloc_size_h       = 4096;
    long  Rows = 0,   Columns = 0;
    long  count_in_array      = 0;
    long  count_in_header     = 0;
    long  block_Current_index = 0;
    char  flag_End_row_loop   = 0;

    if (!Table) return(-1);
    Table_Init(Table, 0, 0);
    if (name && name[0]!='\0') strncpy(Table->filename, name, 1024);

    if(!hfile) {
       fprintf(stderr, "Error: File handle is NULL (Table_Read_Handle).\n");
       return (-1);
    }
    Header = (char*)  calloc(malloc_size_h, sizeof(char));
    Data   = (double*)calloc(malloc_size,   sizeof(double));
    if ((Header == NULL) || (Data == NULL)) {
       fprintf(stderr, "Error: Could not allocate Table and Header (Table_Read_Handle).\n");
       return (-1);
    }

    int flag_In_array = 0;
    do { /* while (!flag_End_row_loop) */
      char  line[1024*CHAR_BUF_LENGTH];
      long  back_pos=0;   /* ftell start of line */

      back_pos = ftell(hfile);
      if (fgets(line, 1024*CHAR_BUF_LENGTH, hfile) != NULL) { /* analyse line */
        /* first skip blank and tabulation characters */
        int i = strspn(line, " \t");

        /* handle comments: stored in header */
        if (NULL != strchr("#%;/", line[i]))
        { /* line is a comment */
          count_in_header += strlen(line);
          if (count_in_header >= malloc_size_h) {
            /* if succeed and in array : add (and realloc if necessary) */
            malloc_size_h = count_in_header+4096;
            Header        = (char*)realloc(Header, malloc_size_h*sizeof(char));
          }
          strncat(Header, line, 4096);
          flag_In_array=0;
          /* exit line and file if passed desired block */
          if (block_number > 0 && block_number == block_Current_index) {
            flag_End_row_loop = 1;
          }

          /* Continue with next line */
          continue;
        }

        /* get the number of columns splitting line with strtok */
        char  *lexeme;
        char  flag_End_Line = 0;
        long  block_Num_Columns = 0;
        const char seps[] = " ,;\t\n\r";

        lexeme = strtok(line, seps);
        while (!flag_End_Line) {
          if ((lexeme != NULL) && (lexeme[0] != '\0')) {
            /* reading line: the token is not empty */
            double X;
            int    count=1;
            /* test if we have 'NaN','Inf' */
            if (!strncasecmp(lexeme,"NaN",3))
              X = 0;
            else if (!strncasecmp(lexeme,"Inf",3) || !strncasecmp(lexeme,"+Inf",4))
              X = FLT_MAX;
            else if (!strncasecmp(lexeme,"-Inf",4))
              X = -FLT_MAX;
            else
              count = sscanf(lexeme,"%lg",&X);
            if (count == 1) {
              /* reading line: the token is a number in the line */
              if (!flag_In_array) {
                /* reading num: not already in a block: starts a new data block */
                block_Current_index++;
                flag_In_array    = 1;
                block_Num_Columns= 0;
                if (block_number > 0) {
                  /* initialise a new data block */
                  Rows = 0;
                  count_in_array = 0;
                } /* else append */
              }
              /* reading num: all blocks or selected block */
              if (flag_In_array && (block_number == 0 ||
                  block_number == block_Current_index)) {
                /* starting block: already the desired number of rows ? */
                if (block_Num_Columns == 0 &&
                    max_rows > 0 && Rows >= max_rows) {
                  flag_End_Line      = 1;
                  flag_End_row_loop  = 1;
                  flag_In_array      = 0;
                  /* reposition to begining of line (ignore line) */
                  fseek(hfile, back_pos, SEEK_SET);
                } else { /* store into data array */
                  if (count_in_array >= malloc_size) {
                    /* realloc data buffer if necessary */
                    malloc_size = count_in_array+CHAR_BUF_LENGTH;
                    Data = (double*) realloc(Data, malloc_size*sizeof(double));
                    if (Data == NULL) {
                      fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Handle).\n",
                              malloc_size*sizeof(double));
                      return (-1);
                    }
                  }
                  if (0 == block_Num_Columns) Rows++;
                  Data[count_in_array] = X;
                  count_in_array++;
                  block_Num_Columns++;
                }
              } /* reading num: end if flag_In_array */
            } /* end reading num: end if sscanf lexeme -> numerical */
            else {
              /* reading line: the token is not numerical in that line. end block */
              if (block_Current_index == block_number) {
                flag_End_Line = 1;
                flag_End_row_loop = 1;
              } else {
                flag_In_array = 0;
                flag_End_Line = 1;
              }
            }
          }
          else {
            /* no more tokens in line */
            flag_End_Line = 1;
            if (block_Num_Columns > 0) Columns = block_Num_Columns;
          }

          // parse next token
          lexeme = strtok(NULL, seps);

        } /* while (!flag_End_Line) */
      } /* end: if fgets */
      else flag_End_row_loop = 1; /* else fgets : end of file */

    } while (!flag_End_row_loop); /* end while flag_End_row_loop */

    Table->block_number = block_number;
    Table->array_length = 1;

    // shrink header to actual size (plus terminating 0-byte)
    if (count_in_header) {
      Header = (char*)realloc(Header, count_in_header*sizeof(char) + 1);
    }
    Table->header = Header;

    if (count_in_array*Rows*Columns == 0)
    {
      Table->rows         = 0;
      Table->columns      = 0;
      free(Data);
      return (0);
    }
    if (Rows * Columns != count_in_array)
    {
      fprintf(stderr, "Warning: Read_Table :%s %s Data has %li values that should be %li x %li\n",
        (Table->filename ? Table->filename : ""),
        (!block_number ? " catenated" : ""),
        count_in_array, Rows, Columns);
      Columns = count_in_array; Rows = 1;
    }
    Data     = (double*)realloc(Data, count_in_array*sizeof(double));
    Table->data         = Data;
    Table->rows         = Rows;
    Table->columns      = Columns;

    return (count_in_array);

  } /* end Table_Read_Handle */

/*******************************************************************************
* long Table_Rebin(t_Table *Table)
*   ACTION: rebin a single Table, sorting 1st column in ascending order
*   input   Table: single table containing data.
*                  The data block is reallocated in this process
*   return  updated Table with increasing, evenly spaced first column (index 0)
*           number of data elements (-1: error, 0:empty data)
*******************************************************************************/
  long Table_Rebin(t_Table *Table)
  {
    double new_step=0;
    long   i;
    /* performs linear interpolation on X axis (0-th column) */

    if (!Table) return(-1);
    if (!Table->data 
    || Table->rows*Table->columns == 0 || !Table->step_x)
      return(0);
    Table_Stat(Table); /* recompute statitstics and minimal step */
    new_step = Table->step_x; /* minimal step in 1st column */

    if (!(Table->constantstep)) /* not already evenly spaced */
    {
      long Length_Table;
      double *New_Table;

      Length_Table = ceil(fabs(Table->max_x - Table->min_x)/new_step)+1;
      New_Table    = (double*)malloc(Length_Table*Table->columns*sizeof(double));

      for (i=0; i < Length_Table; i++)
      {
        long   j;
        double X;
        X = Table->min_x + i*new_step;
        New_Table[i*Table->columns] = X;
        for (j=1; j < Table->columns; j++)
          New_Table[i*Table->columns+j]
                = Table_Value(*Table, X, j);
      } /* end for i */

      Table->rows = Length_Table;
      Table->step_x = new_step;
      Table->max_x = Table->min_x + (Length_Table-1)*new_step; 
      /*max might not be the same anymore
       * Use Length_Table -1 since the first and laset rows are the limits of the defined interval.*/
      free(Table->data);
      Table->data = New_Table;
      Table->constantstep=1;
    } /* end else (!constantstep) */
    return (Table->rows*Table->columns);
  } /* end Table_Rebin */

/*******************************************************************************
* double Table_Index(t_Table Table, long i, long j)
*   ACTION: read an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*   return  Value = data[i][j]
* Returns Value from the i-th row, j-th column of Table
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif

double Table_Index(t_Table Table, long i, long j)
{
  long AbsIndex;

  if (Table.rows == 1 || Table.columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table.columns*Table.rows - 1);
    i = 0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table.rows - 1);
    j = MIN(MAX(0, j), Table.columns - 1);
  }

  /* handle vectors specifically */
  AbsIndex = i*(Table.columns)+j;

  if (Table.data != NULL)
    return (Table.data[AbsIndex]);
  else
    return 0;
} /* end Table_Index */

/*******************************************************************************
* void Table_SetElement(t_Table *Table, long i, long j, double value)
*   ACTION: set an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*           value = data[i][j]
* Returns 0 in case of error
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/
int Table_SetElement(t_Table *Table, long i, long j,
                     double value)
{
  long AbsIndex;

  if (Table->rows == 1 || Table->columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table->columns*Table->rows - 1); i=0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table->rows - 1);
    j = MIN(MAX(0, j), Table->columns - 1);
  }

  AbsIndex = i*(Table->columns)+j;
  if (Table->data != NULL) {
    Table->data[AbsIndex] = value;
    return 1;
  }

  return 0;
} /* end Table_SetElement */

/*******************************************************************************
* double Table_Value(t_Table Table, double X, long j)
*   ACTION: read column [j] of a single Table at row which 1st column is X
*   input   Table: table containing data.
*           X : data value in the first column (index 0)
*           j : index of column from which is extracted the Value (0:Columns-1)
*   return  Value = data[index for X][j] with linear interpolation
* Returns Value from the j-th column of Table corresponding to the
* X value for the 1st column (index 0)
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
double Table_Value(t_Table Table, double X, long j)
{
  long   Index = -1;
  double X1=0, Y1=0, X2=0, Y2=0;
  double ret=0;

  if (X > Table.max_x) return Table_Index(Table,Table.rows-1  ,j);
  if (X < Table.min_x) return Table_Index(Table,0  ,j);

  // Use constant-time lookup when possible
  if(Table.constantstep) {
    Index = (long)floor(
              (X - Table.min_x) / (Table.max_x - Table.min_x) * (Table.rows-1));
    X1 = Table_Index(Table,Index  ,0);
    X2 = Table_Index(Table,Index+1,0);
  }
  // Use binary search on large, monotonic tables
  else if(Table.monotonic && Table.rows > 100) {
    long left = Table.min_x;
    long right = Table.max_x;

    while (!((X1 <= X) && (X < X2)) && (right - left > 1)) {
      Index = (left + right) / 2;

      X1 = Table_Index(Table, Index-1, 0);
      X2 = Table_Index(Table, Index,   0);

      if (X < X1) {
        right = Index;
      } else {
        left  = Index;
      }
    }
  }

  // Fall back to linear search, if no-one else has set X1, X2 correctly
  if (!((X1 <= X) && (X < X2))) {
    /* look for index surrounding X in the table -> Index */
    for (Index=1; Index < Table.rows-1; Index++) {
        X1 = Table_Index(Table, Index-1,0);
        X2 = Table_Index(Table, Index  ,0);
        if ((X1 <= X) && (X < X2)) break;
      } /* end for Index */
  }

  Y1 = Table_Index(Table,Index-1,j);
  Y2 = Table_Index(Table,Index  ,j);

  if (!strcmp(Table.method,"linear")) {
    ret = Table_Interp1d(X, X1,Y1, X2,Y2);
  }
  else if (!strcmp(Table.method,"nearest")) {
    ret = Table_Interp1d_nearest(X, X1,Y1, X2,Y2);
  }

  return ret;
} /* end Table_Value */

/*******************************************************************************
* double Table_Value2d(t_Table Table, double X, double Y)
*   ACTION: read element [X,Y] of a matrix Table
*   input   Table: table containing data.
*           X : row index, may be non integer
*           Y : column index, may be non integer
*   return  Value = data[index X][index Y] with bi-linear interpolation
* Returns Value for the indices [X,Y]
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
  double Table_Value2d(t_Table Table, double X, double Y)
  {
    long   x1,x2,y1,y2;
    double z11,z12,z21,z22;
    double ret=0;

    x1 = (long)floor(X);
    y1 = (long)floor(Y);

    if (x1 > Table.rows-1 || x1 < 0) {
      x2 = x1;
    } else {
      x2 = x1 + 1;
    }

    if (y1 > Table.columns-1 || y1 < 0) {
      y2 = y1;
    } else {
      y2 = y1 + 1;
    }

    z11 = Table_Index(Table, x1, y1);

    if (y2 != y1) z12=Table_Index(Table, x1, y2); else z12 = z11;
    if (x2 != x1) z21=Table_Index(Table, x2, y1); else z21 = z11;
    if (y2 != y1) z22=Table_Index(Table, x2, y2); else z22 = z21;

    if (!strcmp(Table.method,"linear"))
      ret = Table_Interp2d(X,Y, x1,y1,x2,y2, z11,z12,z21,z22);
    else {
      if (fabs(X-x1) < fabs(X-x2)) {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z11; else ret = z12;
      } else {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z21; else ret = z22;
      }
    }
    return ret;
  } /* end Table_Value2d */


/*******************************************************************************
* void Table_Free(t_Table *Table)
*   ACTION: free a single Table
*   return: empty Table
*******************************************************************************/
  void Table_Free(t_Table *Table)
  {
    if( !Table_File_List_gc(Table) ){
       return;
    } 
    if (!Table) return;
    if (Table->data   != NULL) free(Table->data);
    if (Table->header != NULL) free(Table->header);
    Table->data   = NULL;
    Table->header = NULL;
  } /* end Table_Free */

/******************************************************************************
* void Table_Info(t_Table Table)
*    ACTION: print informations about a single Table
*******************************************************************************/
  long Table_Info(t_Table Table)
  {
    char buffer[256];
    long ret=0;

    if (!Table.block_number) strcpy(buffer, "catenated");
    else sprintf(buffer, "block %li", Table.block_number);
    printf("Table from file '%s' (%s)",
      Table.filename ? Table.filename : "", buffer);
    if ((Table.data != NULL) && (Table.rows*Table.columns))
    {
      printf(" is %li x %li ", Table.rows, Table.columns);
      if (Table.rows*Table.columns > 1)
        printf("(x=%g:%g)", Table.min_x, Table.max_x);
      else printf("(x=%g) ", Table.min_x);
      ret = Table.rows*Table.columns;
      if (Table.monotonic)    printf(", monotonic");
      if (Table.constantstep) printf(", constant step");
      printf(". interpolation: %s\n", Table.method);
    }
    else printf(" is empty.\n");

    if (Table.header && strlen(Table.header)) {
      char *header;
      int  i;
      header = malloc(80);
      if (!header) return(ret);
      for (i=0; i<80; header[i++]=0);
      strncpy(header, Table.header, 75);
      if (strlen(Table.header) > 75) {
        strcat( header, " ...");
      }
      for (i=0; i<strlen(header); i++)
        if (header[i] == '\n' || header[i] == '\r') header[i] = ';';
      printf("  '%s'\n", header);
      free(header);
    }

    return(ret);
  } /* end Table_Info */

/******************************************************************************
* long Table_Init(t_Table *Table, m, n)
*   ACTION: initialise a Table to empty m by n table
*   return: empty Table
******************************************************************************/
long Table_Init(t_Table *Table, long rows, long columns)
{
  double *data=NULL;
  long   i;

  if (!Table) return(0);

  Table->header  = NULL;
  Table->filename[0]= '\0';
  Table->filesize= 0;
  Table->min_x   = 0;
  Table->max_x   = 0;
  Table->step_x  = 0;
  Table->block_number = 0;
  Table->array_length = 0;
  Table->monotonic    = 0;
  Table->constantstep = 0;
  Table->begin   = 0;
  Table->end     = 0;
  strcpy(Table->method,"linear");

  if (rows*columns >= 1) {
    data    = (double*)malloc(rows*columns*sizeof(double));
    if (data) for (i=0; i < rows*columns; data[i++]=0);
    else {
      fprintf(stderr,"Error: allocating %ld double elements."
                     "Too big (Table_Init).\n", rows*columns);
      rows = columns = 0;
    }
  }
  Table->rows    = (rows >= 1 ? rows : 0);
  Table->columns = (columns >= 1 ? columns : 0);
  Table->data    = data;
  return(Table->rows*Table->columns);
} /* end Table_Init */

/******************************************************************************
* long Table_Write(t_Table Table, char *file, x1,x2, y1,y2)
*   ACTION: write a Table to disk (ascii).
*     when x1=x2=0 or y1=y2=0, the table default limits are used.
*   return: 0=all is fine, non-0: error
*******************************************************************************/
MCDETECTOR Table_Write(t_Table Table, char *file, char *xl, char *yl, 
  double x1, double x2, double y1, double y2)
{
  long    i =0;
  MCDETECTOR detector;

  if ((Table.data == NULL) && (Table.rows*Table.columns)) {
    detector.m = 0;
    return(detector); /* Table is empty - nothing to do */
  }
  if (!x1 && !x2) {
    x1 = Table.min_x;
    x2 = Table.max_x;
  }
  if (!y1 && !y2) {
    y1 = 1;
    y2 = Table.columns;
  }

  /* transfer content of the Table into a 2D detector */
  Coords coords = { 0, 0, 0};

  if (Table.rows == 1 || Table.columns == 1) {
    detector = mcdetector_out_1D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      "x", x1, x2,
                      Table.rows * Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  } else {
    detector = mcdetector_out_2D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      x1, x2, y1, y2,
                      Table.rows, Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  }
  return(detector);
}

/******************************************************************************
* void Table_Stat(t_Table *Table)
*   ACTION: computes min/max/mean step of 1st column for a single table (private)
*   return: updated Table
*******************************************************************************/
  static void Table_Stat(t_Table *Table)
  {
    long   i;
    double max_x, min_x;
    double row=1;
    char   monotonic=1;
    char   constantstep=1;
    double step=0;
    long n;

    if (!Table) return;
    if (!Table->rows || !Table->columns) return;
    if (Table->rows == 1) row=0; // single row
    max_x = -FLT_MAX;
    min_x =  FLT_MAX;
    n     = (row ? Table->rows : Table->columns);
    /* get min and max of first column/vector */
    for (i=0; i < n; i++)
    {
      double X;
      X = (row ? Table_Index(*Table,i  ,0)
                               : Table_Index(*Table,0, i));
      if (X < min_x) min_x = X;
      if (X > max_x) max_x = X;
    } /* for */
    
    /* test for monotonicity and constant step if the table is an XY or single vector */
    if (n > 1) {
      /* mean step */
      step = (max_x - min_x)/(n-1);
      /* now test if table is monotonic on first column, and get minimal step size */
      for (i=0; i < n-1; i++) {
        double X, diff;;
        X    = (row ? Table_Index(*Table,i  ,0)
                    : Table_Index(*Table,0,  i));
        diff = (row ? Table_Index(*Table,i+1,0)
                    : Table_Index(*Table,0,  i+1)) - X;
        if (diff && fabs(diff) < fabs(step)) step = diff;
        /* change sign ? */
        if ((max_x - min_x)*diff < 0 && monotonic)
          monotonic = 0;
      } /* end for */
      
      /* now test if steps are constant within READ_TABLE_STEPTOL */
      if(!step){
        /*means there's a disconitnuity -> not constantstep*/
        constantstep=0;
      }else if (monotonic) {
        for (i=0; i < n-1; i++) {
          double X, diff;
          X    = (row ? Table_Index(*Table,i  ,0)
              : Table_Index(*Table,0,  i));
          diff = (row ? Table_Index(*Table,i+1,0)
              : Table_Index(*Table,0,  i+1)) - X;
          if ( fabs(step)*(1+READ_TABLE_STEPTOL) < fabs(diff) ||
                fabs(diff) < fabs(step)*(1-READ_TABLE_STEPTOL) )
          { constantstep = 0; break; }
        }
      }

    }
    Table->step_x= step;
    Table->max_x = max_x;
    Table->min_x = min_x;
    Table->monotonic = monotonic;
    Table->constantstep = constantstep;
  } /* end Table_Stat */

/******************************************************************************
* t_Table *Table_Read_Array(char *File, long *blocks)
*   ACTION: read as many data blocks as available, iteratively from file
*   return: initialized t_Table array, last element is an empty Table.
*           the number of extracted blocks in non NULL pointer *blocks
*******************************************************************************/
  t_Table *Table_Read_Array(char *File, long *blocks)
  {
    t_Table *Table_Array=NULL;
    long offset=0;
    long block_number=0;
    long allocated=256;
    long nelements=1;

    /* fisrt allocate an initial empty t_Table array */
    Table_Array = (t_Table *)malloc(allocated*sizeof(t_Table));
    if (!Table_Array) {
      fprintf(stderr, "Error: Can not allocate memory %li (Table_Read_Array).\n",
         allocated*sizeof(t_Table));
      *blocks = 0;
      return (NULL);
    }

    while (nelements > 0)
    {
      t_Table Table;

      /* if ok, set t_Table block number else exit loop */
      block_number++;
      Table.block_number = block_number;
      
      /* access file at offset and get following block. Block number is from the set offset
       * hence the hardcoded 1 - i.e. the next block counted from offset.*/
      nelements = Table_Read_Offset(&Table, File, 1, &offset,0);
      /* if t_Table array is not long enough, expand and realocate */
      if (block_number >= allocated-1) {
        allocated += 256;
        Table_Array = (t_Table *)realloc(Table_Array,
           allocated*sizeof(t_Table));
        if (!Table_Array) {
          fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Array).\n",
              allocated*sizeof(t_Table));
          *blocks = 0;
          return (NULL);
        }
      }
      /* store it into t_Table array */
      //snprintf(Table.filename, 1024, "%s#%li", File, block_number-1);
      Table_Array[block_number-1] = Table;
      /* continues until we find an empty block */
    }
    /* send back number of extracted blocks */
    if (blocks) *blocks = block_number-1;

    /* now store total number of elements in Table array */
    for (offset=0; offset < block_number;
      Table_Array[offset++].array_length = block_number-1);

    return(Table_Array);
  } /* end Table_Read_Array */
/*******************************************************************************
* void Table_Free_Array(t_Table *Table)
*   ACTION: free a Table array
*******************************************************************************/
  void Table_Free_Array(t_Table *Table)
  {
    long index=0;
    if (!Table) return;
    while (Table[index].data || Table[index].header){
            Table_Free(&Table[index]);
            index++;
    }
    free(Table);
  } /* end Table_Free_Array */

/******************************************************************************
* long Table_Info_Array(t_Table *Table)
*    ACTION: print informations about a Table array
*    return: number of elements in the Table array
*******************************************************************************/
  long Table_Info_Array(t_Table *Table)
  {
    long index=0;

    if (!Table) return(-1);
    while (index < Table[index].array_length
       && (Table[index].data || Table[index].header)
       && (Table[index].rows*Table[index].columns) ) {
      Table_Info(Table[index]);
      index++;
    }
    printf("This Table array contains %li elements\n", index);
    return(index);
  } /* end Table_Info_Array */

/******************************************************************************
* char **Table_ParseHeader(char *header, symbol1, symbol2, ..., NULL)
*    ACTION: search for char* symbols in header and return their value or NULL
*            the search is not case sensitive.
*            Last argument MUST be NULL
*    return: array of char* with line following each symbol, or NULL if not found
*******************************************************************************/
#ifndef MyNL_ARGMAX
#define MyNL_ARGMAX 50
#endif

char **Table_ParseHeader_backend(char *header, ...){
  va_list ap;
  char exit_flag=0;
  int counter   =0;
  char **ret    =NULL;
  if (!header || header[0]=='\0') return(NULL);

  ret = (char**)calloc(MyNL_ARGMAX, sizeof(char*));
  if (!ret) {
    printf("Table_ParseHeader: Cannot allocate %i values array for Parser (Table_ParseHeader).\n",
      MyNL_ARGMAX);
    return(NULL);
  }
  for (counter=0; counter < MyNL_ARGMAX; ret[counter++] = NULL);
  counter=0;

  va_start(ap, header);
  while(!exit_flag && counter < MyNL_ARGMAX-1)
  {
    char *arg_char=NULL;
    char *pos     =NULL;
    /* get variable argument value as a char */
    arg_char = va_arg(ap, char *);
    if (!arg_char || arg_char[0]=='\0'){
      exit_flag = 1; break;
    }
    /* search for the symbol in the header */
    pos = (char*)strcasestr(header, arg_char);
    if (pos) {
      char *eol_pos;
      eol_pos = strchr(pos+strlen(arg_char), '\n');
      if (!eol_pos)
        eol_pos = strchr(pos+strlen(arg_char), '\r');
      if (!eol_pos)
        eol_pos = pos+strlen(pos)-1;
      ret[counter] = (char*)malloc(eol_pos - pos);
      if (!ret[counter]) {
        printf("Table_ParseHeader: Cannot allocate value[%i] array for Parser searching for %s (Table_ParseHeader).\n",
          counter, arg_char);
        exit_flag = 1; break;
      }
      strncpy(ret[counter], pos+strlen(arg_char), eol_pos - pos - strlen(arg_char));
      ret[counter][eol_pos - pos - strlen(arg_char)]='\0';
    }
    counter++;
  }
  va_end(ap);
  return(ret);
} /* Table_ParseHeader */

/******************************************************************************
* double Table_Interp1d(x, x1, y1, x2, y2)
*    ACTION: interpolates linearly at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d(double x,
  double x1, double y1,
  double x2, double y2)
{
  double slope;
  if (x2 == x1) return (y1+y2)/2;
  if (y1 == y2) return  y1;
  slope = (y2 - y1)/(x2 - x1);
  return y1+slope*(x - x1);
} /* Table_Interp1d */

/******************************************************************************
* double Table_Interp1d_nearest(x, x1, y1, x2, y2)
*    ACTION: table lookup with nearest method at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d_nearest(double x,
  double x1, double y1,
  double x2, double y2)
{
  if (fabs(x-x1) < fabs(x-x2)) return (y1);
  else return(y2);
} /* Table_Interp1d_nearest */

/******************************************************************************
* double Table_Interp2d(x,y, x1,y1, x2,y2, z11,z12,z21,z22)
*    ACTION: interpolates bi-linearly at (x,y) between z1=f(x1,y1) and z2=f(x2,y2)
*    return: z=f(x,y) value
*    x,y |   x1   x2
*    ----------------
*     y1 |   z11  z21
*     y2 |   z12  z22
*******************************************************************************/
double Table_Interp2d(double x, double y,
  double x1, double y1,
  double x2, double y2,
  double z11, double z12, double z21, double z22)
{
  double ratio_x, ratio_y;
  if (x2 == x1) return Table_Interp1d(y, y1,z11, y2,z12);
  if (y1 == y2) return Table_Interp1d(x, x1,z11, x2,z21);

  ratio_y = (y - y1)/(y2 - y1);
  ratio_x = (x - x1)/(x2 - x1);
  return (1-ratio_x)*(1-ratio_y)*z11 + ratio_x*(1-ratio_y)*z21
    + ratio_x*ratio_y*z22         + (1-ratio_x)*ratio_y*z12;
} /* Table_Interp2d */

/* end of read_table-lib.c */

#line 6654 "instruments/plate49.c"

/* Shared user declarations for all components 'Pore_p_group'. */
#line 60 "Pore_p_group.comp"
#ifndef MCSPO_INTERSECT_PARABOLOID
#define MCSPO_INTERSECT_PARABOLOID 1
    int intersect_paraboloid(double *l0, double x, double y, double z, double kx, double ky, double kz, double Z0, double radius, double *nx, double *ny, double *nz){
        /* Intersection routine for a paraboloid as given by the paper by vanspeybroeck and Chase (appl. optics. 1972)*/
        double alpha,thetap,thetah,P,d,e,C0;
        alpha=0.25*atan(radius/Z0);
        thetap=alpha;
        thetah=alpha*3;
        P=Z0*tan(4*alpha)*tan(thetap);
        d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
        e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
        C0=4*e*e*P*d/(e*e-1);

        double kxn=kx,kyn=ky,kzn=kz;
        NORM(kxn,kyn,kzn);

        double A,B,C;
        A=kxn*kxn + kyn*kyn;
        B=2*(kxn*x + kyn*y+ P*kzn);
        C=x*x + y*y -P*P - 2*P*(Z0-z) - C0;
        int status;

        double l1;
        if ( (status=solve_2nd_order(l0,&l1,A,B,C))==0 ){
            /*note that if l1->NULL only the smallest positive solution is returned*/
            fprintf(stderr,"Error(%s): No solution to second order eq.\n","Pore_p");
        }
        /*compute normal vector here*/
        x+=kxn* (*l0);
        y+=kyn* (*l0);
        z+=kzn* (*l0);

        double delta_y=-P*pow(P*P+2*P*(Z0-z)+C0,-0.5);
        double rp=sqrt(P*P + 2*P*(Z0-z) + C0);

        /* The tilt of the normal vector perpendicular to the optical axis
         * depends only on the displacement in x*/
        *nx=x/rp;//tan(asin(x/rp));
        *ny=y/rp;//1;
        *nz = 0 - delta_y + 0;
        /* the minus sign since a negative slope in rp results in the normal tilting "forward" which
           corresponds to a positive sign in z*/
        NORM(*nx,*ny,*nz);

        return status;
    }
#endif
#line 6705 "instruments/plate49.c"

/* Shared user declarations for all components 'Pore_h_group'. */
#line 57 "Pore_h_group.comp"
#ifndef MCSPO_INTERSECT_HYPERBOLOID
#define MCSPO_INTERSECT_HYPERBOLOID 1
    int intersect_hyperboloid(double *l0, double x, double y, double z, double kx, double ky, double kz, double Z0, double radius, double *nx, double *ny, double *nz){
        double alpha,thetap,thetah,P,d,e,C0;
        alpha=0.25*atan(radius/Z0);
        thetap=alpha;
        thetah=alpha*3;
        P=Z0*tan(4*alpha)*tan(thetap);
        d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
        e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
        C0=4*e*e*P*d/(e*e-1);

        double kxn=kx,kyn=ky,kzn=kz;
        NORM(kxn,kyn,kzn);
        double A,B,C,Z;
        Z=Z0-z;
        /* A=kxn*kxn + kyn*kyn + kzn*kzn - e^2 kzn*kzn = 1 - e^2 kzn^2*/
        A=1-e*e*kzn*kzn;
        B=2*kxn*x + 2*kyn*y+ 2*e*e*(d+Z)*kzn - 2*kzn*(Z);
        C=x*x + y*y + Z*Z - e*e*(d+Z)*(d+Z);

        int status;
        double l1;
        if ( (status=solve_2nd_order(l0,&l1,A,B,C))==0 ){
            /*note that if l1->NULL only the smallest positive solution is returned*/
            fprintf(stderr,"No solution %g %g %g\n ",A,B,C);
        }

        /*compute normal vector*/
        x+=kxn* (*l0);
        y+=kyn* (*l0);
        z+=kzn* (*l0);

        Z=Z0-z;
        double delta_y=-0.5 * pow( e*e*(d+Z)*(d+Z) - Z*Z,-0.5) * ( 2*e*e*(d+Z) - 2*Z);
        double rh=sqrt(e*e * (d+Z0-z)*(d+Z0-z) -(Z0-z)*(Z0-z));

        /* The tilt of the normal vector perpendicular to the optical axis
         * depends only on the displacement in x*/
        *nx=x/rh;//tan(asin(x/rh));
        *ny=y/rh;//1;
        *nz = 0 - delta_y +0;
        /* the minus sign since a negative slope in rh results in the normal tilting "forward" which
           corresponds to a positive sign in z*/
        NORM(*nx,*ny,*nz);

        return status;
    }
#endif
#line 6758 "instruments/plate49.c"

/* Instrument parameters. */
int mcipmodule_nr;
int mcipplate_nr;
int mcipenergy;
int mcipsource_type;
MCNUM mcipsource_th;
MCNUM mcipsource_dx;
MCNUM mcipsource_dy;
int mcipabsorb_sides;
int mcipabsorb_bottom;
char* mcipoutput_filename;

#define mcNUMIPAR 10
int mcnumipar = 10;
struct mcinputtable_struct mcinputtable[mcNUMIPAR+1] = {
  "module_nr", &mcipmodule_nr, instr_type_int, "0", 
  "plate_nr", &mcipplate_nr, instr_type_int, "0", 
  "energy", &mcipenergy, instr_type_int, "1", 
  "source_type", &mcipsource_type, instr_type_int, "0", 
  "source_th", &mcipsource_th, instr_type_double, "0", 
  "source_dx", &mcipsource_dx, instr_type_double, "0", 
  "source_dy", &mcipsource_dy, instr_type_double, "0", 
  "absorb_sides", &mcipabsorb_sides, instr_type_int, "1", 
  "absorb_bottom", &mcipabsorb_bottom, instr_type_int, "1", 
  "output_filename", &mcipoutput_filename, instr_type_string, "", 
  NULL, NULL, instr_type_double, ""
};

/* User declarations from instrument definition. */
#define mccompcurname  AthenaModule
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaAthenaModule coords_set(0,0,0)
#define module_nr mcipmodule_nr
#define plate_nr mcipplate_nr
#define energy mcipenergy
#define source_type mcipsource_type
#define source_th mcipsource_th
#define source_dx mcipsource_dx
#define source_dy mcipsource_dy
#define absorb_sides mcipabsorb_sides
#define absorb_bottom mcipabsorb_bottom
#define output_filename mcipoutput_filename
#line 43 "instruments/plate49.instr"
    int min(int x, int y){
      if(x > y){
        return y;
      }
      return x;
    }

    #define TWOPI 6.283185307
    #define DEGTORAD 0.017453293

    #define FOCALLENGTH 12

    #define PLATE_THICKNESS 0.00017
    #define PORE_PITCH_DEFAULT 0.001
    #define PLATE_PITCH_DEFAULT 0.000775
    #define PORE_HEIGHT_DEFAULT 0.000605
    #define PORE_WIDTH_DEFAULT 0.00083
    #define MODULE_HEIGHT_DEFAULT 0.053645
    #define CHAMFERWIDTH 0

    #include "geom.c"
    #include "dataOutput.c"
    #include <unistd.h>

    // Pore parameters
    #define MAXPORES 93
    double poreX[MAXPORES];
    double poreY[MAXPORES];
    double poreAngle[MAXPORES];
    double poreAngleDegrees[MAXPORES];
    double poreW;
    double poreH;
    double porePitch;

    double radiusP;
    double radiusH;
    double radiusM;

    double moduleAngle;
    int poresPerPlate;

    double parabolaDeviation;
    double hyperbolaDeviation;

    // MISC STUFF
    double sourceToOptics = 1;
    double focalLength = 12;

    double majorRadius = 1.5;

    double dEnergy = 0.00001;     //KeV

    int finalResolution = 1024;
    double detectorSize = 0.13312;

    int wideResolution = 255;
    double wideSize = 3;  //Edge size in meters of wide monitor

    double thX, thY, thZ;
    double srcW;
    double srcH;

    //Counters
    long photonCount;
    long photonPassedThrough;
    double photonPassedThroughWeighted;

    char* coating;
    char* coatingSide;
    char* coatingBottom;

    char enteredPore;
#line 6876 "instruments/plate49.c"
#undef output_filename
#undef absorb_bottom
#undef absorb_sides
#undef source_dy
#undef source_dx
#undef source_th
#undef source_type
#undef energy
#undef plate_nr
#undef module_nr
#undef mcposaAthenaModule
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname

/* xray state table at each component input (local coords) */
/* [x, y, z, kx, ky, kz, phi, t, Ex, Ey, Ez, p] */
MCNUM mccomp_storein[12*155];
/* Components position table (absolute and relative coords) */
Coords mccomp_posa[155];
Coords mccomp_posr[155];
/* Counter for each comp to check for inactive ones */
MCNUM  mcNCounter[155];
MCNUM  mcPCounter[155];
MCNUM  mcP2Counter[155];
#define mcNUMCOMP 154 /* number of components */
/* Counter for PROP ABSORB */
MCNUM  mcAbsorbProp[155];
/* Flag true when previous component acted on the xray (SCATTER) */
MCNUM mcScattered=0;
/* Flag true when xray should be restored (RESTORE) */
MCNUM mcRestore=0;
/* Component group definitions (flags), equals index of scattering comp */
int mcGroupparabolic=0;
int mcGrouphyperbolic=0;
/* Declarations of component definition and setting parameters. */

/* Definition parameters for component 'origin' [1]. */
#define mccorigin_profile 0 /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'origin' [1]. */
MCNUM mccorigin_percent;
MCNUM mccorigin_flag_save;
MCNUM mccorigin_minutes;

/* Definition parameters for component 'srcDirectional' [3]. */
#define mccsrcDirectional_spectrum_file NULL /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'srcDirectional' [3]. */
MCNUM mccsrcDirectional_xwidth;
MCNUM mccsrcDirectional_yheight;
MCNUM mccsrcDirectional_focus_aw;
MCNUM mccsrcDirectional_focus_ah;
MCNUM mccsrcDirectional_E0;
MCNUM mccsrcDirectional_dE;
MCNUM mccsrcDirectional_lambda0;
MCNUM mccsrcDirectional_dlambda;
MCNUM mccsrcDirectional_flux;
MCNUM mccsrcDirectional_gauss;
MCNUM mccsrcDirectional_gauss_a;
MCNUM mccsrcDirectional_randomphase;
MCNUM mccsrcDirectional_phase;

/* Definition parameters for component 'srcDirectionalWide' [4]. */
#define mccsrcDirectionalWide_spectrum_file NULL /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'srcDirectionalWide' [4]. */
MCNUM mccsrcDirectionalWide_xwidth;
MCNUM mccsrcDirectionalWide_yheight;
MCNUM mccsrcDirectionalWide_focus_aw;
MCNUM mccsrcDirectionalWide_focus_ah;
MCNUM mccsrcDirectionalWide_E0;
MCNUM mccsrcDirectionalWide_dE;
MCNUM mccsrcDirectionalWide_lambda0;
MCNUM mccsrcDirectionalWide_dlambda;
MCNUM mccsrcDirectionalWide_flux;
MCNUM mccsrcDirectionalWide_gauss;
MCNUM mccsrcDirectionalWide_gauss_a;
MCNUM mccsrcDirectionalWide_randomphase;
MCNUM mccsrcDirectionalWide_phase;

/* Setting parameters for component 'PoreP0' [54]. */
MCNUM mccPoreP0_radius_p;
MCNUM mccPoreP0_radius_m;
MCNUM mccPoreP0_Z0;
MCNUM mccPoreP0_xwidth;
MCNUM mccPoreP0_yheight;
MCNUM mccPoreP0_chamferwidth;
char mccPoreP0_mirror_reflec[16384];
char mccPoreP0_bottom_reflec[16384];
char mccPoreP0_side_reflec[16384];
MCNUM mccPoreP0_R_d;
MCNUM mccPoreP0_absorb_sides;

/* Setting parameters for component 'PoreP1' [55]. */
MCNUM mccPoreP1_radius_p;
MCNUM mccPoreP1_radius_m;
MCNUM mccPoreP1_Z0;
MCNUM mccPoreP1_xwidth;
MCNUM mccPoreP1_yheight;
MCNUM mccPoreP1_chamferwidth;
char mccPoreP1_mirror_reflec[16384];
char mccPoreP1_bottom_reflec[16384];
char mccPoreP1_side_reflec[16384];
MCNUM mccPoreP1_R_d;
MCNUM mccPoreP1_absorb_sides;

/* Setting parameters for component 'PoreP2' [56]. */
MCNUM mccPoreP2_radius_p;
MCNUM mccPoreP2_radius_m;
MCNUM mccPoreP2_Z0;
MCNUM mccPoreP2_xwidth;
MCNUM mccPoreP2_yheight;
MCNUM mccPoreP2_chamferwidth;
char mccPoreP2_mirror_reflec[16384];
char mccPoreP2_bottom_reflec[16384];
char mccPoreP2_side_reflec[16384];
MCNUM mccPoreP2_R_d;
MCNUM mccPoreP2_absorb_sides;

/* Setting parameters for component 'PoreP3' [57]. */
MCNUM mccPoreP3_radius_p;
MCNUM mccPoreP3_radius_m;
MCNUM mccPoreP3_Z0;
MCNUM mccPoreP3_xwidth;
MCNUM mccPoreP3_yheight;
MCNUM mccPoreP3_chamferwidth;
char mccPoreP3_mirror_reflec[16384];
char mccPoreP3_bottom_reflec[16384];
char mccPoreP3_side_reflec[16384];
MCNUM mccPoreP3_R_d;
MCNUM mccPoreP3_absorb_sides;

/* Setting parameters for component 'PoreP4' [58]. */
MCNUM mccPoreP4_radius_p;
MCNUM mccPoreP4_radius_m;
MCNUM mccPoreP4_Z0;
MCNUM mccPoreP4_xwidth;
MCNUM mccPoreP4_yheight;
MCNUM mccPoreP4_chamferwidth;
char mccPoreP4_mirror_reflec[16384];
char mccPoreP4_bottom_reflec[16384];
char mccPoreP4_side_reflec[16384];
MCNUM mccPoreP4_R_d;
MCNUM mccPoreP4_absorb_sides;

/* Setting parameters for component 'PoreP5' [59]. */
MCNUM mccPoreP5_radius_p;
MCNUM mccPoreP5_radius_m;
MCNUM mccPoreP5_Z0;
MCNUM mccPoreP5_xwidth;
MCNUM mccPoreP5_yheight;
MCNUM mccPoreP5_chamferwidth;
char mccPoreP5_mirror_reflec[16384];
char mccPoreP5_bottom_reflec[16384];
char mccPoreP5_side_reflec[16384];
MCNUM mccPoreP5_R_d;
MCNUM mccPoreP5_absorb_sides;

/* Setting parameters for component 'PoreP6' [60]. */
MCNUM mccPoreP6_radius_p;
MCNUM mccPoreP6_radius_m;
MCNUM mccPoreP6_Z0;
MCNUM mccPoreP6_xwidth;
MCNUM mccPoreP6_yheight;
MCNUM mccPoreP6_chamferwidth;
char mccPoreP6_mirror_reflec[16384];
char mccPoreP6_bottom_reflec[16384];
char mccPoreP6_side_reflec[16384];
MCNUM mccPoreP6_R_d;
MCNUM mccPoreP6_absorb_sides;

/* Setting parameters for component 'PoreP7' [61]. */
MCNUM mccPoreP7_radius_p;
MCNUM mccPoreP7_radius_m;
MCNUM mccPoreP7_Z0;
MCNUM mccPoreP7_xwidth;
MCNUM mccPoreP7_yheight;
MCNUM mccPoreP7_chamferwidth;
char mccPoreP7_mirror_reflec[16384];
char mccPoreP7_bottom_reflec[16384];
char mccPoreP7_side_reflec[16384];
MCNUM mccPoreP7_R_d;
MCNUM mccPoreP7_absorb_sides;

/* Setting parameters for component 'PoreP8' [62]. */
MCNUM mccPoreP8_radius_p;
MCNUM mccPoreP8_radius_m;
MCNUM mccPoreP8_Z0;
MCNUM mccPoreP8_xwidth;
MCNUM mccPoreP8_yheight;
MCNUM mccPoreP8_chamferwidth;
char mccPoreP8_mirror_reflec[16384];
char mccPoreP8_bottom_reflec[16384];
char mccPoreP8_side_reflec[16384];
MCNUM mccPoreP8_R_d;
MCNUM mccPoreP8_absorb_sides;

/* Setting parameters for component 'PoreP9' [63]. */
MCNUM mccPoreP9_radius_p;
MCNUM mccPoreP9_radius_m;
MCNUM mccPoreP9_Z0;
MCNUM mccPoreP9_xwidth;
MCNUM mccPoreP9_yheight;
MCNUM mccPoreP9_chamferwidth;
char mccPoreP9_mirror_reflec[16384];
char mccPoreP9_bottom_reflec[16384];
char mccPoreP9_side_reflec[16384];
MCNUM mccPoreP9_R_d;
MCNUM mccPoreP9_absorb_sides;

/* Setting parameters for component 'PoreP10' [64]. */
MCNUM mccPoreP10_radius_p;
MCNUM mccPoreP10_radius_m;
MCNUM mccPoreP10_Z0;
MCNUM mccPoreP10_xwidth;
MCNUM mccPoreP10_yheight;
MCNUM mccPoreP10_chamferwidth;
char mccPoreP10_mirror_reflec[16384];
char mccPoreP10_bottom_reflec[16384];
char mccPoreP10_side_reflec[16384];
MCNUM mccPoreP10_R_d;
MCNUM mccPoreP10_absorb_sides;

/* Setting parameters for component 'PoreP11' [65]. */
MCNUM mccPoreP11_radius_p;
MCNUM mccPoreP11_radius_m;
MCNUM mccPoreP11_Z0;
MCNUM mccPoreP11_xwidth;
MCNUM mccPoreP11_yheight;
MCNUM mccPoreP11_chamferwidth;
char mccPoreP11_mirror_reflec[16384];
char mccPoreP11_bottom_reflec[16384];
char mccPoreP11_side_reflec[16384];
MCNUM mccPoreP11_R_d;
MCNUM mccPoreP11_absorb_sides;

/* Setting parameters for component 'PoreP12' [66]. */
MCNUM mccPoreP12_radius_p;
MCNUM mccPoreP12_radius_m;
MCNUM mccPoreP12_Z0;
MCNUM mccPoreP12_xwidth;
MCNUM mccPoreP12_yheight;
MCNUM mccPoreP12_chamferwidth;
char mccPoreP12_mirror_reflec[16384];
char mccPoreP12_bottom_reflec[16384];
char mccPoreP12_side_reflec[16384];
MCNUM mccPoreP12_R_d;
MCNUM mccPoreP12_absorb_sides;

/* Setting parameters for component 'PoreP13' [67]. */
MCNUM mccPoreP13_radius_p;
MCNUM mccPoreP13_radius_m;
MCNUM mccPoreP13_Z0;
MCNUM mccPoreP13_xwidth;
MCNUM mccPoreP13_yheight;
MCNUM mccPoreP13_chamferwidth;
char mccPoreP13_mirror_reflec[16384];
char mccPoreP13_bottom_reflec[16384];
char mccPoreP13_side_reflec[16384];
MCNUM mccPoreP13_R_d;
MCNUM mccPoreP13_absorb_sides;

/* Setting parameters for component 'PoreP14' [68]. */
MCNUM mccPoreP14_radius_p;
MCNUM mccPoreP14_radius_m;
MCNUM mccPoreP14_Z0;
MCNUM mccPoreP14_xwidth;
MCNUM mccPoreP14_yheight;
MCNUM mccPoreP14_chamferwidth;
char mccPoreP14_mirror_reflec[16384];
char mccPoreP14_bottom_reflec[16384];
char mccPoreP14_side_reflec[16384];
MCNUM mccPoreP14_R_d;
MCNUM mccPoreP14_absorb_sides;

/* Setting parameters for component 'PoreP15' [69]. */
MCNUM mccPoreP15_radius_p;
MCNUM mccPoreP15_radius_m;
MCNUM mccPoreP15_Z0;
MCNUM mccPoreP15_xwidth;
MCNUM mccPoreP15_yheight;
MCNUM mccPoreP15_chamferwidth;
char mccPoreP15_mirror_reflec[16384];
char mccPoreP15_bottom_reflec[16384];
char mccPoreP15_side_reflec[16384];
MCNUM mccPoreP15_R_d;
MCNUM mccPoreP15_absorb_sides;

/* Setting parameters for component 'PoreP16' [70]. */
MCNUM mccPoreP16_radius_p;
MCNUM mccPoreP16_radius_m;
MCNUM mccPoreP16_Z0;
MCNUM mccPoreP16_xwidth;
MCNUM mccPoreP16_yheight;
MCNUM mccPoreP16_chamferwidth;
char mccPoreP16_mirror_reflec[16384];
char mccPoreP16_bottom_reflec[16384];
char mccPoreP16_side_reflec[16384];
MCNUM mccPoreP16_R_d;
MCNUM mccPoreP16_absorb_sides;

/* Setting parameters for component 'PoreP17' [71]. */
MCNUM mccPoreP17_radius_p;
MCNUM mccPoreP17_radius_m;
MCNUM mccPoreP17_Z0;
MCNUM mccPoreP17_xwidth;
MCNUM mccPoreP17_yheight;
MCNUM mccPoreP17_chamferwidth;
char mccPoreP17_mirror_reflec[16384];
char mccPoreP17_bottom_reflec[16384];
char mccPoreP17_side_reflec[16384];
MCNUM mccPoreP17_R_d;
MCNUM mccPoreP17_absorb_sides;

/* Setting parameters for component 'PoreP18' [72]. */
MCNUM mccPoreP18_radius_p;
MCNUM mccPoreP18_radius_m;
MCNUM mccPoreP18_Z0;
MCNUM mccPoreP18_xwidth;
MCNUM mccPoreP18_yheight;
MCNUM mccPoreP18_chamferwidth;
char mccPoreP18_mirror_reflec[16384];
char mccPoreP18_bottom_reflec[16384];
char mccPoreP18_side_reflec[16384];
MCNUM mccPoreP18_R_d;
MCNUM mccPoreP18_absorb_sides;

/* Setting parameters for component 'PoreP19' [73]. */
MCNUM mccPoreP19_radius_p;
MCNUM mccPoreP19_radius_m;
MCNUM mccPoreP19_Z0;
MCNUM mccPoreP19_xwidth;
MCNUM mccPoreP19_yheight;
MCNUM mccPoreP19_chamferwidth;
char mccPoreP19_mirror_reflec[16384];
char mccPoreP19_bottom_reflec[16384];
char mccPoreP19_side_reflec[16384];
MCNUM mccPoreP19_R_d;
MCNUM mccPoreP19_absorb_sides;

/* Setting parameters for component 'PoreP20' [74]. */
MCNUM mccPoreP20_radius_p;
MCNUM mccPoreP20_radius_m;
MCNUM mccPoreP20_Z0;
MCNUM mccPoreP20_xwidth;
MCNUM mccPoreP20_yheight;
MCNUM mccPoreP20_chamferwidth;
char mccPoreP20_mirror_reflec[16384];
char mccPoreP20_bottom_reflec[16384];
char mccPoreP20_side_reflec[16384];
MCNUM mccPoreP20_R_d;
MCNUM mccPoreP20_absorb_sides;

/* Setting parameters for component 'PoreP21' [75]. */
MCNUM mccPoreP21_radius_p;
MCNUM mccPoreP21_radius_m;
MCNUM mccPoreP21_Z0;
MCNUM mccPoreP21_xwidth;
MCNUM mccPoreP21_yheight;
MCNUM mccPoreP21_chamferwidth;
char mccPoreP21_mirror_reflec[16384];
char mccPoreP21_bottom_reflec[16384];
char mccPoreP21_side_reflec[16384];
MCNUM mccPoreP21_R_d;
MCNUM mccPoreP21_absorb_sides;

/* Setting parameters for component 'PoreP22' [76]. */
MCNUM mccPoreP22_radius_p;
MCNUM mccPoreP22_radius_m;
MCNUM mccPoreP22_Z0;
MCNUM mccPoreP22_xwidth;
MCNUM mccPoreP22_yheight;
MCNUM mccPoreP22_chamferwidth;
char mccPoreP22_mirror_reflec[16384];
char mccPoreP22_bottom_reflec[16384];
char mccPoreP22_side_reflec[16384];
MCNUM mccPoreP22_R_d;
MCNUM mccPoreP22_absorb_sides;

/* Setting parameters for component 'PoreP23' [77]. */
MCNUM mccPoreP23_radius_p;
MCNUM mccPoreP23_radius_m;
MCNUM mccPoreP23_Z0;
MCNUM mccPoreP23_xwidth;
MCNUM mccPoreP23_yheight;
MCNUM mccPoreP23_chamferwidth;
char mccPoreP23_mirror_reflec[16384];
char mccPoreP23_bottom_reflec[16384];
char mccPoreP23_side_reflec[16384];
MCNUM mccPoreP23_R_d;
MCNUM mccPoreP23_absorb_sides;

/* Setting parameters for component 'PoreP24' [78]. */
MCNUM mccPoreP24_radius_p;
MCNUM mccPoreP24_radius_m;
MCNUM mccPoreP24_Z0;
MCNUM mccPoreP24_xwidth;
MCNUM mccPoreP24_yheight;
MCNUM mccPoreP24_chamferwidth;
char mccPoreP24_mirror_reflec[16384];
char mccPoreP24_bottom_reflec[16384];
char mccPoreP24_side_reflec[16384];
MCNUM mccPoreP24_R_d;
MCNUM mccPoreP24_absorb_sides;

/* Setting parameters for component 'PoreP25' [79]. */
MCNUM mccPoreP25_radius_p;
MCNUM mccPoreP25_radius_m;
MCNUM mccPoreP25_Z0;
MCNUM mccPoreP25_xwidth;
MCNUM mccPoreP25_yheight;
MCNUM mccPoreP25_chamferwidth;
char mccPoreP25_mirror_reflec[16384];
char mccPoreP25_bottom_reflec[16384];
char mccPoreP25_side_reflec[16384];
MCNUM mccPoreP25_R_d;
MCNUM mccPoreP25_absorb_sides;

/* Setting parameters for component 'PoreP26' [80]. */
MCNUM mccPoreP26_radius_p;
MCNUM mccPoreP26_radius_m;
MCNUM mccPoreP26_Z0;
MCNUM mccPoreP26_xwidth;
MCNUM mccPoreP26_yheight;
MCNUM mccPoreP26_chamferwidth;
char mccPoreP26_mirror_reflec[16384];
char mccPoreP26_bottom_reflec[16384];
char mccPoreP26_side_reflec[16384];
MCNUM mccPoreP26_R_d;
MCNUM mccPoreP26_absorb_sides;

/* Setting parameters for component 'PoreP27' [81]. */
MCNUM mccPoreP27_radius_p;
MCNUM mccPoreP27_radius_m;
MCNUM mccPoreP27_Z0;
MCNUM mccPoreP27_xwidth;
MCNUM mccPoreP27_yheight;
MCNUM mccPoreP27_chamferwidth;
char mccPoreP27_mirror_reflec[16384];
char mccPoreP27_bottom_reflec[16384];
char mccPoreP27_side_reflec[16384];
MCNUM mccPoreP27_R_d;
MCNUM mccPoreP27_absorb_sides;

/* Setting parameters for component 'PoreP28' [82]. */
MCNUM mccPoreP28_radius_p;
MCNUM mccPoreP28_radius_m;
MCNUM mccPoreP28_Z0;
MCNUM mccPoreP28_xwidth;
MCNUM mccPoreP28_yheight;
MCNUM mccPoreP28_chamferwidth;
char mccPoreP28_mirror_reflec[16384];
char mccPoreP28_bottom_reflec[16384];
char mccPoreP28_side_reflec[16384];
MCNUM mccPoreP28_R_d;
MCNUM mccPoreP28_absorb_sides;

/* Setting parameters for component 'PoreP29' [83]. */
MCNUM mccPoreP29_radius_p;
MCNUM mccPoreP29_radius_m;
MCNUM mccPoreP29_Z0;
MCNUM mccPoreP29_xwidth;
MCNUM mccPoreP29_yheight;
MCNUM mccPoreP29_chamferwidth;
char mccPoreP29_mirror_reflec[16384];
char mccPoreP29_bottom_reflec[16384];
char mccPoreP29_side_reflec[16384];
MCNUM mccPoreP29_R_d;
MCNUM mccPoreP29_absorb_sides;

/* Setting parameters for component 'PoreP30' [84]. */
MCNUM mccPoreP30_radius_p;
MCNUM mccPoreP30_radius_m;
MCNUM mccPoreP30_Z0;
MCNUM mccPoreP30_xwidth;
MCNUM mccPoreP30_yheight;
MCNUM mccPoreP30_chamferwidth;
char mccPoreP30_mirror_reflec[16384];
char mccPoreP30_bottom_reflec[16384];
char mccPoreP30_side_reflec[16384];
MCNUM mccPoreP30_R_d;
MCNUM mccPoreP30_absorb_sides;

/* Setting parameters for component 'PoreP31' [85]. */
MCNUM mccPoreP31_radius_p;
MCNUM mccPoreP31_radius_m;
MCNUM mccPoreP31_Z0;
MCNUM mccPoreP31_xwidth;
MCNUM mccPoreP31_yheight;
MCNUM mccPoreP31_chamferwidth;
char mccPoreP31_mirror_reflec[16384];
char mccPoreP31_bottom_reflec[16384];
char mccPoreP31_side_reflec[16384];
MCNUM mccPoreP31_R_d;
MCNUM mccPoreP31_absorb_sides;

/* Setting parameters for component 'PoreP32' [86]. */
MCNUM mccPoreP32_radius_p;
MCNUM mccPoreP32_radius_m;
MCNUM mccPoreP32_Z0;
MCNUM mccPoreP32_xwidth;
MCNUM mccPoreP32_yheight;
MCNUM mccPoreP32_chamferwidth;
char mccPoreP32_mirror_reflec[16384];
char mccPoreP32_bottom_reflec[16384];
char mccPoreP32_side_reflec[16384];
MCNUM mccPoreP32_R_d;
MCNUM mccPoreP32_absorb_sides;

/* Setting parameters for component 'PoreP33' [87]. */
MCNUM mccPoreP33_radius_p;
MCNUM mccPoreP33_radius_m;
MCNUM mccPoreP33_Z0;
MCNUM mccPoreP33_xwidth;
MCNUM mccPoreP33_yheight;
MCNUM mccPoreP33_chamferwidth;
char mccPoreP33_mirror_reflec[16384];
char mccPoreP33_bottom_reflec[16384];
char mccPoreP33_side_reflec[16384];
MCNUM mccPoreP33_R_d;
MCNUM mccPoreP33_absorb_sides;

/* Setting parameters for component 'PoreP34' [88]. */
MCNUM mccPoreP34_radius_p;
MCNUM mccPoreP34_radius_m;
MCNUM mccPoreP34_Z0;
MCNUM mccPoreP34_xwidth;
MCNUM mccPoreP34_yheight;
MCNUM mccPoreP34_chamferwidth;
char mccPoreP34_mirror_reflec[16384];
char mccPoreP34_bottom_reflec[16384];
char mccPoreP34_side_reflec[16384];
MCNUM mccPoreP34_R_d;
MCNUM mccPoreP34_absorb_sides;

/* Setting parameters for component 'PoreP35' [89]. */
MCNUM mccPoreP35_radius_p;
MCNUM mccPoreP35_radius_m;
MCNUM mccPoreP35_Z0;
MCNUM mccPoreP35_xwidth;
MCNUM mccPoreP35_yheight;
MCNUM mccPoreP35_chamferwidth;
char mccPoreP35_mirror_reflec[16384];
char mccPoreP35_bottom_reflec[16384];
char mccPoreP35_side_reflec[16384];
MCNUM mccPoreP35_R_d;
MCNUM mccPoreP35_absorb_sides;

/* Setting parameters for component 'PoreP36' [90]. */
MCNUM mccPoreP36_radius_p;
MCNUM mccPoreP36_radius_m;
MCNUM mccPoreP36_Z0;
MCNUM mccPoreP36_xwidth;
MCNUM mccPoreP36_yheight;
MCNUM mccPoreP36_chamferwidth;
char mccPoreP36_mirror_reflec[16384];
char mccPoreP36_bottom_reflec[16384];
char mccPoreP36_side_reflec[16384];
MCNUM mccPoreP36_R_d;
MCNUM mccPoreP36_absorb_sides;

/* Setting parameters for component 'PoreP37' [91]. */
MCNUM mccPoreP37_radius_p;
MCNUM mccPoreP37_radius_m;
MCNUM mccPoreP37_Z0;
MCNUM mccPoreP37_xwidth;
MCNUM mccPoreP37_yheight;
MCNUM mccPoreP37_chamferwidth;
char mccPoreP37_mirror_reflec[16384];
char mccPoreP37_bottom_reflec[16384];
char mccPoreP37_side_reflec[16384];
MCNUM mccPoreP37_R_d;
MCNUM mccPoreP37_absorb_sides;

/* Setting parameters for component 'PoreP38' [92]. */
MCNUM mccPoreP38_radius_p;
MCNUM mccPoreP38_radius_m;
MCNUM mccPoreP38_Z0;
MCNUM mccPoreP38_xwidth;
MCNUM mccPoreP38_yheight;
MCNUM mccPoreP38_chamferwidth;
char mccPoreP38_mirror_reflec[16384];
char mccPoreP38_bottom_reflec[16384];
char mccPoreP38_side_reflec[16384];
MCNUM mccPoreP38_R_d;
MCNUM mccPoreP38_absorb_sides;

/* Setting parameters for component 'PoreP39' [93]. */
MCNUM mccPoreP39_radius_p;
MCNUM mccPoreP39_radius_m;
MCNUM mccPoreP39_Z0;
MCNUM mccPoreP39_xwidth;
MCNUM mccPoreP39_yheight;
MCNUM mccPoreP39_chamferwidth;
char mccPoreP39_mirror_reflec[16384];
char mccPoreP39_bottom_reflec[16384];
char mccPoreP39_side_reflec[16384];
MCNUM mccPoreP39_R_d;
MCNUM mccPoreP39_absorb_sides;

/* Setting parameters for component 'PoreP40' [94]. */
MCNUM mccPoreP40_radius_p;
MCNUM mccPoreP40_radius_m;
MCNUM mccPoreP40_Z0;
MCNUM mccPoreP40_xwidth;
MCNUM mccPoreP40_yheight;
MCNUM mccPoreP40_chamferwidth;
char mccPoreP40_mirror_reflec[16384];
char mccPoreP40_bottom_reflec[16384];
char mccPoreP40_side_reflec[16384];
MCNUM mccPoreP40_R_d;
MCNUM mccPoreP40_absorb_sides;

/* Setting parameters for component 'PoreP41' [95]. */
MCNUM mccPoreP41_radius_p;
MCNUM mccPoreP41_radius_m;
MCNUM mccPoreP41_Z0;
MCNUM mccPoreP41_xwidth;
MCNUM mccPoreP41_yheight;
MCNUM mccPoreP41_chamferwidth;
char mccPoreP41_mirror_reflec[16384];
char mccPoreP41_bottom_reflec[16384];
char mccPoreP41_side_reflec[16384];
MCNUM mccPoreP41_R_d;
MCNUM mccPoreP41_absorb_sides;

/* Setting parameters for component 'PoreP42' [96]. */
MCNUM mccPoreP42_radius_p;
MCNUM mccPoreP42_radius_m;
MCNUM mccPoreP42_Z0;
MCNUM mccPoreP42_xwidth;
MCNUM mccPoreP42_yheight;
MCNUM mccPoreP42_chamferwidth;
char mccPoreP42_mirror_reflec[16384];
char mccPoreP42_bottom_reflec[16384];
char mccPoreP42_side_reflec[16384];
MCNUM mccPoreP42_R_d;
MCNUM mccPoreP42_absorb_sides;

/* Setting parameters for component 'PoreP43' [97]. */
MCNUM mccPoreP43_radius_p;
MCNUM mccPoreP43_radius_m;
MCNUM mccPoreP43_Z0;
MCNUM mccPoreP43_xwidth;
MCNUM mccPoreP43_yheight;
MCNUM mccPoreP43_chamferwidth;
char mccPoreP43_mirror_reflec[16384];
char mccPoreP43_bottom_reflec[16384];
char mccPoreP43_side_reflec[16384];
MCNUM mccPoreP43_R_d;
MCNUM mccPoreP43_absorb_sides;

/* Setting parameters for component 'PoreP44' [98]. */
MCNUM mccPoreP44_radius_p;
MCNUM mccPoreP44_radius_m;
MCNUM mccPoreP44_Z0;
MCNUM mccPoreP44_xwidth;
MCNUM mccPoreP44_yheight;
MCNUM mccPoreP44_chamferwidth;
char mccPoreP44_mirror_reflec[16384];
char mccPoreP44_bottom_reflec[16384];
char mccPoreP44_side_reflec[16384];
MCNUM mccPoreP44_R_d;
MCNUM mccPoreP44_absorb_sides;

/* Setting parameters for component 'PoreP45' [99]. */
MCNUM mccPoreP45_radius_p;
MCNUM mccPoreP45_radius_m;
MCNUM mccPoreP45_Z0;
MCNUM mccPoreP45_xwidth;
MCNUM mccPoreP45_yheight;
MCNUM mccPoreP45_chamferwidth;
char mccPoreP45_mirror_reflec[16384];
char mccPoreP45_bottom_reflec[16384];
char mccPoreP45_side_reflec[16384];
MCNUM mccPoreP45_R_d;
MCNUM mccPoreP45_absorb_sides;

/* Setting parameters for component 'PoreP46' [100]. */
MCNUM mccPoreP46_radius_p;
MCNUM mccPoreP46_radius_m;
MCNUM mccPoreP46_Z0;
MCNUM mccPoreP46_xwidth;
MCNUM mccPoreP46_yheight;
MCNUM mccPoreP46_chamferwidth;
char mccPoreP46_mirror_reflec[16384];
char mccPoreP46_bottom_reflec[16384];
char mccPoreP46_side_reflec[16384];
MCNUM mccPoreP46_R_d;
MCNUM mccPoreP46_absorb_sides;

/* Setting parameters for component 'PoreP47' [101]. */
MCNUM mccPoreP47_radius_p;
MCNUM mccPoreP47_radius_m;
MCNUM mccPoreP47_Z0;
MCNUM mccPoreP47_xwidth;
MCNUM mccPoreP47_yheight;
MCNUM mccPoreP47_chamferwidth;
char mccPoreP47_mirror_reflec[16384];
char mccPoreP47_bottom_reflec[16384];
char mccPoreP47_side_reflec[16384];
MCNUM mccPoreP47_R_d;
MCNUM mccPoreP47_absorb_sides;

/* Setting parameters for component 'PoreP48' [102]. */
MCNUM mccPoreP48_radius_p;
MCNUM mccPoreP48_radius_m;
MCNUM mccPoreP48_Z0;
MCNUM mccPoreP48_xwidth;
MCNUM mccPoreP48_yheight;
MCNUM mccPoreP48_chamferwidth;
char mccPoreP48_mirror_reflec[16384];
char mccPoreP48_bottom_reflec[16384];
char mccPoreP48_side_reflec[16384];
MCNUM mccPoreP48_R_d;
MCNUM mccPoreP48_absorb_sides;

/* Setting parameters for component 'PoreH0' [103]. */
MCNUM mccPoreH0_radius_m;
MCNUM mccPoreH0_radius_h;
MCNUM mccPoreH0_Z0;
MCNUM mccPoreH0_xwidth;
MCNUM mccPoreH0_yheight;
MCNUM mccPoreH0_chamferwidth;
char mccPoreH0_mirror_reflec[16384];
char mccPoreH0_bottom_reflec[16384];
char mccPoreH0_side_reflec[16384];
MCNUM mccPoreH0_R_d;
MCNUM mccPoreH0_absorb_sides;

/* Setting parameters for component 'PoreH1' [104]. */
MCNUM mccPoreH1_radius_m;
MCNUM mccPoreH1_radius_h;
MCNUM mccPoreH1_Z0;
MCNUM mccPoreH1_xwidth;
MCNUM mccPoreH1_yheight;
MCNUM mccPoreH1_chamferwidth;
char mccPoreH1_mirror_reflec[16384];
char mccPoreH1_bottom_reflec[16384];
char mccPoreH1_side_reflec[16384];
MCNUM mccPoreH1_R_d;
MCNUM mccPoreH1_absorb_sides;

/* Setting parameters for component 'PoreH2' [105]. */
MCNUM mccPoreH2_radius_m;
MCNUM mccPoreH2_radius_h;
MCNUM mccPoreH2_Z0;
MCNUM mccPoreH2_xwidth;
MCNUM mccPoreH2_yheight;
MCNUM mccPoreH2_chamferwidth;
char mccPoreH2_mirror_reflec[16384];
char mccPoreH2_bottom_reflec[16384];
char mccPoreH2_side_reflec[16384];
MCNUM mccPoreH2_R_d;
MCNUM mccPoreH2_absorb_sides;

/* Setting parameters for component 'PoreH3' [106]. */
MCNUM mccPoreH3_radius_m;
MCNUM mccPoreH3_radius_h;
MCNUM mccPoreH3_Z0;
MCNUM mccPoreH3_xwidth;
MCNUM mccPoreH3_yheight;
MCNUM mccPoreH3_chamferwidth;
char mccPoreH3_mirror_reflec[16384];
char mccPoreH3_bottom_reflec[16384];
char mccPoreH3_side_reflec[16384];
MCNUM mccPoreH3_R_d;
MCNUM mccPoreH3_absorb_sides;

/* Setting parameters for component 'PoreH4' [107]. */
MCNUM mccPoreH4_radius_m;
MCNUM mccPoreH4_radius_h;
MCNUM mccPoreH4_Z0;
MCNUM mccPoreH4_xwidth;
MCNUM mccPoreH4_yheight;
MCNUM mccPoreH4_chamferwidth;
char mccPoreH4_mirror_reflec[16384];
char mccPoreH4_bottom_reflec[16384];
char mccPoreH4_side_reflec[16384];
MCNUM mccPoreH4_R_d;
MCNUM mccPoreH4_absorb_sides;

/* Setting parameters for component 'PoreH5' [108]. */
MCNUM mccPoreH5_radius_m;
MCNUM mccPoreH5_radius_h;
MCNUM mccPoreH5_Z0;
MCNUM mccPoreH5_xwidth;
MCNUM mccPoreH5_yheight;
MCNUM mccPoreH5_chamferwidth;
char mccPoreH5_mirror_reflec[16384];
char mccPoreH5_bottom_reflec[16384];
char mccPoreH5_side_reflec[16384];
MCNUM mccPoreH5_R_d;
MCNUM mccPoreH5_absorb_sides;

/* Setting parameters for component 'PoreH6' [109]. */
MCNUM mccPoreH6_radius_m;
MCNUM mccPoreH6_radius_h;
MCNUM mccPoreH6_Z0;
MCNUM mccPoreH6_xwidth;
MCNUM mccPoreH6_yheight;
MCNUM mccPoreH6_chamferwidth;
char mccPoreH6_mirror_reflec[16384];
char mccPoreH6_bottom_reflec[16384];
char mccPoreH6_side_reflec[16384];
MCNUM mccPoreH6_R_d;
MCNUM mccPoreH6_absorb_sides;

/* Setting parameters for component 'PoreH7' [110]. */
MCNUM mccPoreH7_radius_m;
MCNUM mccPoreH7_radius_h;
MCNUM mccPoreH7_Z0;
MCNUM mccPoreH7_xwidth;
MCNUM mccPoreH7_yheight;
MCNUM mccPoreH7_chamferwidth;
char mccPoreH7_mirror_reflec[16384];
char mccPoreH7_bottom_reflec[16384];
char mccPoreH7_side_reflec[16384];
MCNUM mccPoreH7_R_d;
MCNUM mccPoreH7_absorb_sides;

/* Setting parameters for component 'PoreH8' [111]. */
MCNUM mccPoreH8_radius_m;
MCNUM mccPoreH8_radius_h;
MCNUM mccPoreH8_Z0;
MCNUM mccPoreH8_xwidth;
MCNUM mccPoreH8_yheight;
MCNUM mccPoreH8_chamferwidth;
char mccPoreH8_mirror_reflec[16384];
char mccPoreH8_bottom_reflec[16384];
char mccPoreH8_side_reflec[16384];
MCNUM mccPoreH8_R_d;
MCNUM mccPoreH8_absorb_sides;

/* Setting parameters for component 'PoreH9' [112]. */
MCNUM mccPoreH9_radius_m;
MCNUM mccPoreH9_radius_h;
MCNUM mccPoreH9_Z0;
MCNUM mccPoreH9_xwidth;
MCNUM mccPoreH9_yheight;
MCNUM mccPoreH9_chamferwidth;
char mccPoreH9_mirror_reflec[16384];
char mccPoreH9_bottom_reflec[16384];
char mccPoreH9_side_reflec[16384];
MCNUM mccPoreH9_R_d;
MCNUM mccPoreH9_absorb_sides;

/* Setting parameters for component 'PoreH10' [113]. */
MCNUM mccPoreH10_radius_m;
MCNUM mccPoreH10_radius_h;
MCNUM mccPoreH10_Z0;
MCNUM mccPoreH10_xwidth;
MCNUM mccPoreH10_yheight;
MCNUM mccPoreH10_chamferwidth;
char mccPoreH10_mirror_reflec[16384];
char mccPoreH10_bottom_reflec[16384];
char mccPoreH10_side_reflec[16384];
MCNUM mccPoreH10_R_d;
MCNUM mccPoreH10_absorb_sides;

/* Setting parameters for component 'PoreH11' [114]. */
MCNUM mccPoreH11_radius_m;
MCNUM mccPoreH11_radius_h;
MCNUM mccPoreH11_Z0;
MCNUM mccPoreH11_xwidth;
MCNUM mccPoreH11_yheight;
MCNUM mccPoreH11_chamferwidth;
char mccPoreH11_mirror_reflec[16384];
char mccPoreH11_bottom_reflec[16384];
char mccPoreH11_side_reflec[16384];
MCNUM mccPoreH11_R_d;
MCNUM mccPoreH11_absorb_sides;

/* Setting parameters for component 'PoreH12' [115]. */
MCNUM mccPoreH12_radius_m;
MCNUM mccPoreH12_radius_h;
MCNUM mccPoreH12_Z0;
MCNUM mccPoreH12_xwidth;
MCNUM mccPoreH12_yheight;
MCNUM mccPoreH12_chamferwidth;
char mccPoreH12_mirror_reflec[16384];
char mccPoreH12_bottom_reflec[16384];
char mccPoreH12_side_reflec[16384];
MCNUM mccPoreH12_R_d;
MCNUM mccPoreH12_absorb_sides;

/* Setting parameters for component 'PoreH13' [116]. */
MCNUM mccPoreH13_radius_m;
MCNUM mccPoreH13_radius_h;
MCNUM mccPoreH13_Z0;
MCNUM mccPoreH13_xwidth;
MCNUM mccPoreH13_yheight;
MCNUM mccPoreH13_chamferwidth;
char mccPoreH13_mirror_reflec[16384];
char mccPoreH13_bottom_reflec[16384];
char mccPoreH13_side_reflec[16384];
MCNUM mccPoreH13_R_d;
MCNUM mccPoreH13_absorb_sides;

/* Setting parameters for component 'PoreH14' [117]. */
MCNUM mccPoreH14_radius_m;
MCNUM mccPoreH14_radius_h;
MCNUM mccPoreH14_Z0;
MCNUM mccPoreH14_xwidth;
MCNUM mccPoreH14_yheight;
MCNUM mccPoreH14_chamferwidth;
char mccPoreH14_mirror_reflec[16384];
char mccPoreH14_bottom_reflec[16384];
char mccPoreH14_side_reflec[16384];
MCNUM mccPoreH14_R_d;
MCNUM mccPoreH14_absorb_sides;

/* Setting parameters for component 'PoreH15' [118]. */
MCNUM mccPoreH15_radius_m;
MCNUM mccPoreH15_radius_h;
MCNUM mccPoreH15_Z0;
MCNUM mccPoreH15_xwidth;
MCNUM mccPoreH15_yheight;
MCNUM mccPoreH15_chamferwidth;
char mccPoreH15_mirror_reflec[16384];
char mccPoreH15_bottom_reflec[16384];
char mccPoreH15_side_reflec[16384];
MCNUM mccPoreH15_R_d;
MCNUM mccPoreH15_absorb_sides;

/* Setting parameters for component 'PoreH16' [119]. */
MCNUM mccPoreH16_radius_m;
MCNUM mccPoreH16_radius_h;
MCNUM mccPoreH16_Z0;
MCNUM mccPoreH16_xwidth;
MCNUM mccPoreH16_yheight;
MCNUM mccPoreH16_chamferwidth;
char mccPoreH16_mirror_reflec[16384];
char mccPoreH16_bottom_reflec[16384];
char mccPoreH16_side_reflec[16384];
MCNUM mccPoreH16_R_d;
MCNUM mccPoreH16_absorb_sides;

/* Setting parameters for component 'PoreH17' [120]. */
MCNUM mccPoreH17_radius_m;
MCNUM mccPoreH17_radius_h;
MCNUM mccPoreH17_Z0;
MCNUM mccPoreH17_xwidth;
MCNUM mccPoreH17_yheight;
MCNUM mccPoreH17_chamferwidth;
char mccPoreH17_mirror_reflec[16384];
char mccPoreH17_bottom_reflec[16384];
char mccPoreH17_side_reflec[16384];
MCNUM mccPoreH17_R_d;
MCNUM mccPoreH17_absorb_sides;

/* Setting parameters for component 'PoreH18' [121]. */
MCNUM mccPoreH18_radius_m;
MCNUM mccPoreH18_radius_h;
MCNUM mccPoreH18_Z0;
MCNUM mccPoreH18_xwidth;
MCNUM mccPoreH18_yheight;
MCNUM mccPoreH18_chamferwidth;
char mccPoreH18_mirror_reflec[16384];
char mccPoreH18_bottom_reflec[16384];
char mccPoreH18_side_reflec[16384];
MCNUM mccPoreH18_R_d;
MCNUM mccPoreH18_absorb_sides;

/* Setting parameters for component 'PoreH19' [122]. */
MCNUM mccPoreH19_radius_m;
MCNUM mccPoreH19_radius_h;
MCNUM mccPoreH19_Z0;
MCNUM mccPoreH19_xwidth;
MCNUM mccPoreH19_yheight;
MCNUM mccPoreH19_chamferwidth;
char mccPoreH19_mirror_reflec[16384];
char mccPoreH19_bottom_reflec[16384];
char mccPoreH19_side_reflec[16384];
MCNUM mccPoreH19_R_d;
MCNUM mccPoreH19_absorb_sides;

/* Setting parameters for component 'PoreH20' [123]. */
MCNUM mccPoreH20_radius_m;
MCNUM mccPoreH20_radius_h;
MCNUM mccPoreH20_Z0;
MCNUM mccPoreH20_xwidth;
MCNUM mccPoreH20_yheight;
MCNUM mccPoreH20_chamferwidth;
char mccPoreH20_mirror_reflec[16384];
char mccPoreH20_bottom_reflec[16384];
char mccPoreH20_side_reflec[16384];
MCNUM mccPoreH20_R_d;
MCNUM mccPoreH20_absorb_sides;

/* Setting parameters for component 'PoreH21' [124]. */
MCNUM mccPoreH21_radius_m;
MCNUM mccPoreH21_radius_h;
MCNUM mccPoreH21_Z0;
MCNUM mccPoreH21_xwidth;
MCNUM mccPoreH21_yheight;
MCNUM mccPoreH21_chamferwidth;
char mccPoreH21_mirror_reflec[16384];
char mccPoreH21_bottom_reflec[16384];
char mccPoreH21_side_reflec[16384];
MCNUM mccPoreH21_R_d;
MCNUM mccPoreH21_absorb_sides;

/* Setting parameters for component 'PoreH22' [125]. */
MCNUM mccPoreH22_radius_m;
MCNUM mccPoreH22_radius_h;
MCNUM mccPoreH22_Z0;
MCNUM mccPoreH22_xwidth;
MCNUM mccPoreH22_yheight;
MCNUM mccPoreH22_chamferwidth;
char mccPoreH22_mirror_reflec[16384];
char mccPoreH22_bottom_reflec[16384];
char mccPoreH22_side_reflec[16384];
MCNUM mccPoreH22_R_d;
MCNUM mccPoreH22_absorb_sides;

/* Setting parameters for component 'PoreH23' [126]. */
MCNUM mccPoreH23_radius_m;
MCNUM mccPoreH23_radius_h;
MCNUM mccPoreH23_Z0;
MCNUM mccPoreH23_xwidth;
MCNUM mccPoreH23_yheight;
MCNUM mccPoreH23_chamferwidth;
char mccPoreH23_mirror_reflec[16384];
char mccPoreH23_bottom_reflec[16384];
char mccPoreH23_side_reflec[16384];
MCNUM mccPoreH23_R_d;
MCNUM mccPoreH23_absorb_sides;

/* Setting parameters for component 'PoreH24' [127]. */
MCNUM mccPoreH24_radius_m;
MCNUM mccPoreH24_radius_h;
MCNUM mccPoreH24_Z0;
MCNUM mccPoreH24_xwidth;
MCNUM mccPoreH24_yheight;
MCNUM mccPoreH24_chamferwidth;
char mccPoreH24_mirror_reflec[16384];
char mccPoreH24_bottom_reflec[16384];
char mccPoreH24_side_reflec[16384];
MCNUM mccPoreH24_R_d;
MCNUM mccPoreH24_absorb_sides;

/* Setting parameters for component 'PoreH25' [128]. */
MCNUM mccPoreH25_radius_m;
MCNUM mccPoreH25_radius_h;
MCNUM mccPoreH25_Z0;
MCNUM mccPoreH25_xwidth;
MCNUM mccPoreH25_yheight;
MCNUM mccPoreH25_chamferwidth;
char mccPoreH25_mirror_reflec[16384];
char mccPoreH25_bottom_reflec[16384];
char mccPoreH25_side_reflec[16384];
MCNUM mccPoreH25_R_d;
MCNUM mccPoreH25_absorb_sides;

/* Setting parameters for component 'PoreH26' [129]. */
MCNUM mccPoreH26_radius_m;
MCNUM mccPoreH26_radius_h;
MCNUM mccPoreH26_Z0;
MCNUM mccPoreH26_xwidth;
MCNUM mccPoreH26_yheight;
MCNUM mccPoreH26_chamferwidth;
char mccPoreH26_mirror_reflec[16384];
char mccPoreH26_bottom_reflec[16384];
char mccPoreH26_side_reflec[16384];
MCNUM mccPoreH26_R_d;
MCNUM mccPoreH26_absorb_sides;

/* Setting parameters for component 'PoreH27' [130]. */
MCNUM mccPoreH27_radius_m;
MCNUM mccPoreH27_radius_h;
MCNUM mccPoreH27_Z0;
MCNUM mccPoreH27_xwidth;
MCNUM mccPoreH27_yheight;
MCNUM mccPoreH27_chamferwidth;
char mccPoreH27_mirror_reflec[16384];
char mccPoreH27_bottom_reflec[16384];
char mccPoreH27_side_reflec[16384];
MCNUM mccPoreH27_R_d;
MCNUM mccPoreH27_absorb_sides;

/* Setting parameters for component 'PoreH28' [131]. */
MCNUM mccPoreH28_radius_m;
MCNUM mccPoreH28_radius_h;
MCNUM mccPoreH28_Z0;
MCNUM mccPoreH28_xwidth;
MCNUM mccPoreH28_yheight;
MCNUM mccPoreH28_chamferwidth;
char mccPoreH28_mirror_reflec[16384];
char mccPoreH28_bottom_reflec[16384];
char mccPoreH28_side_reflec[16384];
MCNUM mccPoreH28_R_d;
MCNUM mccPoreH28_absorb_sides;

/* Setting parameters for component 'PoreH29' [132]. */
MCNUM mccPoreH29_radius_m;
MCNUM mccPoreH29_radius_h;
MCNUM mccPoreH29_Z0;
MCNUM mccPoreH29_xwidth;
MCNUM mccPoreH29_yheight;
MCNUM mccPoreH29_chamferwidth;
char mccPoreH29_mirror_reflec[16384];
char mccPoreH29_bottom_reflec[16384];
char mccPoreH29_side_reflec[16384];
MCNUM mccPoreH29_R_d;
MCNUM mccPoreH29_absorb_sides;

/* Setting parameters for component 'PoreH30' [133]. */
MCNUM mccPoreH30_radius_m;
MCNUM mccPoreH30_radius_h;
MCNUM mccPoreH30_Z0;
MCNUM mccPoreH30_xwidth;
MCNUM mccPoreH30_yheight;
MCNUM mccPoreH30_chamferwidth;
char mccPoreH30_mirror_reflec[16384];
char mccPoreH30_bottom_reflec[16384];
char mccPoreH30_side_reflec[16384];
MCNUM mccPoreH30_R_d;
MCNUM mccPoreH30_absorb_sides;

/* Setting parameters for component 'PoreH31' [134]. */
MCNUM mccPoreH31_radius_m;
MCNUM mccPoreH31_radius_h;
MCNUM mccPoreH31_Z0;
MCNUM mccPoreH31_xwidth;
MCNUM mccPoreH31_yheight;
MCNUM mccPoreH31_chamferwidth;
char mccPoreH31_mirror_reflec[16384];
char mccPoreH31_bottom_reflec[16384];
char mccPoreH31_side_reflec[16384];
MCNUM mccPoreH31_R_d;
MCNUM mccPoreH31_absorb_sides;

/* Setting parameters for component 'PoreH32' [135]. */
MCNUM mccPoreH32_radius_m;
MCNUM mccPoreH32_radius_h;
MCNUM mccPoreH32_Z0;
MCNUM mccPoreH32_xwidth;
MCNUM mccPoreH32_yheight;
MCNUM mccPoreH32_chamferwidth;
char mccPoreH32_mirror_reflec[16384];
char mccPoreH32_bottom_reflec[16384];
char mccPoreH32_side_reflec[16384];
MCNUM mccPoreH32_R_d;
MCNUM mccPoreH32_absorb_sides;

/* Setting parameters for component 'PoreH33' [136]. */
MCNUM mccPoreH33_radius_m;
MCNUM mccPoreH33_radius_h;
MCNUM mccPoreH33_Z0;
MCNUM mccPoreH33_xwidth;
MCNUM mccPoreH33_yheight;
MCNUM mccPoreH33_chamferwidth;
char mccPoreH33_mirror_reflec[16384];
char mccPoreH33_bottom_reflec[16384];
char mccPoreH33_side_reflec[16384];
MCNUM mccPoreH33_R_d;
MCNUM mccPoreH33_absorb_sides;

/* Setting parameters for component 'PoreH34' [137]. */
MCNUM mccPoreH34_radius_m;
MCNUM mccPoreH34_radius_h;
MCNUM mccPoreH34_Z0;
MCNUM mccPoreH34_xwidth;
MCNUM mccPoreH34_yheight;
MCNUM mccPoreH34_chamferwidth;
char mccPoreH34_mirror_reflec[16384];
char mccPoreH34_bottom_reflec[16384];
char mccPoreH34_side_reflec[16384];
MCNUM mccPoreH34_R_d;
MCNUM mccPoreH34_absorb_sides;

/* Setting parameters for component 'PoreH35' [138]. */
MCNUM mccPoreH35_radius_m;
MCNUM mccPoreH35_radius_h;
MCNUM mccPoreH35_Z0;
MCNUM mccPoreH35_xwidth;
MCNUM mccPoreH35_yheight;
MCNUM mccPoreH35_chamferwidth;
char mccPoreH35_mirror_reflec[16384];
char mccPoreH35_bottom_reflec[16384];
char mccPoreH35_side_reflec[16384];
MCNUM mccPoreH35_R_d;
MCNUM mccPoreH35_absorb_sides;

/* Setting parameters for component 'PoreH36' [139]. */
MCNUM mccPoreH36_radius_m;
MCNUM mccPoreH36_radius_h;
MCNUM mccPoreH36_Z0;
MCNUM mccPoreH36_xwidth;
MCNUM mccPoreH36_yheight;
MCNUM mccPoreH36_chamferwidth;
char mccPoreH36_mirror_reflec[16384];
char mccPoreH36_bottom_reflec[16384];
char mccPoreH36_side_reflec[16384];
MCNUM mccPoreH36_R_d;
MCNUM mccPoreH36_absorb_sides;

/* Setting parameters for component 'PoreH37' [140]. */
MCNUM mccPoreH37_radius_m;
MCNUM mccPoreH37_radius_h;
MCNUM mccPoreH37_Z0;
MCNUM mccPoreH37_xwidth;
MCNUM mccPoreH37_yheight;
MCNUM mccPoreH37_chamferwidth;
char mccPoreH37_mirror_reflec[16384];
char mccPoreH37_bottom_reflec[16384];
char mccPoreH37_side_reflec[16384];
MCNUM mccPoreH37_R_d;
MCNUM mccPoreH37_absorb_sides;

/* Setting parameters for component 'PoreH38' [141]. */
MCNUM mccPoreH38_radius_m;
MCNUM mccPoreH38_radius_h;
MCNUM mccPoreH38_Z0;
MCNUM mccPoreH38_xwidth;
MCNUM mccPoreH38_yheight;
MCNUM mccPoreH38_chamferwidth;
char mccPoreH38_mirror_reflec[16384];
char mccPoreH38_bottom_reflec[16384];
char mccPoreH38_side_reflec[16384];
MCNUM mccPoreH38_R_d;
MCNUM mccPoreH38_absorb_sides;

/* Setting parameters for component 'PoreH39' [142]. */
MCNUM mccPoreH39_radius_m;
MCNUM mccPoreH39_radius_h;
MCNUM mccPoreH39_Z0;
MCNUM mccPoreH39_xwidth;
MCNUM mccPoreH39_yheight;
MCNUM mccPoreH39_chamferwidth;
char mccPoreH39_mirror_reflec[16384];
char mccPoreH39_bottom_reflec[16384];
char mccPoreH39_side_reflec[16384];
MCNUM mccPoreH39_R_d;
MCNUM mccPoreH39_absorb_sides;

/* Setting parameters for component 'PoreH40' [143]. */
MCNUM mccPoreH40_radius_m;
MCNUM mccPoreH40_radius_h;
MCNUM mccPoreH40_Z0;
MCNUM mccPoreH40_xwidth;
MCNUM mccPoreH40_yheight;
MCNUM mccPoreH40_chamferwidth;
char mccPoreH40_mirror_reflec[16384];
char mccPoreH40_bottom_reflec[16384];
char mccPoreH40_side_reflec[16384];
MCNUM mccPoreH40_R_d;
MCNUM mccPoreH40_absorb_sides;

/* Setting parameters for component 'PoreH41' [144]. */
MCNUM mccPoreH41_radius_m;
MCNUM mccPoreH41_radius_h;
MCNUM mccPoreH41_Z0;
MCNUM mccPoreH41_xwidth;
MCNUM mccPoreH41_yheight;
MCNUM mccPoreH41_chamferwidth;
char mccPoreH41_mirror_reflec[16384];
char mccPoreH41_bottom_reflec[16384];
char mccPoreH41_side_reflec[16384];
MCNUM mccPoreH41_R_d;
MCNUM mccPoreH41_absorb_sides;

/* Setting parameters for component 'PoreH42' [145]. */
MCNUM mccPoreH42_radius_m;
MCNUM mccPoreH42_radius_h;
MCNUM mccPoreH42_Z0;
MCNUM mccPoreH42_xwidth;
MCNUM mccPoreH42_yheight;
MCNUM mccPoreH42_chamferwidth;
char mccPoreH42_mirror_reflec[16384];
char mccPoreH42_bottom_reflec[16384];
char mccPoreH42_side_reflec[16384];
MCNUM mccPoreH42_R_d;
MCNUM mccPoreH42_absorb_sides;

/* Setting parameters for component 'PoreH43' [146]. */
MCNUM mccPoreH43_radius_m;
MCNUM mccPoreH43_radius_h;
MCNUM mccPoreH43_Z0;
MCNUM mccPoreH43_xwidth;
MCNUM mccPoreH43_yheight;
MCNUM mccPoreH43_chamferwidth;
char mccPoreH43_mirror_reflec[16384];
char mccPoreH43_bottom_reflec[16384];
char mccPoreH43_side_reflec[16384];
MCNUM mccPoreH43_R_d;
MCNUM mccPoreH43_absorb_sides;

/* Setting parameters for component 'PoreH44' [147]. */
MCNUM mccPoreH44_radius_m;
MCNUM mccPoreH44_radius_h;
MCNUM mccPoreH44_Z0;
MCNUM mccPoreH44_xwidth;
MCNUM mccPoreH44_yheight;
MCNUM mccPoreH44_chamferwidth;
char mccPoreH44_mirror_reflec[16384];
char mccPoreH44_bottom_reflec[16384];
char mccPoreH44_side_reflec[16384];
MCNUM mccPoreH44_R_d;
MCNUM mccPoreH44_absorb_sides;

/* Setting parameters for component 'PoreH45' [148]. */
MCNUM mccPoreH45_radius_m;
MCNUM mccPoreH45_radius_h;
MCNUM mccPoreH45_Z0;
MCNUM mccPoreH45_xwidth;
MCNUM mccPoreH45_yheight;
MCNUM mccPoreH45_chamferwidth;
char mccPoreH45_mirror_reflec[16384];
char mccPoreH45_bottom_reflec[16384];
char mccPoreH45_side_reflec[16384];
MCNUM mccPoreH45_R_d;
MCNUM mccPoreH45_absorb_sides;

/* Setting parameters for component 'PoreH46' [149]. */
MCNUM mccPoreH46_radius_m;
MCNUM mccPoreH46_radius_h;
MCNUM mccPoreH46_Z0;
MCNUM mccPoreH46_xwidth;
MCNUM mccPoreH46_yheight;
MCNUM mccPoreH46_chamferwidth;
char mccPoreH46_mirror_reflec[16384];
char mccPoreH46_bottom_reflec[16384];
char mccPoreH46_side_reflec[16384];
MCNUM mccPoreH46_R_d;
MCNUM mccPoreH46_absorb_sides;

/* Setting parameters for component 'PoreH47' [150]. */
MCNUM mccPoreH47_radius_m;
MCNUM mccPoreH47_radius_h;
MCNUM mccPoreH47_Z0;
MCNUM mccPoreH47_xwidth;
MCNUM mccPoreH47_yheight;
MCNUM mccPoreH47_chamferwidth;
char mccPoreH47_mirror_reflec[16384];
char mccPoreH47_bottom_reflec[16384];
char mccPoreH47_side_reflec[16384];
MCNUM mccPoreH47_R_d;
MCNUM mccPoreH47_absorb_sides;

/* Setting parameters for component 'PoreH48' [151]. */
MCNUM mccPoreH48_radius_m;
MCNUM mccPoreH48_radius_h;
MCNUM mccPoreH48_Z0;
MCNUM mccPoreH48_xwidth;
MCNUM mccPoreH48_yheight;
MCNUM mccPoreH48_chamferwidth;
char mccPoreH48_mirror_reflec[16384];
char mccPoreH48_bottom_reflec[16384];
char mccPoreH48_side_reflec[16384];
MCNUM mccPoreH48_R_d;
MCNUM mccPoreH48_absorb_sides;

/* Definition parameters for component 'monitorAfter' [152]. */
#define mccmonitorAfter_nx wideResolution
#define mccmonitorAfter_ny wideResolution
#define mccmonitorAfter_nr 0
#define mccmonitorAfter_filename 0 /* declared as a string. May produce warnings at compile */
#define mccmonitorAfter_restore_xray 1
/* Setting parameters for component 'monitorAfter' [152]. */
MCNUM mccmonitorAfter_xmin;
MCNUM mccmonitorAfter_xmax;
MCNUM mccmonitorAfter_ymin;
MCNUM mccmonitorAfter_ymax;
MCNUM mccmonitorAfter_xwidth;
MCNUM mccmonitorAfter_yheight;
MCNUM mccmonitorAfter_radius;

/* Definition parameters for component 'endMonitorWide' [153]. */
#define mccendMonitorWide_nx wideResolution
#define mccendMonitorWide_ny wideResolution
#define mccendMonitorWide_nr 0
#define mccendMonitorWide_filename 0 /* declared as a string. May produce warnings at compile */
#define mccendMonitorWide_restore_xray 0
/* Setting parameters for component 'endMonitorWide' [153]. */
MCNUM mccendMonitorWide_xmin;
MCNUM mccendMonitorWide_xmax;
MCNUM mccendMonitorWide_ymin;
MCNUM mccendMonitorWide_ymax;
MCNUM mccendMonitorWide_xwidth;
MCNUM mccendMonitorWide_yheight;
MCNUM mccendMonitorWide_radius;

/* User component declarations. */

/* User declarations for component 'origin' [1]. */
#define mccompcurname  origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define profile mccorigin_profile
#define IntermediateCnts mccorigin_IntermediateCnts
#define StartTime mccorigin_StartTime
#define EndTime mccorigin_EndTime
#define percent mccorigin_percent
#define flag_save mccorigin_flag_save
#define minutes mccorigin_minutes
#line 50 "/usr/share/mcxtrace/1.4/misc/Progress_bar.comp"
#ifndef PROGRESS_BAR
#define PROGRESS_BAR
#else
#error Only one Progress_bar component may be used in an instrument definition.
#endif

  double IntermediateCnts=0;
  time_t StartTime       =0;
  time_t EndTime         =0;
  time_t CurrentTime     =0;
#line 8283 "instruments/plate49.c"
#undef minutes
#undef flag_save
#undef percent
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef profile
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ThetaArm' [2]. */
#define mccompcurname  ThetaArm
#define mccompcurtype  Arm
#define mccompcurindex 2
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'srcDirectional' [3]. */
#define mccompcurname  srcDirectional
#define mccompcurtype  Source_div
#define mccompcurindex 3
#define spectrum_file mccsrcDirectional_spectrum_file
#define prms mccsrcDirectional_prms
#define p_init mccsrcDirectional_p_init
#define dist mccsrcDirectional_dist
#define xwidth mccsrcDirectional_xwidth
#define yheight mccsrcDirectional_yheight
#define focus_aw mccsrcDirectional_focus_aw
#define focus_ah mccsrcDirectional_focus_ah
#define E0 mccsrcDirectional_E0
#define dE mccsrcDirectional_dE
#define lambda0 mccsrcDirectional_lambda0
#define dlambda mccsrcDirectional_dlambda
#define flux mccsrcDirectional_flux
#define gauss mccsrcDirectional_gauss
#define gauss_a mccsrcDirectional_gauss_a
#define randomphase mccsrcDirectional_randomphase
#define phase mccsrcDirectional_phase
#line 69 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
  double  p_init, dist;
  struct {
    double K,dK,xmin,xmax,xw_2,focus_xw_2,ymin,ymax,yh_2,focus_yh_2,pmul,pint;
    t_Table T;
  } prms;
#line 8330 "instruments/plate49.c"
#undef phase
#undef randomphase
#undef gauss_a
#undef gauss
#undef flux
#undef dlambda
#undef lambda0
#undef dE
#undef E0
#undef focus_ah
#undef focus_aw
#undef yheight
#undef xwidth
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'srcDirectionalWide' [4]. */
#define mccompcurname  srcDirectionalWide
#define mccompcurtype  Source_div
#define mccompcurindex 4
#define spectrum_file mccsrcDirectionalWide_spectrum_file
#define prms mccsrcDirectionalWide_prms
#define p_init mccsrcDirectionalWide_p_init
#define dist mccsrcDirectionalWide_dist
#define xwidth mccsrcDirectionalWide_xwidth
#define yheight mccsrcDirectionalWide_yheight
#define focus_aw mccsrcDirectionalWide_focus_aw
#define focus_ah mccsrcDirectionalWide_focus_ah
#define E0 mccsrcDirectionalWide_E0
#define dE mccsrcDirectionalWide_dE
#define lambda0 mccsrcDirectionalWide_lambda0
#define dlambda mccsrcDirectionalWide_dlambda
#define flux mccsrcDirectionalWide_flux
#define gauss mccsrcDirectionalWide_gauss
#define gauss_a mccsrcDirectionalWide_gauss_a
#define randomphase mccsrcDirectionalWide_randomphase
#define phase mccsrcDirectionalWide_phase
#line 69 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
  double  p_init, dist;
  struct {
    double K,dK,xmin,xmax,xw_2,focus_xw_2,ymin,ymax,yh_2,focus_yh_2,pmul,pint;
    t_Table T;
  } prms;
#line 8379 "instruments/plate49.c"
#undef phase
#undef randomphase
#undef gauss_a
#undef gauss
#undef flux
#undef dlambda
#undef lambda0
#undef dE
#undef E0
#undef focus_ah
#undef focus_aw
#undef yheight
#undef xwidth
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm0' [5]. */
#define mccompcurname  PoreArm0
#define mccompcurtype  Arm
#define mccompcurindex 5
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm1' [6]. */
#define mccompcurname  PoreArm1
#define mccompcurtype  Arm
#define mccompcurindex 6
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm2' [7]. */
#define mccompcurname  PoreArm2
#define mccompcurtype  Arm
#define mccompcurindex 7
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm3' [8]. */
#define mccompcurname  PoreArm3
#define mccompcurtype  Arm
#define mccompcurindex 8
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm4' [9]. */
#define mccompcurname  PoreArm4
#define mccompcurtype  Arm
#define mccompcurindex 9
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm5' [10]. */
#define mccompcurname  PoreArm5
#define mccompcurtype  Arm
#define mccompcurindex 10
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm6' [11]. */
#define mccompcurname  PoreArm6
#define mccompcurtype  Arm
#define mccompcurindex 11
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm7' [12]. */
#define mccompcurname  PoreArm7
#define mccompcurtype  Arm
#define mccompcurindex 12
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm8' [13]. */
#define mccompcurname  PoreArm8
#define mccompcurtype  Arm
#define mccompcurindex 13
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm9' [14]. */
#define mccompcurname  PoreArm9
#define mccompcurtype  Arm
#define mccompcurindex 14
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm10' [15]. */
#define mccompcurname  PoreArm10
#define mccompcurtype  Arm
#define mccompcurindex 15
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm11' [16]. */
#define mccompcurname  PoreArm11
#define mccompcurtype  Arm
#define mccompcurindex 16
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm12' [17]. */
#define mccompcurname  PoreArm12
#define mccompcurtype  Arm
#define mccompcurindex 17
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm13' [18]. */
#define mccompcurname  PoreArm13
#define mccompcurtype  Arm
#define mccompcurindex 18
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm14' [19]. */
#define mccompcurname  PoreArm14
#define mccompcurtype  Arm
#define mccompcurindex 19
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm15' [20]. */
#define mccompcurname  PoreArm15
#define mccompcurtype  Arm
#define mccompcurindex 20
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm16' [21]. */
#define mccompcurname  PoreArm16
#define mccompcurtype  Arm
#define mccompcurindex 21
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm17' [22]. */
#define mccompcurname  PoreArm17
#define mccompcurtype  Arm
#define mccompcurindex 22
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm18' [23]. */
#define mccompcurname  PoreArm18
#define mccompcurtype  Arm
#define mccompcurindex 23
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm19' [24]. */
#define mccompcurname  PoreArm19
#define mccompcurtype  Arm
#define mccompcurindex 24
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm20' [25]. */
#define mccompcurname  PoreArm20
#define mccompcurtype  Arm
#define mccompcurindex 25
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm21' [26]. */
#define mccompcurname  PoreArm21
#define mccompcurtype  Arm
#define mccompcurindex 26
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm22' [27]. */
#define mccompcurname  PoreArm22
#define mccompcurtype  Arm
#define mccompcurindex 27
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm23' [28]. */
#define mccompcurname  PoreArm23
#define mccompcurtype  Arm
#define mccompcurindex 28
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm24' [29]. */
#define mccompcurname  PoreArm24
#define mccompcurtype  Arm
#define mccompcurindex 29
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm25' [30]. */
#define mccompcurname  PoreArm25
#define mccompcurtype  Arm
#define mccompcurindex 30
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm26' [31]. */
#define mccompcurname  PoreArm26
#define mccompcurtype  Arm
#define mccompcurindex 31
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm27' [32]. */
#define mccompcurname  PoreArm27
#define mccompcurtype  Arm
#define mccompcurindex 32
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm28' [33]. */
#define mccompcurname  PoreArm28
#define mccompcurtype  Arm
#define mccompcurindex 33
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm29' [34]. */
#define mccompcurname  PoreArm29
#define mccompcurtype  Arm
#define mccompcurindex 34
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm30' [35]. */
#define mccompcurname  PoreArm30
#define mccompcurtype  Arm
#define mccompcurindex 35
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm31' [36]. */
#define mccompcurname  PoreArm31
#define mccompcurtype  Arm
#define mccompcurindex 36
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm32' [37]. */
#define mccompcurname  PoreArm32
#define mccompcurtype  Arm
#define mccompcurindex 37
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm33' [38]. */
#define mccompcurname  PoreArm33
#define mccompcurtype  Arm
#define mccompcurindex 38
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm34' [39]. */
#define mccompcurname  PoreArm34
#define mccompcurtype  Arm
#define mccompcurindex 39
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm35' [40]. */
#define mccompcurname  PoreArm35
#define mccompcurtype  Arm
#define mccompcurindex 40
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm36' [41]. */
#define mccompcurname  PoreArm36
#define mccompcurtype  Arm
#define mccompcurindex 41
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm37' [42]. */
#define mccompcurname  PoreArm37
#define mccompcurtype  Arm
#define mccompcurindex 42
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm38' [43]. */
#define mccompcurname  PoreArm38
#define mccompcurtype  Arm
#define mccompcurindex 43
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm39' [44]. */
#define mccompcurname  PoreArm39
#define mccompcurtype  Arm
#define mccompcurindex 44
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm40' [45]. */
#define mccompcurname  PoreArm40
#define mccompcurtype  Arm
#define mccompcurindex 45
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm41' [46]. */
#define mccompcurname  PoreArm41
#define mccompcurtype  Arm
#define mccompcurindex 46
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm42' [47]. */
#define mccompcurname  PoreArm42
#define mccompcurtype  Arm
#define mccompcurindex 47
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm43' [48]. */
#define mccompcurname  PoreArm43
#define mccompcurtype  Arm
#define mccompcurindex 48
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm44' [49]. */
#define mccompcurname  PoreArm44
#define mccompcurtype  Arm
#define mccompcurindex 49
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm45' [50]. */
#define mccompcurname  PoreArm45
#define mccompcurtype  Arm
#define mccompcurindex 50
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm46' [51]. */
#define mccompcurname  PoreArm46
#define mccompcurtype  Arm
#define mccompcurindex 51
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm47' [52]. */
#define mccompcurname  PoreArm47
#define mccompcurtype  Arm
#define mccompcurindex 52
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreArm48' [53]. */
#define mccompcurname  PoreArm48
#define mccompcurtype  Arm
#define mccompcurindex 53
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP0' [54]. */
#define mccompcurname  PoreP0
#define mccompcurtype  Pore_p_group
#define mccompcurindex 54
#define nLeft mccPoreP0_nLeft
#define nRight mccPoreP0_nRight
#define nExit mccPoreP0_nExit
#define nTop mccPoreP0_nTop
#define nBottom mccPoreP0_nBottom
#define wLeft mccPoreP0_wLeft
#define wRight mccPoreP0_wRight
#define wExit mccPoreP0_wExit
#define wall mccPoreP0_wall
#define zentry mccPoreP0_zentry
#define reflec_top_table mccPoreP0_reflec_top_table
#define reflec_bottom_table mccPoreP0_reflec_bottom_table
#define reflec_side_table mccPoreP0_reflec_side_table
#define ref_prms mccPoreP0_ref_prms
#define radius_p mccPoreP0_radius_p
#define radius_m mccPoreP0_radius_m
#define Z0 mccPoreP0_Z0
#define xwidth mccPoreP0_xwidth
#define yheight mccPoreP0_yheight
#define chamferwidth mccPoreP0_chamferwidth
#define mirror_reflec mccPoreP0_mirror_reflec
#define bottom_reflec mccPoreP0_bottom_reflec
#define side_reflec mccPoreP0_side_reflec
#define R_d mccPoreP0_R_d
#define absorb_sides mccPoreP0_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 8840 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP1' [55]. */
#define mccompcurname  PoreP1
#define mccompcurtype  Pore_p_group
#define mccompcurindex 55
#define nLeft mccPoreP1_nLeft
#define nRight mccPoreP1_nRight
#define nExit mccPoreP1_nExit
#define nTop mccPoreP1_nTop
#define nBottom mccPoreP1_nBottom
#define wLeft mccPoreP1_wLeft
#define wRight mccPoreP1_wRight
#define wExit mccPoreP1_wExit
#define wall mccPoreP1_wall
#define zentry mccPoreP1_zentry
#define reflec_top_table mccPoreP1_reflec_top_table
#define reflec_bottom_table mccPoreP1_reflec_bottom_table
#define reflec_side_table mccPoreP1_reflec_side_table
#define ref_prms mccPoreP1_ref_prms
#define radius_p mccPoreP1_radius_p
#define radius_m mccPoreP1_radius_m
#define Z0 mccPoreP1_Z0
#define xwidth mccPoreP1_xwidth
#define yheight mccPoreP1_yheight
#define chamferwidth mccPoreP1_chamferwidth
#define mirror_reflec mccPoreP1_mirror_reflec
#define bottom_reflec mccPoreP1_bottom_reflec
#define side_reflec mccPoreP1_side_reflec
#define R_d mccPoreP1_R_d
#define absorb_sides mccPoreP1_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 8917 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP2' [56]. */
#define mccompcurname  PoreP2
#define mccompcurtype  Pore_p_group
#define mccompcurindex 56
#define nLeft mccPoreP2_nLeft
#define nRight mccPoreP2_nRight
#define nExit mccPoreP2_nExit
#define nTop mccPoreP2_nTop
#define nBottom mccPoreP2_nBottom
#define wLeft mccPoreP2_wLeft
#define wRight mccPoreP2_wRight
#define wExit mccPoreP2_wExit
#define wall mccPoreP2_wall
#define zentry mccPoreP2_zentry
#define reflec_top_table mccPoreP2_reflec_top_table
#define reflec_bottom_table mccPoreP2_reflec_bottom_table
#define reflec_side_table mccPoreP2_reflec_side_table
#define ref_prms mccPoreP2_ref_prms
#define radius_p mccPoreP2_radius_p
#define radius_m mccPoreP2_radius_m
#define Z0 mccPoreP2_Z0
#define xwidth mccPoreP2_xwidth
#define yheight mccPoreP2_yheight
#define chamferwidth mccPoreP2_chamferwidth
#define mirror_reflec mccPoreP2_mirror_reflec
#define bottom_reflec mccPoreP2_bottom_reflec
#define side_reflec mccPoreP2_side_reflec
#define R_d mccPoreP2_R_d
#define absorb_sides mccPoreP2_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 8994 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP3' [57]. */
#define mccompcurname  PoreP3
#define mccompcurtype  Pore_p_group
#define mccompcurindex 57
#define nLeft mccPoreP3_nLeft
#define nRight mccPoreP3_nRight
#define nExit mccPoreP3_nExit
#define nTop mccPoreP3_nTop
#define nBottom mccPoreP3_nBottom
#define wLeft mccPoreP3_wLeft
#define wRight mccPoreP3_wRight
#define wExit mccPoreP3_wExit
#define wall mccPoreP3_wall
#define zentry mccPoreP3_zentry
#define reflec_top_table mccPoreP3_reflec_top_table
#define reflec_bottom_table mccPoreP3_reflec_bottom_table
#define reflec_side_table mccPoreP3_reflec_side_table
#define ref_prms mccPoreP3_ref_prms
#define radius_p mccPoreP3_radius_p
#define radius_m mccPoreP3_radius_m
#define Z0 mccPoreP3_Z0
#define xwidth mccPoreP3_xwidth
#define yheight mccPoreP3_yheight
#define chamferwidth mccPoreP3_chamferwidth
#define mirror_reflec mccPoreP3_mirror_reflec
#define bottom_reflec mccPoreP3_bottom_reflec
#define side_reflec mccPoreP3_side_reflec
#define R_d mccPoreP3_R_d
#define absorb_sides mccPoreP3_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9071 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP4' [58]. */
#define mccompcurname  PoreP4
#define mccompcurtype  Pore_p_group
#define mccompcurindex 58
#define nLeft mccPoreP4_nLeft
#define nRight mccPoreP4_nRight
#define nExit mccPoreP4_nExit
#define nTop mccPoreP4_nTop
#define nBottom mccPoreP4_nBottom
#define wLeft mccPoreP4_wLeft
#define wRight mccPoreP4_wRight
#define wExit mccPoreP4_wExit
#define wall mccPoreP4_wall
#define zentry mccPoreP4_zentry
#define reflec_top_table mccPoreP4_reflec_top_table
#define reflec_bottom_table mccPoreP4_reflec_bottom_table
#define reflec_side_table mccPoreP4_reflec_side_table
#define ref_prms mccPoreP4_ref_prms
#define radius_p mccPoreP4_radius_p
#define radius_m mccPoreP4_radius_m
#define Z0 mccPoreP4_Z0
#define xwidth mccPoreP4_xwidth
#define yheight mccPoreP4_yheight
#define chamferwidth mccPoreP4_chamferwidth
#define mirror_reflec mccPoreP4_mirror_reflec
#define bottom_reflec mccPoreP4_bottom_reflec
#define side_reflec mccPoreP4_side_reflec
#define R_d mccPoreP4_R_d
#define absorb_sides mccPoreP4_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9148 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP5' [59]. */
#define mccompcurname  PoreP5
#define mccompcurtype  Pore_p_group
#define mccompcurindex 59
#define nLeft mccPoreP5_nLeft
#define nRight mccPoreP5_nRight
#define nExit mccPoreP5_nExit
#define nTop mccPoreP5_nTop
#define nBottom mccPoreP5_nBottom
#define wLeft mccPoreP5_wLeft
#define wRight mccPoreP5_wRight
#define wExit mccPoreP5_wExit
#define wall mccPoreP5_wall
#define zentry mccPoreP5_zentry
#define reflec_top_table mccPoreP5_reflec_top_table
#define reflec_bottom_table mccPoreP5_reflec_bottom_table
#define reflec_side_table mccPoreP5_reflec_side_table
#define ref_prms mccPoreP5_ref_prms
#define radius_p mccPoreP5_radius_p
#define radius_m mccPoreP5_radius_m
#define Z0 mccPoreP5_Z0
#define xwidth mccPoreP5_xwidth
#define yheight mccPoreP5_yheight
#define chamferwidth mccPoreP5_chamferwidth
#define mirror_reflec mccPoreP5_mirror_reflec
#define bottom_reflec mccPoreP5_bottom_reflec
#define side_reflec mccPoreP5_side_reflec
#define R_d mccPoreP5_R_d
#define absorb_sides mccPoreP5_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9225 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP6' [60]. */
#define mccompcurname  PoreP6
#define mccompcurtype  Pore_p_group
#define mccompcurindex 60
#define nLeft mccPoreP6_nLeft
#define nRight mccPoreP6_nRight
#define nExit mccPoreP6_nExit
#define nTop mccPoreP6_nTop
#define nBottom mccPoreP6_nBottom
#define wLeft mccPoreP6_wLeft
#define wRight mccPoreP6_wRight
#define wExit mccPoreP6_wExit
#define wall mccPoreP6_wall
#define zentry mccPoreP6_zentry
#define reflec_top_table mccPoreP6_reflec_top_table
#define reflec_bottom_table mccPoreP6_reflec_bottom_table
#define reflec_side_table mccPoreP6_reflec_side_table
#define ref_prms mccPoreP6_ref_prms
#define radius_p mccPoreP6_radius_p
#define radius_m mccPoreP6_radius_m
#define Z0 mccPoreP6_Z0
#define xwidth mccPoreP6_xwidth
#define yheight mccPoreP6_yheight
#define chamferwidth mccPoreP6_chamferwidth
#define mirror_reflec mccPoreP6_mirror_reflec
#define bottom_reflec mccPoreP6_bottom_reflec
#define side_reflec mccPoreP6_side_reflec
#define R_d mccPoreP6_R_d
#define absorb_sides mccPoreP6_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9302 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP7' [61]. */
#define mccompcurname  PoreP7
#define mccompcurtype  Pore_p_group
#define mccompcurindex 61
#define nLeft mccPoreP7_nLeft
#define nRight mccPoreP7_nRight
#define nExit mccPoreP7_nExit
#define nTop mccPoreP7_nTop
#define nBottom mccPoreP7_nBottom
#define wLeft mccPoreP7_wLeft
#define wRight mccPoreP7_wRight
#define wExit mccPoreP7_wExit
#define wall mccPoreP7_wall
#define zentry mccPoreP7_zentry
#define reflec_top_table mccPoreP7_reflec_top_table
#define reflec_bottom_table mccPoreP7_reflec_bottom_table
#define reflec_side_table mccPoreP7_reflec_side_table
#define ref_prms mccPoreP7_ref_prms
#define radius_p mccPoreP7_radius_p
#define radius_m mccPoreP7_radius_m
#define Z0 mccPoreP7_Z0
#define xwidth mccPoreP7_xwidth
#define yheight mccPoreP7_yheight
#define chamferwidth mccPoreP7_chamferwidth
#define mirror_reflec mccPoreP7_mirror_reflec
#define bottom_reflec mccPoreP7_bottom_reflec
#define side_reflec mccPoreP7_side_reflec
#define R_d mccPoreP7_R_d
#define absorb_sides mccPoreP7_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9379 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP8' [62]. */
#define mccompcurname  PoreP8
#define mccompcurtype  Pore_p_group
#define mccompcurindex 62
#define nLeft mccPoreP8_nLeft
#define nRight mccPoreP8_nRight
#define nExit mccPoreP8_nExit
#define nTop mccPoreP8_nTop
#define nBottom mccPoreP8_nBottom
#define wLeft mccPoreP8_wLeft
#define wRight mccPoreP8_wRight
#define wExit mccPoreP8_wExit
#define wall mccPoreP8_wall
#define zentry mccPoreP8_zentry
#define reflec_top_table mccPoreP8_reflec_top_table
#define reflec_bottom_table mccPoreP8_reflec_bottom_table
#define reflec_side_table mccPoreP8_reflec_side_table
#define ref_prms mccPoreP8_ref_prms
#define radius_p mccPoreP8_radius_p
#define radius_m mccPoreP8_radius_m
#define Z0 mccPoreP8_Z0
#define xwidth mccPoreP8_xwidth
#define yheight mccPoreP8_yheight
#define chamferwidth mccPoreP8_chamferwidth
#define mirror_reflec mccPoreP8_mirror_reflec
#define bottom_reflec mccPoreP8_bottom_reflec
#define side_reflec mccPoreP8_side_reflec
#define R_d mccPoreP8_R_d
#define absorb_sides mccPoreP8_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9456 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP9' [63]. */
#define mccompcurname  PoreP9
#define mccompcurtype  Pore_p_group
#define mccompcurindex 63
#define nLeft mccPoreP9_nLeft
#define nRight mccPoreP9_nRight
#define nExit mccPoreP9_nExit
#define nTop mccPoreP9_nTop
#define nBottom mccPoreP9_nBottom
#define wLeft mccPoreP9_wLeft
#define wRight mccPoreP9_wRight
#define wExit mccPoreP9_wExit
#define wall mccPoreP9_wall
#define zentry mccPoreP9_zentry
#define reflec_top_table mccPoreP9_reflec_top_table
#define reflec_bottom_table mccPoreP9_reflec_bottom_table
#define reflec_side_table mccPoreP9_reflec_side_table
#define ref_prms mccPoreP9_ref_prms
#define radius_p mccPoreP9_radius_p
#define radius_m mccPoreP9_radius_m
#define Z0 mccPoreP9_Z0
#define xwidth mccPoreP9_xwidth
#define yheight mccPoreP9_yheight
#define chamferwidth mccPoreP9_chamferwidth
#define mirror_reflec mccPoreP9_mirror_reflec
#define bottom_reflec mccPoreP9_bottom_reflec
#define side_reflec mccPoreP9_side_reflec
#define R_d mccPoreP9_R_d
#define absorb_sides mccPoreP9_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9533 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP10' [64]. */
#define mccompcurname  PoreP10
#define mccompcurtype  Pore_p_group
#define mccompcurindex 64
#define nLeft mccPoreP10_nLeft
#define nRight mccPoreP10_nRight
#define nExit mccPoreP10_nExit
#define nTop mccPoreP10_nTop
#define nBottom mccPoreP10_nBottom
#define wLeft mccPoreP10_wLeft
#define wRight mccPoreP10_wRight
#define wExit mccPoreP10_wExit
#define wall mccPoreP10_wall
#define zentry mccPoreP10_zentry
#define reflec_top_table mccPoreP10_reflec_top_table
#define reflec_bottom_table mccPoreP10_reflec_bottom_table
#define reflec_side_table mccPoreP10_reflec_side_table
#define ref_prms mccPoreP10_ref_prms
#define radius_p mccPoreP10_radius_p
#define radius_m mccPoreP10_radius_m
#define Z0 mccPoreP10_Z0
#define xwidth mccPoreP10_xwidth
#define yheight mccPoreP10_yheight
#define chamferwidth mccPoreP10_chamferwidth
#define mirror_reflec mccPoreP10_mirror_reflec
#define bottom_reflec mccPoreP10_bottom_reflec
#define side_reflec mccPoreP10_side_reflec
#define R_d mccPoreP10_R_d
#define absorb_sides mccPoreP10_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9610 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP11' [65]. */
#define mccompcurname  PoreP11
#define mccompcurtype  Pore_p_group
#define mccompcurindex 65
#define nLeft mccPoreP11_nLeft
#define nRight mccPoreP11_nRight
#define nExit mccPoreP11_nExit
#define nTop mccPoreP11_nTop
#define nBottom mccPoreP11_nBottom
#define wLeft mccPoreP11_wLeft
#define wRight mccPoreP11_wRight
#define wExit mccPoreP11_wExit
#define wall mccPoreP11_wall
#define zentry mccPoreP11_zentry
#define reflec_top_table mccPoreP11_reflec_top_table
#define reflec_bottom_table mccPoreP11_reflec_bottom_table
#define reflec_side_table mccPoreP11_reflec_side_table
#define ref_prms mccPoreP11_ref_prms
#define radius_p mccPoreP11_radius_p
#define radius_m mccPoreP11_radius_m
#define Z0 mccPoreP11_Z0
#define xwidth mccPoreP11_xwidth
#define yheight mccPoreP11_yheight
#define chamferwidth mccPoreP11_chamferwidth
#define mirror_reflec mccPoreP11_mirror_reflec
#define bottom_reflec mccPoreP11_bottom_reflec
#define side_reflec mccPoreP11_side_reflec
#define R_d mccPoreP11_R_d
#define absorb_sides mccPoreP11_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9687 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP12' [66]. */
#define mccompcurname  PoreP12
#define mccompcurtype  Pore_p_group
#define mccompcurindex 66
#define nLeft mccPoreP12_nLeft
#define nRight mccPoreP12_nRight
#define nExit mccPoreP12_nExit
#define nTop mccPoreP12_nTop
#define nBottom mccPoreP12_nBottom
#define wLeft mccPoreP12_wLeft
#define wRight mccPoreP12_wRight
#define wExit mccPoreP12_wExit
#define wall mccPoreP12_wall
#define zentry mccPoreP12_zentry
#define reflec_top_table mccPoreP12_reflec_top_table
#define reflec_bottom_table mccPoreP12_reflec_bottom_table
#define reflec_side_table mccPoreP12_reflec_side_table
#define ref_prms mccPoreP12_ref_prms
#define radius_p mccPoreP12_radius_p
#define radius_m mccPoreP12_radius_m
#define Z0 mccPoreP12_Z0
#define xwidth mccPoreP12_xwidth
#define yheight mccPoreP12_yheight
#define chamferwidth mccPoreP12_chamferwidth
#define mirror_reflec mccPoreP12_mirror_reflec
#define bottom_reflec mccPoreP12_bottom_reflec
#define side_reflec mccPoreP12_side_reflec
#define R_d mccPoreP12_R_d
#define absorb_sides mccPoreP12_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9764 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP13' [67]. */
#define mccompcurname  PoreP13
#define mccompcurtype  Pore_p_group
#define mccompcurindex 67
#define nLeft mccPoreP13_nLeft
#define nRight mccPoreP13_nRight
#define nExit mccPoreP13_nExit
#define nTop mccPoreP13_nTop
#define nBottom mccPoreP13_nBottom
#define wLeft mccPoreP13_wLeft
#define wRight mccPoreP13_wRight
#define wExit mccPoreP13_wExit
#define wall mccPoreP13_wall
#define zentry mccPoreP13_zentry
#define reflec_top_table mccPoreP13_reflec_top_table
#define reflec_bottom_table mccPoreP13_reflec_bottom_table
#define reflec_side_table mccPoreP13_reflec_side_table
#define ref_prms mccPoreP13_ref_prms
#define radius_p mccPoreP13_radius_p
#define radius_m mccPoreP13_radius_m
#define Z0 mccPoreP13_Z0
#define xwidth mccPoreP13_xwidth
#define yheight mccPoreP13_yheight
#define chamferwidth mccPoreP13_chamferwidth
#define mirror_reflec mccPoreP13_mirror_reflec
#define bottom_reflec mccPoreP13_bottom_reflec
#define side_reflec mccPoreP13_side_reflec
#define R_d mccPoreP13_R_d
#define absorb_sides mccPoreP13_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9841 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP14' [68]. */
#define mccompcurname  PoreP14
#define mccompcurtype  Pore_p_group
#define mccompcurindex 68
#define nLeft mccPoreP14_nLeft
#define nRight mccPoreP14_nRight
#define nExit mccPoreP14_nExit
#define nTop mccPoreP14_nTop
#define nBottom mccPoreP14_nBottom
#define wLeft mccPoreP14_wLeft
#define wRight mccPoreP14_wRight
#define wExit mccPoreP14_wExit
#define wall mccPoreP14_wall
#define zentry mccPoreP14_zentry
#define reflec_top_table mccPoreP14_reflec_top_table
#define reflec_bottom_table mccPoreP14_reflec_bottom_table
#define reflec_side_table mccPoreP14_reflec_side_table
#define ref_prms mccPoreP14_ref_prms
#define radius_p mccPoreP14_radius_p
#define radius_m mccPoreP14_radius_m
#define Z0 mccPoreP14_Z0
#define xwidth mccPoreP14_xwidth
#define yheight mccPoreP14_yheight
#define chamferwidth mccPoreP14_chamferwidth
#define mirror_reflec mccPoreP14_mirror_reflec
#define bottom_reflec mccPoreP14_bottom_reflec
#define side_reflec mccPoreP14_side_reflec
#define R_d mccPoreP14_R_d
#define absorb_sides mccPoreP14_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9918 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP15' [69]. */
#define mccompcurname  PoreP15
#define mccompcurtype  Pore_p_group
#define mccompcurindex 69
#define nLeft mccPoreP15_nLeft
#define nRight mccPoreP15_nRight
#define nExit mccPoreP15_nExit
#define nTop mccPoreP15_nTop
#define nBottom mccPoreP15_nBottom
#define wLeft mccPoreP15_wLeft
#define wRight mccPoreP15_wRight
#define wExit mccPoreP15_wExit
#define wall mccPoreP15_wall
#define zentry mccPoreP15_zentry
#define reflec_top_table mccPoreP15_reflec_top_table
#define reflec_bottom_table mccPoreP15_reflec_bottom_table
#define reflec_side_table mccPoreP15_reflec_side_table
#define ref_prms mccPoreP15_ref_prms
#define radius_p mccPoreP15_radius_p
#define radius_m mccPoreP15_radius_m
#define Z0 mccPoreP15_Z0
#define xwidth mccPoreP15_xwidth
#define yheight mccPoreP15_yheight
#define chamferwidth mccPoreP15_chamferwidth
#define mirror_reflec mccPoreP15_mirror_reflec
#define bottom_reflec mccPoreP15_bottom_reflec
#define side_reflec mccPoreP15_side_reflec
#define R_d mccPoreP15_R_d
#define absorb_sides mccPoreP15_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 9995 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP16' [70]. */
#define mccompcurname  PoreP16
#define mccompcurtype  Pore_p_group
#define mccompcurindex 70
#define nLeft mccPoreP16_nLeft
#define nRight mccPoreP16_nRight
#define nExit mccPoreP16_nExit
#define nTop mccPoreP16_nTop
#define nBottom mccPoreP16_nBottom
#define wLeft mccPoreP16_wLeft
#define wRight mccPoreP16_wRight
#define wExit mccPoreP16_wExit
#define wall mccPoreP16_wall
#define zentry mccPoreP16_zentry
#define reflec_top_table mccPoreP16_reflec_top_table
#define reflec_bottom_table mccPoreP16_reflec_bottom_table
#define reflec_side_table mccPoreP16_reflec_side_table
#define ref_prms mccPoreP16_ref_prms
#define radius_p mccPoreP16_radius_p
#define radius_m mccPoreP16_radius_m
#define Z0 mccPoreP16_Z0
#define xwidth mccPoreP16_xwidth
#define yheight mccPoreP16_yheight
#define chamferwidth mccPoreP16_chamferwidth
#define mirror_reflec mccPoreP16_mirror_reflec
#define bottom_reflec mccPoreP16_bottom_reflec
#define side_reflec mccPoreP16_side_reflec
#define R_d mccPoreP16_R_d
#define absorb_sides mccPoreP16_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10072 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP17' [71]. */
#define mccompcurname  PoreP17
#define mccompcurtype  Pore_p_group
#define mccompcurindex 71
#define nLeft mccPoreP17_nLeft
#define nRight mccPoreP17_nRight
#define nExit mccPoreP17_nExit
#define nTop mccPoreP17_nTop
#define nBottom mccPoreP17_nBottom
#define wLeft mccPoreP17_wLeft
#define wRight mccPoreP17_wRight
#define wExit mccPoreP17_wExit
#define wall mccPoreP17_wall
#define zentry mccPoreP17_zentry
#define reflec_top_table mccPoreP17_reflec_top_table
#define reflec_bottom_table mccPoreP17_reflec_bottom_table
#define reflec_side_table mccPoreP17_reflec_side_table
#define ref_prms mccPoreP17_ref_prms
#define radius_p mccPoreP17_radius_p
#define radius_m mccPoreP17_radius_m
#define Z0 mccPoreP17_Z0
#define xwidth mccPoreP17_xwidth
#define yheight mccPoreP17_yheight
#define chamferwidth mccPoreP17_chamferwidth
#define mirror_reflec mccPoreP17_mirror_reflec
#define bottom_reflec mccPoreP17_bottom_reflec
#define side_reflec mccPoreP17_side_reflec
#define R_d mccPoreP17_R_d
#define absorb_sides mccPoreP17_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10149 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP18' [72]. */
#define mccompcurname  PoreP18
#define mccompcurtype  Pore_p_group
#define mccompcurindex 72
#define nLeft mccPoreP18_nLeft
#define nRight mccPoreP18_nRight
#define nExit mccPoreP18_nExit
#define nTop mccPoreP18_nTop
#define nBottom mccPoreP18_nBottom
#define wLeft mccPoreP18_wLeft
#define wRight mccPoreP18_wRight
#define wExit mccPoreP18_wExit
#define wall mccPoreP18_wall
#define zentry mccPoreP18_zentry
#define reflec_top_table mccPoreP18_reflec_top_table
#define reflec_bottom_table mccPoreP18_reflec_bottom_table
#define reflec_side_table mccPoreP18_reflec_side_table
#define ref_prms mccPoreP18_ref_prms
#define radius_p mccPoreP18_radius_p
#define radius_m mccPoreP18_radius_m
#define Z0 mccPoreP18_Z0
#define xwidth mccPoreP18_xwidth
#define yheight mccPoreP18_yheight
#define chamferwidth mccPoreP18_chamferwidth
#define mirror_reflec mccPoreP18_mirror_reflec
#define bottom_reflec mccPoreP18_bottom_reflec
#define side_reflec mccPoreP18_side_reflec
#define R_d mccPoreP18_R_d
#define absorb_sides mccPoreP18_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10226 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP19' [73]. */
#define mccompcurname  PoreP19
#define mccompcurtype  Pore_p_group
#define mccompcurindex 73
#define nLeft mccPoreP19_nLeft
#define nRight mccPoreP19_nRight
#define nExit mccPoreP19_nExit
#define nTop mccPoreP19_nTop
#define nBottom mccPoreP19_nBottom
#define wLeft mccPoreP19_wLeft
#define wRight mccPoreP19_wRight
#define wExit mccPoreP19_wExit
#define wall mccPoreP19_wall
#define zentry mccPoreP19_zentry
#define reflec_top_table mccPoreP19_reflec_top_table
#define reflec_bottom_table mccPoreP19_reflec_bottom_table
#define reflec_side_table mccPoreP19_reflec_side_table
#define ref_prms mccPoreP19_ref_prms
#define radius_p mccPoreP19_radius_p
#define radius_m mccPoreP19_radius_m
#define Z0 mccPoreP19_Z0
#define xwidth mccPoreP19_xwidth
#define yheight mccPoreP19_yheight
#define chamferwidth mccPoreP19_chamferwidth
#define mirror_reflec mccPoreP19_mirror_reflec
#define bottom_reflec mccPoreP19_bottom_reflec
#define side_reflec mccPoreP19_side_reflec
#define R_d mccPoreP19_R_d
#define absorb_sides mccPoreP19_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10303 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP20' [74]. */
#define mccompcurname  PoreP20
#define mccompcurtype  Pore_p_group
#define mccompcurindex 74
#define nLeft mccPoreP20_nLeft
#define nRight mccPoreP20_nRight
#define nExit mccPoreP20_nExit
#define nTop mccPoreP20_nTop
#define nBottom mccPoreP20_nBottom
#define wLeft mccPoreP20_wLeft
#define wRight mccPoreP20_wRight
#define wExit mccPoreP20_wExit
#define wall mccPoreP20_wall
#define zentry mccPoreP20_zentry
#define reflec_top_table mccPoreP20_reflec_top_table
#define reflec_bottom_table mccPoreP20_reflec_bottom_table
#define reflec_side_table mccPoreP20_reflec_side_table
#define ref_prms mccPoreP20_ref_prms
#define radius_p mccPoreP20_radius_p
#define radius_m mccPoreP20_radius_m
#define Z0 mccPoreP20_Z0
#define xwidth mccPoreP20_xwidth
#define yheight mccPoreP20_yheight
#define chamferwidth mccPoreP20_chamferwidth
#define mirror_reflec mccPoreP20_mirror_reflec
#define bottom_reflec mccPoreP20_bottom_reflec
#define side_reflec mccPoreP20_side_reflec
#define R_d mccPoreP20_R_d
#define absorb_sides mccPoreP20_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10380 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP21' [75]. */
#define mccompcurname  PoreP21
#define mccompcurtype  Pore_p_group
#define mccompcurindex 75
#define nLeft mccPoreP21_nLeft
#define nRight mccPoreP21_nRight
#define nExit mccPoreP21_nExit
#define nTop mccPoreP21_nTop
#define nBottom mccPoreP21_nBottom
#define wLeft mccPoreP21_wLeft
#define wRight mccPoreP21_wRight
#define wExit mccPoreP21_wExit
#define wall mccPoreP21_wall
#define zentry mccPoreP21_zentry
#define reflec_top_table mccPoreP21_reflec_top_table
#define reflec_bottom_table mccPoreP21_reflec_bottom_table
#define reflec_side_table mccPoreP21_reflec_side_table
#define ref_prms mccPoreP21_ref_prms
#define radius_p mccPoreP21_radius_p
#define radius_m mccPoreP21_radius_m
#define Z0 mccPoreP21_Z0
#define xwidth mccPoreP21_xwidth
#define yheight mccPoreP21_yheight
#define chamferwidth mccPoreP21_chamferwidth
#define mirror_reflec mccPoreP21_mirror_reflec
#define bottom_reflec mccPoreP21_bottom_reflec
#define side_reflec mccPoreP21_side_reflec
#define R_d mccPoreP21_R_d
#define absorb_sides mccPoreP21_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10457 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP22' [76]. */
#define mccompcurname  PoreP22
#define mccompcurtype  Pore_p_group
#define mccompcurindex 76
#define nLeft mccPoreP22_nLeft
#define nRight mccPoreP22_nRight
#define nExit mccPoreP22_nExit
#define nTop mccPoreP22_nTop
#define nBottom mccPoreP22_nBottom
#define wLeft mccPoreP22_wLeft
#define wRight mccPoreP22_wRight
#define wExit mccPoreP22_wExit
#define wall mccPoreP22_wall
#define zentry mccPoreP22_zentry
#define reflec_top_table mccPoreP22_reflec_top_table
#define reflec_bottom_table mccPoreP22_reflec_bottom_table
#define reflec_side_table mccPoreP22_reflec_side_table
#define ref_prms mccPoreP22_ref_prms
#define radius_p mccPoreP22_radius_p
#define radius_m mccPoreP22_radius_m
#define Z0 mccPoreP22_Z0
#define xwidth mccPoreP22_xwidth
#define yheight mccPoreP22_yheight
#define chamferwidth mccPoreP22_chamferwidth
#define mirror_reflec mccPoreP22_mirror_reflec
#define bottom_reflec mccPoreP22_bottom_reflec
#define side_reflec mccPoreP22_side_reflec
#define R_d mccPoreP22_R_d
#define absorb_sides mccPoreP22_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10534 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP23' [77]. */
#define mccompcurname  PoreP23
#define mccompcurtype  Pore_p_group
#define mccompcurindex 77
#define nLeft mccPoreP23_nLeft
#define nRight mccPoreP23_nRight
#define nExit mccPoreP23_nExit
#define nTop mccPoreP23_nTop
#define nBottom mccPoreP23_nBottom
#define wLeft mccPoreP23_wLeft
#define wRight mccPoreP23_wRight
#define wExit mccPoreP23_wExit
#define wall mccPoreP23_wall
#define zentry mccPoreP23_zentry
#define reflec_top_table mccPoreP23_reflec_top_table
#define reflec_bottom_table mccPoreP23_reflec_bottom_table
#define reflec_side_table mccPoreP23_reflec_side_table
#define ref_prms mccPoreP23_ref_prms
#define radius_p mccPoreP23_radius_p
#define radius_m mccPoreP23_radius_m
#define Z0 mccPoreP23_Z0
#define xwidth mccPoreP23_xwidth
#define yheight mccPoreP23_yheight
#define chamferwidth mccPoreP23_chamferwidth
#define mirror_reflec mccPoreP23_mirror_reflec
#define bottom_reflec mccPoreP23_bottom_reflec
#define side_reflec mccPoreP23_side_reflec
#define R_d mccPoreP23_R_d
#define absorb_sides mccPoreP23_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10611 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP24' [78]. */
#define mccompcurname  PoreP24
#define mccompcurtype  Pore_p_group
#define mccompcurindex 78
#define nLeft mccPoreP24_nLeft
#define nRight mccPoreP24_nRight
#define nExit mccPoreP24_nExit
#define nTop mccPoreP24_nTop
#define nBottom mccPoreP24_nBottom
#define wLeft mccPoreP24_wLeft
#define wRight mccPoreP24_wRight
#define wExit mccPoreP24_wExit
#define wall mccPoreP24_wall
#define zentry mccPoreP24_zentry
#define reflec_top_table mccPoreP24_reflec_top_table
#define reflec_bottom_table mccPoreP24_reflec_bottom_table
#define reflec_side_table mccPoreP24_reflec_side_table
#define ref_prms mccPoreP24_ref_prms
#define radius_p mccPoreP24_radius_p
#define radius_m mccPoreP24_radius_m
#define Z0 mccPoreP24_Z0
#define xwidth mccPoreP24_xwidth
#define yheight mccPoreP24_yheight
#define chamferwidth mccPoreP24_chamferwidth
#define mirror_reflec mccPoreP24_mirror_reflec
#define bottom_reflec mccPoreP24_bottom_reflec
#define side_reflec mccPoreP24_side_reflec
#define R_d mccPoreP24_R_d
#define absorb_sides mccPoreP24_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10688 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP25' [79]. */
#define mccompcurname  PoreP25
#define mccompcurtype  Pore_p_group
#define mccompcurindex 79
#define nLeft mccPoreP25_nLeft
#define nRight mccPoreP25_nRight
#define nExit mccPoreP25_nExit
#define nTop mccPoreP25_nTop
#define nBottom mccPoreP25_nBottom
#define wLeft mccPoreP25_wLeft
#define wRight mccPoreP25_wRight
#define wExit mccPoreP25_wExit
#define wall mccPoreP25_wall
#define zentry mccPoreP25_zentry
#define reflec_top_table mccPoreP25_reflec_top_table
#define reflec_bottom_table mccPoreP25_reflec_bottom_table
#define reflec_side_table mccPoreP25_reflec_side_table
#define ref_prms mccPoreP25_ref_prms
#define radius_p mccPoreP25_radius_p
#define radius_m mccPoreP25_radius_m
#define Z0 mccPoreP25_Z0
#define xwidth mccPoreP25_xwidth
#define yheight mccPoreP25_yheight
#define chamferwidth mccPoreP25_chamferwidth
#define mirror_reflec mccPoreP25_mirror_reflec
#define bottom_reflec mccPoreP25_bottom_reflec
#define side_reflec mccPoreP25_side_reflec
#define R_d mccPoreP25_R_d
#define absorb_sides mccPoreP25_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10765 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP26' [80]. */
#define mccompcurname  PoreP26
#define mccompcurtype  Pore_p_group
#define mccompcurindex 80
#define nLeft mccPoreP26_nLeft
#define nRight mccPoreP26_nRight
#define nExit mccPoreP26_nExit
#define nTop mccPoreP26_nTop
#define nBottom mccPoreP26_nBottom
#define wLeft mccPoreP26_wLeft
#define wRight mccPoreP26_wRight
#define wExit mccPoreP26_wExit
#define wall mccPoreP26_wall
#define zentry mccPoreP26_zentry
#define reflec_top_table mccPoreP26_reflec_top_table
#define reflec_bottom_table mccPoreP26_reflec_bottom_table
#define reflec_side_table mccPoreP26_reflec_side_table
#define ref_prms mccPoreP26_ref_prms
#define radius_p mccPoreP26_radius_p
#define radius_m mccPoreP26_radius_m
#define Z0 mccPoreP26_Z0
#define xwidth mccPoreP26_xwidth
#define yheight mccPoreP26_yheight
#define chamferwidth mccPoreP26_chamferwidth
#define mirror_reflec mccPoreP26_mirror_reflec
#define bottom_reflec mccPoreP26_bottom_reflec
#define side_reflec mccPoreP26_side_reflec
#define R_d mccPoreP26_R_d
#define absorb_sides mccPoreP26_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10842 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP27' [81]. */
#define mccompcurname  PoreP27
#define mccompcurtype  Pore_p_group
#define mccompcurindex 81
#define nLeft mccPoreP27_nLeft
#define nRight mccPoreP27_nRight
#define nExit mccPoreP27_nExit
#define nTop mccPoreP27_nTop
#define nBottom mccPoreP27_nBottom
#define wLeft mccPoreP27_wLeft
#define wRight mccPoreP27_wRight
#define wExit mccPoreP27_wExit
#define wall mccPoreP27_wall
#define zentry mccPoreP27_zentry
#define reflec_top_table mccPoreP27_reflec_top_table
#define reflec_bottom_table mccPoreP27_reflec_bottom_table
#define reflec_side_table mccPoreP27_reflec_side_table
#define ref_prms mccPoreP27_ref_prms
#define radius_p mccPoreP27_radius_p
#define radius_m mccPoreP27_radius_m
#define Z0 mccPoreP27_Z0
#define xwidth mccPoreP27_xwidth
#define yheight mccPoreP27_yheight
#define chamferwidth mccPoreP27_chamferwidth
#define mirror_reflec mccPoreP27_mirror_reflec
#define bottom_reflec mccPoreP27_bottom_reflec
#define side_reflec mccPoreP27_side_reflec
#define R_d mccPoreP27_R_d
#define absorb_sides mccPoreP27_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10919 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP28' [82]. */
#define mccompcurname  PoreP28
#define mccompcurtype  Pore_p_group
#define mccompcurindex 82
#define nLeft mccPoreP28_nLeft
#define nRight mccPoreP28_nRight
#define nExit mccPoreP28_nExit
#define nTop mccPoreP28_nTop
#define nBottom mccPoreP28_nBottom
#define wLeft mccPoreP28_wLeft
#define wRight mccPoreP28_wRight
#define wExit mccPoreP28_wExit
#define wall mccPoreP28_wall
#define zentry mccPoreP28_zentry
#define reflec_top_table mccPoreP28_reflec_top_table
#define reflec_bottom_table mccPoreP28_reflec_bottom_table
#define reflec_side_table mccPoreP28_reflec_side_table
#define ref_prms mccPoreP28_ref_prms
#define radius_p mccPoreP28_radius_p
#define radius_m mccPoreP28_radius_m
#define Z0 mccPoreP28_Z0
#define xwidth mccPoreP28_xwidth
#define yheight mccPoreP28_yheight
#define chamferwidth mccPoreP28_chamferwidth
#define mirror_reflec mccPoreP28_mirror_reflec
#define bottom_reflec mccPoreP28_bottom_reflec
#define side_reflec mccPoreP28_side_reflec
#define R_d mccPoreP28_R_d
#define absorb_sides mccPoreP28_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 10996 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP29' [83]. */
#define mccompcurname  PoreP29
#define mccompcurtype  Pore_p_group
#define mccompcurindex 83
#define nLeft mccPoreP29_nLeft
#define nRight mccPoreP29_nRight
#define nExit mccPoreP29_nExit
#define nTop mccPoreP29_nTop
#define nBottom mccPoreP29_nBottom
#define wLeft mccPoreP29_wLeft
#define wRight mccPoreP29_wRight
#define wExit mccPoreP29_wExit
#define wall mccPoreP29_wall
#define zentry mccPoreP29_zentry
#define reflec_top_table mccPoreP29_reflec_top_table
#define reflec_bottom_table mccPoreP29_reflec_bottom_table
#define reflec_side_table mccPoreP29_reflec_side_table
#define ref_prms mccPoreP29_ref_prms
#define radius_p mccPoreP29_radius_p
#define radius_m mccPoreP29_radius_m
#define Z0 mccPoreP29_Z0
#define xwidth mccPoreP29_xwidth
#define yheight mccPoreP29_yheight
#define chamferwidth mccPoreP29_chamferwidth
#define mirror_reflec mccPoreP29_mirror_reflec
#define bottom_reflec mccPoreP29_bottom_reflec
#define side_reflec mccPoreP29_side_reflec
#define R_d mccPoreP29_R_d
#define absorb_sides mccPoreP29_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11073 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP30' [84]. */
#define mccompcurname  PoreP30
#define mccompcurtype  Pore_p_group
#define mccompcurindex 84
#define nLeft mccPoreP30_nLeft
#define nRight mccPoreP30_nRight
#define nExit mccPoreP30_nExit
#define nTop mccPoreP30_nTop
#define nBottom mccPoreP30_nBottom
#define wLeft mccPoreP30_wLeft
#define wRight mccPoreP30_wRight
#define wExit mccPoreP30_wExit
#define wall mccPoreP30_wall
#define zentry mccPoreP30_zentry
#define reflec_top_table mccPoreP30_reflec_top_table
#define reflec_bottom_table mccPoreP30_reflec_bottom_table
#define reflec_side_table mccPoreP30_reflec_side_table
#define ref_prms mccPoreP30_ref_prms
#define radius_p mccPoreP30_radius_p
#define radius_m mccPoreP30_radius_m
#define Z0 mccPoreP30_Z0
#define xwidth mccPoreP30_xwidth
#define yheight mccPoreP30_yheight
#define chamferwidth mccPoreP30_chamferwidth
#define mirror_reflec mccPoreP30_mirror_reflec
#define bottom_reflec mccPoreP30_bottom_reflec
#define side_reflec mccPoreP30_side_reflec
#define R_d mccPoreP30_R_d
#define absorb_sides mccPoreP30_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11150 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP31' [85]. */
#define mccompcurname  PoreP31
#define mccompcurtype  Pore_p_group
#define mccompcurindex 85
#define nLeft mccPoreP31_nLeft
#define nRight mccPoreP31_nRight
#define nExit mccPoreP31_nExit
#define nTop mccPoreP31_nTop
#define nBottom mccPoreP31_nBottom
#define wLeft mccPoreP31_wLeft
#define wRight mccPoreP31_wRight
#define wExit mccPoreP31_wExit
#define wall mccPoreP31_wall
#define zentry mccPoreP31_zentry
#define reflec_top_table mccPoreP31_reflec_top_table
#define reflec_bottom_table mccPoreP31_reflec_bottom_table
#define reflec_side_table mccPoreP31_reflec_side_table
#define ref_prms mccPoreP31_ref_prms
#define radius_p mccPoreP31_radius_p
#define radius_m mccPoreP31_radius_m
#define Z0 mccPoreP31_Z0
#define xwidth mccPoreP31_xwidth
#define yheight mccPoreP31_yheight
#define chamferwidth mccPoreP31_chamferwidth
#define mirror_reflec mccPoreP31_mirror_reflec
#define bottom_reflec mccPoreP31_bottom_reflec
#define side_reflec mccPoreP31_side_reflec
#define R_d mccPoreP31_R_d
#define absorb_sides mccPoreP31_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11227 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP32' [86]. */
#define mccompcurname  PoreP32
#define mccompcurtype  Pore_p_group
#define mccompcurindex 86
#define nLeft mccPoreP32_nLeft
#define nRight mccPoreP32_nRight
#define nExit mccPoreP32_nExit
#define nTop mccPoreP32_nTop
#define nBottom mccPoreP32_nBottom
#define wLeft mccPoreP32_wLeft
#define wRight mccPoreP32_wRight
#define wExit mccPoreP32_wExit
#define wall mccPoreP32_wall
#define zentry mccPoreP32_zentry
#define reflec_top_table mccPoreP32_reflec_top_table
#define reflec_bottom_table mccPoreP32_reflec_bottom_table
#define reflec_side_table mccPoreP32_reflec_side_table
#define ref_prms mccPoreP32_ref_prms
#define radius_p mccPoreP32_radius_p
#define radius_m mccPoreP32_radius_m
#define Z0 mccPoreP32_Z0
#define xwidth mccPoreP32_xwidth
#define yheight mccPoreP32_yheight
#define chamferwidth mccPoreP32_chamferwidth
#define mirror_reflec mccPoreP32_mirror_reflec
#define bottom_reflec mccPoreP32_bottom_reflec
#define side_reflec mccPoreP32_side_reflec
#define R_d mccPoreP32_R_d
#define absorb_sides mccPoreP32_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11304 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP33' [87]. */
#define mccompcurname  PoreP33
#define mccompcurtype  Pore_p_group
#define mccompcurindex 87
#define nLeft mccPoreP33_nLeft
#define nRight mccPoreP33_nRight
#define nExit mccPoreP33_nExit
#define nTop mccPoreP33_nTop
#define nBottom mccPoreP33_nBottom
#define wLeft mccPoreP33_wLeft
#define wRight mccPoreP33_wRight
#define wExit mccPoreP33_wExit
#define wall mccPoreP33_wall
#define zentry mccPoreP33_zentry
#define reflec_top_table mccPoreP33_reflec_top_table
#define reflec_bottom_table mccPoreP33_reflec_bottom_table
#define reflec_side_table mccPoreP33_reflec_side_table
#define ref_prms mccPoreP33_ref_prms
#define radius_p mccPoreP33_radius_p
#define radius_m mccPoreP33_radius_m
#define Z0 mccPoreP33_Z0
#define xwidth mccPoreP33_xwidth
#define yheight mccPoreP33_yheight
#define chamferwidth mccPoreP33_chamferwidth
#define mirror_reflec mccPoreP33_mirror_reflec
#define bottom_reflec mccPoreP33_bottom_reflec
#define side_reflec mccPoreP33_side_reflec
#define R_d mccPoreP33_R_d
#define absorb_sides mccPoreP33_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11381 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP34' [88]. */
#define mccompcurname  PoreP34
#define mccompcurtype  Pore_p_group
#define mccompcurindex 88
#define nLeft mccPoreP34_nLeft
#define nRight mccPoreP34_nRight
#define nExit mccPoreP34_nExit
#define nTop mccPoreP34_nTop
#define nBottom mccPoreP34_nBottom
#define wLeft mccPoreP34_wLeft
#define wRight mccPoreP34_wRight
#define wExit mccPoreP34_wExit
#define wall mccPoreP34_wall
#define zentry mccPoreP34_zentry
#define reflec_top_table mccPoreP34_reflec_top_table
#define reflec_bottom_table mccPoreP34_reflec_bottom_table
#define reflec_side_table mccPoreP34_reflec_side_table
#define ref_prms mccPoreP34_ref_prms
#define radius_p mccPoreP34_radius_p
#define radius_m mccPoreP34_radius_m
#define Z0 mccPoreP34_Z0
#define xwidth mccPoreP34_xwidth
#define yheight mccPoreP34_yheight
#define chamferwidth mccPoreP34_chamferwidth
#define mirror_reflec mccPoreP34_mirror_reflec
#define bottom_reflec mccPoreP34_bottom_reflec
#define side_reflec mccPoreP34_side_reflec
#define R_d mccPoreP34_R_d
#define absorb_sides mccPoreP34_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11458 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP35' [89]. */
#define mccompcurname  PoreP35
#define mccompcurtype  Pore_p_group
#define mccompcurindex 89
#define nLeft mccPoreP35_nLeft
#define nRight mccPoreP35_nRight
#define nExit mccPoreP35_nExit
#define nTop mccPoreP35_nTop
#define nBottom mccPoreP35_nBottom
#define wLeft mccPoreP35_wLeft
#define wRight mccPoreP35_wRight
#define wExit mccPoreP35_wExit
#define wall mccPoreP35_wall
#define zentry mccPoreP35_zentry
#define reflec_top_table mccPoreP35_reflec_top_table
#define reflec_bottom_table mccPoreP35_reflec_bottom_table
#define reflec_side_table mccPoreP35_reflec_side_table
#define ref_prms mccPoreP35_ref_prms
#define radius_p mccPoreP35_radius_p
#define radius_m mccPoreP35_radius_m
#define Z0 mccPoreP35_Z0
#define xwidth mccPoreP35_xwidth
#define yheight mccPoreP35_yheight
#define chamferwidth mccPoreP35_chamferwidth
#define mirror_reflec mccPoreP35_mirror_reflec
#define bottom_reflec mccPoreP35_bottom_reflec
#define side_reflec mccPoreP35_side_reflec
#define R_d mccPoreP35_R_d
#define absorb_sides mccPoreP35_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11535 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP36' [90]. */
#define mccompcurname  PoreP36
#define mccompcurtype  Pore_p_group
#define mccompcurindex 90
#define nLeft mccPoreP36_nLeft
#define nRight mccPoreP36_nRight
#define nExit mccPoreP36_nExit
#define nTop mccPoreP36_nTop
#define nBottom mccPoreP36_nBottom
#define wLeft mccPoreP36_wLeft
#define wRight mccPoreP36_wRight
#define wExit mccPoreP36_wExit
#define wall mccPoreP36_wall
#define zentry mccPoreP36_zentry
#define reflec_top_table mccPoreP36_reflec_top_table
#define reflec_bottom_table mccPoreP36_reflec_bottom_table
#define reflec_side_table mccPoreP36_reflec_side_table
#define ref_prms mccPoreP36_ref_prms
#define radius_p mccPoreP36_radius_p
#define radius_m mccPoreP36_radius_m
#define Z0 mccPoreP36_Z0
#define xwidth mccPoreP36_xwidth
#define yheight mccPoreP36_yheight
#define chamferwidth mccPoreP36_chamferwidth
#define mirror_reflec mccPoreP36_mirror_reflec
#define bottom_reflec mccPoreP36_bottom_reflec
#define side_reflec mccPoreP36_side_reflec
#define R_d mccPoreP36_R_d
#define absorb_sides mccPoreP36_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11612 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP37' [91]. */
#define mccompcurname  PoreP37
#define mccompcurtype  Pore_p_group
#define mccompcurindex 91
#define nLeft mccPoreP37_nLeft
#define nRight mccPoreP37_nRight
#define nExit mccPoreP37_nExit
#define nTop mccPoreP37_nTop
#define nBottom mccPoreP37_nBottom
#define wLeft mccPoreP37_wLeft
#define wRight mccPoreP37_wRight
#define wExit mccPoreP37_wExit
#define wall mccPoreP37_wall
#define zentry mccPoreP37_zentry
#define reflec_top_table mccPoreP37_reflec_top_table
#define reflec_bottom_table mccPoreP37_reflec_bottom_table
#define reflec_side_table mccPoreP37_reflec_side_table
#define ref_prms mccPoreP37_ref_prms
#define radius_p mccPoreP37_radius_p
#define radius_m mccPoreP37_radius_m
#define Z0 mccPoreP37_Z0
#define xwidth mccPoreP37_xwidth
#define yheight mccPoreP37_yheight
#define chamferwidth mccPoreP37_chamferwidth
#define mirror_reflec mccPoreP37_mirror_reflec
#define bottom_reflec mccPoreP37_bottom_reflec
#define side_reflec mccPoreP37_side_reflec
#define R_d mccPoreP37_R_d
#define absorb_sides mccPoreP37_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11689 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP38' [92]. */
#define mccompcurname  PoreP38
#define mccompcurtype  Pore_p_group
#define mccompcurindex 92
#define nLeft mccPoreP38_nLeft
#define nRight mccPoreP38_nRight
#define nExit mccPoreP38_nExit
#define nTop mccPoreP38_nTop
#define nBottom mccPoreP38_nBottom
#define wLeft mccPoreP38_wLeft
#define wRight mccPoreP38_wRight
#define wExit mccPoreP38_wExit
#define wall mccPoreP38_wall
#define zentry mccPoreP38_zentry
#define reflec_top_table mccPoreP38_reflec_top_table
#define reflec_bottom_table mccPoreP38_reflec_bottom_table
#define reflec_side_table mccPoreP38_reflec_side_table
#define ref_prms mccPoreP38_ref_prms
#define radius_p mccPoreP38_radius_p
#define radius_m mccPoreP38_radius_m
#define Z0 mccPoreP38_Z0
#define xwidth mccPoreP38_xwidth
#define yheight mccPoreP38_yheight
#define chamferwidth mccPoreP38_chamferwidth
#define mirror_reflec mccPoreP38_mirror_reflec
#define bottom_reflec mccPoreP38_bottom_reflec
#define side_reflec mccPoreP38_side_reflec
#define R_d mccPoreP38_R_d
#define absorb_sides mccPoreP38_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11766 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP39' [93]. */
#define mccompcurname  PoreP39
#define mccompcurtype  Pore_p_group
#define mccompcurindex 93
#define nLeft mccPoreP39_nLeft
#define nRight mccPoreP39_nRight
#define nExit mccPoreP39_nExit
#define nTop mccPoreP39_nTop
#define nBottom mccPoreP39_nBottom
#define wLeft mccPoreP39_wLeft
#define wRight mccPoreP39_wRight
#define wExit mccPoreP39_wExit
#define wall mccPoreP39_wall
#define zentry mccPoreP39_zentry
#define reflec_top_table mccPoreP39_reflec_top_table
#define reflec_bottom_table mccPoreP39_reflec_bottom_table
#define reflec_side_table mccPoreP39_reflec_side_table
#define ref_prms mccPoreP39_ref_prms
#define radius_p mccPoreP39_radius_p
#define radius_m mccPoreP39_radius_m
#define Z0 mccPoreP39_Z0
#define xwidth mccPoreP39_xwidth
#define yheight mccPoreP39_yheight
#define chamferwidth mccPoreP39_chamferwidth
#define mirror_reflec mccPoreP39_mirror_reflec
#define bottom_reflec mccPoreP39_bottom_reflec
#define side_reflec mccPoreP39_side_reflec
#define R_d mccPoreP39_R_d
#define absorb_sides mccPoreP39_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11843 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP40' [94]. */
#define mccompcurname  PoreP40
#define mccompcurtype  Pore_p_group
#define mccompcurindex 94
#define nLeft mccPoreP40_nLeft
#define nRight mccPoreP40_nRight
#define nExit mccPoreP40_nExit
#define nTop mccPoreP40_nTop
#define nBottom mccPoreP40_nBottom
#define wLeft mccPoreP40_wLeft
#define wRight mccPoreP40_wRight
#define wExit mccPoreP40_wExit
#define wall mccPoreP40_wall
#define zentry mccPoreP40_zentry
#define reflec_top_table mccPoreP40_reflec_top_table
#define reflec_bottom_table mccPoreP40_reflec_bottom_table
#define reflec_side_table mccPoreP40_reflec_side_table
#define ref_prms mccPoreP40_ref_prms
#define radius_p mccPoreP40_radius_p
#define radius_m mccPoreP40_radius_m
#define Z0 mccPoreP40_Z0
#define xwidth mccPoreP40_xwidth
#define yheight mccPoreP40_yheight
#define chamferwidth mccPoreP40_chamferwidth
#define mirror_reflec mccPoreP40_mirror_reflec
#define bottom_reflec mccPoreP40_bottom_reflec
#define side_reflec mccPoreP40_side_reflec
#define R_d mccPoreP40_R_d
#define absorb_sides mccPoreP40_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11920 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP41' [95]. */
#define mccompcurname  PoreP41
#define mccompcurtype  Pore_p_group
#define mccompcurindex 95
#define nLeft mccPoreP41_nLeft
#define nRight mccPoreP41_nRight
#define nExit mccPoreP41_nExit
#define nTop mccPoreP41_nTop
#define nBottom mccPoreP41_nBottom
#define wLeft mccPoreP41_wLeft
#define wRight mccPoreP41_wRight
#define wExit mccPoreP41_wExit
#define wall mccPoreP41_wall
#define zentry mccPoreP41_zentry
#define reflec_top_table mccPoreP41_reflec_top_table
#define reflec_bottom_table mccPoreP41_reflec_bottom_table
#define reflec_side_table mccPoreP41_reflec_side_table
#define ref_prms mccPoreP41_ref_prms
#define radius_p mccPoreP41_radius_p
#define radius_m mccPoreP41_radius_m
#define Z0 mccPoreP41_Z0
#define xwidth mccPoreP41_xwidth
#define yheight mccPoreP41_yheight
#define chamferwidth mccPoreP41_chamferwidth
#define mirror_reflec mccPoreP41_mirror_reflec
#define bottom_reflec mccPoreP41_bottom_reflec
#define side_reflec mccPoreP41_side_reflec
#define R_d mccPoreP41_R_d
#define absorb_sides mccPoreP41_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 11997 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP42' [96]. */
#define mccompcurname  PoreP42
#define mccompcurtype  Pore_p_group
#define mccompcurindex 96
#define nLeft mccPoreP42_nLeft
#define nRight mccPoreP42_nRight
#define nExit mccPoreP42_nExit
#define nTop mccPoreP42_nTop
#define nBottom mccPoreP42_nBottom
#define wLeft mccPoreP42_wLeft
#define wRight mccPoreP42_wRight
#define wExit mccPoreP42_wExit
#define wall mccPoreP42_wall
#define zentry mccPoreP42_zentry
#define reflec_top_table mccPoreP42_reflec_top_table
#define reflec_bottom_table mccPoreP42_reflec_bottom_table
#define reflec_side_table mccPoreP42_reflec_side_table
#define ref_prms mccPoreP42_ref_prms
#define radius_p mccPoreP42_radius_p
#define radius_m mccPoreP42_radius_m
#define Z0 mccPoreP42_Z0
#define xwidth mccPoreP42_xwidth
#define yheight mccPoreP42_yheight
#define chamferwidth mccPoreP42_chamferwidth
#define mirror_reflec mccPoreP42_mirror_reflec
#define bottom_reflec mccPoreP42_bottom_reflec
#define side_reflec mccPoreP42_side_reflec
#define R_d mccPoreP42_R_d
#define absorb_sides mccPoreP42_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12074 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP43' [97]. */
#define mccompcurname  PoreP43
#define mccompcurtype  Pore_p_group
#define mccompcurindex 97
#define nLeft mccPoreP43_nLeft
#define nRight mccPoreP43_nRight
#define nExit mccPoreP43_nExit
#define nTop mccPoreP43_nTop
#define nBottom mccPoreP43_nBottom
#define wLeft mccPoreP43_wLeft
#define wRight mccPoreP43_wRight
#define wExit mccPoreP43_wExit
#define wall mccPoreP43_wall
#define zentry mccPoreP43_zentry
#define reflec_top_table mccPoreP43_reflec_top_table
#define reflec_bottom_table mccPoreP43_reflec_bottom_table
#define reflec_side_table mccPoreP43_reflec_side_table
#define ref_prms mccPoreP43_ref_prms
#define radius_p mccPoreP43_radius_p
#define radius_m mccPoreP43_radius_m
#define Z0 mccPoreP43_Z0
#define xwidth mccPoreP43_xwidth
#define yheight mccPoreP43_yheight
#define chamferwidth mccPoreP43_chamferwidth
#define mirror_reflec mccPoreP43_mirror_reflec
#define bottom_reflec mccPoreP43_bottom_reflec
#define side_reflec mccPoreP43_side_reflec
#define R_d mccPoreP43_R_d
#define absorb_sides mccPoreP43_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12151 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP44' [98]. */
#define mccompcurname  PoreP44
#define mccompcurtype  Pore_p_group
#define mccompcurindex 98
#define nLeft mccPoreP44_nLeft
#define nRight mccPoreP44_nRight
#define nExit mccPoreP44_nExit
#define nTop mccPoreP44_nTop
#define nBottom mccPoreP44_nBottom
#define wLeft mccPoreP44_wLeft
#define wRight mccPoreP44_wRight
#define wExit mccPoreP44_wExit
#define wall mccPoreP44_wall
#define zentry mccPoreP44_zentry
#define reflec_top_table mccPoreP44_reflec_top_table
#define reflec_bottom_table mccPoreP44_reflec_bottom_table
#define reflec_side_table mccPoreP44_reflec_side_table
#define ref_prms mccPoreP44_ref_prms
#define radius_p mccPoreP44_radius_p
#define radius_m mccPoreP44_radius_m
#define Z0 mccPoreP44_Z0
#define xwidth mccPoreP44_xwidth
#define yheight mccPoreP44_yheight
#define chamferwidth mccPoreP44_chamferwidth
#define mirror_reflec mccPoreP44_mirror_reflec
#define bottom_reflec mccPoreP44_bottom_reflec
#define side_reflec mccPoreP44_side_reflec
#define R_d mccPoreP44_R_d
#define absorb_sides mccPoreP44_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12228 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP45' [99]. */
#define mccompcurname  PoreP45
#define mccompcurtype  Pore_p_group
#define mccompcurindex 99
#define nLeft mccPoreP45_nLeft
#define nRight mccPoreP45_nRight
#define nExit mccPoreP45_nExit
#define nTop mccPoreP45_nTop
#define nBottom mccPoreP45_nBottom
#define wLeft mccPoreP45_wLeft
#define wRight mccPoreP45_wRight
#define wExit mccPoreP45_wExit
#define wall mccPoreP45_wall
#define zentry mccPoreP45_zentry
#define reflec_top_table mccPoreP45_reflec_top_table
#define reflec_bottom_table mccPoreP45_reflec_bottom_table
#define reflec_side_table mccPoreP45_reflec_side_table
#define ref_prms mccPoreP45_ref_prms
#define radius_p mccPoreP45_radius_p
#define radius_m mccPoreP45_radius_m
#define Z0 mccPoreP45_Z0
#define xwidth mccPoreP45_xwidth
#define yheight mccPoreP45_yheight
#define chamferwidth mccPoreP45_chamferwidth
#define mirror_reflec mccPoreP45_mirror_reflec
#define bottom_reflec mccPoreP45_bottom_reflec
#define side_reflec mccPoreP45_side_reflec
#define R_d mccPoreP45_R_d
#define absorb_sides mccPoreP45_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12305 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP46' [100]. */
#define mccompcurname  PoreP46
#define mccompcurtype  Pore_p_group
#define mccompcurindex 100
#define nLeft mccPoreP46_nLeft
#define nRight mccPoreP46_nRight
#define nExit mccPoreP46_nExit
#define nTop mccPoreP46_nTop
#define nBottom mccPoreP46_nBottom
#define wLeft mccPoreP46_wLeft
#define wRight mccPoreP46_wRight
#define wExit mccPoreP46_wExit
#define wall mccPoreP46_wall
#define zentry mccPoreP46_zentry
#define reflec_top_table mccPoreP46_reflec_top_table
#define reflec_bottom_table mccPoreP46_reflec_bottom_table
#define reflec_side_table mccPoreP46_reflec_side_table
#define ref_prms mccPoreP46_ref_prms
#define radius_p mccPoreP46_radius_p
#define radius_m mccPoreP46_radius_m
#define Z0 mccPoreP46_Z0
#define xwidth mccPoreP46_xwidth
#define yheight mccPoreP46_yheight
#define chamferwidth mccPoreP46_chamferwidth
#define mirror_reflec mccPoreP46_mirror_reflec
#define bottom_reflec mccPoreP46_bottom_reflec
#define side_reflec mccPoreP46_side_reflec
#define R_d mccPoreP46_R_d
#define absorb_sides mccPoreP46_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12382 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP47' [101]. */
#define mccompcurname  PoreP47
#define mccompcurtype  Pore_p_group
#define mccompcurindex 101
#define nLeft mccPoreP47_nLeft
#define nRight mccPoreP47_nRight
#define nExit mccPoreP47_nExit
#define nTop mccPoreP47_nTop
#define nBottom mccPoreP47_nBottom
#define wLeft mccPoreP47_wLeft
#define wRight mccPoreP47_wRight
#define wExit mccPoreP47_wExit
#define wall mccPoreP47_wall
#define zentry mccPoreP47_zentry
#define reflec_top_table mccPoreP47_reflec_top_table
#define reflec_bottom_table mccPoreP47_reflec_bottom_table
#define reflec_side_table mccPoreP47_reflec_side_table
#define ref_prms mccPoreP47_ref_prms
#define radius_p mccPoreP47_radius_p
#define radius_m mccPoreP47_radius_m
#define Z0 mccPoreP47_Z0
#define xwidth mccPoreP47_xwidth
#define yheight mccPoreP47_yheight
#define chamferwidth mccPoreP47_chamferwidth
#define mirror_reflec mccPoreP47_mirror_reflec
#define bottom_reflec mccPoreP47_bottom_reflec
#define side_reflec mccPoreP47_side_reflec
#define R_d mccPoreP47_R_d
#define absorb_sides mccPoreP47_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12459 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreP48' [102]. */
#define mccompcurname  PoreP48
#define mccompcurtype  Pore_p_group
#define mccompcurindex 102
#define nLeft mccPoreP48_nLeft
#define nRight mccPoreP48_nRight
#define nExit mccPoreP48_nExit
#define nTop mccPoreP48_nTop
#define nBottom mccPoreP48_nBottom
#define wLeft mccPoreP48_wLeft
#define wRight mccPoreP48_wRight
#define wExit mccPoreP48_wExit
#define wall mccPoreP48_wall
#define zentry mccPoreP48_zentry
#define reflec_top_table mccPoreP48_reflec_top_table
#define reflec_bottom_table mccPoreP48_reflec_bottom_table
#define reflec_side_table mccPoreP48_reflec_side_table
#define ref_prms mccPoreP48_ref_prms
#define radius_p mccPoreP48_radius_p
#define radius_m mccPoreP48_radius_m
#define Z0 mccPoreP48_Z0
#define xwidth mccPoreP48_xwidth
#define yheight mccPoreP48_yheight
#define chamferwidth mccPoreP48_chamferwidth
#define mirror_reflec mccPoreP48_mirror_reflec
#define bottom_reflec mccPoreP48_bottom_reflec
#define side_reflec mccPoreP48_side_reflec
#define R_d mccPoreP48_R_d
#define absorb_sides mccPoreP48_absorb_sides
#line 113 "Pore_p_group.comp"
    #include "dataOutput.c"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    double zentry;

    int (*intersect_wolterI) (double, double, double, double, double, double, double, double, double, double, double, double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12536 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH0' [103]. */
#define mccompcurname  PoreH0
#define mccompcurtype  Pore_h_group
#define mccompcurindex 103
#define nLeft mccPoreH0_nLeft
#define nRight mccPoreH0_nRight
#define nExit mccPoreH0_nExit
#define wLeft mccPoreH0_wLeft
#define wRight mccPoreH0_wRight
#define wExit mccPoreH0_wExit
#define wall mccPoreH0_wall
#define nTop mccPoreH0_nTop
#define nBottom mccPoreH0_nBottom
#define zexit mccPoreH0_zexit
#define zentry mccPoreH0_zentry
#define intersect_wolterI mccPoreH0_intersect_wolterI
#define reflec_side_table mccPoreH0_reflec_side_table
#define reflec_top_table mccPoreH0_reflec_top_table
#define reflec_bottom_table mccPoreH0_reflec_bottom_table
#define ref_prms mccPoreH0_ref_prms
#define radius_m mccPoreH0_radius_m
#define radius_h mccPoreH0_radius_h
#define Z0 mccPoreH0_Z0
#define xwidth mccPoreH0_xwidth
#define yheight mccPoreH0_yheight
#define chamferwidth mccPoreH0_chamferwidth
#define mirror_reflec mccPoreH0_mirror_reflec
#define bottom_reflec mccPoreH0_bottom_reflec
#define side_reflec mccPoreH0_side_reflec
#define R_d mccPoreH0_R_d
#define absorb_sides mccPoreH0_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12610 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH1' [104]. */
#define mccompcurname  PoreH1
#define mccompcurtype  Pore_h_group
#define mccompcurindex 104
#define nLeft mccPoreH1_nLeft
#define nRight mccPoreH1_nRight
#define nExit mccPoreH1_nExit
#define wLeft mccPoreH1_wLeft
#define wRight mccPoreH1_wRight
#define wExit mccPoreH1_wExit
#define wall mccPoreH1_wall
#define nTop mccPoreH1_nTop
#define nBottom mccPoreH1_nBottom
#define zexit mccPoreH1_zexit
#define zentry mccPoreH1_zentry
#define intersect_wolterI mccPoreH1_intersect_wolterI
#define reflec_side_table mccPoreH1_reflec_side_table
#define reflec_top_table mccPoreH1_reflec_top_table
#define reflec_bottom_table mccPoreH1_reflec_bottom_table
#define ref_prms mccPoreH1_ref_prms
#define radius_m mccPoreH1_radius_m
#define radius_h mccPoreH1_radius_h
#define Z0 mccPoreH1_Z0
#define xwidth mccPoreH1_xwidth
#define yheight mccPoreH1_yheight
#define chamferwidth mccPoreH1_chamferwidth
#define mirror_reflec mccPoreH1_mirror_reflec
#define bottom_reflec mccPoreH1_bottom_reflec
#define side_reflec mccPoreH1_side_reflec
#define R_d mccPoreH1_R_d
#define absorb_sides mccPoreH1_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12686 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH2' [105]. */
#define mccompcurname  PoreH2
#define mccompcurtype  Pore_h_group
#define mccompcurindex 105
#define nLeft mccPoreH2_nLeft
#define nRight mccPoreH2_nRight
#define nExit mccPoreH2_nExit
#define wLeft mccPoreH2_wLeft
#define wRight mccPoreH2_wRight
#define wExit mccPoreH2_wExit
#define wall mccPoreH2_wall
#define nTop mccPoreH2_nTop
#define nBottom mccPoreH2_nBottom
#define zexit mccPoreH2_zexit
#define zentry mccPoreH2_zentry
#define intersect_wolterI mccPoreH2_intersect_wolterI
#define reflec_side_table mccPoreH2_reflec_side_table
#define reflec_top_table mccPoreH2_reflec_top_table
#define reflec_bottom_table mccPoreH2_reflec_bottom_table
#define ref_prms mccPoreH2_ref_prms
#define radius_m mccPoreH2_radius_m
#define radius_h mccPoreH2_radius_h
#define Z0 mccPoreH2_Z0
#define xwidth mccPoreH2_xwidth
#define yheight mccPoreH2_yheight
#define chamferwidth mccPoreH2_chamferwidth
#define mirror_reflec mccPoreH2_mirror_reflec
#define bottom_reflec mccPoreH2_bottom_reflec
#define side_reflec mccPoreH2_side_reflec
#define R_d mccPoreH2_R_d
#define absorb_sides mccPoreH2_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12762 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH3' [106]. */
#define mccompcurname  PoreH3
#define mccompcurtype  Pore_h_group
#define mccompcurindex 106
#define nLeft mccPoreH3_nLeft
#define nRight mccPoreH3_nRight
#define nExit mccPoreH3_nExit
#define wLeft mccPoreH3_wLeft
#define wRight mccPoreH3_wRight
#define wExit mccPoreH3_wExit
#define wall mccPoreH3_wall
#define nTop mccPoreH3_nTop
#define nBottom mccPoreH3_nBottom
#define zexit mccPoreH3_zexit
#define zentry mccPoreH3_zentry
#define intersect_wolterI mccPoreH3_intersect_wolterI
#define reflec_side_table mccPoreH3_reflec_side_table
#define reflec_top_table mccPoreH3_reflec_top_table
#define reflec_bottom_table mccPoreH3_reflec_bottom_table
#define ref_prms mccPoreH3_ref_prms
#define radius_m mccPoreH3_radius_m
#define radius_h mccPoreH3_radius_h
#define Z0 mccPoreH3_Z0
#define xwidth mccPoreH3_xwidth
#define yheight mccPoreH3_yheight
#define chamferwidth mccPoreH3_chamferwidth
#define mirror_reflec mccPoreH3_mirror_reflec
#define bottom_reflec mccPoreH3_bottom_reflec
#define side_reflec mccPoreH3_side_reflec
#define R_d mccPoreH3_R_d
#define absorb_sides mccPoreH3_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12838 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH4' [107]. */
#define mccompcurname  PoreH4
#define mccompcurtype  Pore_h_group
#define mccompcurindex 107
#define nLeft mccPoreH4_nLeft
#define nRight mccPoreH4_nRight
#define nExit mccPoreH4_nExit
#define wLeft mccPoreH4_wLeft
#define wRight mccPoreH4_wRight
#define wExit mccPoreH4_wExit
#define wall mccPoreH4_wall
#define nTop mccPoreH4_nTop
#define nBottom mccPoreH4_nBottom
#define zexit mccPoreH4_zexit
#define zentry mccPoreH4_zentry
#define intersect_wolterI mccPoreH4_intersect_wolterI
#define reflec_side_table mccPoreH4_reflec_side_table
#define reflec_top_table mccPoreH4_reflec_top_table
#define reflec_bottom_table mccPoreH4_reflec_bottom_table
#define ref_prms mccPoreH4_ref_prms
#define radius_m mccPoreH4_radius_m
#define radius_h mccPoreH4_radius_h
#define Z0 mccPoreH4_Z0
#define xwidth mccPoreH4_xwidth
#define yheight mccPoreH4_yheight
#define chamferwidth mccPoreH4_chamferwidth
#define mirror_reflec mccPoreH4_mirror_reflec
#define bottom_reflec mccPoreH4_bottom_reflec
#define side_reflec mccPoreH4_side_reflec
#define R_d mccPoreH4_R_d
#define absorb_sides mccPoreH4_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12914 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH5' [108]. */
#define mccompcurname  PoreH5
#define mccompcurtype  Pore_h_group
#define mccompcurindex 108
#define nLeft mccPoreH5_nLeft
#define nRight mccPoreH5_nRight
#define nExit mccPoreH5_nExit
#define wLeft mccPoreH5_wLeft
#define wRight mccPoreH5_wRight
#define wExit mccPoreH5_wExit
#define wall mccPoreH5_wall
#define nTop mccPoreH5_nTop
#define nBottom mccPoreH5_nBottom
#define zexit mccPoreH5_zexit
#define zentry mccPoreH5_zentry
#define intersect_wolterI mccPoreH5_intersect_wolterI
#define reflec_side_table mccPoreH5_reflec_side_table
#define reflec_top_table mccPoreH5_reflec_top_table
#define reflec_bottom_table mccPoreH5_reflec_bottom_table
#define ref_prms mccPoreH5_ref_prms
#define radius_m mccPoreH5_radius_m
#define radius_h mccPoreH5_radius_h
#define Z0 mccPoreH5_Z0
#define xwidth mccPoreH5_xwidth
#define yheight mccPoreH5_yheight
#define chamferwidth mccPoreH5_chamferwidth
#define mirror_reflec mccPoreH5_mirror_reflec
#define bottom_reflec mccPoreH5_bottom_reflec
#define side_reflec mccPoreH5_side_reflec
#define R_d mccPoreH5_R_d
#define absorb_sides mccPoreH5_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 12990 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH6' [109]. */
#define mccompcurname  PoreH6
#define mccompcurtype  Pore_h_group
#define mccompcurindex 109
#define nLeft mccPoreH6_nLeft
#define nRight mccPoreH6_nRight
#define nExit mccPoreH6_nExit
#define wLeft mccPoreH6_wLeft
#define wRight mccPoreH6_wRight
#define wExit mccPoreH6_wExit
#define wall mccPoreH6_wall
#define nTop mccPoreH6_nTop
#define nBottom mccPoreH6_nBottom
#define zexit mccPoreH6_zexit
#define zentry mccPoreH6_zentry
#define intersect_wolterI mccPoreH6_intersect_wolterI
#define reflec_side_table mccPoreH6_reflec_side_table
#define reflec_top_table mccPoreH6_reflec_top_table
#define reflec_bottom_table mccPoreH6_reflec_bottom_table
#define ref_prms mccPoreH6_ref_prms
#define radius_m mccPoreH6_radius_m
#define radius_h mccPoreH6_radius_h
#define Z0 mccPoreH6_Z0
#define xwidth mccPoreH6_xwidth
#define yheight mccPoreH6_yheight
#define chamferwidth mccPoreH6_chamferwidth
#define mirror_reflec mccPoreH6_mirror_reflec
#define bottom_reflec mccPoreH6_bottom_reflec
#define side_reflec mccPoreH6_side_reflec
#define R_d mccPoreH6_R_d
#define absorb_sides mccPoreH6_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13066 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH7' [110]. */
#define mccompcurname  PoreH7
#define mccompcurtype  Pore_h_group
#define mccompcurindex 110
#define nLeft mccPoreH7_nLeft
#define nRight mccPoreH7_nRight
#define nExit mccPoreH7_nExit
#define wLeft mccPoreH7_wLeft
#define wRight mccPoreH7_wRight
#define wExit mccPoreH7_wExit
#define wall mccPoreH7_wall
#define nTop mccPoreH7_nTop
#define nBottom mccPoreH7_nBottom
#define zexit mccPoreH7_zexit
#define zentry mccPoreH7_zentry
#define intersect_wolterI mccPoreH7_intersect_wolterI
#define reflec_side_table mccPoreH7_reflec_side_table
#define reflec_top_table mccPoreH7_reflec_top_table
#define reflec_bottom_table mccPoreH7_reflec_bottom_table
#define ref_prms mccPoreH7_ref_prms
#define radius_m mccPoreH7_radius_m
#define radius_h mccPoreH7_radius_h
#define Z0 mccPoreH7_Z0
#define xwidth mccPoreH7_xwidth
#define yheight mccPoreH7_yheight
#define chamferwidth mccPoreH7_chamferwidth
#define mirror_reflec mccPoreH7_mirror_reflec
#define bottom_reflec mccPoreH7_bottom_reflec
#define side_reflec mccPoreH7_side_reflec
#define R_d mccPoreH7_R_d
#define absorb_sides mccPoreH7_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13142 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH8' [111]. */
#define mccompcurname  PoreH8
#define mccompcurtype  Pore_h_group
#define mccompcurindex 111
#define nLeft mccPoreH8_nLeft
#define nRight mccPoreH8_nRight
#define nExit mccPoreH8_nExit
#define wLeft mccPoreH8_wLeft
#define wRight mccPoreH8_wRight
#define wExit mccPoreH8_wExit
#define wall mccPoreH8_wall
#define nTop mccPoreH8_nTop
#define nBottom mccPoreH8_nBottom
#define zexit mccPoreH8_zexit
#define zentry mccPoreH8_zentry
#define intersect_wolterI mccPoreH8_intersect_wolterI
#define reflec_side_table mccPoreH8_reflec_side_table
#define reflec_top_table mccPoreH8_reflec_top_table
#define reflec_bottom_table mccPoreH8_reflec_bottom_table
#define ref_prms mccPoreH8_ref_prms
#define radius_m mccPoreH8_radius_m
#define radius_h mccPoreH8_radius_h
#define Z0 mccPoreH8_Z0
#define xwidth mccPoreH8_xwidth
#define yheight mccPoreH8_yheight
#define chamferwidth mccPoreH8_chamferwidth
#define mirror_reflec mccPoreH8_mirror_reflec
#define bottom_reflec mccPoreH8_bottom_reflec
#define side_reflec mccPoreH8_side_reflec
#define R_d mccPoreH8_R_d
#define absorb_sides mccPoreH8_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13218 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH9' [112]. */
#define mccompcurname  PoreH9
#define mccompcurtype  Pore_h_group
#define mccompcurindex 112
#define nLeft mccPoreH9_nLeft
#define nRight mccPoreH9_nRight
#define nExit mccPoreH9_nExit
#define wLeft mccPoreH9_wLeft
#define wRight mccPoreH9_wRight
#define wExit mccPoreH9_wExit
#define wall mccPoreH9_wall
#define nTop mccPoreH9_nTop
#define nBottom mccPoreH9_nBottom
#define zexit mccPoreH9_zexit
#define zentry mccPoreH9_zentry
#define intersect_wolterI mccPoreH9_intersect_wolterI
#define reflec_side_table mccPoreH9_reflec_side_table
#define reflec_top_table mccPoreH9_reflec_top_table
#define reflec_bottom_table mccPoreH9_reflec_bottom_table
#define ref_prms mccPoreH9_ref_prms
#define radius_m mccPoreH9_radius_m
#define radius_h mccPoreH9_radius_h
#define Z0 mccPoreH9_Z0
#define xwidth mccPoreH9_xwidth
#define yheight mccPoreH9_yheight
#define chamferwidth mccPoreH9_chamferwidth
#define mirror_reflec mccPoreH9_mirror_reflec
#define bottom_reflec mccPoreH9_bottom_reflec
#define side_reflec mccPoreH9_side_reflec
#define R_d mccPoreH9_R_d
#define absorb_sides mccPoreH9_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13294 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH10' [113]. */
#define mccompcurname  PoreH10
#define mccompcurtype  Pore_h_group
#define mccompcurindex 113
#define nLeft mccPoreH10_nLeft
#define nRight mccPoreH10_nRight
#define nExit mccPoreH10_nExit
#define wLeft mccPoreH10_wLeft
#define wRight mccPoreH10_wRight
#define wExit mccPoreH10_wExit
#define wall mccPoreH10_wall
#define nTop mccPoreH10_nTop
#define nBottom mccPoreH10_nBottom
#define zexit mccPoreH10_zexit
#define zentry mccPoreH10_zentry
#define intersect_wolterI mccPoreH10_intersect_wolterI
#define reflec_side_table mccPoreH10_reflec_side_table
#define reflec_top_table mccPoreH10_reflec_top_table
#define reflec_bottom_table mccPoreH10_reflec_bottom_table
#define ref_prms mccPoreH10_ref_prms
#define radius_m mccPoreH10_radius_m
#define radius_h mccPoreH10_radius_h
#define Z0 mccPoreH10_Z0
#define xwidth mccPoreH10_xwidth
#define yheight mccPoreH10_yheight
#define chamferwidth mccPoreH10_chamferwidth
#define mirror_reflec mccPoreH10_mirror_reflec
#define bottom_reflec mccPoreH10_bottom_reflec
#define side_reflec mccPoreH10_side_reflec
#define R_d mccPoreH10_R_d
#define absorb_sides mccPoreH10_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13370 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH11' [114]. */
#define mccompcurname  PoreH11
#define mccompcurtype  Pore_h_group
#define mccompcurindex 114
#define nLeft mccPoreH11_nLeft
#define nRight mccPoreH11_nRight
#define nExit mccPoreH11_nExit
#define wLeft mccPoreH11_wLeft
#define wRight mccPoreH11_wRight
#define wExit mccPoreH11_wExit
#define wall mccPoreH11_wall
#define nTop mccPoreH11_nTop
#define nBottom mccPoreH11_nBottom
#define zexit mccPoreH11_zexit
#define zentry mccPoreH11_zentry
#define intersect_wolterI mccPoreH11_intersect_wolterI
#define reflec_side_table mccPoreH11_reflec_side_table
#define reflec_top_table mccPoreH11_reflec_top_table
#define reflec_bottom_table mccPoreH11_reflec_bottom_table
#define ref_prms mccPoreH11_ref_prms
#define radius_m mccPoreH11_radius_m
#define radius_h mccPoreH11_radius_h
#define Z0 mccPoreH11_Z0
#define xwidth mccPoreH11_xwidth
#define yheight mccPoreH11_yheight
#define chamferwidth mccPoreH11_chamferwidth
#define mirror_reflec mccPoreH11_mirror_reflec
#define bottom_reflec mccPoreH11_bottom_reflec
#define side_reflec mccPoreH11_side_reflec
#define R_d mccPoreH11_R_d
#define absorb_sides mccPoreH11_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13446 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH12' [115]. */
#define mccompcurname  PoreH12
#define mccompcurtype  Pore_h_group
#define mccompcurindex 115
#define nLeft mccPoreH12_nLeft
#define nRight mccPoreH12_nRight
#define nExit mccPoreH12_nExit
#define wLeft mccPoreH12_wLeft
#define wRight mccPoreH12_wRight
#define wExit mccPoreH12_wExit
#define wall mccPoreH12_wall
#define nTop mccPoreH12_nTop
#define nBottom mccPoreH12_nBottom
#define zexit mccPoreH12_zexit
#define zentry mccPoreH12_zentry
#define intersect_wolterI mccPoreH12_intersect_wolterI
#define reflec_side_table mccPoreH12_reflec_side_table
#define reflec_top_table mccPoreH12_reflec_top_table
#define reflec_bottom_table mccPoreH12_reflec_bottom_table
#define ref_prms mccPoreH12_ref_prms
#define radius_m mccPoreH12_radius_m
#define radius_h mccPoreH12_radius_h
#define Z0 mccPoreH12_Z0
#define xwidth mccPoreH12_xwidth
#define yheight mccPoreH12_yheight
#define chamferwidth mccPoreH12_chamferwidth
#define mirror_reflec mccPoreH12_mirror_reflec
#define bottom_reflec mccPoreH12_bottom_reflec
#define side_reflec mccPoreH12_side_reflec
#define R_d mccPoreH12_R_d
#define absorb_sides mccPoreH12_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13522 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH13' [116]. */
#define mccompcurname  PoreH13
#define mccompcurtype  Pore_h_group
#define mccompcurindex 116
#define nLeft mccPoreH13_nLeft
#define nRight mccPoreH13_nRight
#define nExit mccPoreH13_nExit
#define wLeft mccPoreH13_wLeft
#define wRight mccPoreH13_wRight
#define wExit mccPoreH13_wExit
#define wall mccPoreH13_wall
#define nTop mccPoreH13_nTop
#define nBottom mccPoreH13_nBottom
#define zexit mccPoreH13_zexit
#define zentry mccPoreH13_zentry
#define intersect_wolterI mccPoreH13_intersect_wolterI
#define reflec_side_table mccPoreH13_reflec_side_table
#define reflec_top_table mccPoreH13_reflec_top_table
#define reflec_bottom_table mccPoreH13_reflec_bottom_table
#define ref_prms mccPoreH13_ref_prms
#define radius_m mccPoreH13_radius_m
#define radius_h mccPoreH13_radius_h
#define Z0 mccPoreH13_Z0
#define xwidth mccPoreH13_xwidth
#define yheight mccPoreH13_yheight
#define chamferwidth mccPoreH13_chamferwidth
#define mirror_reflec mccPoreH13_mirror_reflec
#define bottom_reflec mccPoreH13_bottom_reflec
#define side_reflec mccPoreH13_side_reflec
#define R_d mccPoreH13_R_d
#define absorb_sides mccPoreH13_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13598 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH14' [117]. */
#define mccompcurname  PoreH14
#define mccompcurtype  Pore_h_group
#define mccompcurindex 117
#define nLeft mccPoreH14_nLeft
#define nRight mccPoreH14_nRight
#define nExit mccPoreH14_nExit
#define wLeft mccPoreH14_wLeft
#define wRight mccPoreH14_wRight
#define wExit mccPoreH14_wExit
#define wall mccPoreH14_wall
#define nTop mccPoreH14_nTop
#define nBottom mccPoreH14_nBottom
#define zexit mccPoreH14_zexit
#define zentry mccPoreH14_zentry
#define intersect_wolterI mccPoreH14_intersect_wolterI
#define reflec_side_table mccPoreH14_reflec_side_table
#define reflec_top_table mccPoreH14_reflec_top_table
#define reflec_bottom_table mccPoreH14_reflec_bottom_table
#define ref_prms mccPoreH14_ref_prms
#define radius_m mccPoreH14_radius_m
#define radius_h mccPoreH14_radius_h
#define Z0 mccPoreH14_Z0
#define xwidth mccPoreH14_xwidth
#define yheight mccPoreH14_yheight
#define chamferwidth mccPoreH14_chamferwidth
#define mirror_reflec mccPoreH14_mirror_reflec
#define bottom_reflec mccPoreH14_bottom_reflec
#define side_reflec mccPoreH14_side_reflec
#define R_d mccPoreH14_R_d
#define absorb_sides mccPoreH14_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13674 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH15' [118]. */
#define mccompcurname  PoreH15
#define mccompcurtype  Pore_h_group
#define mccompcurindex 118
#define nLeft mccPoreH15_nLeft
#define nRight mccPoreH15_nRight
#define nExit mccPoreH15_nExit
#define wLeft mccPoreH15_wLeft
#define wRight mccPoreH15_wRight
#define wExit mccPoreH15_wExit
#define wall mccPoreH15_wall
#define nTop mccPoreH15_nTop
#define nBottom mccPoreH15_nBottom
#define zexit mccPoreH15_zexit
#define zentry mccPoreH15_zentry
#define intersect_wolterI mccPoreH15_intersect_wolterI
#define reflec_side_table mccPoreH15_reflec_side_table
#define reflec_top_table mccPoreH15_reflec_top_table
#define reflec_bottom_table mccPoreH15_reflec_bottom_table
#define ref_prms mccPoreH15_ref_prms
#define radius_m mccPoreH15_radius_m
#define radius_h mccPoreH15_radius_h
#define Z0 mccPoreH15_Z0
#define xwidth mccPoreH15_xwidth
#define yheight mccPoreH15_yheight
#define chamferwidth mccPoreH15_chamferwidth
#define mirror_reflec mccPoreH15_mirror_reflec
#define bottom_reflec mccPoreH15_bottom_reflec
#define side_reflec mccPoreH15_side_reflec
#define R_d mccPoreH15_R_d
#define absorb_sides mccPoreH15_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13750 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH16' [119]. */
#define mccompcurname  PoreH16
#define mccompcurtype  Pore_h_group
#define mccompcurindex 119
#define nLeft mccPoreH16_nLeft
#define nRight mccPoreH16_nRight
#define nExit mccPoreH16_nExit
#define wLeft mccPoreH16_wLeft
#define wRight mccPoreH16_wRight
#define wExit mccPoreH16_wExit
#define wall mccPoreH16_wall
#define nTop mccPoreH16_nTop
#define nBottom mccPoreH16_nBottom
#define zexit mccPoreH16_zexit
#define zentry mccPoreH16_zentry
#define intersect_wolterI mccPoreH16_intersect_wolterI
#define reflec_side_table mccPoreH16_reflec_side_table
#define reflec_top_table mccPoreH16_reflec_top_table
#define reflec_bottom_table mccPoreH16_reflec_bottom_table
#define ref_prms mccPoreH16_ref_prms
#define radius_m mccPoreH16_radius_m
#define radius_h mccPoreH16_radius_h
#define Z0 mccPoreH16_Z0
#define xwidth mccPoreH16_xwidth
#define yheight mccPoreH16_yheight
#define chamferwidth mccPoreH16_chamferwidth
#define mirror_reflec mccPoreH16_mirror_reflec
#define bottom_reflec mccPoreH16_bottom_reflec
#define side_reflec mccPoreH16_side_reflec
#define R_d mccPoreH16_R_d
#define absorb_sides mccPoreH16_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13826 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH17' [120]. */
#define mccompcurname  PoreH17
#define mccompcurtype  Pore_h_group
#define mccompcurindex 120
#define nLeft mccPoreH17_nLeft
#define nRight mccPoreH17_nRight
#define nExit mccPoreH17_nExit
#define wLeft mccPoreH17_wLeft
#define wRight mccPoreH17_wRight
#define wExit mccPoreH17_wExit
#define wall mccPoreH17_wall
#define nTop mccPoreH17_nTop
#define nBottom mccPoreH17_nBottom
#define zexit mccPoreH17_zexit
#define zentry mccPoreH17_zentry
#define intersect_wolterI mccPoreH17_intersect_wolterI
#define reflec_side_table mccPoreH17_reflec_side_table
#define reflec_top_table mccPoreH17_reflec_top_table
#define reflec_bottom_table mccPoreH17_reflec_bottom_table
#define ref_prms mccPoreH17_ref_prms
#define radius_m mccPoreH17_radius_m
#define radius_h mccPoreH17_radius_h
#define Z0 mccPoreH17_Z0
#define xwidth mccPoreH17_xwidth
#define yheight mccPoreH17_yheight
#define chamferwidth mccPoreH17_chamferwidth
#define mirror_reflec mccPoreH17_mirror_reflec
#define bottom_reflec mccPoreH17_bottom_reflec
#define side_reflec mccPoreH17_side_reflec
#define R_d mccPoreH17_R_d
#define absorb_sides mccPoreH17_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13902 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH18' [121]. */
#define mccompcurname  PoreH18
#define mccompcurtype  Pore_h_group
#define mccompcurindex 121
#define nLeft mccPoreH18_nLeft
#define nRight mccPoreH18_nRight
#define nExit mccPoreH18_nExit
#define wLeft mccPoreH18_wLeft
#define wRight mccPoreH18_wRight
#define wExit mccPoreH18_wExit
#define wall mccPoreH18_wall
#define nTop mccPoreH18_nTop
#define nBottom mccPoreH18_nBottom
#define zexit mccPoreH18_zexit
#define zentry mccPoreH18_zentry
#define intersect_wolterI mccPoreH18_intersect_wolterI
#define reflec_side_table mccPoreH18_reflec_side_table
#define reflec_top_table mccPoreH18_reflec_top_table
#define reflec_bottom_table mccPoreH18_reflec_bottom_table
#define ref_prms mccPoreH18_ref_prms
#define radius_m mccPoreH18_radius_m
#define radius_h mccPoreH18_radius_h
#define Z0 mccPoreH18_Z0
#define xwidth mccPoreH18_xwidth
#define yheight mccPoreH18_yheight
#define chamferwidth mccPoreH18_chamferwidth
#define mirror_reflec mccPoreH18_mirror_reflec
#define bottom_reflec mccPoreH18_bottom_reflec
#define side_reflec mccPoreH18_side_reflec
#define R_d mccPoreH18_R_d
#define absorb_sides mccPoreH18_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 13978 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH19' [122]. */
#define mccompcurname  PoreH19
#define mccompcurtype  Pore_h_group
#define mccompcurindex 122
#define nLeft mccPoreH19_nLeft
#define nRight mccPoreH19_nRight
#define nExit mccPoreH19_nExit
#define wLeft mccPoreH19_wLeft
#define wRight mccPoreH19_wRight
#define wExit mccPoreH19_wExit
#define wall mccPoreH19_wall
#define nTop mccPoreH19_nTop
#define nBottom mccPoreH19_nBottom
#define zexit mccPoreH19_zexit
#define zentry mccPoreH19_zentry
#define intersect_wolterI mccPoreH19_intersect_wolterI
#define reflec_side_table mccPoreH19_reflec_side_table
#define reflec_top_table mccPoreH19_reflec_top_table
#define reflec_bottom_table mccPoreH19_reflec_bottom_table
#define ref_prms mccPoreH19_ref_prms
#define radius_m mccPoreH19_radius_m
#define radius_h mccPoreH19_radius_h
#define Z0 mccPoreH19_Z0
#define xwidth mccPoreH19_xwidth
#define yheight mccPoreH19_yheight
#define chamferwidth mccPoreH19_chamferwidth
#define mirror_reflec mccPoreH19_mirror_reflec
#define bottom_reflec mccPoreH19_bottom_reflec
#define side_reflec mccPoreH19_side_reflec
#define R_d mccPoreH19_R_d
#define absorb_sides mccPoreH19_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14054 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH20' [123]. */
#define mccompcurname  PoreH20
#define mccompcurtype  Pore_h_group
#define mccompcurindex 123
#define nLeft mccPoreH20_nLeft
#define nRight mccPoreH20_nRight
#define nExit mccPoreH20_nExit
#define wLeft mccPoreH20_wLeft
#define wRight mccPoreH20_wRight
#define wExit mccPoreH20_wExit
#define wall mccPoreH20_wall
#define nTop mccPoreH20_nTop
#define nBottom mccPoreH20_nBottom
#define zexit mccPoreH20_zexit
#define zentry mccPoreH20_zentry
#define intersect_wolterI mccPoreH20_intersect_wolterI
#define reflec_side_table mccPoreH20_reflec_side_table
#define reflec_top_table mccPoreH20_reflec_top_table
#define reflec_bottom_table mccPoreH20_reflec_bottom_table
#define ref_prms mccPoreH20_ref_prms
#define radius_m mccPoreH20_radius_m
#define radius_h mccPoreH20_radius_h
#define Z0 mccPoreH20_Z0
#define xwidth mccPoreH20_xwidth
#define yheight mccPoreH20_yheight
#define chamferwidth mccPoreH20_chamferwidth
#define mirror_reflec mccPoreH20_mirror_reflec
#define bottom_reflec mccPoreH20_bottom_reflec
#define side_reflec mccPoreH20_side_reflec
#define R_d mccPoreH20_R_d
#define absorb_sides mccPoreH20_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14130 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH21' [124]. */
#define mccompcurname  PoreH21
#define mccompcurtype  Pore_h_group
#define mccompcurindex 124
#define nLeft mccPoreH21_nLeft
#define nRight mccPoreH21_nRight
#define nExit mccPoreH21_nExit
#define wLeft mccPoreH21_wLeft
#define wRight mccPoreH21_wRight
#define wExit mccPoreH21_wExit
#define wall mccPoreH21_wall
#define nTop mccPoreH21_nTop
#define nBottom mccPoreH21_nBottom
#define zexit mccPoreH21_zexit
#define zentry mccPoreH21_zentry
#define intersect_wolterI mccPoreH21_intersect_wolterI
#define reflec_side_table mccPoreH21_reflec_side_table
#define reflec_top_table mccPoreH21_reflec_top_table
#define reflec_bottom_table mccPoreH21_reflec_bottom_table
#define ref_prms mccPoreH21_ref_prms
#define radius_m mccPoreH21_radius_m
#define radius_h mccPoreH21_radius_h
#define Z0 mccPoreH21_Z0
#define xwidth mccPoreH21_xwidth
#define yheight mccPoreH21_yheight
#define chamferwidth mccPoreH21_chamferwidth
#define mirror_reflec mccPoreH21_mirror_reflec
#define bottom_reflec mccPoreH21_bottom_reflec
#define side_reflec mccPoreH21_side_reflec
#define R_d mccPoreH21_R_d
#define absorb_sides mccPoreH21_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14206 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH22' [125]. */
#define mccompcurname  PoreH22
#define mccompcurtype  Pore_h_group
#define mccompcurindex 125
#define nLeft mccPoreH22_nLeft
#define nRight mccPoreH22_nRight
#define nExit mccPoreH22_nExit
#define wLeft mccPoreH22_wLeft
#define wRight mccPoreH22_wRight
#define wExit mccPoreH22_wExit
#define wall mccPoreH22_wall
#define nTop mccPoreH22_nTop
#define nBottom mccPoreH22_nBottom
#define zexit mccPoreH22_zexit
#define zentry mccPoreH22_zentry
#define intersect_wolterI mccPoreH22_intersect_wolterI
#define reflec_side_table mccPoreH22_reflec_side_table
#define reflec_top_table mccPoreH22_reflec_top_table
#define reflec_bottom_table mccPoreH22_reflec_bottom_table
#define ref_prms mccPoreH22_ref_prms
#define radius_m mccPoreH22_radius_m
#define radius_h mccPoreH22_radius_h
#define Z0 mccPoreH22_Z0
#define xwidth mccPoreH22_xwidth
#define yheight mccPoreH22_yheight
#define chamferwidth mccPoreH22_chamferwidth
#define mirror_reflec mccPoreH22_mirror_reflec
#define bottom_reflec mccPoreH22_bottom_reflec
#define side_reflec mccPoreH22_side_reflec
#define R_d mccPoreH22_R_d
#define absorb_sides mccPoreH22_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14282 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH23' [126]. */
#define mccompcurname  PoreH23
#define mccompcurtype  Pore_h_group
#define mccompcurindex 126
#define nLeft mccPoreH23_nLeft
#define nRight mccPoreH23_nRight
#define nExit mccPoreH23_nExit
#define wLeft mccPoreH23_wLeft
#define wRight mccPoreH23_wRight
#define wExit mccPoreH23_wExit
#define wall mccPoreH23_wall
#define nTop mccPoreH23_nTop
#define nBottom mccPoreH23_nBottom
#define zexit mccPoreH23_zexit
#define zentry mccPoreH23_zentry
#define intersect_wolterI mccPoreH23_intersect_wolterI
#define reflec_side_table mccPoreH23_reflec_side_table
#define reflec_top_table mccPoreH23_reflec_top_table
#define reflec_bottom_table mccPoreH23_reflec_bottom_table
#define ref_prms mccPoreH23_ref_prms
#define radius_m mccPoreH23_radius_m
#define radius_h mccPoreH23_radius_h
#define Z0 mccPoreH23_Z0
#define xwidth mccPoreH23_xwidth
#define yheight mccPoreH23_yheight
#define chamferwidth mccPoreH23_chamferwidth
#define mirror_reflec mccPoreH23_mirror_reflec
#define bottom_reflec mccPoreH23_bottom_reflec
#define side_reflec mccPoreH23_side_reflec
#define R_d mccPoreH23_R_d
#define absorb_sides mccPoreH23_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14358 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH24' [127]. */
#define mccompcurname  PoreH24
#define mccompcurtype  Pore_h_group
#define mccompcurindex 127
#define nLeft mccPoreH24_nLeft
#define nRight mccPoreH24_nRight
#define nExit mccPoreH24_nExit
#define wLeft mccPoreH24_wLeft
#define wRight mccPoreH24_wRight
#define wExit mccPoreH24_wExit
#define wall mccPoreH24_wall
#define nTop mccPoreH24_nTop
#define nBottom mccPoreH24_nBottom
#define zexit mccPoreH24_zexit
#define zentry mccPoreH24_zentry
#define intersect_wolterI mccPoreH24_intersect_wolterI
#define reflec_side_table mccPoreH24_reflec_side_table
#define reflec_top_table mccPoreH24_reflec_top_table
#define reflec_bottom_table mccPoreH24_reflec_bottom_table
#define ref_prms mccPoreH24_ref_prms
#define radius_m mccPoreH24_radius_m
#define radius_h mccPoreH24_radius_h
#define Z0 mccPoreH24_Z0
#define xwidth mccPoreH24_xwidth
#define yheight mccPoreH24_yheight
#define chamferwidth mccPoreH24_chamferwidth
#define mirror_reflec mccPoreH24_mirror_reflec
#define bottom_reflec mccPoreH24_bottom_reflec
#define side_reflec mccPoreH24_side_reflec
#define R_d mccPoreH24_R_d
#define absorb_sides mccPoreH24_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14434 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH25' [128]. */
#define mccompcurname  PoreH25
#define mccompcurtype  Pore_h_group
#define mccompcurindex 128
#define nLeft mccPoreH25_nLeft
#define nRight mccPoreH25_nRight
#define nExit mccPoreH25_nExit
#define wLeft mccPoreH25_wLeft
#define wRight mccPoreH25_wRight
#define wExit mccPoreH25_wExit
#define wall mccPoreH25_wall
#define nTop mccPoreH25_nTop
#define nBottom mccPoreH25_nBottom
#define zexit mccPoreH25_zexit
#define zentry mccPoreH25_zentry
#define intersect_wolterI mccPoreH25_intersect_wolterI
#define reflec_side_table mccPoreH25_reflec_side_table
#define reflec_top_table mccPoreH25_reflec_top_table
#define reflec_bottom_table mccPoreH25_reflec_bottom_table
#define ref_prms mccPoreH25_ref_prms
#define radius_m mccPoreH25_radius_m
#define radius_h mccPoreH25_radius_h
#define Z0 mccPoreH25_Z0
#define xwidth mccPoreH25_xwidth
#define yheight mccPoreH25_yheight
#define chamferwidth mccPoreH25_chamferwidth
#define mirror_reflec mccPoreH25_mirror_reflec
#define bottom_reflec mccPoreH25_bottom_reflec
#define side_reflec mccPoreH25_side_reflec
#define R_d mccPoreH25_R_d
#define absorb_sides mccPoreH25_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14510 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH26' [129]. */
#define mccompcurname  PoreH26
#define mccompcurtype  Pore_h_group
#define mccompcurindex 129
#define nLeft mccPoreH26_nLeft
#define nRight mccPoreH26_nRight
#define nExit mccPoreH26_nExit
#define wLeft mccPoreH26_wLeft
#define wRight mccPoreH26_wRight
#define wExit mccPoreH26_wExit
#define wall mccPoreH26_wall
#define nTop mccPoreH26_nTop
#define nBottom mccPoreH26_nBottom
#define zexit mccPoreH26_zexit
#define zentry mccPoreH26_zentry
#define intersect_wolterI mccPoreH26_intersect_wolterI
#define reflec_side_table mccPoreH26_reflec_side_table
#define reflec_top_table mccPoreH26_reflec_top_table
#define reflec_bottom_table mccPoreH26_reflec_bottom_table
#define ref_prms mccPoreH26_ref_prms
#define radius_m mccPoreH26_radius_m
#define radius_h mccPoreH26_radius_h
#define Z0 mccPoreH26_Z0
#define xwidth mccPoreH26_xwidth
#define yheight mccPoreH26_yheight
#define chamferwidth mccPoreH26_chamferwidth
#define mirror_reflec mccPoreH26_mirror_reflec
#define bottom_reflec mccPoreH26_bottom_reflec
#define side_reflec mccPoreH26_side_reflec
#define R_d mccPoreH26_R_d
#define absorb_sides mccPoreH26_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14586 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH27' [130]. */
#define mccompcurname  PoreH27
#define mccompcurtype  Pore_h_group
#define mccompcurindex 130
#define nLeft mccPoreH27_nLeft
#define nRight mccPoreH27_nRight
#define nExit mccPoreH27_nExit
#define wLeft mccPoreH27_wLeft
#define wRight mccPoreH27_wRight
#define wExit mccPoreH27_wExit
#define wall mccPoreH27_wall
#define nTop mccPoreH27_nTop
#define nBottom mccPoreH27_nBottom
#define zexit mccPoreH27_zexit
#define zentry mccPoreH27_zentry
#define intersect_wolterI mccPoreH27_intersect_wolterI
#define reflec_side_table mccPoreH27_reflec_side_table
#define reflec_top_table mccPoreH27_reflec_top_table
#define reflec_bottom_table mccPoreH27_reflec_bottom_table
#define ref_prms mccPoreH27_ref_prms
#define radius_m mccPoreH27_radius_m
#define radius_h mccPoreH27_radius_h
#define Z0 mccPoreH27_Z0
#define xwidth mccPoreH27_xwidth
#define yheight mccPoreH27_yheight
#define chamferwidth mccPoreH27_chamferwidth
#define mirror_reflec mccPoreH27_mirror_reflec
#define bottom_reflec mccPoreH27_bottom_reflec
#define side_reflec mccPoreH27_side_reflec
#define R_d mccPoreH27_R_d
#define absorb_sides mccPoreH27_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14662 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH28' [131]. */
#define mccompcurname  PoreH28
#define mccompcurtype  Pore_h_group
#define mccompcurindex 131
#define nLeft mccPoreH28_nLeft
#define nRight mccPoreH28_nRight
#define nExit mccPoreH28_nExit
#define wLeft mccPoreH28_wLeft
#define wRight mccPoreH28_wRight
#define wExit mccPoreH28_wExit
#define wall mccPoreH28_wall
#define nTop mccPoreH28_nTop
#define nBottom mccPoreH28_nBottom
#define zexit mccPoreH28_zexit
#define zentry mccPoreH28_zentry
#define intersect_wolterI mccPoreH28_intersect_wolterI
#define reflec_side_table mccPoreH28_reflec_side_table
#define reflec_top_table mccPoreH28_reflec_top_table
#define reflec_bottom_table mccPoreH28_reflec_bottom_table
#define ref_prms mccPoreH28_ref_prms
#define radius_m mccPoreH28_radius_m
#define radius_h mccPoreH28_radius_h
#define Z0 mccPoreH28_Z0
#define xwidth mccPoreH28_xwidth
#define yheight mccPoreH28_yheight
#define chamferwidth mccPoreH28_chamferwidth
#define mirror_reflec mccPoreH28_mirror_reflec
#define bottom_reflec mccPoreH28_bottom_reflec
#define side_reflec mccPoreH28_side_reflec
#define R_d mccPoreH28_R_d
#define absorb_sides mccPoreH28_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14738 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH29' [132]. */
#define mccompcurname  PoreH29
#define mccompcurtype  Pore_h_group
#define mccompcurindex 132
#define nLeft mccPoreH29_nLeft
#define nRight mccPoreH29_nRight
#define nExit mccPoreH29_nExit
#define wLeft mccPoreH29_wLeft
#define wRight mccPoreH29_wRight
#define wExit mccPoreH29_wExit
#define wall mccPoreH29_wall
#define nTop mccPoreH29_nTop
#define nBottom mccPoreH29_nBottom
#define zexit mccPoreH29_zexit
#define zentry mccPoreH29_zentry
#define intersect_wolterI mccPoreH29_intersect_wolterI
#define reflec_side_table mccPoreH29_reflec_side_table
#define reflec_top_table mccPoreH29_reflec_top_table
#define reflec_bottom_table mccPoreH29_reflec_bottom_table
#define ref_prms mccPoreH29_ref_prms
#define radius_m mccPoreH29_radius_m
#define radius_h mccPoreH29_radius_h
#define Z0 mccPoreH29_Z0
#define xwidth mccPoreH29_xwidth
#define yheight mccPoreH29_yheight
#define chamferwidth mccPoreH29_chamferwidth
#define mirror_reflec mccPoreH29_mirror_reflec
#define bottom_reflec mccPoreH29_bottom_reflec
#define side_reflec mccPoreH29_side_reflec
#define R_d mccPoreH29_R_d
#define absorb_sides mccPoreH29_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14814 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH30' [133]. */
#define mccompcurname  PoreH30
#define mccompcurtype  Pore_h_group
#define mccompcurindex 133
#define nLeft mccPoreH30_nLeft
#define nRight mccPoreH30_nRight
#define nExit mccPoreH30_nExit
#define wLeft mccPoreH30_wLeft
#define wRight mccPoreH30_wRight
#define wExit mccPoreH30_wExit
#define wall mccPoreH30_wall
#define nTop mccPoreH30_nTop
#define nBottom mccPoreH30_nBottom
#define zexit mccPoreH30_zexit
#define zentry mccPoreH30_zentry
#define intersect_wolterI mccPoreH30_intersect_wolterI
#define reflec_side_table mccPoreH30_reflec_side_table
#define reflec_top_table mccPoreH30_reflec_top_table
#define reflec_bottom_table mccPoreH30_reflec_bottom_table
#define ref_prms mccPoreH30_ref_prms
#define radius_m mccPoreH30_radius_m
#define radius_h mccPoreH30_radius_h
#define Z0 mccPoreH30_Z0
#define xwidth mccPoreH30_xwidth
#define yheight mccPoreH30_yheight
#define chamferwidth mccPoreH30_chamferwidth
#define mirror_reflec mccPoreH30_mirror_reflec
#define bottom_reflec mccPoreH30_bottom_reflec
#define side_reflec mccPoreH30_side_reflec
#define R_d mccPoreH30_R_d
#define absorb_sides mccPoreH30_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14890 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH31' [134]. */
#define mccompcurname  PoreH31
#define mccompcurtype  Pore_h_group
#define mccompcurindex 134
#define nLeft mccPoreH31_nLeft
#define nRight mccPoreH31_nRight
#define nExit mccPoreH31_nExit
#define wLeft mccPoreH31_wLeft
#define wRight mccPoreH31_wRight
#define wExit mccPoreH31_wExit
#define wall mccPoreH31_wall
#define nTop mccPoreH31_nTop
#define nBottom mccPoreH31_nBottom
#define zexit mccPoreH31_zexit
#define zentry mccPoreH31_zentry
#define intersect_wolterI mccPoreH31_intersect_wolterI
#define reflec_side_table mccPoreH31_reflec_side_table
#define reflec_top_table mccPoreH31_reflec_top_table
#define reflec_bottom_table mccPoreH31_reflec_bottom_table
#define ref_prms mccPoreH31_ref_prms
#define radius_m mccPoreH31_radius_m
#define radius_h mccPoreH31_radius_h
#define Z0 mccPoreH31_Z0
#define xwidth mccPoreH31_xwidth
#define yheight mccPoreH31_yheight
#define chamferwidth mccPoreH31_chamferwidth
#define mirror_reflec mccPoreH31_mirror_reflec
#define bottom_reflec mccPoreH31_bottom_reflec
#define side_reflec mccPoreH31_side_reflec
#define R_d mccPoreH31_R_d
#define absorb_sides mccPoreH31_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 14966 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH32' [135]. */
#define mccompcurname  PoreH32
#define mccompcurtype  Pore_h_group
#define mccompcurindex 135
#define nLeft mccPoreH32_nLeft
#define nRight mccPoreH32_nRight
#define nExit mccPoreH32_nExit
#define wLeft mccPoreH32_wLeft
#define wRight mccPoreH32_wRight
#define wExit mccPoreH32_wExit
#define wall mccPoreH32_wall
#define nTop mccPoreH32_nTop
#define nBottom mccPoreH32_nBottom
#define zexit mccPoreH32_zexit
#define zentry mccPoreH32_zentry
#define intersect_wolterI mccPoreH32_intersect_wolterI
#define reflec_side_table mccPoreH32_reflec_side_table
#define reflec_top_table mccPoreH32_reflec_top_table
#define reflec_bottom_table mccPoreH32_reflec_bottom_table
#define ref_prms mccPoreH32_ref_prms
#define radius_m mccPoreH32_radius_m
#define radius_h mccPoreH32_radius_h
#define Z0 mccPoreH32_Z0
#define xwidth mccPoreH32_xwidth
#define yheight mccPoreH32_yheight
#define chamferwidth mccPoreH32_chamferwidth
#define mirror_reflec mccPoreH32_mirror_reflec
#define bottom_reflec mccPoreH32_bottom_reflec
#define side_reflec mccPoreH32_side_reflec
#define R_d mccPoreH32_R_d
#define absorb_sides mccPoreH32_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15042 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH33' [136]. */
#define mccompcurname  PoreH33
#define mccompcurtype  Pore_h_group
#define mccompcurindex 136
#define nLeft mccPoreH33_nLeft
#define nRight mccPoreH33_nRight
#define nExit mccPoreH33_nExit
#define wLeft mccPoreH33_wLeft
#define wRight mccPoreH33_wRight
#define wExit mccPoreH33_wExit
#define wall mccPoreH33_wall
#define nTop mccPoreH33_nTop
#define nBottom mccPoreH33_nBottom
#define zexit mccPoreH33_zexit
#define zentry mccPoreH33_zentry
#define intersect_wolterI mccPoreH33_intersect_wolterI
#define reflec_side_table mccPoreH33_reflec_side_table
#define reflec_top_table mccPoreH33_reflec_top_table
#define reflec_bottom_table mccPoreH33_reflec_bottom_table
#define ref_prms mccPoreH33_ref_prms
#define radius_m mccPoreH33_radius_m
#define radius_h mccPoreH33_radius_h
#define Z0 mccPoreH33_Z0
#define xwidth mccPoreH33_xwidth
#define yheight mccPoreH33_yheight
#define chamferwidth mccPoreH33_chamferwidth
#define mirror_reflec mccPoreH33_mirror_reflec
#define bottom_reflec mccPoreH33_bottom_reflec
#define side_reflec mccPoreH33_side_reflec
#define R_d mccPoreH33_R_d
#define absorb_sides mccPoreH33_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15118 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH34' [137]. */
#define mccompcurname  PoreH34
#define mccompcurtype  Pore_h_group
#define mccompcurindex 137
#define nLeft mccPoreH34_nLeft
#define nRight mccPoreH34_nRight
#define nExit mccPoreH34_nExit
#define wLeft mccPoreH34_wLeft
#define wRight mccPoreH34_wRight
#define wExit mccPoreH34_wExit
#define wall mccPoreH34_wall
#define nTop mccPoreH34_nTop
#define nBottom mccPoreH34_nBottom
#define zexit mccPoreH34_zexit
#define zentry mccPoreH34_zentry
#define intersect_wolterI mccPoreH34_intersect_wolterI
#define reflec_side_table mccPoreH34_reflec_side_table
#define reflec_top_table mccPoreH34_reflec_top_table
#define reflec_bottom_table mccPoreH34_reflec_bottom_table
#define ref_prms mccPoreH34_ref_prms
#define radius_m mccPoreH34_radius_m
#define radius_h mccPoreH34_radius_h
#define Z0 mccPoreH34_Z0
#define xwidth mccPoreH34_xwidth
#define yheight mccPoreH34_yheight
#define chamferwidth mccPoreH34_chamferwidth
#define mirror_reflec mccPoreH34_mirror_reflec
#define bottom_reflec mccPoreH34_bottom_reflec
#define side_reflec mccPoreH34_side_reflec
#define R_d mccPoreH34_R_d
#define absorb_sides mccPoreH34_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15194 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH35' [138]. */
#define mccompcurname  PoreH35
#define mccompcurtype  Pore_h_group
#define mccompcurindex 138
#define nLeft mccPoreH35_nLeft
#define nRight mccPoreH35_nRight
#define nExit mccPoreH35_nExit
#define wLeft mccPoreH35_wLeft
#define wRight mccPoreH35_wRight
#define wExit mccPoreH35_wExit
#define wall mccPoreH35_wall
#define nTop mccPoreH35_nTop
#define nBottom mccPoreH35_nBottom
#define zexit mccPoreH35_zexit
#define zentry mccPoreH35_zentry
#define intersect_wolterI mccPoreH35_intersect_wolterI
#define reflec_side_table mccPoreH35_reflec_side_table
#define reflec_top_table mccPoreH35_reflec_top_table
#define reflec_bottom_table mccPoreH35_reflec_bottom_table
#define ref_prms mccPoreH35_ref_prms
#define radius_m mccPoreH35_radius_m
#define radius_h mccPoreH35_radius_h
#define Z0 mccPoreH35_Z0
#define xwidth mccPoreH35_xwidth
#define yheight mccPoreH35_yheight
#define chamferwidth mccPoreH35_chamferwidth
#define mirror_reflec mccPoreH35_mirror_reflec
#define bottom_reflec mccPoreH35_bottom_reflec
#define side_reflec mccPoreH35_side_reflec
#define R_d mccPoreH35_R_d
#define absorb_sides mccPoreH35_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15270 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH36' [139]. */
#define mccompcurname  PoreH36
#define mccompcurtype  Pore_h_group
#define mccompcurindex 139
#define nLeft mccPoreH36_nLeft
#define nRight mccPoreH36_nRight
#define nExit mccPoreH36_nExit
#define wLeft mccPoreH36_wLeft
#define wRight mccPoreH36_wRight
#define wExit mccPoreH36_wExit
#define wall mccPoreH36_wall
#define nTop mccPoreH36_nTop
#define nBottom mccPoreH36_nBottom
#define zexit mccPoreH36_zexit
#define zentry mccPoreH36_zentry
#define intersect_wolterI mccPoreH36_intersect_wolterI
#define reflec_side_table mccPoreH36_reflec_side_table
#define reflec_top_table mccPoreH36_reflec_top_table
#define reflec_bottom_table mccPoreH36_reflec_bottom_table
#define ref_prms mccPoreH36_ref_prms
#define radius_m mccPoreH36_radius_m
#define radius_h mccPoreH36_radius_h
#define Z0 mccPoreH36_Z0
#define xwidth mccPoreH36_xwidth
#define yheight mccPoreH36_yheight
#define chamferwidth mccPoreH36_chamferwidth
#define mirror_reflec mccPoreH36_mirror_reflec
#define bottom_reflec mccPoreH36_bottom_reflec
#define side_reflec mccPoreH36_side_reflec
#define R_d mccPoreH36_R_d
#define absorb_sides mccPoreH36_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15346 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH37' [140]. */
#define mccompcurname  PoreH37
#define mccompcurtype  Pore_h_group
#define mccompcurindex 140
#define nLeft mccPoreH37_nLeft
#define nRight mccPoreH37_nRight
#define nExit mccPoreH37_nExit
#define wLeft mccPoreH37_wLeft
#define wRight mccPoreH37_wRight
#define wExit mccPoreH37_wExit
#define wall mccPoreH37_wall
#define nTop mccPoreH37_nTop
#define nBottom mccPoreH37_nBottom
#define zexit mccPoreH37_zexit
#define zentry mccPoreH37_zentry
#define intersect_wolterI mccPoreH37_intersect_wolterI
#define reflec_side_table mccPoreH37_reflec_side_table
#define reflec_top_table mccPoreH37_reflec_top_table
#define reflec_bottom_table mccPoreH37_reflec_bottom_table
#define ref_prms mccPoreH37_ref_prms
#define radius_m mccPoreH37_radius_m
#define radius_h mccPoreH37_radius_h
#define Z0 mccPoreH37_Z0
#define xwidth mccPoreH37_xwidth
#define yheight mccPoreH37_yheight
#define chamferwidth mccPoreH37_chamferwidth
#define mirror_reflec mccPoreH37_mirror_reflec
#define bottom_reflec mccPoreH37_bottom_reflec
#define side_reflec mccPoreH37_side_reflec
#define R_d mccPoreH37_R_d
#define absorb_sides mccPoreH37_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15422 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH38' [141]. */
#define mccompcurname  PoreH38
#define mccompcurtype  Pore_h_group
#define mccompcurindex 141
#define nLeft mccPoreH38_nLeft
#define nRight mccPoreH38_nRight
#define nExit mccPoreH38_nExit
#define wLeft mccPoreH38_wLeft
#define wRight mccPoreH38_wRight
#define wExit mccPoreH38_wExit
#define wall mccPoreH38_wall
#define nTop mccPoreH38_nTop
#define nBottom mccPoreH38_nBottom
#define zexit mccPoreH38_zexit
#define zentry mccPoreH38_zentry
#define intersect_wolterI mccPoreH38_intersect_wolterI
#define reflec_side_table mccPoreH38_reflec_side_table
#define reflec_top_table mccPoreH38_reflec_top_table
#define reflec_bottom_table mccPoreH38_reflec_bottom_table
#define ref_prms mccPoreH38_ref_prms
#define radius_m mccPoreH38_radius_m
#define radius_h mccPoreH38_radius_h
#define Z0 mccPoreH38_Z0
#define xwidth mccPoreH38_xwidth
#define yheight mccPoreH38_yheight
#define chamferwidth mccPoreH38_chamferwidth
#define mirror_reflec mccPoreH38_mirror_reflec
#define bottom_reflec mccPoreH38_bottom_reflec
#define side_reflec mccPoreH38_side_reflec
#define R_d mccPoreH38_R_d
#define absorb_sides mccPoreH38_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15498 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH39' [142]. */
#define mccompcurname  PoreH39
#define mccompcurtype  Pore_h_group
#define mccompcurindex 142
#define nLeft mccPoreH39_nLeft
#define nRight mccPoreH39_nRight
#define nExit mccPoreH39_nExit
#define wLeft mccPoreH39_wLeft
#define wRight mccPoreH39_wRight
#define wExit mccPoreH39_wExit
#define wall mccPoreH39_wall
#define nTop mccPoreH39_nTop
#define nBottom mccPoreH39_nBottom
#define zexit mccPoreH39_zexit
#define zentry mccPoreH39_zentry
#define intersect_wolterI mccPoreH39_intersect_wolterI
#define reflec_side_table mccPoreH39_reflec_side_table
#define reflec_top_table mccPoreH39_reflec_top_table
#define reflec_bottom_table mccPoreH39_reflec_bottom_table
#define ref_prms mccPoreH39_ref_prms
#define radius_m mccPoreH39_radius_m
#define radius_h mccPoreH39_radius_h
#define Z0 mccPoreH39_Z0
#define xwidth mccPoreH39_xwidth
#define yheight mccPoreH39_yheight
#define chamferwidth mccPoreH39_chamferwidth
#define mirror_reflec mccPoreH39_mirror_reflec
#define bottom_reflec mccPoreH39_bottom_reflec
#define side_reflec mccPoreH39_side_reflec
#define R_d mccPoreH39_R_d
#define absorb_sides mccPoreH39_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15574 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH40' [143]. */
#define mccompcurname  PoreH40
#define mccompcurtype  Pore_h_group
#define mccompcurindex 143
#define nLeft mccPoreH40_nLeft
#define nRight mccPoreH40_nRight
#define nExit mccPoreH40_nExit
#define wLeft mccPoreH40_wLeft
#define wRight mccPoreH40_wRight
#define wExit mccPoreH40_wExit
#define wall mccPoreH40_wall
#define nTop mccPoreH40_nTop
#define nBottom mccPoreH40_nBottom
#define zexit mccPoreH40_zexit
#define zentry mccPoreH40_zentry
#define intersect_wolterI mccPoreH40_intersect_wolterI
#define reflec_side_table mccPoreH40_reflec_side_table
#define reflec_top_table mccPoreH40_reflec_top_table
#define reflec_bottom_table mccPoreH40_reflec_bottom_table
#define ref_prms mccPoreH40_ref_prms
#define radius_m mccPoreH40_radius_m
#define radius_h mccPoreH40_radius_h
#define Z0 mccPoreH40_Z0
#define xwidth mccPoreH40_xwidth
#define yheight mccPoreH40_yheight
#define chamferwidth mccPoreH40_chamferwidth
#define mirror_reflec mccPoreH40_mirror_reflec
#define bottom_reflec mccPoreH40_bottom_reflec
#define side_reflec mccPoreH40_side_reflec
#define R_d mccPoreH40_R_d
#define absorb_sides mccPoreH40_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15650 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH41' [144]. */
#define mccompcurname  PoreH41
#define mccompcurtype  Pore_h_group
#define mccompcurindex 144
#define nLeft mccPoreH41_nLeft
#define nRight mccPoreH41_nRight
#define nExit mccPoreH41_nExit
#define wLeft mccPoreH41_wLeft
#define wRight mccPoreH41_wRight
#define wExit mccPoreH41_wExit
#define wall mccPoreH41_wall
#define nTop mccPoreH41_nTop
#define nBottom mccPoreH41_nBottom
#define zexit mccPoreH41_zexit
#define zentry mccPoreH41_zentry
#define intersect_wolterI mccPoreH41_intersect_wolterI
#define reflec_side_table mccPoreH41_reflec_side_table
#define reflec_top_table mccPoreH41_reflec_top_table
#define reflec_bottom_table mccPoreH41_reflec_bottom_table
#define ref_prms mccPoreH41_ref_prms
#define radius_m mccPoreH41_radius_m
#define radius_h mccPoreH41_radius_h
#define Z0 mccPoreH41_Z0
#define xwidth mccPoreH41_xwidth
#define yheight mccPoreH41_yheight
#define chamferwidth mccPoreH41_chamferwidth
#define mirror_reflec mccPoreH41_mirror_reflec
#define bottom_reflec mccPoreH41_bottom_reflec
#define side_reflec mccPoreH41_side_reflec
#define R_d mccPoreH41_R_d
#define absorb_sides mccPoreH41_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15726 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH42' [145]. */
#define mccompcurname  PoreH42
#define mccompcurtype  Pore_h_group
#define mccompcurindex 145
#define nLeft mccPoreH42_nLeft
#define nRight mccPoreH42_nRight
#define nExit mccPoreH42_nExit
#define wLeft mccPoreH42_wLeft
#define wRight mccPoreH42_wRight
#define wExit mccPoreH42_wExit
#define wall mccPoreH42_wall
#define nTop mccPoreH42_nTop
#define nBottom mccPoreH42_nBottom
#define zexit mccPoreH42_zexit
#define zentry mccPoreH42_zentry
#define intersect_wolterI mccPoreH42_intersect_wolterI
#define reflec_side_table mccPoreH42_reflec_side_table
#define reflec_top_table mccPoreH42_reflec_top_table
#define reflec_bottom_table mccPoreH42_reflec_bottom_table
#define ref_prms mccPoreH42_ref_prms
#define radius_m mccPoreH42_radius_m
#define radius_h mccPoreH42_radius_h
#define Z0 mccPoreH42_Z0
#define xwidth mccPoreH42_xwidth
#define yheight mccPoreH42_yheight
#define chamferwidth mccPoreH42_chamferwidth
#define mirror_reflec mccPoreH42_mirror_reflec
#define bottom_reflec mccPoreH42_bottom_reflec
#define side_reflec mccPoreH42_side_reflec
#define R_d mccPoreH42_R_d
#define absorb_sides mccPoreH42_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15802 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH43' [146]. */
#define mccompcurname  PoreH43
#define mccompcurtype  Pore_h_group
#define mccompcurindex 146
#define nLeft mccPoreH43_nLeft
#define nRight mccPoreH43_nRight
#define nExit mccPoreH43_nExit
#define wLeft mccPoreH43_wLeft
#define wRight mccPoreH43_wRight
#define wExit mccPoreH43_wExit
#define wall mccPoreH43_wall
#define nTop mccPoreH43_nTop
#define nBottom mccPoreH43_nBottom
#define zexit mccPoreH43_zexit
#define zentry mccPoreH43_zentry
#define intersect_wolterI mccPoreH43_intersect_wolterI
#define reflec_side_table mccPoreH43_reflec_side_table
#define reflec_top_table mccPoreH43_reflec_top_table
#define reflec_bottom_table mccPoreH43_reflec_bottom_table
#define ref_prms mccPoreH43_ref_prms
#define radius_m mccPoreH43_radius_m
#define radius_h mccPoreH43_radius_h
#define Z0 mccPoreH43_Z0
#define xwidth mccPoreH43_xwidth
#define yheight mccPoreH43_yheight
#define chamferwidth mccPoreH43_chamferwidth
#define mirror_reflec mccPoreH43_mirror_reflec
#define bottom_reflec mccPoreH43_bottom_reflec
#define side_reflec mccPoreH43_side_reflec
#define R_d mccPoreH43_R_d
#define absorb_sides mccPoreH43_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15878 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH44' [147]. */
#define mccompcurname  PoreH44
#define mccompcurtype  Pore_h_group
#define mccompcurindex 147
#define nLeft mccPoreH44_nLeft
#define nRight mccPoreH44_nRight
#define nExit mccPoreH44_nExit
#define wLeft mccPoreH44_wLeft
#define wRight mccPoreH44_wRight
#define wExit mccPoreH44_wExit
#define wall mccPoreH44_wall
#define nTop mccPoreH44_nTop
#define nBottom mccPoreH44_nBottom
#define zexit mccPoreH44_zexit
#define zentry mccPoreH44_zentry
#define intersect_wolterI mccPoreH44_intersect_wolterI
#define reflec_side_table mccPoreH44_reflec_side_table
#define reflec_top_table mccPoreH44_reflec_top_table
#define reflec_bottom_table mccPoreH44_reflec_bottom_table
#define ref_prms mccPoreH44_ref_prms
#define radius_m mccPoreH44_radius_m
#define radius_h mccPoreH44_radius_h
#define Z0 mccPoreH44_Z0
#define xwidth mccPoreH44_xwidth
#define yheight mccPoreH44_yheight
#define chamferwidth mccPoreH44_chamferwidth
#define mirror_reflec mccPoreH44_mirror_reflec
#define bottom_reflec mccPoreH44_bottom_reflec
#define side_reflec mccPoreH44_side_reflec
#define R_d mccPoreH44_R_d
#define absorb_sides mccPoreH44_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 15954 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH45' [148]. */
#define mccompcurname  PoreH45
#define mccompcurtype  Pore_h_group
#define mccompcurindex 148
#define nLeft mccPoreH45_nLeft
#define nRight mccPoreH45_nRight
#define nExit mccPoreH45_nExit
#define wLeft mccPoreH45_wLeft
#define wRight mccPoreH45_wRight
#define wExit mccPoreH45_wExit
#define wall mccPoreH45_wall
#define nTop mccPoreH45_nTop
#define nBottom mccPoreH45_nBottom
#define zexit mccPoreH45_zexit
#define zentry mccPoreH45_zentry
#define intersect_wolterI mccPoreH45_intersect_wolterI
#define reflec_side_table mccPoreH45_reflec_side_table
#define reflec_top_table mccPoreH45_reflec_top_table
#define reflec_bottom_table mccPoreH45_reflec_bottom_table
#define ref_prms mccPoreH45_ref_prms
#define radius_m mccPoreH45_radius_m
#define radius_h mccPoreH45_radius_h
#define Z0 mccPoreH45_Z0
#define xwidth mccPoreH45_xwidth
#define yheight mccPoreH45_yheight
#define chamferwidth mccPoreH45_chamferwidth
#define mirror_reflec mccPoreH45_mirror_reflec
#define bottom_reflec mccPoreH45_bottom_reflec
#define side_reflec mccPoreH45_side_reflec
#define R_d mccPoreH45_R_d
#define absorb_sides mccPoreH45_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 16030 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH46' [149]. */
#define mccompcurname  PoreH46
#define mccompcurtype  Pore_h_group
#define mccompcurindex 149
#define nLeft mccPoreH46_nLeft
#define nRight mccPoreH46_nRight
#define nExit mccPoreH46_nExit
#define wLeft mccPoreH46_wLeft
#define wRight mccPoreH46_wRight
#define wExit mccPoreH46_wExit
#define wall mccPoreH46_wall
#define nTop mccPoreH46_nTop
#define nBottom mccPoreH46_nBottom
#define zexit mccPoreH46_zexit
#define zentry mccPoreH46_zentry
#define intersect_wolterI mccPoreH46_intersect_wolterI
#define reflec_side_table mccPoreH46_reflec_side_table
#define reflec_top_table mccPoreH46_reflec_top_table
#define reflec_bottom_table mccPoreH46_reflec_bottom_table
#define ref_prms mccPoreH46_ref_prms
#define radius_m mccPoreH46_radius_m
#define radius_h mccPoreH46_radius_h
#define Z0 mccPoreH46_Z0
#define xwidth mccPoreH46_xwidth
#define yheight mccPoreH46_yheight
#define chamferwidth mccPoreH46_chamferwidth
#define mirror_reflec mccPoreH46_mirror_reflec
#define bottom_reflec mccPoreH46_bottom_reflec
#define side_reflec mccPoreH46_side_reflec
#define R_d mccPoreH46_R_d
#define absorb_sides mccPoreH46_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 16106 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH47' [150]. */
#define mccompcurname  PoreH47
#define mccompcurtype  Pore_h_group
#define mccompcurindex 150
#define nLeft mccPoreH47_nLeft
#define nRight mccPoreH47_nRight
#define nExit mccPoreH47_nExit
#define wLeft mccPoreH47_wLeft
#define wRight mccPoreH47_wRight
#define wExit mccPoreH47_wExit
#define wall mccPoreH47_wall
#define nTop mccPoreH47_nTop
#define nBottom mccPoreH47_nBottom
#define zexit mccPoreH47_zexit
#define zentry mccPoreH47_zentry
#define intersect_wolterI mccPoreH47_intersect_wolterI
#define reflec_side_table mccPoreH47_reflec_side_table
#define reflec_top_table mccPoreH47_reflec_top_table
#define reflec_bottom_table mccPoreH47_reflec_bottom_table
#define ref_prms mccPoreH47_ref_prms
#define radius_m mccPoreH47_radius_m
#define radius_h mccPoreH47_radius_h
#define Z0 mccPoreH47_Z0
#define xwidth mccPoreH47_xwidth
#define yheight mccPoreH47_yheight
#define chamferwidth mccPoreH47_chamferwidth
#define mirror_reflec mccPoreH47_mirror_reflec
#define bottom_reflec mccPoreH47_bottom_reflec
#define side_reflec mccPoreH47_side_reflec
#define R_d mccPoreH47_R_d
#define absorb_sides mccPoreH47_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 16182 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PoreH48' [151]. */
#define mccompcurname  PoreH48
#define mccompcurtype  Pore_h_group
#define mccompcurindex 151
#define nLeft mccPoreH48_nLeft
#define nRight mccPoreH48_nRight
#define nExit mccPoreH48_nExit
#define wLeft mccPoreH48_wLeft
#define wRight mccPoreH48_wRight
#define wExit mccPoreH48_wExit
#define wall mccPoreH48_wall
#define nTop mccPoreH48_nTop
#define nBottom mccPoreH48_nBottom
#define zexit mccPoreH48_zexit
#define zentry mccPoreH48_zentry
#define intersect_wolterI mccPoreH48_intersect_wolterI
#define reflec_side_table mccPoreH48_reflec_side_table
#define reflec_top_table mccPoreH48_reflec_top_table
#define reflec_bottom_table mccPoreH48_reflec_bottom_table
#define ref_prms mccPoreH48_ref_prms
#define radius_m mccPoreH48_radius_m
#define radius_h mccPoreH48_radius_h
#define Z0 mccPoreH48_Z0
#define xwidth mccPoreH48_xwidth
#define yheight mccPoreH48_yheight
#define chamferwidth mccPoreH48_chamferwidth
#define mirror_reflec mccPoreH48_mirror_reflec
#define bottom_reflec mccPoreH48_bottom_reflec
#define side_reflec mccPoreH48_side_reflec
#define R_d mccPoreH48_R_d
#define absorb_sides mccPoreH48_absorb_sides
#line 112 "Pore_h_group.comp"
    double nLeft[3],wLeft[3];
    double nRight[3], wRight[3];
    double nExit[3], wExit[3];
    double nEntry[3], wEntry[3];
    double nTop[3],nBottom[3];
    double zexit;
    struct {double e_min,e_step,e_max,theta_min,theta_step,theta_max;} ref_prms[3];

    //int (*intersect_wolterI) (*double, double, double, double,  double, double, double,  double, double, *double, *double,*double);

    t_Table reflec_side_table,reflec_top_table,reflec_bottom_table;

#line 16258 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monitorAfter' [152]. */
#define mccompcurname  monitorAfter
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 152
#define nx mccmonitorAfter_nx
#define ny mccmonitorAfter_ny
#define nr mccmonitorAfter_nr
#define filename mccmonitorAfter_filename
#define restore_xray mccmonitorAfter_restore_xray
#define PSD_N mccmonitorAfter_PSD_N
#define PSD_p mccmonitorAfter_PSD_p
#define PSD_p2 mccmonitorAfter_PSD_p2
#define posx mccmonitorAfter_posx
#define posy mccmonitorAfter_posy
#define xmin mccmonitorAfter_xmin
#define xmax mccmonitorAfter_xmax
#define ymin mccmonitorAfter_ymin
#define ymax mccmonitorAfter_ymax
#define xwidth mccmonitorAfter_xwidth
#define yheight mccmonitorAfter_yheight
#define radius mccmonitorAfter_radius
#line 62 "PSD_monitor_ext.comp"
    double **PSD_N;
    double **PSD_p;
    double **PSD_p2;
    double posx;
    double posy;
#line 16317 "instruments/plate49.c"
#undef radius
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'endMonitorWide' [153]. */
#define mccompcurname  endMonitorWide
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 153
#define nx mccendMonitorWide_nx
#define ny mccendMonitorWide_ny
#define nr mccendMonitorWide_nr
#define filename mccendMonitorWide_filename
#define restore_xray mccendMonitorWide_restore_xray
#define PSD_N mccendMonitorWide_PSD_N
#define PSD_p mccendMonitorWide_PSD_p
#define PSD_p2 mccendMonitorWide_PSD_p2
#define posx mccendMonitorWide_posx
#define posy mccendMonitorWide_posy
#define xmin mccendMonitorWide_xmin
#define xmax mccendMonitorWide_xmax
#define ymin mccendMonitorWide_ymin
#define ymax mccendMonitorWide_ymax
#define xwidth mccendMonitorWide_xwidth
#define yheight mccendMonitorWide_yheight
#define radius mccendMonitorWide_radius
#line 62 "PSD_monitor_ext.comp"
    double **PSD_N;
    double **PSD_p;
    double **PSD_p2;
    double posx;
    double posy;
#line 16366 "instruments/plate49.c"
#undef radius
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

Coords mcposaorigin, mcposrorigin;
Rotation mcrotaorigin, mcrotrorigin;
Coords mcposaThetaArm, mcposrThetaArm;
Rotation mcrotaThetaArm, mcrotrThetaArm;
Coords mcposasrcDirectional, mcposrsrcDirectional;
Rotation mcrotasrcDirectional, mcrotrsrcDirectional;
Coords mcposasrcDirectionalWide, mcposrsrcDirectionalWide;
Rotation mcrotasrcDirectionalWide, mcrotrsrcDirectionalWide;
Coords mcposaPoreArm0, mcposrPoreArm0;
Rotation mcrotaPoreArm0, mcrotrPoreArm0;
Coords mcposaPoreArm1, mcposrPoreArm1;
Rotation mcrotaPoreArm1, mcrotrPoreArm1;
Coords mcposaPoreArm2, mcposrPoreArm2;
Rotation mcrotaPoreArm2, mcrotrPoreArm2;
Coords mcposaPoreArm3, mcposrPoreArm3;
Rotation mcrotaPoreArm3, mcrotrPoreArm3;
Coords mcposaPoreArm4, mcposrPoreArm4;
Rotation mcrotaPoreArm4, mcrotrPoreArm4;
Coords mcposaPoreArm5, mcposrPoreArm5;
Rotation mcrotaPoreArm5, mcrotrPoreArm5;
Coords mcposaPoreArm6, mcposrPoreArm6;
Rotation mcrotaPoreArm6, mcrotrPoreArm6;
Coords mcposaPoreArm7, mcposrPoreArm7;
Rotation mcrotaPoreArm7, mcrotrPoreArm7;
Coords mcposaPoreArm8, mcposrPoreArm8;
Rotation mcrotaPoreArm8, mcrotrPoreArm8;
Coords mcposaPoreArm9, mcposrPoreArm9;
Rotation mcrotaPoreArm9, mcrotrPoreArm9;
Coords mcposaPoreArm10, mcposrPoreArm10;
Rotation mcrotaPoreArm10, mcrotrPoreArm10;
Coords mcposaPoreArm11, mcposrPoreArm11;
Rotation mcrotaPoreArm11, mcrotrPoreArm11;
Coords mcposaPoreArm12, mcposrPoreArm12;
Rotation mcrotaPoreArm12, mcrotrPoreArm12;
Coords mcposaPoreArm13, mcposrPoreArm13;
Rotation mcrotaPoreArm13, mcrotrPoreArm13;
Coords mcposaPoreArm14, mcposrPoreArm14;
Rotation mcrotaPoreArm14, mcrotrPoreArm14;
Coords mcposaPoreArm15, mcposrPoreArm15;
Rotation mcrotaPoreArm15, mcrotrPoreArm15;
Coords mcposaPoreArm16, mcposrPoreArm16;
Rotation mcrotaPoreArm16, mcrotrPoreArm16;
Coords mcposaPoreArm17, mcposrPoreArm17;
Rotation mcrotaPoreArm17, mcrotrPoreArm17;
Coords mcposaPoreArm18, mcposrPoreArm18;
Rotation mcrotaPoreArm18, mcrotrPoreArm18;
Coords mcposaPoreArm19, mcposrPoreArm19;
Rotation mcrotaPoreArm19, mcrotrPoreArm19;
Coords mcposaPoreArm20, mcposrPoreArm20;
Rotation mcrotaPoreArm20, mcrotrPoreArm20;
Coords mcposaPoreArm21, mcposrPoreArm21;
Rotation mcrotaPoreArm21, mcrotrPoreArm21;
Coords mcposaPoreArm22, mcposrPoreArm22;
Rotation mcrotaPoreArm22, mcrotrPoreArm22;
Coords mcposaPoreArm23, mcposrPoreArm23;
Rotation mcrotaPoreArm23, mcrotrPoreArm23;
Coords mcposaPoreArm24, mcposrPoreArm24;
Rotation mcrotaPoreArm24, mcrotrPoreArm24;
Coords mcposaPoreArm25, mcposrPoreArm25;
Rotation mcrotaPoreArm25, mcrotrPoreArm25;
Coords mcposaPoreArm26, mcposrPoreArm26;
Rotation mcrotaPoreArm26, mcrotrPoreArm26;
Coords mcposaPoreArm27, mcposrPoreArm27;
Rotation mcrotaPoreArm27, mcrotrPoreArm27;
Coords mcposaPoreArm28, mcposrPoreArm28;
Rotation mcrotaPoreArm28, mcrotrPoreArm28;
Coords mcposaPoreArm29, mcposrPoreArm29;
Rotation mcrotaPoreArm29, mcrotrPoreArm29;
Coords mcposaPoreArm30, mcposrPoreArm30;
Rotation mcrotaPoreArm30, mcrotrPoreArm30;
Coords mcposaPoreArm31, mcposrPoreArm31;
Rotation mcrotaPoreArm31, mcrotrPoreArm31;
Coords mcposaPoreArm32, mcposrPoreArm32;
Rotation mcrotaPoreArm32, mcrotrPoreArm32;
Coords mcposaPoreArm33, mcposrPoreArm33;
Rotation mcrotaPoreArm33, mcrotrPoreArm33;
Coords mcposaPoreArm34, mcposrPoreArm34;
Rotation mcrotaPoreArm34, mcrotrPoreArm34;
Coords mcposaPoreArm35, mcposrPoreArm35;
Rotation mcrotaPoreArm35, mcrotrPoreArm35;
Coords mcposaPoreArm36, mcposrPoreArm36;
Rotation mcrotaPoreArm36, mcrotrPoreArm36;
Coords mcposaPoreArm37, mcposrPoreArm37;
Rotation mcrotaPoreArm37, mcrotrPoreArm37;
Coords mcposaPoreArm38, mcposrPoreArm38;
Rotation mcrotaPoreArm38, mcrotrPoreArm38;
Coords mcposaPoreArm39, mcposrPoreArm39;
Rotation mcrotaPoreArm39, mcrotrPoreArm39;
Coords mcposaPoreArm40, mcposrPoreArm40;
Rotation mcrotaPoreArm40, mcrotrPoreArm40;
Coords mcposaPoreArm41, mcposrPoreArm41;
Rotation mcrotaPoreArm41, mcrotrPoreArm41;
Coords mcposaPoreArm42, mcposrPoreArm42;
Rotation mcrotaPoreArm42, mcrotrPoreArm42;
Coords mcposaPoreArm43, mcposrPoreArm43;
Rotation mcrotaPoreArm43, mcrotrPoreArm43;
Coords mcposaPoreArm44, mcposrPoreArm44;
Rotation mcrotaPoreArm44, mcrotrPoreArm44;
Coords mcposaPoreArm45, mcposrPoreArm45;
Rotation mcrotaPoreArm45, mcrotrPoreArm45;
Coords mcposaPoreArm46, mcposrPoreArm46;
Rotation mcrotaPoreArm46, mcrotrPoreArm46;
Coords mcposaPoreArm47, mcposrPoreArm47;
Rotation mcrotaPoreArm47, mcrotrPoreArm47;
Coords mcposaPoreArm48, mcposrPoreArm48;
Rotation mcrotaPoreArm48, mcrotrPoreArm48;
Coords mcposaPoreP0, mcposrPoreP0;
Rotation mcrotaPoreP0, mcrotrPoreP0;
Coords mcposaPoreP1, mcposrPoreP1;
Rotation mcrotaPoreP1, mcrotrPoreP1;
Coords mcposaPoreP2, mcposrPoreP2;
Rotation mcrotaPoreP2, mcrotrPoreP2;
Coords mcposaPoreP3, mcposrPoreP3;
Rotation mcrotaPoreP3, mcrotrPoreP3;
Coords mcposaPoreP4, mcposrPoreP4;
Rotation mcrotaPoreP4, mcrotrPoreP4;
Coords mcposaPoreP5, mcposrPoreP5;
Rotation mcrotaPoreP5, mcrotrPoreP5;
Coords mcposaPoreP6, mcposrPoreP6;
Rotation mcrotaPoreP6, mcrotrPoreP6;
Coords mcposaPoreP7, mcposrPoreP7;
Rotation mcrotaPoreP7, mcrotrPoreP7;
Coords mcposaPoreP8, mcposrPoreP8;
Rotation mcrotaPoreP8, mcrotrPoreP8;
Coords mcposaPoreP9, mcposrPoreP9;
Rotation mcrotaPoreP9, mcrotrPoreP9;
Coords mcposaPoreP10, mcposrPoreP10;
Rotation mcrotaPoreP10, mcrotrPoreP10;
Coords mcposaPoreP11, mcposrPoreP11;
Rotation mcrotaPoreP11, mcrotrPoreP11;
Coords mcposaPoreP12, mcposrPoreP12;
Rotation mcrotaPoreP12, mcrotrPoreP12;
Coords mcposaPoreP13, mcposrPoreP13;
Rotation mcrotaPoreP13, mcrotrPoreP13;
Coords mcposaPoreP14, mcposrPoreP14;
Rotation mcrotaPoreP14, mcrotrPoreP14;
Coords mcposaPoreP15, mcposrPoreP15;
Rotation mcrotaPoreP15, mcrotrPoreP15;
Coords mcposaPoreP16, mcposrPoreP16;
Rotation mcrotaPoreP16, mcrotrPoreP16;
Coords mcposaPoreP17, mcposrPoreP17;
Rotation mcrotaPoreP17, mcrotrPoreP17;
Coords mcposaPoreP18, mcposrPoreP18;
Rotation mcrotaPoreP18, mcrotrPoreP18;
Coords mcposaPoreP19, mcposrPoreP19;
Rotation mcrotaPoreP19, mcrotrPoreP19;
Coords mcposaPoreP20, mcposrPoreP20;
Rotation mcrotaPoreP20, mcrotrPoreP20;
Coords mcposaPoreP21, mcposrPoreP21;
Rotation mcrotaPoreP21, mcrotrPoreP21;
Coords mcposaPoreP22, mcposrPoreP22;
Rotation mcrotaPoreP22, mcrotrPoreP22;
Coords mcposaPoreP23, mcposrPoreP23;
Rotation mcrotaPoreP23, mcrotrPoreP23;
Coords mcposaPoreP24, mcposrPoreP24;
Rotation mcrotaPoreP24, mcrotrPoreP24;
Coords mcposaPoreP25, mcposrPoreP25;
Rotation mcrotaPoreP25, mcrotrPoreP25;
Coords mcposaPoreP26, mcposrPoreP26;
Rotation mcrotaPoreP26, mcrotrPoreP26;
Coords mcposaPoreP27, mcposrPoreP27;
Rotation mcrotaPoreP27, mcrotrPoreP27;
Coords mcposaPoreP28, mcposrPoreP28;
Rotation mcrotaPoreP28, mcrotrPoreP28;
Coords mcposaPoreP29, mcposrPoreP29;
Rotation mcrotaPoreP29, mcrotrPoreP29;
Coords mcposaPoreP30, mcposrPoreP30;
Rotation mcrotaPoreP30, mcrotrPoreP30;
Coords mcposaPoreP31, mcposrPoreP31;
Rotation mcrotaPoreP31, mcrotrPoreP31;
Coords mcposaPoreP32, mcposrPoreP32;
Rotation mcrotaPoreP32, mcrotrPoreP32;
Coords mcposaPoreP33, mcposrPoreP33;
Rotation mcrotaPoreP33, mcrotrPoreP33;
Coords mcposaPoreP34, mcposrPoreP34;
Rotation mcrotaPoreP34, mcrotrPoreP34;
Coords mcposaPoreP35, mcposrPoreP35;
Rotation mcrotaPoreP35, mcrotrPoreP35;
Coords mcposaPoreP36, mcposrPoreP36;
Rotation mcrotaPoreP36, mcrotrPoreP36;
Coords mcposaPoreP37, mcposrPoreP37;
Rotation mcrotaPoreP37, mcrotrPoreP37;
Coords mcposaPoreP38, mcposrPoreP38;
Rotation mcrotaPoreP38, mcrotrPoreP38;
Coords mcposaPoreP39, mcposrPoreP39;
Rotation mcrotaPoreP39, mcrotrPoreP39;
Coords mcposaPoreP40, mcposrPoreP40;
Rotation mcrotaPoreP40, mcrotrPoreP40;
Coords mcposaPoreP41, mcposrPoreP41;
Rotation mcrotaPoreP41, mcrotrPoreP41;
Coords mcposaPoreP42, mcposrPoreP42;
Rotation mcrotaPoreP42, mcrotrPoreP42;
Coords mcposaPoreP43, mcposrPoreP43;
Rotation mcrotaPoreP43, mcrotrPoreP43;
Coords mcposaPoreP44, mcposrPoreP44;
Rotation mcrotaPoreP44, mcrotrPoreP44;
Coords mcposaPoreP45, mcposrPoreP45;
Rotation mcrotaPoreP45, mcrotrPoreP45;
Coords mcposaPoreP46, mcposrPoreP46;
Rotation mcrotaPoreP46, mcrotrPoreP46;
Coords mcposaPoreP47, mcposrPoreP47;
Rotation mcrotaPoreP47, mcrotrPoreP47;
Coords mcposaPoreP48, mcposrPoreP48;
Rotation mcrotaPoreP48, mcrotrPoreP48;
Coords mcposaPoreH0, mcposrPoreH0;
Rotation mcrotaPoreH0, mcrotrPoreH0;
Coords mcposaPoreH1, mcposrPoreH1;
Rotation mcrotaPoreH1, mcrotrPoreH1;
Coords mcposaPoreH2, mcposrPoreH2;
Rotation mcrotaPoreH2, mcrotrPoreH2;
Coords mcposaPoreH3, mcposrPoreH3;
Rotation mcrotaPoreH3, mcrotrPoreH3;
Coords mcposaPoreH4, mcposrPoreH4;
Rotation mcrotaPoreH4, mcrotrPoreH4;
Coords mcposaPoreH5, mcposrPoreH5;
Rotation mcrotaPoreH5, mcrotrPoreH5;
Coords mcposaPoreH6, mcposrPoreH6;
Rotation mcrotaPoreH6, mcrotrPoreH6;
Coords mcposaPoreH7, mcposrPoreH7;
Rotation mcrotaPoreH7, mcrotrPoreH7;
Coords mcposaPoreH8, mcposrPoreH8;
Rotation mcrotaPoreH8, mcrotrPoreH8;
Coords mcposaPoreH9, mcposrPoreH9;
Rotation mcrotaPoreH9, mcrotrPoreH9;
Coords mcposaPoreH10, mcposrPoreH10;
Rotation mcrotaPoreH10, mcrotrPoreH10;
Coords mcposaPoreH11, mcposrPoreH11;
Rotation mcrotaPoreH11, mcrotrPoreH11;
Coords mcposaPoreH12, mcposrPoreH12;
Rotation mcrotaPoreH12, mcrotrPoreH12;
Coords mcposaPoreH13, mcposrPoreH13;
Rotation mcrotaPoreH13, mcrotrPoreH13;
Coords mcposaPoreH14, mcposrPoreH14;
Rotation mcrotaPoreH14, mcrotrPoreH14;
Coords mcposaPoreH15, mcposrPoreH15;
Rotation mcrotaPoreH15, mcrotrPoreH15;
Coords mcposaPoreH16, mcposrPoreH16;
Rotation mcrotaPoreH16, mcrotrPoreH16;
Coords mcposaPoreH17, mcposrPoreH17;
Rotation mcrotaPoreH17, mcrotrPoreH17;
Coords mcposaPoreH18, mcposrPoreH18;
Rotation mcrotaPoreH18, mcrotrPoreH18;
Coords mcposaPoreH19, mcposrPoreH19;
Rotation mcrotaPoreH19, mcrotrPoreH19;
Coords mcposaPoreH20, mcposrPoreH20;
Rotation mcrotaPoreH20, mcrotrPoreH20;
Coords mcposaPoreH21, mcposrPoreH21;
Rotation mcrotaPoreH21, mcrotrPoreH21;
Coords mcposaPoreH22, mcposrPoreH22;
Rotation mcrotaPoreH22, mcrotrPoreH22;
Coords mcposaPoreH23, mcposrPoreH23;
Rotation mcrotaPoreH23, mcrotrPoreH23;
Coords mcposaPoreH24, mcposrPoreH24;
Rotation mcrotaPoreH24, mcrotrPoreH24;
Coords mcposaPoreH25, mcposrPoreH25;
Rotation mcrotaPoreH25, mcrotrPoreH25;
Coords mcposaPoreH26, mcposrPoreH26;
Rotation mcrotaPoreH26, mcrotrPoreH26;
Coords mcposaPoreH27, mcposrPoreH27;
Rotation mcrotaPoreH27, mcrotrPoreH27;
Coords mcposaPoreH28, mcposrPoreH28;
Rotation mcrotaPoreH28, mcrotrPoreH28;
Coords mcposaPoreH29, mcposrPoreH29;
Rotation mcrotaPoreH29, mcrotrPoreH29;
Coords mcposaPoreH30, mcposrPoreH30;
Rotation mcrotaPoreH30, mcrotrPoreH30;
Coords mcposaPoreH31, mcposrPoreH31;
Rotation mcrotaPoreH31, mcrotrPoreH31;
Coords mcposaPoreH32, mcposrPoreH32;
Rotation mcrotaPoreH32, mcrotrPoreH32;
Coords mcposaPoreH33, mcposrPoreH33;
Rotation mcrotaPoreH33, mcrotrPoreH33;
Coords mcposaPoreH34, mcposrPoreH34;
Rotation mcrotaPoreH34, mcrotrPoreH34;
Coords mcposaPoreH35, mcposrPoreH35;
Rotation mcrotaPoreH35, mcrotrPoreH35;
Coords mcposaPoreH36, mcposrPoreH36;
Rotation mcrotaPoreH36, mcrotrPoreH36;
Coords mcposaPoreH37, mcposrPoreH37;
Rotation mcrotaPoreH37, mcrotrPoreH37;
Coords mcposaPoreH38, mcposrPoreH38;
Rotation mcrotaPoreH38, mcrotrPoreH38;
Coords mcposaPoreH39, mcposrPoreH39;
Rotation mcrotaPoreH39, mcrotrPoreH39;
Coords mcposaPoreH40, mcposrPoreH40;
Rotation mcrotaPoreH40, mcrotrPoreH40;
Coords mcposaPoreH41, mcposrPoreH41;
Rotation mcrotaPoreH41, mcrotrPoreH41;
Coords mcposaPoreH42, mcposrPoreH42;
Rotation mcrotaPoreH42, mcrotrPoreH42;
Coords mcposaPoreH43, mcposrPoreH43;
Rotation mcrotaPoreH43, mcrotrPoreH43;
Coords mcposaPoreH44, mcposrPoreH44;
Rotation mcrotaPoreH44, mcrotrPoreH44;
Coords mcposaPoreH45, mcposrPoreH45;
Rotation mcrotaPoreH45, mcrotrPoreH45;
Coords mcposaPoreH46, mcposrPoreH46;
Rotation mcrotaPoreH46, mcrotrPoreH46;
Coords mcposaPoreH47, mcposrPoreH47;
Rotation mcrotaPoreH47, mcrotrPoreH47;
Coords mcposaPoreH48, mcposrPoreH48;
Rotation mcrotaPoreH48, mcrotrPoreH48;
Coords mcposamonitorAfter, mcposrmonitorAfter;
Rotation mcrotamonitorAfter, mcrotrmonitorAfter;
Coords mcposaendMonitorWide, mcposrendMonitorWide;
Rotation mcrotaendMonitorWide, mcrotrendMonitorWide;

MCNUM mcnx, mcny, mcnz, mcnkx, mcnky, mcnkz, mcnphi, mcnt, mcnEx, mcnEy, mcnEz, mcnp;

/* end declare */

void mcinit(void) {
#define mccompcurname  AthenaModule
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaAthenaModule coords_set(0,0,0)
#define module_nr mcipmodule_nr
#define plate_nr mcipplate_nr
#define energy mcipenergy
#define source_type mcipsource_type
#define source_th mcipsource_th
#define source_dx mcipsource_dx
#define source_dy mcipsource_dy
#define absorb_sides mcipabsorb_sides
#define absorb_bottom mcipabsorb_bottom
#define output_filename mcipoutput_filename
#line 121 "instruments/plate49.instr"
{
    bufferInit();
porePitch = 0.001000;
poresPerPlate = 49;
    //porePitch = something
    //poresPerPlate = something else

    poreW = porePitch-PLATE_THICKNESS;
    poreH = PORE_HEIGHT_DEFAULT;

    photonCount = -1;

    int ring = getRing(module_nr);
    int moduleOnRing = getModuleOnRing(module_nr);

    moduleAngle = getModuleAngle(moduleOnRing, ring);

    double plateWidth = getPoreGeom(ring, plate_nr, 'w');
    int poresOnPlateTest = floor(plateWidth/porePitch);
    poresOnPlateTest = poresOnPlateTest - ((poresOnPlateTest + 1) & 1);
    if(poresOnPlateTest != poresPerPlate){
        printf("Plate dimensions do not fit with instrument file: %d / %d\n", poresPerPlate, poresOnPlateTest);
        sleep(1);
        exit(130);
    }
    int poresPerHalfPlate = poresPerPlate/2;

    radiusP = getPoreGeom(ring, plate_nr, 'p');
    radiusM = getPoreGeom(ring, plate_nr, 'm');
    radiusH = getPoreGeom(ring, plate_nr, 'h');

    int i;
    for(i = 0; i < poresPerPlate; i++){
        poreAngle[i] = (porePitch/radiusM)*(i - poresPerHalfPlate) + moduleAngle;
        poreAngleDegrees[i] = poreAngle[i]/DEGTORAD;
        poreX[i] = radiusM*cos(poreAngle[i]);
        poreY[i] = radiusM*sin(poreAngle[i]);
    }

    thX = poreX[poresPerHalfPlate];
    thY = poreY[poresPerHalfPlate];

    thZ = -getPoreGeom(ring, plate_nr, 'l');

    srcW = plateWidth*1.05;
    srcH = srcW;

    coating = malloc(100);
    coatingSide = malloc(100);
    coatingBottom = malloc(100);

    if(energy >= 1 && energy <= 10){
        sprintf(coating, "coatings/B4C80_Ir100_45sigma_%dkeV.dat", energy);
        sprintf(coatingSide, "%s", coating);
        sprintf(coatingBottom, "%s", coating);
        printf("Selecting energy %d keV\n", energy);
    } else {
        energy = 1; //energy doesn't matter at this point as no coatings are set, this is to avoid e=0
        coating = "coatings/mirror_coating_unity.txt";
        coatingSide = coating;
        coatingBottom = coating;
        printf("Selecting unity reflectivity\n");
    }
    if(absorb_sides){
        coatingSide = "coatings/mirror_coating_zero.txt";
    }
    if(absorb_bottom){
        coatingBottom = "coatings/mirror_coating_zero";
    }
}
#line 16785 "instruments/plate49.c"
#undef output_filename
#undef absorb_bottom
#undef absorb_sides
#undef source_dy
#undef source_dx
#undef source_th
#undef source_type
#undef energy
#undef plate_nr
#undef module_nr
#undef mcposaAthenaModule
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname
  /* Computation of coordinate transformations. */
  {
    Coords mctc1, mctc2, mcLastComp;
    Rotation mctr1;
    double mcAccumulatedILength = 0;
    /* Initialize "last" component origin as (0,0,0) */
    mcLastComp = coords_set(0,0,0);

    mcDEBUG_INSTR()
  /* Component initializations. */
    /* Component origin. */
  /* Setting parameters for component origin. */
  SIG_MESSAGE("origin (Init:SetPar)");
#line 44 "instruments/plate49.instr"
  mccorigin_percent = 10;
#line 44 "instruments/plate49.instr"
  mccorigin_flag_save = 0;
#line 44 "instruments/plate49.instr"
  mccorigin_minutes = 0;
#line 16819 "instruments/plate49.c"

  SIG_MESSAGE("origin (Init:Place/Rotate)");
  rot_set_rotation(mcrotaorigin,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 16826 "instruments/plate49.c"
  rot_copy(mcrotrorigin, mcrotaorigin);
  mcposaorigin = coords_set(
#line 198 "instruments/plate49.instr"
    0,
#line 198 "instruments/plate49.instr"
    0,
#line 198 "instruments/plate49.instr"
    0);
#line 16835 "instruments/plate49.c"
  mctc1 = coords_neg(mcposaorigin);
  mcposrorigin = rot_apply(mcrotaorigin, mctc1);
  mcDEBUG_COMPONENT("origin", mcposaorigin, mcrotaorigin)
  mccomp_posa[1] = mcposaorigin;
  mccomp_posr[1] = mcposrorigin;
  mcNCounter[1]  = mcPCounter[1] = mcP2Counter[1] = 0;
  mcAbsorbProp[1]= 0;
    /* Component ThetaArm. */
  /* Setting parameters for component ThetaArm. */
  SIG_MESSAGE("ThetaArm (Init:SetPar)");

  SIG_MESSAGE("ThetaArm (Init:Place/Rotate)");
  rot_set_rotation(mcrotaThetaArm,
#line 208 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 208 "instruments/plate49.instr"
    (mcipsource_th / 60.0)*DEG2RAD,
#line 208 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 16855 "instruments/plate49.c"
  rot_transpose(mcrotaorigin, mctr1);
  rot_mul(mcrotaThetaArm, mctr1, mcrotrThetaArm);
  mcposaThetaArm = coords_set(
#line 207 "instruments/plate49.instr"
    thX,
#line 207 "instruments/plate49.instr"
    thY,
#line 207 "instruments/plate49.instr"
    thZ);
#line 16865 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaorigin, mcposaThetaArm);
  mcposrThetaArm = rot_apply(mcrotaThetaArm, mctc1);
  mcDEBUG_COMPONENT("ThetaArm", mcposaThetaArm, mcrotaThetaArm)
  mccomp_posa[2] = mcposaThetaArm;
  mccomp_posr[2] = mcposrThetaArm;
  mcNCounter[2]  = mcPCounter[2] = mcP2Counter[2] = 0;
  mcAbsorbProp[2]= 0;
    /* Component srcDirectional. */
  /* Setting parameters for component srcDirectional. */
  SIG_MESSAGE("srcDirectional (Init:SetPar)");
#line 213 "instruments/plate49.instr"
  mccsrcDirectional_xwidth = srcW;
#line 214 "instruments/plate49.instr"
  mccsrcDirectional_yheight = srcH;
#line 215 "instruments/plate49.instr"
  mccsrcDirectional_focus_aw = mcipsource_dx / 60 * DEGTORAD;
#line 216 "instruments/plate49.instr"
  mccsrcDirectional_focus_ah = mcipsource_dy / 60 * DEGTORAD;
#line 211 "instruments/plate49.instr"
  mccsrcDirectional_E0 = mcipenergy;
#line 212 "instruments/plate49.instr"
  mccsrcDirectional_dE = dEnergy;
#line 58 "instruments/plate49.instr"
  mccsrcDirectional_lambda0 = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectional_dlambda = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectional_flux = 0;
#line 217 "instruments/plate49.instr"
  mccsrcDirectional_gauss = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectional_gauss_a = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectional_randomphase = 1;
#line 58 "instruments/plate49.instr"
  mccsrcDirectional_phase = 0;
#line 16902 "instruments/plate49.c"

  SIG_MESSAGE("srcDirectional (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 220 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 220 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 220 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 16912 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaThetaArm, mcrotasrcDirectional);
  rot_transpose(mcrotaThetaArm, mctr1);
  rot_mul(mcrotasrcDirectional, mctr1, mcrotrsrcDirectional);
  mctc1 = coords_set(
#line 219 "instruments/plate49.instr"
    0,
#line 219 "instruments/plate49.instr"
    0,
#line 219 "instruments/plate49.instr"
    - sourceToOptics);
#line 16923 "instruments/plate49.c"
  rot_transpose(mcrotaThetaArm, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasrcDirectional = coords_add(mcposaThetaArm, mctc2);
  mctc1 = coords_sub(mcposaThetaArm, mcposasrcDirectional);
  mcposrsrcDirectional = rot_apply(mcrotasrcDirectional, mctc1);
  mcDEBUG_COMPONENT("srcDirectional", mcposasrcDirectional, mcrotasrcDirectional)
  mccomp_posa[3] = mcposasrcDirectional;
  mccomp_posr[3] = mcposrsrcDirectional;
  mcNCounter[3]  = mcPCounter[3] = mcP2Counter[3] = 0;
  mcAbsorbProp[3]= 0;
    /* Component srcDirectionalWide. */
  /* Setting parameters for component srcDirectionalWide. */
  SIG_MESSAGE("srcDirectionalWide (Init:SetPar)");
#line 225 "instruments/plate49.instr"
  mccsrcDirectionalWide_xwidth = 3 * srcW;
#line 226 "instruments/plate49.instr"
  mccsrcDirectionalWide_yheight = 3 * srcH;
#line 227 "instruments/plate49.instr"
  mccsrcDirectionalWide_focus_aw = mcipsource_dx / 60 * DEGTORAD;
#line 228 "instruments/plate49.instr"
  mccsrcDirectionalWide_focus_ah = mcipsource_dy / 60 * DEGTORAD;
#line 223 "instruments/plate49.instr"
  mccsrcDirectionalWide_E0 = mcipenergy;
#line 224 "instruments/plate49.instr"
  mccsrcDirectionalWide_dE = dEnergy;
#line 58 "instruments/plate49.instr"
  mccsrcDirectionalWide_lambda0 = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectionalWide_dlambda = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectionalWide_flux = 0;
#line 229 "instruments/plate49.instr"
  mccsrcDirectionalWide_gauss = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectionalWide_gauss_a = 0;
#line 58 "instruments/plate49.instr"
  mccsrcDirectionalWide_randomphase = 1;
#line 58 "instruments/plate49.instr"
  mccsrcDirectionalWide_phase = 0;
#line 16963 "instruments/plate49.c"

  SIG_MESSAGE("srcDirectionalWide (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 232 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 232 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 232 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 16973 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaThetaArm, mcrotasrcDirectionalWide);
  rot_transpose(mcrotasrcDirectional, mctr1);
  rot_mul(mcrotasrcDirectionalWide, mctr1, mcrotrsrcDirectionalWide);
  mctc1 = coords_set(
#line 231 "instruments/plate49.instr"
    0,
#line 231 "instruments/plate49.instr"
    0,
#line 231 "instruments/plate49.instr"
    - sourceToOptics);
#line 16984 "instruments/plate49.c"
  rot_transpose(mcrotaThetaArm, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasrcDirectionalWide = coords_add(mcposaThetaArm, mctc2);
  mctc1 = coords_sub(mcposasrcDirectional, mcposasrcDirectionalWide);
  mcposrsrcDirectionalWide = rot_apply(mcrotasrcDirectionalWide, mctc1);
  mcDEBUG_COMPONENT("srcDirectionalWide", mcposasrcDirectionalWide, mcrotasrcDirectionalWide)
  mccomp_posa[4] = mcposasrcDirectionalWide;
  mccomp_posr[4] = mcposrsrcDirectionalWide;
  mcNCounter[4]  = mcPCounter[4] = mcP2Counter[4] = 0;
  mcAbsorbProp[4]= 0;
    /* Component PoreArm0. */
  /* Setting parameters for component PoreArm0. */
  SIG_MESSAGE("PoreArm0 (Init:SetPar)");

  SIG_MESSAGE("PoreArm0 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm0,
#line 239 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 239 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 239 "instruments/plate49.instr"
    (poreAngleDegrees [ 0 ] -90)*DEG2RAD);
#line 17007 "instruments/plate49.c"
  rot_transpose(mcrotasrcDirectionalWide, mctr1);
  rot_mul(mcrotaPoreArm0, mctr1, mcrotrPoreArm0);
  mcposaPoreArm0 = coords_set(
#line 238 "instruments/plate49.instr"
    0,
#line 238 "instruments/plate49.instr"
    0,
#line 238 "instruments/plate49.instr"
    0);
#line 17017 "instruments/plate49.c"
  mctc1 = coords_sub(mcposasrcDirectionalWide, mcposaPoreArm0);
  mcposrPoreArm0 = rot_apply(mcrotaPoreArm0, mctc1);
  mcDEBUG_COMPONENT("PoreArm0", mcposaPoreArm0, mcrotaPoreArm0)
  mccomp_posa[5] = mcposaPoreArm0;
  mccomp_posr[5] = mcposrPoreArm0;
  mcNCounter[5]  = mcPCounter[5] = mcP2Counter[5] = 0;
  mcAbsorbProp[5]= 0;
    /* Component PoreArm1. */
  /* Setting parameters for component PoreArm1. */
  SIG_MESSAGE("PoreArm1 (Init:SetPar)");

  SIG_MESSAGE("PoreArm1 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm1,
#line 243 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 243 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 243 "instruments/plate49.instr"
    (poreAngleDegrees [ 1 ] -90)*DEG2RAD);
#line 17037 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm0, mctr1);
  rot_mul(mcrotaPoreArm1, mctr1, mcrotrPoreArm1);
  mcposaPoreArm1 = coords_set(
#line 242 "instruments/plate49.instr"
    0,
#line 242 "instruments/plate49.instr"
    0,
#line 242 "instruments/plate49.instr"
    0);
#line 17047 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm0, mcposaPoreArm1);
  mcposrPoreArm1 = rot_apply(mcrotaPoreArm1, mctc1);
  mcDEBUG_COMPONENT("PoreArm1", mcposaPoreArm1, mcrotaPoreArm1)
  mccomp_posa[6] = mcposaPoreArm1;
  mccomp_posr[6] = mcposrPoreArm1;
  mcNCounter[6]  = mcPCounter[6] = mcP2Counter[6] = 0;
  mcAbsorbProp[6]= 0;
    /* Component PoreArm2. */
  /* Setting parameters for component PoreArm2. */
  SIG_MESSAGE("PoreArm2 (Init:SetPar)");

  SIG_MESSAGE("PoreArm2 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm2,
#line 247 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 247 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 247 "instruments/plate49.instr"
    (poreAngleDegrees [ 2 ] -90)*DEG2RAD);
#line 17067 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm1, mctr1);
  rot_mul(mcrotaPoreArm2, mctr1, mcrotrPoreArm2);
  mcposaPoreArm2 = coords_set(
#line 246 "instruments/plate49.instr"
    0,
#line 246 "instruments/plate49.instr"
    0,
#line 246 "instruments/plate49.instr"
    0);
#line 17077 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm1, mcposaPoreArm2);
  mcposrPoreArm2 = rot_apply(mcrotaPoreArm2, mctc1);
  mcDEBUG_COMPONENT("PoreArm2", mcposaPoreArm2, mcrotaPoreArm2)
  mccomp_posa[7] = mcposaPoreArm2;
  mccomp_posr[7] = mcposrPoreArm2;
  mcNCounter[7]  = mcPCounter[7] = mcP2Counter[7] = 0;
  mcAbsorbProp[7]= 0;
    /* Component PoreArm3. */
  /* Setting parameters for component PoreArm3. */
  SIG_MESSAGE("PoreArm3 (Init:SetPar)");

  SIG_MESSAGE("PoreArm3 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm3,
#line 251 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 251 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 251 "instruments/plate49.instr"
    (poreAngleDegrees [ 3 ] -90)*DEG2RAD);
#line 17097 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm2, mctr1);
  rot_mul(mcrotaPoreArm3, mctr1, mcrotrPoreArm3);
  mcposaPoreArm3 = coords_set(
#line 250 "instruments/plate49.instr"
    0,
#line 250 "instruments/plate49.instr"
    0,
#line 250 "instruments/plate49.instr"
    0);
#line 17107 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm2, mcposaPoreArm3);
  mcposrPoreArm3 = rot_apply(mcrotaPoreArm3, mctc1);
  mcDEBUG_COMPONENT("PoreArm3", mcposaPoreArm3, mcrotaPoreArm3)
  mccomp_posa[8] = mcposaPoreArm3;
  mccomp_posr[8] = mcposrPoreArm3;
  mcNCounter[8]  = mcPCounter[8] = mcP2Counter[8] = 0;
  mcAbsorbProp[8]= 0;
    /* Component PoreArm4. */
  /* Setting parameters for component PoreArm4. */
  SIG_MESSAGE("PoreArm4 (Init:SetPar)");

  SIG_MESSAGE("PoreArm4 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm4,
#line 255 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 255 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 255 "instruments/plate49.instr"
    (poreAngleDegrees [ 4 ] -90)*DEG2RAD);
#line 17127 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm3, mctr1);
  rot_mul(mcrotaPoreArm4, mctr1, mcrotrPoreArm4);
  mcposaPoreArm4 = coords_set(
#line 254 "instruments/plate49.instr"
    0,
#line 254 "instruments/plate49.instr"
    0,
#line 254 "instruments/plate49.instr"
    0);
#line 17137 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm3, mcposaPoreArm4);
  mcposrPoreArm4 = rot_apply(mcrotaPoreArm4, mctc1);
  mcDEBUG_COMPONENT("PoreArm4", mcposaPoreArm4, mcrotaPoreArm4)
  mccomp_posa[9] = mcposaPoreArm4;
  mccomp_posr[9] = mcposrPoreArm4;
  mcNCounter[9]  = mcPCounter[9] = mcP2Counter[9] = 0;
  mcAbsorbProp[9]= 0;
    /* Component PoreArm5. */
  /* Setting parameters for component PoreArm5. */
  SIG_MESSAGE("PoreArm5 (Init:SetPar)");

  SIG_MESSAGE("PoreArm5 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm5,
#line 259 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 259 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 259 "instruments/plate49.instr"
    (poreAngleDegrees [ 5 ] -90)*DEG2RAD);
#line 17157 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm4, mctr1);
  rot_mul(mcrotaPoreArm5, mctr1, mcrotrPoreArm5);
  mcposaPoreArm5 = coords_set(
#line 258 "instruments/plate49.instr"
    0,
#line 258 "instruments/plate49.instr"
    0,
#line 258 "instruments/plate49.instr"
    0);
#line 17167 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm4, mcposaPoreArm5);
  mcposrPoreArm5 = rot_apply(mcrotaPoreArm5, mctc1);
  mcDEBUG_COMPONENT("PoreArm5", mcposaPoreArm5, mcrotaPoreArm5)
  mccomp_posa[10] = mcposaPoreArm5;
  mccomp_posr[10] = mcposrPoreArm5;
  mcNCounter[10]  = mcPCounter[10] = mcP2Counter[10] = 0;
  mcAbsorbProp[10]= 0;
    /* Component PoreArm6. */
  /* Setting parameters for component PoreArm6. */
  SIG_MESSAGE("PoreArm6 (Init:SetPar)");

  SIG_MESSAGE("PoreArm6 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm6,
#line 263 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 263 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 263 "instruments/plate49.instr"
    (poreAngleDegrees [ 6 ] -90)*DEG2RAD);
#line 17187 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm5, mctr1);
  rot_mul(mcrotaPoreArm6, mctr1, mcrotrPoreArm6);
  mcposaPoreArm6 = coords_set(
#line 262 "instruments/plate49.instr"
    0,
#line 262 "instruments/plate49.instr"
    0,
#line 262 "instruments/plate49.instr"
    0);
#line 17197 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm5, mcposaPoreArm6);
  mcposrPoreArm6 = rot_apply(mcrotaPoreArm6, mctc1);
  mcDEBUG_COMPONENT("PoreArm6", mcposaPoreArm6, mcrotaPoreArm6)
  mccomp_posa[11] = mcposaPoreArm6;
  mccomp_posr[11] = mcposrPoreArm6;
  mcNCounter[11]  = mcPCounter[11] = mcP2Counter[11] = 0;
  mcAbsorbProp[11]= 0;
    /* Component PoreArm7. */
  /* Setting parameters for component PoreArm7. */
  SIG_MESSAGE("PoreArm7 (Init:SetPar)");

  SIG_MESSAGE("PoreArm7 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm7,
#line 267 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 267 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 267 "instruments/plate49.instr"
    (poreAngleDegrees [ 7 ] -90)*DEG2RAD);
#line 17217 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm6, mctr1);
  rot_mul(mcrotaPoreArm7, mctr1, mcrotrPoreArm7);
  mcposaPoreArm7 = coords_set(
#line 266 "instruments/plate49.instr"
    0,
#line 266 "instruments/plate49.instr"
    0,
#line 266 "instruments/plate49.instr"
    0);
#line 17227 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm6, mcposaPoreArm7);
  mcposrPoreArm7 = rot_apply(mcrotaPoreArm7, mctc1);
  mcDEBUG_COMPONENT("PoreArm7", mcposaPoreArm7, mcrotaPoreArm7)
  mccomp_posa[12] = mcposaPoreArm7;
  mccomp_posr[12] = mcposrPoreArm7;
  mcNCounter[12]  = mcPCounter[12] = mcP2Counter[12] = 0;
  mcAbsorbProp[12]= 0;
    /* Component PoreArm8. */
  /* Setting parameters for component PoreArm8. */
  SIG_MESSAGE("PoreArm8 (Init:SetPar)");

  SIG_MESSAGE("PoreArm8 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm8,
#line 271 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 271 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 271 "instruments/plate49.instr"
    (poreAngleDegrees [ 8 ] -90)*DEG2RAD);
#line 17247 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm7, mctr1);
  rot_mul(mcrotaPoreArm8, mctr1, mcrotrPoreArm8);
  mcposaPoreArm8 = coords_set(
#line 270 "instruments/plate49.instr"
    0,
#line 270 "instruments/plate49.instr"
    0,
#line 270 "instruments/plate49.instr"
    0);
#line 17257 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm7, mcposaPoreArm8);
  mcposrPoreArm8 = rot_apply(mcrotaPoreArm8, mctc1);
  mcDEBUG_COMPONENT("PoreArm8", mcposaPoreArm8, mcrotaPoreArm8)
  mccomp_posa[13] = mcposaPoreArm8;
  mccomp_posr[13] = mcposrPoreArm8;
  mcNCounter[13]  = mcPCounter[13] = mcP2Counter[13] = 0;
  mcAbsorbProp[13]= 0;
    /* Component PoreArm9. */
  /* Setting parameters for component PoreArm9. */
  SIG_MESSAGE("PoreArm9 (Init:SetPar)");

  SIG_MESSAGE("PoreArm9 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm9,
#line 275 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 275 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 275 "instruments/plate49.instr"
    (poreAngleDegrees [ 9 ] -90)*DEG2RAD);
#line 17277 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm8, mctr1);
  rot_mul(mcrotaPoreArm9, mctr1, mcrotrPoreArm9);
  mcposaPoreArm9 = coords_set(
#line 274 "instruments/plate49.instr"
    0,
#line 274 "instruments/plate49.instr"
    0,
#line 274 "instruments/plate49.instr"
    0);
#line 17287 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm8, mcposaPoreArm9);
  mcposrPoreArm9 = rot_apply(mcrotaPoreArm9, mctc1);
  mcDEBUG_COMPONENT("PoreArm9", mcposaPoreArm9, mcrotaPoreArm9)
  mccomp_posa[14] = mcposaPoreArm9;
  mccomp_posr[14] = mcposrPoreArm9;
  mcNCounter[14]  = mcPCounter[14] = mcP2Counter[14] = 0;
  mcAbsorbProp[14]= 0;
    /* Component PoreArm10. */
  /* Setting parameters for component PoreArm10. */
  SIG_MESSAGE("PoreArm10 (Init:SetPar)");

  SIG_MESSAGE("PoreArm10 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm10,
#line 279 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 279 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 279 "instruments/plate49.instr"
    (poreAngleDegrees [ 10 ] -90)*DEG2RAD);
#line 17307 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm9, mctr1);
  rot_mul(mcrotaPoreArm10, mctr1, mcrotrPoreArm10);
  mcposaPoreArm10 = coords_set(
#line 278 "instruments/plate49.instr"
    0,
#line 278 "instruments/plate49.instr"
    0,
#line 278 "instruments/plate49.instr"
    0);
#line 17317 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm9, mcposaPoreArm10);
  mcposrPoreArm10 = rot_apply(mcrotaPoreArm10, mctc1);
  mcDEBUG_COMPONENT("PoreArm10", mcposaPoreArm10, mcrotaPoreArm10)
  mccomp_posa[15] = mcposaPoreArm10;
  mccomp_posr[15] = mcposrPoreArm10;
  mcNCounter[15]  = mcPCounter[15] = mcP2Counter[15] = 0;
  mcAbsorbProp[15]= 0;
    /* Component PoreArm11. */
  /* Setting parameters for component PoreArm11. */
  SIG_MESSAGE("PoreArm11 (Init:SetPar)");

  SIG_MESSAGE("PoreArm11 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm11,
#line 283 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 283 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 283 "instruments/plate49.instr"
    (poreAngleDegrees [ 11 ] -90)*DEG2RAD);
#line 17337 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm10, mctr1);
  rot_mul(mcrotaPoreArm11, mctr1, mcrotrPoreArm11);
  mcposaPoreArm11 = coords_set(
#line 282 "instruments/plate49.instr"
    0,
#line 282 "instruments/plate49.instr"
    0,
#line 282 "instruments/plate49.instr"
    0);
#line 17347 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm10, mcposaPoreArm11);
  mcposrPoreArm11 = rot_apply(mcrotaPoreArm11, mctc1);
  mcDEBUG_COMPONENT("PoreArm11", mcposaPoreArm11, mcrotaPoreArm11)
  mccomp_posa[16] = mcposaPoreArm11;
  mccomp_posr[16] = mcposrPoreArm11;
  mcNCounter[16]  = mcPCounter[16] = mcP2Counter[16] = 0;
  mcAbsorbProp[16]= 0;
    /* Component PoreArm12. */
  /* Setting parameters for component PoreArm12. */
  SIG_MESSAGE("PoreArm12 (Init:SetPar)");

  SIG_MESSAGE("PoreArm12 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm12,
#line 287 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 287 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 287 "instruments/plate49.instr"
    (poreAngleDegrees [ 12 ] -90)*DEG2RAD);
#line 17367 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm11, mctr1);
  rot_mul(mcrotaPoreArm12, mctr1, mcrotrPoreArm12);
  mcposaPoreArm12 = coords_set(
#line 286 "instruments/plate49.instr"
    0,
#line 286 "instruments/plate49.instr"
    0,
#line 286 "instruments/plate49.instr"
    0);
#line 17377 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm11, mcposaPoreArm12);
  mcposrPoreArm12 = rot_apply(mcrotaPoreArm12, mctc1);
  mcDEBUG_COMPONENT("PoreArm12", mcposaPoreArm12, mcrotaPoreArm12)
  mccomp_posa[17] = mcposaPoreArm12;
  mccomp_posr[17] = mcposrPoreArm12;
  mcNCounter[17]  = mcPCounter[17] = mcP2Counter[17] = 0;
  mcAbsorbProp[17]= 0;
    /* Component PoreArm13. */
  /* Setting parameters for component PoreArm13. */
  SIG_MESSAGE("PoreArm13 (Init:SetPar)");

  SIG_MESSAGE("PoreArm13 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm13,
#line 291 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 291 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 291 "instruments/plate49.instr"
    (poreAngleDegrees [ 13 ] -90)*DEG2RAD);
#line 17397 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm12, mctr1);
  rot_mul(mcrotaPoreArm13, mctr1, mcrotrPoreArm13);
  mcposaPoreArm13 = coords_set(
#line 290 "instruments/plate49.instr"
    0,
#line 290 "instruments/plate49.instr"
    0,
#line 290 "instruments/plate49.instr"
    0);
#line 17407 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm12, mcposaPoreArm13);
  mcposrPoreArm13 = rot_apply(mcrotaPoreArm13, mctc1);
  mcDEBUG_COMPONENT("PoreArm13", mcposaPoreArm13, mcrotaPoreArm13)
  mccomp_posa[18] = mcposaPoreArm13;
  mccomp_posr[18] = mcposrPoreArm13;
  mcNCounter[18]  = mcPCounter[18] = mcP2Counter[18] = 0;
  mcAbsorbProp[18]= 0;
    /* Component PoreArm14. */
  /* Setting parameters for component PoreArm14. */
  SIG_MESSAGE("PoreArm14 (Init:SetPar)");

  SIG_MESSAGE("PoreArm14 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm14,
#line 295 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 295 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 295 "instruments/plate49.instr"
    (poreAngleDegrees [ 14 ] -90)*DEG2RAD);
#line 17427 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm13, mctr1);
  rot_mul(mcrotaPoreArm14, mctr1, mcrotrPoreArm14);
  mcposaPoreArm14 = coords_set(
#line 294 "instruments/plate49.instr"
    0,
#line 294 "instruments/plate49.instr"
    0,
#line 294 "instruments/plate49.instr"
    0);
#line 17437 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm13, mcposaPoreArm14);
  mcposrPoreArm14 = rot_apply(mcrotaPoreArm14, mctc1);
  mcDEBUG_COMPONENT("PoreArm14", mcposaPoreArm14, mcrotaPoreArm14)
  mccomp_posa[19] = mcposaPoreArm14;
  mccomp_posr[19] = mcposrPoreArm14;
  mcNCounter[19]  = mcPCounter[19] = mcP2Counter[19] = 0;
  mcAbsorbProp[19]= 0;
    /* Component PoreArm15. */
  /* Setting parameters for component PoreArm15. */
  SIG_MESSAGE("PoreArm15 (Init:SetPar)");

  SIG_MESSAGE("PoreArm15 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm15,
#line 299 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 299 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 299 "instruments/plate49.instr"
    (poreAngleDegrees [ 15 ] -90)*DEG2RAD);
#line 17457 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm14, mctr1);
  rot_mul(mcrotaPoreArm15, mctr1, mcrotrPoreArm15);
  mcposaPoreArm15 = coords_set(
#line 298 "instruments/plate49.instr"
    0,
#line 298 "instruments/plate49.instr"
    0,
#line 298 "instruments/plate49.instr"
    0);
#line 17467 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm14, mcposaPoreArm15);
  mcposrPoreArm15 = rot_apply(mcrotaPoreArm15, mctc1);
  mcDEBUG_COMPONENT("PoreArm15", mcposaPoreArm15, mcrotaPoreArm15)
  mccomp_posa[20] = mcposaPoreArm15;
  mccomp_posr[20] = mcposrPoreArm15;
  mcNCounter[20]  = mcPCounter[20] = mcP2Counter[20] = 0;
  mcAbsorbProp[20]= 0;
    /* Component PoreArm16. */
  /* Setting parameters for component PoreArm16. */
  SIG_MESSAGE("PoreArm16 (Init:SetPar)");

  SIG_MESSAGE("PoreArm16 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm16,
#line 303 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 303 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 303 "instruments/plate49.instr"
    (poreAngleDegrees [ 16 ] -90)*DEG2RAD);
#line 17487 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm15, mctr1);
  rot_mul(mcrotaPoreArm16, mctr1, mcrotrPoreArm16);
  mcposaPoreArm16 = coords_set(
#line 302 "instruments/plate49.instr"
    0,
#line 302 "instruments/plate49.instr"
    0,
#line 302 "instruments/plate49.instr"
    0);
#line 17497 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm15, mcposaPoreArm16);
  mcposrPoreArm16 = rot_apply(mcrotaPoreArm16, mctc1);
  mcDEBUG_COMPONENT("PoreArm16", mcposaPoreArm16, mcrotaPoreArm16)
  mccomp_posa[21] = mcposaPoreArm16;
  mccomp_posr[21] = mcposrPoreArm16;
  mcNCounter[21]  = mcPCounter[21] = mcP2Counter[21] = 0;
  mcAbsorbProp[21]= 0;
    /* Component PoreArm17. */
  /* Setting parameters for component PoreArm17. */
  SIG_MESSAGE("PoreArm17 (Init:SetPar)");

  SIG_MESSAGE("PoreArm17 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm17,
#line 307 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 307 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 307 "instruments/plate49.instr"
    (poreAngleDegrees [ 17 ] -90)*DEG2RAD);
#line 17517 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm16, mctr1);
  rot_mul(mcrotaPoreArm17, mctr1, mcrotrPoreArm17);
  mcposaPoreArm17 = coords_set(
#line 306 "instruments/plate49.instr"
    0,
#line 306 "instruments/plate49.instr"
    0,
#line 306 "instruments/plate49.instr"
    0);
#line 17527 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm16, mcposaPoreArm17);
  mcposrPoreArm17 = rot_apply(mcrotaPoreArm17, mctc1);
  mcDEBUG_COMPONENT("PoreArm17", mcposaPoreArm17, mcrotaPoreArm17)
  mccomp_posa[22] = mcposaPoreArm17;
  mccomp_posr[22] = mcposrPoreArm17;
  mcNCounter[22]  = mcPCounter[22] = mcP2Counter[22] = 0;
  mcAbsorbProp[22]= 0;
    /* Component PoreArm18. */
  /* Setting parameters for component PoreArm18. */
  SIG_MESSAGE("PoreArm18 (Init:SetPar)");

  SIG_MESSAGE("PoreArm18 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm18,
#line 311 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 311 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 311 "instruments/plate49.instr"
    (poreAngleDegrees [ 18 ] -90)*DEG2RAD);
#line 17547 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm17, mctr1);
  rot_mul(mcrotaPoreArm18, mctr1, mcrotrPoreArm18);
  mcposaPoreArm18 = coords_set(
#line 310 "instruments/plate49.instr"
    0,
#line 310 "instruments/plate49.instr"
    0,
#line 310 "instruments/plate49.instr"
    0);
#line 17557 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm17, mcposaPoreArm18);
  mcposrPoreArm18 = rot_apply(mcrotaPoreArm18, mctc1);
  mcDEBUG_COMPONENT("PoreArm18", mcposaPoreArm18, mcrotaPoreArm18)
  mccomp_posa[23] = mcposaPoreArm18;
  mccomp_posr[23] = mcposrPoreArm18;
  mcNCounter[23]  = mcPCounter[23] = mcP2Counter[23] = 0;
  mcAbsorbProp[23]= 0;
    /* Component PoreArm19. */
  /* Setting parameters for component PoreArm19. */
  SIG_MESSAGE("PoreArm19 (Init:SetPar)");

  SIG_MESSAGE("PoreArm19 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm19,
#line 315 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 315 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 315 "instruments/plate49.instr"
    (poreAngleDegrees [ 19 ] -90)*DEG2RAD);
#line 17577 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm18, mctr1);
  rot_mul(mcrotaPoreArm19, mctr1, mcrotrPoreArm19);
  mcposaPoreArm19 = coords_set(
#line 314 "instruments/plate49.instr"
    0,
#line 314 "instruments/plate49.instr"
    0,
#line 314 "instruments/plate49.instr"
    0);
#line 17587 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm18, mcposaPoreArm19);
  mcposrPoreArm19 = rot_apply(mcrotaPoreArm19, mctc1);
  mcDEBUG_COMPONENT("PoreArm19", mcposaPoreArm19, mcrotaPoreArm19)
  mccomp_posa[24] = mcposaPoreArm19;
  mccomp_posr[24] = mcposrPoreArm19;
  mcNCounter[24]  = mcPCounter[24] = mcP2Counter[24] = 0;
  mcAbsorbProp[24]= 0;
    /* Component PoreArm20. */
  /* Setting parameters for component PoreArm20. */
  SIG_MESSAGE("PoreArm20 (Init:SetPar)");

  SIG_MESSAGE("PoreArm20 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm20,
#line 319 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 319 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 319 "instruments/plate49.instr"
    (poreAngleDegrees [ 20 ] -90)*DEG2RAD);
#line 17607 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm19, mctr1);
  rot_mul(mcrotaPoreArm20, mctr1, mcrotrPoreArm20);
  mcposaPoreArm20 = coords_set(
#line 318 "instruments/plate49.instr"
    0,
#line 318 "instruments/plate49.instr"
    0,
#line 318 "instruments/plate49.instr"
    0);
#line 17617 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm19, mcposaPoreArm20);
  mcposrPoreArm20 = rot_apply(mcrotaPoreArm20, mctc1);
  mcDEBUG_COMPONENT("PoreArm20", mcposaPoreArm20, mcrotaPoreArm20)
  mccomp_posa[25] = mcposaPoreArm20;
  mccomp_posr[25] = mcposrPoreArm20;
  mcNCounter[25]  = mcPCounter[25] = mcP2Counter[25] = 0;
  mcAbsorbProp[25]= 0;
    /* Component PoreArm21. */
  /* Setting parameters for component PoreArm21. */
  SIG_MESSAGE("PoreArm21 (Init:SetPar)");

  SIG_MESSAGE("PoreArm21 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm21,
#line 323 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 323 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 323 "instruments/plate49.instr"
    (poreAngleDegrees [ 21 ] -90)*DEG2RAD);
#line 17637 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm20, mctr1);
  rot_mul(mcrotaPoreArm21, mctr1, mcrotrPoreArm21);
  mcposaPoreArm21 = coords_set(
#line 322 "instruments/plate49.instr"
    0,
#line 322 "instruments/plate49.instr"
    0,
#line 322 "instruments/plate49.instr"
    0);
#line 17647 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm20, mcposaPoreArm21);
  mcposrPoreArm21 = rot_apply(mcrotaPoreArm21, mctc1);
  mcDEBUG_COMPONENT("PoreArm21", mcposaPoreArm21, mcrotaPoreArm21)
  mccomp_posa[26] = mcposaPoreArm21;
  mccomp_posr[26] = mcposrPoreArm21;
  mcNCounter[26]  = mcPCounter[26] = mcP2Counter[26] = 0;
  mcAbsorbProp[26]= 0;
    /* Component PoreArm22. */
  /* Setting parameters for component PoreArm22. */
  SIG_MESSAGE("PoreArm22 (Init:SetPar)");

  SIG_MESSAGE("PoreArm22 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm22,
#line 327 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 327 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 327 "instruments/plate49.instr"
    (poreAngleDegrees [ 22 ] -90)*DEG2RAD);
#line 17667 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm21, mctr1);
  rot_mul(mcrotaPoreArm22, mctr1, mcrotrPoreArm22);
  mcposaPoreArm22 = coords_set(
#line 326 "instruments/plate49.instr"
    0,
#line 326 "instruments/plate49.instr"
    0,
#line 326 "instruments/plate49.instr"
    0);
#line 17677 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm21, mcposaPoreArm22);
  mcposrPoreArm22 = rot_apply(mcrotaPoreArm22, mctc1);
  mcDEBUG_COMPONENT("PoreArm22", mcposaPoreArm22, mcrotaPoreArm22)
  mccomp_posa[27] = mcposaPoreArm22;
  mccomp_posr[27] = mcposrPoreArm22;
  mcNCounter[27]  = mcPCounter[27] = mcP2Counter[27] = 0;
  mcAbsorbProp[27]= 0;
    /* Component PoreArm23. */
  /* Setting parameters for component PoreArm23. */
  SIG_MESSAGE("PoreArm23 (Init:SetPar)");

  SIG_MESSAGE("PoreArm23 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm23,
#line 331 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 331 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 331 "instruments/plate49.instr"
    (poreAngleDegrees [ 23 ] -90)*DEG2RAD);
#line 17697 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm22, mctr1);
  rot_mul(mcrotaPoreArm23, mctr1, mcrotrPoreArm23);
  mcposaPoreArm23 = coords_set(
#line 330 "instruments/plate49.instr"
    0,
#line 330 "instruments/plate49.instr"
    0,
#line 330 "instruments/plate49.instr"
    0);
#line 17707 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm22, mcposaPoreArm23);
  mcposrPoreArm23 = rot_apply(mcrotaPoreArm23, mctc1);
  mcDEBUG_COMPONENT("PoreArm23", mcposaPoreArm23, mcrotaPoreArm23)
  mccomp_posa[28] = mcposaPoreArm23;
  mccomp_posr[28] = mcposrPoreArm23;
  mcNCounter[28]  = mcPCounter[28] = mcP2Counter[28] = 0;
  mcAbsorbProp[28]= 0;
    /* Component PoreArm24. */
  /* Setting parameters for component PoreArm24. */
  SIG_MESSAGE("PoreArm24 (Init:SetPar)");

  SIG_MESSAGE("PoreArm24 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm24,
#line 335 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 335 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 335 "instruments/plate49.instr"
    (poreAngleDegrees [ 24 ] -90)*DEG2RAD);
#line 17727 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm23, mctr1);
  rot_mul(mcrotaPoreArm24, mctr1, mcrotrPoreArm24);
  mcposaPoreArm24 = coords_set(
#line 334 "instruments/plate49.instr"
    0,
#line 334 "instruments/plate49.instr"
    0,
#line 334 "instruments/plate49.instr"
    0);
#line 17737 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm23, mcposaPoreArm24);
  mcposrPoreArm24 = rot_apply(mcrotaPoreArm24, mctc1);
  mcDEBUG_COMPONENT("PoreArm24", mcposaPoreArm24, mcrotaPoreArm24)
  mccomp_posa[29] = mcposaPoreArm24;
  mccomp_posr[29] = mcposrPoreArm24;
  mcNCounter[29]  = mcPCounter[29] = mcP2Counter[29] = 0;
  mcAbsorbProp[29]= 0;
    /* Component PoreArm25. */
  /* Setting parameters for component PoreArm25. */
  SIG_MESSAGE("PoreArm25 (Init:SetPar)");

  SIG_MESSAGE("PoreArm25 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm25,
#line 339 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 339 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 339 "instruments/plate49.instr"
    (poreAngleDegrees [ 25 ] -90)*DEG2RAD);
#line 17757 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm24, mctr1);
  rot_mul(mcrotaPoreArm25, mctr1, mcrotrPoreArm25);
  mcposaPoreArm25 = coords_set(
#line 338 "instruments/plate49.instr"
    0,
#line 338 "instruments/plate49.instr"
    0,
#line 338 "instruments/plate49.instr"
    0);
#line 17767 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm24, mcposaPoreArm25);
  mcposrPoreArm25 = rot_apply(mcrotaPoreArm25, mctc1);
  mcDEBUG_COMPONENT("PoreArm25", mcposaPoreArm25, mcrotaPoreArm25)
  mccomp_posa[30] = mcposaPoreArm25;
  mccomp_posr[30] = mcposrPoreArm25;
  mcNCounter[30]  = mcPCounter[30] = mcP2Counter[30] = 0;
  mcAbsorbProp[30]= 0;
    /* Component PoreArm26. */
  /* Setting parameters for component PoreArm26. */
  SIG_MESSAGE("PoreArm26 (Init:SetPar)");

  SIG_MESSAGE("PoreArm26 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm26,
#line 343 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 343 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 343 "instruments/plate49.instr"
    (poreAngleDegrees [ 26 ] -90)*DEG2RAD);
#line 17787 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm25, mctr1);
  rot_mul(mcrotaPoreArm26, mctr1, mcrotrPoreArm26);
  mcposaPoreArm26 = coords_set(
#line 342 "instruments/plate49.instr"
    0,
#line 342 "instruments/plate49.instr"
    0,
#line 342 "instruments/plate49.instr"
    0);
#line 17797 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm25, mcposaPoreArm26);
  mcposrPoreArm26 = rot_apply(mcrotaPoreArm26, mctc1);
  mcDEBUG_COMPONENT("PoreArm26", mcposaPoreArm26, mcrotaPoreArm26)
  mccomp_posa[31] = mcposaPoreArm26;
  mccomp_posr[31] = mcposrPoreArm26;
  mcNCounter[31]  = mcPCounter[31] = mcP2Counter[31] = 0;
  mcAbsorbProp[31]= 0;
    /* Component PoreArm27. */
  /* Setting parameters for component PoreArm27. */
  SIG_MESSAGE("PoreArm27 (Init:SetPar)");

  SIG_MESSAGE("PoreArm27 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm27,
#line 347 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 347 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 347 "instruments/plate49.instr"
    (poreAngleDegrees [ 27 ] -90)*DEG2RAD);
#line 17817 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm26, mctr1);
  rot_mul(mcrotaPoreArm27, mctr1, mcrotrPoreArm27);
  mcposaPoreArm27 = coords_set(
#line 346 "instruments/plate49.instr"
    0,
#line 346 "instruments/plate49.instr"
    0,
#line 346 "instruments/plate49.instr"
    0);
#line 17827 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm26, mcposaPoreArm27);
  mcposrPoreArm27 = rot_apply(mcrotaPoreArm27, mctc1);
  mcDEBUG_COMPONENT("PoreArm27", mcposaPoreArm27, mcrotaPoreArm27)
  mccomp_posa[32] = mcposaPoreArm27;
  mccomp_posr[32] = mcposrPoreArm27;
  mcNCounter[32]  = mcPCounter[32] = mcP2Counter[32] = 0;
  mcAbsorbProp[32]= 0;
    /* Component PoreArm28. */
  /* Setting parameters for component PoreArm28. */
  SIG_MESSAGE("PoreArm28 (Init:SetPar)");

  SIG_MESSAGE("PoreArm28 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm28,
#line 351 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 351 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 351 "instruments/plate49.instr"
    (poreAngleDegrees [ 28 ] -90)*DEG2RAD);
#line 17847 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm27, mctr1);
  rot_mul(mcrotaPoreArm28, mctr1, mcrotrPoreArm28);
  mcposaPoreArm28 = coords_set(
#line 350 "instruments/plate49.instr"
    0,
#line 350 "instruments/plate49.instr"
    0,
#line 350 "instruments/plate49.instr"
    0);
#line 17857 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm27, mcposaPoreArm28);
  mcposrPoreArm28 = rot_apply(mcrotaPoreArm28, mctc1);
  mcDEBUG_COMPONENT("PoreArm28", mcposaPoreArm28, mcrotaPoreArm28)
  mccomp_posa[33] = mcposaPoreArm28;
  mccomp_posr[33] = mcposrPoreArm28;
  mcNCounter[33]  = mcPCounter[33] = mcP2Counter[33] = 0;
  mcAbsorbProp[33]= 0;
    /* Component PoreArm29. */
  /* Setting parameters for component PoreArm29. */
  SIG_MESSAGE("PoreArm29 (Init:SetPar)");

  SIG_MESSAGE("PoreArm29 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm29,
#line 355 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 355 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 355 "instruments/plate49.instr"
    (poreAngleDegrees [ 29 ] -90)*DEG2RAD);
#line 17877 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm28, mctr1);
  rot_mul(mcrotaPoreArm29, mctr1, mcrotrPoreArm29);
  mcposaPoreArm29 = coords_set(
#line 354 "instruments/plate49.instr"
    0,
#line 354 "instruments/plate49.instr"
    0,
#line 354 "instruments/plate49.instr"
    0);
#line 17887 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm28, mcposaPoreArm29);
  mcposrPoreArm29 = rot_apply(mcrotaPoreArm29, mctc1);
  mcDEBUG_COMPONENT("PoreArm29", mcposaPoreArm29, mcrotaPoreArm29)
  mccomp_posa[34] = mcposaPoreArm29;
  mccomp_posr[34] = mcposrPoreArm29;
  mcNCounter[34]  = mcPCounter[34] = mcP2Counter[34] = 0;
  mcAbsorbProp[34]= 0;
    /* Component PoreArm30. */
  /* Setting parameters for component PoreArm30. */
  SIG_MESSAGE("PoreArm30 (Init:SetPar)");

  SIG_MESSAGE("PoreArm30 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm30,
#line 359 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 359 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 359 "instruments/plate49.instr"
    (poreAngleDegrees [ 30 ] -90)*DEG2RAD);
#line 17907 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm29, mctr1);
  rot_mul(mcrotaPoreArm30, mctr1, mcrotrPoreArm30);
  mcposaPoreArm30 = coords_set(
#line 358 "instruments/plate49.instr"
    0,
#line 358 "instruments/plate49.instr"
    0,
#line 358 "instruments/plate49.instr"
    0);
#line 17917 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm29, mcposaPoreArm30);
  mcposrPoreArm30 = rot_apply(mcrotaPoreArm30, mctc1);
  mcDEBUG_COMPONENT("PoreArm30", mcposaPoreArm30, mcrotaPoreArm30)
  mccomp_posa[35] = mcposaPoreArm30;
  mccomp_posr[35] = mcposrPoreArm30;
  mcNCounter[35]  = mcPCounter[35] = mcP2Counter[35] = 0;
  mcAbsorbProp[35]= 0;
    /* Component PoreArm31. */
  /* Setting parameters for component PoreArm31. */
  SIG_MESSAGE("PoreArm31 (Init:SetPar)");

  SIG_MESSAGE("PoreArm31 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm31,
#line 363 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 363 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 363 "instruments/plate49.instr"
    (poreAngleDegrees [ 31 ] -90)*DEG2RAD);
#line 17937 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm30, mctr1);
  rot_mul(mcrotaPoreArm31, mctr1, mcrotrPoreArm31);
  mcposaPoreArm31 = coords_set(
#line 362 "instruments/plate49.instr"
    0,
#line 362 "instruments/plate49.instr"
    0,
#line 362 "instruments/plate49.instr"
    0);
#line 17947 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm30, mcposaPoreArm31);
  mcposrPoreArm31 = rot_apply(mcrotaPoreArm31, mctc1);
  mcDEBUG_COMPONENT("PoreArm31", mcposaPoreArm31, mcrotaPoreArm31)
  mccomp_posa[36] = mcposaPoreArm31;
  mccomp_posr[36] = mcposrPoreArm31;
  mcNCounter[36]  = mcPCounter[36] = mcP2Counter[36] = 0;
  mcAbsorbProp[36]= 0;
    /* Component PoreArm32. */
  /* Setting parameters for component PoreArm32. */
  SIG_MESSAGE("PoreArm32 (Init:SetPar)");

  SIG_MESSAGE("PoreArm32 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm32,
#line 367 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 367 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 367 "instruments/plate49.instr"
    (poreAngleDegrees [ 32 ] -90)*DEG2RAD);
#line 17967 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm31, mctr1);
  rot_mul(mcrotaPoreArm32, mctr1, mcrotrPoreArm32);
  mcposaPoreArm32 = coords_set(
#line 366 "instruments/plate49.instr"
    0,
#line 366 "instruments/plate49.instr"
    0,
#line 366 "instruments/plate49.instr"
    0);
#line 17977 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm31, mcposaPoreArm32);
  mcposrPoreArm32 = rot_apply(mcrotaPoreArm32, mctc1);
  mcDEBUG_COMPONENT("PoreArm32", mcposaPoreArm32, mcrotaPoreArm32)
  mccomp_posa[37] = mcposaPoreArm32;
  mccomp_posr[37] = mcposrPoreArm32;
  mcNCounter[37]  = mcPCounter[37] = mcP2Counter[37] = 0;
  mcAbsorbProp[37]= 0;
    /* Component PoreArm33. */
  /* Setting parameters for component PoreArm33. */
  SIG_MESSAGE("PoreArm33 (Init:SetPar)");

  SIG_MESSAGE("PoreArm33 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm33,
#line 371 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 371 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 371 "instruments/plate49.instr"
    (poreAngleDegrees [ 33 ] -90)*DEG2RAD);
#line 17997 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm32, mctr1);
  rot_mul(mcrotaPoreArm33, mctr1, mcrotrPoreArm33);
  mcposaPoreArm33 = coords_set(
#line 370 "instruments/plate49.instr"
    0,
#line 370 "instruments/plate49.instr"
    0,
#line 370 "instruments/plate49.instr"
    0);
#line 18007 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm32, mcposaPoreArm33);
  mcposrPoreArm33 = rot_apply(mcrotaPoreArm33, mctc1);
  mcDEBUG_COMPONENT("PoreArm33", mcposaPoreArm33, mcrotaPoreArm33)
  mccomp_posa[38] = mcposaPoreArm33;
  mccomp_posr[38] = mcposrPoreArm33;
  mcNCounter[38]  = mcPCounter[38] = mcP2Counter[38] = 0;
  mcAbsorbProp[38]= 0;
    /* Component PoreArm34. */
  /* Setting parameters for component PoreArm34. */
  SIG_MESSAGE("PoreArm34 (Init:SetPar)");

  SIG_MESSAGE("PoreArm34 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm34,
#line 375 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 375 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 375 "instruments/plate49.instr"
    (poreAngleDegrees [ 34 ] -90)*DEG2RAD);
#line 18027 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm33, mctr1);
  rot_mul(mcrotaPoreArm34, mctr1, mcrotrPoreArm34);
  mcposaPoreArm34 = coords_set(
#line 374 "instruments/plate49.instr"
    0,
#line 374 "instruments/plate49.instr"
    0,
#line 374 "instruments/plate49.instr"
    0);
#line 18037 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm33, mcposaPoreArm34);
  mcposrPoreArm34 = rot_apply(mcrotaPoreArm34, mctc1);
  mcDEBUG_COMPONENT("PoreArm34", mcposaPoreArm34, mcrotaPoreArm34)
  mccomp_posa[39] = mcposaPoreArm34;
  mccomp_posr[39] = mcposrPoreArm34;
  mcNCounter[39]  = mcPCounter[39] = mcP2Counter[39] = 0;
  mcAbsorbProp[39]= 0;
    /* Component PoreArm35. */
  /* Setting parameters for component PoreArm35. */
  SIG_MESSAGE("PoreArm35 (Init:SetPar)");

  SIG_MESSAGE("PoreArm35 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm35,
#line 379 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 379 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 379 "instruments/plate49.instr"
    (poreAngleDegrees [ 35 ] -90)*DEG2RAD);
#line 18057 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm34, mctr1);
  rot_mul(mcrotaPoreArm35, mctr1, mcrotrPoreArm35);
  mcposaPoreArm35 = coords_set(
#line 378 "instruments/plate49.instr"
    0,
#line 378 "instruments/plate49.instr"
    0,
#line 378 "instruments/plate49.instr"
    0);
#line 18067 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm34, mcposaPoreArm35);
  mcposrPoreArm35 = rot_apply(mcrotaPoreArm35, mctc1);
  mcDEBUG_COMPONENT("PoreArm35", mcposaPoreArm35, mcrotaPoreArm35)
  mccomp_posa[40] = mcposaPoreArm35;
  mccomp_posr[40] = mcposrPoreArm35;
  mcNCounter[40]  = mcPCounter[40] = mcP2Counter[40] = 0;
  mcAbsorbProp[40]= 0;
    /* Component PoreArm36. */
  /* Setting parameters for component PoreArm36. */
  SIG_MESSAGE("PoreArm36 (Init:SetPar)");

  SIG_MESSAGE("PoreArm36 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm36,
#line 383 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 383 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 383 "instruments/plate49.instr"
    (poreAngleDegrees [ 36 ] -90)*DEG2RAD);
#line 18087 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm35, mctr1);
  rot_mul(mcrotaPoreArm36, mctr1, mcrotrPoreArm36);
  mcposaPoreArm36 = coords_set(
#line 382 "instruments/plate49.instr"
    0,
#line 382 "instruments/plate49.instr"
    0,
#line 382 "instruments/plate49.instr"
    0);
#line 18097 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm35, mcposaPoreArm36);
  mcposrPoreArm36 = rot_apply(mcrotaPoreArm36, mctc1);
  mcDEBUG_COMPONENT("PoreArm36", mcposaPoreArm36, mcrotaPoreArm36)
  mccomp_posa[41] = mcposaPoreArm36;
  mccomp_posr[41] = mcposrPoreArm36;
  mcNCounter[41]  = mcPCounter[41] = mcP2Counter[41] = 0;
  mcAbsorbProp[41]= 0;
    /* Component PoreArm37. */
  /* Setting parameters for component PoreArm37. */
  SIG_MESSAGE("PoreArm37 (Init:SetPar)");

  SIG_MESSAGE("PoreArm37 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm37,
#line 387 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 387 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 387 "instruments/plate49.instr"
    (poreAngleDegrees [ 37 ] -90)*DEG2RAD);
#line 18117 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm36, mctr1);
  rot_mul(mcrotaPoreArm37, mctr1, mcrotrPoreArm37);
  mcposaPoreArm37 = coords_set(
#line 386 "instruments/plate49.instr"
    0,
#line 386 "instruments/plate49.instr"
    0,
#line 386 "instruments/plate49.instr"
    0);
#line 18127 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm36, mcposaPoreArm37);
  mcposrPoreArm37 = rot_apply(mcrotaPoreArm37, mctc1);
  mcDEBUG_COMPONENT("PoreArm37", mcposaPoreArm37, mcrotaPoreArm37)
  mccomp_posa[42] = mcposaPoreArm37;
  mccomp_posr[42] = mcposrPoreArm37;
  mcNCounter[42]  = mcPCounter[42] = mcP2Counter[42] = 0;
  mcAbsorbProp[42]= 0;
    /* Component PoreArm38. */
  /* Setting parameters for component PoreArm38. */
  SIG_MESSAGE("PoreArm38 (Init:SetPar)");

  SIG_MESSAGE("PoreArm38 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm38,
#line 391 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 391 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 391 "instruments/plate49.instr"
    (poreAngleDegrees [ 38 ] -90)*DEG2RAD);
#line 18147 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm37, mctr1);
  rot_mul(mcrotaPoreArm38, mctr1, mcrotrPoreArm38);
  mcposaPoreArm38 = coords_set(
#line 390 "instruments/plate49.instr"
    0,
#line 390 "instruments/plate49.instr"
    0,
#line 390 "instruments/plate49.instr"
    0);
#line 18157 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm37, mcposaPoreArm38);
  mcposrPoreArm38 = rot_apply(mcrotaPoreArm38, mctc1);
  mcDEBUG_COMPONENT("PoreArm38", mcposaPoreArm38, mcrotaPoreArm38)
  mccomp_posa[43] = mcposaPoreArm38;
  mccomp_posr[43] = mcposrPoreArm38;
  mcNCounter[43]  = mcPCounter[43] = mcP2Counter[43] = 0;
  mcAbsorbProp[43]= 0;
    /* Component PoreArm39. */
  /* Setting parameters for component PoreArm39. */
  SIG_MESSAGE("PoreArm39 (Init:SetPar)");

  SIG_MESSAGE("PoreArm39 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm39,
#line 395 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 395 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 395 "instruments/plate49.instr"
    (poreAngleDegrees [ 39 ] -90)*DEG2RAD);
#line 18177 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm38, mctr1);
  rot_mul(mcrotaPoreArm39, mctr1, mcrotrPoreArm39);
  mcposaPoreArm39 = coords_set(
#line 394 "instruments/plate49.instr"
    0,
#line 394 "instruments/plate49.instr"
    0,
#line 394 "instruments/plate49.instr"
    0);
#line 18187 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm38, mcposaPoreArm39);
  mcposrPoreArm39 = rot_apply(mcrotaPoreArm39, mctc1);
  mcDEBUG_COMPONENT("PoreArm39", mcposaPoreArm39, mcrotaPoreArm39)
  mccomp_posa[44] = mcposaPoreArm39;
  mccomp_posr[44] = mcposrPoreArm39;
  mcNCounter[44]  = mcPCounter[44] = mcP2Counter[44] = 0;
  mcAbsorbProp[44]= 0;
    /* Component PoreArm40. */
  /* Setting parameters for component PoreArm40. */
  SIG_MESSAGE("PoreArm40 (Init:SetPar)");

  SIG_MESSAGE("PoreArm40 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm40,
#line 399 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 399 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 399 "instruments/plate49.instr"
    (poreAngleDegrees [ 40 ] -90)*DEG2RAD);
#line 18207 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm39, mctr1);
  rot_mul(mcrotaPoreArm40, mctr1, mcrotrPoreArm40);
  mcposaPoreArm40 = coords_set(
#line 398 "instruments/plate49.instr"
    0,
#line 398 "instruments/plate49.instr"
    0,
#line 398 "instruments/plate49.instr"
    0);
#line 18217 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm39, mcposaPoreArm40);
  mcposrPoreArm40 = rot_apply(mcrotaPoreArm40, mctc1);
  mcDEBUG_COMPONENT("PoreArm40", mcposaPoreArm40, mcrotaPoreArm40)
  mccomp_posa[45] = mcposaPoreArm40;
  mccomp_posr[45] = mcposrPoreArm40;
  mcNCounter[45]  = mcPCounter[45] = mcP2Counter[45] = 0;
  mcAbsorbProp[45]= 0;
    /* Component PoreArm41. */
  /* Setting parameters for component PoreArm41. */
  SIG_MESSAGE("PoreArm41 (Init:SetPar)");

  SIG_MESSAGE("PoreArm41 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm41,
#line 403 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 403 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 403 "instruments/plate49.instr"
    (poreAngleDegrees [ 41 ] -90)*DEG2RAD);
#line 18237 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm40, mctr1);
  rot_mul(mcrotaPoreArm41, mctr1, mcrotrPoreArm41);
  mcposaPoreArm41 = coords_set(
#line 402 "instruments/plate49.instr"
    0,
#line 402 "instruments/plate49.instr"
    0,
#line 402 "instruments/plate49.instr"
    0);
#line 18247 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm40, mcposaPoreArm41);
  mcposrPoreArm41 = rot_apply(mcrotaPoreArm41, mctc1);
  mcDEBUG_COMPONENT("PoreArm41", mcposaPoreArm41, mcrotaPoreArm41)
  mccomp_posa[46] = mcposaPoreArm41;
  mccomp_posr[46] = mcposrPoreArm41;
  mcNCounter[46]  = mcPCounter[46] = mcP2Counter[46] = 0;
  mcAbsorbProp[46]= 0;
    /* Component PoreArm42. */
  /* Setting parameters for component PoreArm42. */
  SIG_MESSAGE("PoreArm42 (Init:SetPar)");

  SIG_MESSAGE("PoreArm42 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm42,
#line 407 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 407 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 407 "instruments/plate49.instr"
    (poreAngleDegrees [ 42 ] -90)*DEG2RAD);
#line 18267 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm41, mctr1);
  rot_mul(mcrotaPoreArm42, mctr1, mcrotrPoreArm42);
  mcposaPoreArm42 = coords_set(
#line 406 "instruments/plate49.instr"
    0,
#line 406 "instruments/plate49.instr"
    0,
#line 406 "instruments/plate49.instr"
    0);
#line 18277 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm41, mcposaPoreArm42);
  mcposrPoreArm42 = rot_apply(mcrotaPoreArm42, mctc1);
  mcDEBUG_COMPONENT("PoreArm42", mcposaPoreArm42, mcrotaPoreArm42)
  mccomp_posa[47] = mcposaPoreArm42;
  mccomp_posr[47] = mcposrPoreArm42;
  mcNCounter[47]  = mcPCounter[47] = mcP2Counter[47] = 0;
  mcAbsorbProp[47]= 0;
    /* Component PoreArm43. */
  /* Setting parameters for component PoreArm43. */
  SIG_MESSAGE("PoreArm43 (Init:SetPar)");

  SIG_MESSAGE("PoreArm43 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm43,
#line 411 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 411 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 411 "instruments/plate49.instr"
    (poreAngleDegrees [ 43 ] -90)*DEG2RAD);
#line 18297 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm42, mctr1);
  rot_mul(mcrotaPoreArm43, mctr1, mcrotrPoreArm43);
  mcposaPoreArm43 = coords_set(
#line 410 "instruments/plate49.instr"
    0,
#line 410 "instruments/plate49.instr"
    0,
#line 410 "instruments/plate49.instr"
    0);
#line 18307 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm42, mcposaPoreArm43);
  mcposrPoreArm43 = rot_apply(mcrotaPoreArm43, mctc1);
  mcDEBUG_COMPONENT("PoreArm43", mcposaPoreArm43, mcrotaPoreArm43)
  mccomp_posa[48] = mcposaPoreArm43;
  mccomp_posr[48] = mcposrPoreArm43;
  mcNCounter[48]  = mcPCounter[48] = mcP2Counter[48] = 0;
  mcAbsorbProp[48]= 0;
    /* Component PoreArm44. */
  /* Setting parameters for component PoreArm44. */
  SIG_MESSAGE("PoreArm44 (Init:SetPar)");

  SIG_MESSAGE("PoreArm44 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm44,
#line 415 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 415 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 415 "instruments/plate49.instr"
    (poreAngleDegrees [ 44 ] -90)*DEG2RAD);
#line 18327 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm43, mctr1);
  rot_mul(mcrotaPoreArm44, mctr1, mcrotrPoreArm44);
  mcposaPoreArm44 = coords_set(
#line 414 "instruments/plate49.instr"
    0,
#line 414 "instruments/plate49.instr"
    0,
#line 414 "instruments/plate49.instr"
    0);
#line 18337 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm43, mcposaPoreArm44);
  mcposrPoreArm44 = rot_apply(mcrotaPoreArm44, mctc1);
  mcDEBUG_COMPONENT("PoreArm44", mcposaPoreArm44, mcrotaPoreArm44)
  mccomp_posa[49] = mcposaPoreArm44;
  mccomp_posr[49] = mcposrPoreArm44;
  mcNCounter[49]  = mcPCounter[49] = mcP2Counter[49] = 0;
  mcAbsorbProp[49]= 0;
    /* Component PoreArm45. */
  /* Setting parameters for component PoreArm45. */
  SIG_MESSAGE("PoreArm45 (Init:SetPar)");

  SIG_MESSAGE("PoreArm45 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm45,
#line 419 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 419 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 419 "instruments/plate49.instr"
    (poreAngleDegrees [ 45 ] -90)*DEG2RAD);
#line 18357 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm44, mctr1);
  rot_mul(mcrotaPoreArm45, mctr1, mcrotrPoreArm45);
  mcposaPoreArm45 = coords_set(
#line 418 "instruments/plate49.instr"
    0,
#line 418 "instruments/plate49.instr"
    0,
#line 418 "instruments/plate49.instr"
    0);
#line 18367 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm44, mcposaPoreArm45);
  mcposrPoreArm45 = rot_apply(mcrotaPoreArm45, mctc1);
  mcDEBUG_COMPONENT("PoreArm45", mcposaPoreArm45, mcrotaPoreArm45)
  mccomp_posa[50] = mcposaPoreArm45;
  mccomp_posr[50] = mcposrPoreArm45;
  mcNCounter[50]  = mcPCounter[50] = mcP2Counter[50] = 0;
  mcAbsorbProp[50]= 0;
    /* Component PoreArm46. */
  /* Setting parameters for component PoreArm46. */
  SIG_MESSAGE("PoreArm46 (Init:SetPar)");

  SIG_MESSAGE("PoreArm46 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm46,
#line 423 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 423 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 423 "instruments/plate49.instr"
    (poreAngleDegrees [ 46 ] -90)*DEG2RAD);
#line 18387 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm45, mctr1);
  rot_mul(mcrotaPoreArm46, mctr1, mcrotrPoreArm46);
  mcposaPoreArm46 = coords_set(
#line 422 "instruments/plate49.instr"
    0,
#line 422 "instruments/plate49.instr"
    0,
#line 422 "instruments/plate49.instr"
    0);
#line 18397 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm45, mcposaPoreArm46);
  mcposrPoreArm46 = rot_apply(mcrotaPoreArm46, mctc1);
  mcDEBUG_COMPONENT("PoreArm46", mcposaPoreArm46, mcrotaPoreArm46)
  mccomp_posa[51] = mcposaPoreArm46;
  mccomp_posr[51] = mcposrPoreArm46;
  mcNCounter[51]  = mcPCounter[51] = mcP2Counter[51] = 0;
  mcAbsorbProp[51]= 0;
    /* Component PoreArm47. */
  /* Setting parameters for component PoreArm47. */
  SIG_MESSAGE("PoreArm47 (Init:SetPar)");

  SIG_MESSAGE("PoreArm47 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm47,
#line 427 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 427 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 427 "instruments/plate49.instr"
    (poreAngleDegrees [ 47 ] -90)*DEG2RAD);
#line 18417 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm46, mctr1);
  rot_mul(mcrotaPoreArm47, mctr1, mcrotrPoreArm47);
  mcposaPoreArm47 = coords_set(
#line 426 "instruments/plate49.instr"
    0,
#line 426 "instruments/plate49.instr"
    0,
#line 426 "instruments/plate49.instr"
    0);
#line 18427 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm46, mcposaPoreArm47);
  mcposrPoreArm47 = rot_apply(mcrotaPoreArm47, mctc1);
  mcDEBUG_COMPONENT("PoreArm47", mcposaPoreArm47, mcrotaPoreArm47)
  mccomp_posa[52] = mcposaPoreArm47;
  mccomp_posr[52] = mcposrPoreArm47;
  mcNCounter[52]  = mcPCounter[52] = mcP2Counter[52] = 0;
  mcAbsorbProp[52]= 0;
    /* Component PoreArm48. */
  /* Setting parameters for component PoreArm48. */
  SIG_MESSAGE("PoreArm48 (Init:SetPar)");

  SIG_MESSAGE("PoreArm48 (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPoreArm48,
#line 431 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 431 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 431 "instruments/plate49.instr"
    (poreAngleDegrees [ 48 ] -90)*DEG2RAD);
#line 18447 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm47, mctr1);
  rot_mul(mcrotaPoreArm48, mctr1, mcrotrPoreArm48);
  mcposaPoreArm48 = coords_set(
#line 430 "instruments/plate49.instr"
    0,
#line 430 "instruments/plate49.instr"
    0,
#line 430 "instruments/plate49.instr"
    0);
#line 18457 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreArm47, mcposaPoreArm48);
  mcposrPoreArm48 = rot_apply(mcrotaPoreArm48, mctc1);
  mcDEBUG_COMPONENT("PoreArm48", mcposaPoreArm48, mcrotaPoreArm48)
  mccomp_posa[53] = mcposaPoreArm48;
  mccomp_posr[53] = mcposrPoreArm48;
  mcNCounter[53]  = mcPCounter[53] = mcP2Counter[53] = 0;
  mcAbsorbProp[53]= 0;
    /* Component PoreP0. */
  /* Setting parameters for component PoreP0. */
  SIG_MESSAGE("PoreP0 (Init:SetPar)");
#line 436 "instruments/plate49.instr"
  mccPoreP0_radius_p = radiusP;
#line 437 "instruments/plate49.instr"
  mccPoreP0_radius_m = radiusM;
#line 438 "instruments/plate49.instr"
  mccPoreP0_Z0 = FOCALLENGTH;
#line 439 "instruments/plate49.instr"
  mccPoreP0_xwidth = poreW;
#line 440 "instruments/plate49.instr"
  mccPoreP0_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP0_chamferwidth = 0;
#line 441 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP0_mirror_reflec, coating ? coating : "", 16384); else mccPoreP0_mirror_reflec[0]='\0';
#line 442 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP0_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP0_bottom_reflec[0]='\0';
#line 443 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP0_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP0_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP0_R_d = 1;
#line 444 "instruments/plate49.instr"
  mccPoreP0_absorb_sides = 0;
#line 18490 "instruments/plate49.c"

  SIG_MESSAGE("PoreP0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 446 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 446 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 446 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18500 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm0, mcrotaPoreP0);
  rot_transpose(mcrotaPoreArm48, mctr1);
  rot_mul(mcrotaPoreP0, mctr1, mcrotrPoreP0);
  mctc1 = coords_set(
#line 445 "instruments/plate49.instr"
    0,
#line 445 "instruments/plate49.instr"
    radiusM,
#line 445 "instruments/plate49.instr"
    0);
#line 18511 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP0 = coords_add(mcposaPoreArm0, mctc2);
  mctc1 = coords_sub(mcposaPoreArm48, mcposaPoreP0);
  mcposrPoreP0 = rot_apply(mcrotaPoreP0, mctc1);
  mcDEBUG_COMPONENT("PoreP0", mcposaPoreP0, mcrotaPoreP0)
  mccomp_posa[54] = mcposaPoreP0;
  mccomp_posr[54] = mcposrPoreP0;
  mcNCounter[54]  = mcPCounter[54] = mcP2Counter[54] = 0;
  mcAbsorbProp[54]= 0;
    /* Component PoreP1. */
  /* Setting parameters for component PoreP1. */
  SIG_MESSAGE("PoreP1 (Init:SetPar)");
#line 450 "instruments/plate49.instr"
  mccPoreP1_radius_p = radiusP;
#line 451 "instruments/plate49.instr"
  mccPoreP1_radius_m = radiusM;
#line 452 "instruments/plate49.instr"
  mccPoreP1_Z0 = FOCALLENGTH;
#line 453 "instruments/plate49.instr"
  mccPoreP1_xwidth = poreW;
#line 454 "instruments/plate49.instr"
  mccPoreP1_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP1_chamferwidth = 0;
#line 455 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP1_mirror_reflec, coating ? coating : "", 16384); else mccPoreP1_mirror_reflec[0]='\0';
#line 456 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP1_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP1_bottom_reflec[0]='\0';
#line 457 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP1_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP1_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP1_R_d = 1;
#line 458 "instruments/plate49.instr"
  mccPoreP1_absorb_sides = 0;
#line 18547 "instruments/plate49.c"

  SIG_MESSAGE("PoreP1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 460 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 460 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 460 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18557 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm1, mcrotaPoreP1);
  rot_transpose(mcrotaPoreP0, mctr1);
  rot_mul(mcrotaPoreP1, mctr1, mcrotrPoreP1);
  mctc1 = coords_set(
#line 459 "instruments/plate49.instr"
    0,
#line 459 "instruments/plate49.instr"
    radiusM,
#line 459 "instruments/plate49.instr"
    0);
#line 18568 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP1 = coords_add(mcposaPoreArm1, mctc2);
  mctc1 = coords_sub(mcposaPoreP0, mcposaPoreP1);
  mcposrPoreP1 = rot_apply(mcrotaPoreP1, mctc1);
  mcDEBUG_COMPONENT("PoreP1", mcposaPoreP1, mcrotaPoreP1)
  mccomp_posa[55] = mcposaPoreP1;
  mccomp_posr[55] = mcposrPoreP1;
  mcNCounter[55]  = mcPCounter[55] = mcP2Counter[55] = 0;
  mcAbsorbProp[55]= 0;
    /* Component PoreP2. */
  /* Setting parameters for component PoreP2. */
  SIG_MESSAGE("PoreP2 (Init:SetPar)");
#line 464 "instruments/plate49.instr"
  mccPoreP2_radius_p = radiusP;
#line 465 "instruments/plate49.instr"
  mccPoreP2_radius_m = radiusM;
#line 466 "instruments/plate49.instr"
  mccPoreP2_Z0 = FOCALLENGTH;
#line 467 "instruments/plate49.instr"
  mccPoreP2_xwidth = poreW;
#line 468 "instruments/plate49.instr"
  mccPoreP2_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP2_chamferwidth = 0;
#line 469 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP2_mirror_reflec, coating ? coating : "", 16384); else mccPoreP2_mirror_reflec[0]='\0';
#line 470 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP2_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP2_bottom_reflec[0]='\0';
#line 471 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP2_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP2_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP2_R_d = 1;
#line 472 "instruments/plate49.instr"
  mccPoreP2_absorb_sides = 0;
#line 18604 "instruments/plate49.c"

  SIG_MESSAGE("PoreP2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 474 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 474 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 474 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18614 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm2, mcrotaPoreP2);
  rot_transpose(mcrotaPoreP1, mctr1);
  rot_mul(mcrotaPoreP2, mctr1, mcrotrPoreP2);
  mctc1 = coords_set(
#line 473 "instruments/plate49.instr"
    0,
#line 473 "instruments/plate49.instr"
    radiusM,
#line 473 "instruments/plate49.instr"
    0);
#line 18625 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP2 = coords_add(mcposaPoreArm2, mctc2);
  mctc1 = coords_sub(mcposaPoreP1, mcposaPoreP2);
  mcposrPoreP2 = rot_apply(mcrotaPoreP2, mctc1);
  mcDEBUG_COMPONENT("PoreP2", mcposaPoreP2, mcrotaPoreP2)
  mccomp_posa[56] = mcposaPoreP2;
  mccomp_posr[56] = mcposrPoreP2;
  mcNCounter[56]  = mcPCounter[56] = mcP2Counter[56] = 0;
  mcAbsorbProp[56]= 0;
    /* Component PoreP3. */
  /* Setting parameters for component PoreP3. */
  SIG_MESSAGE("PoreP3 (Init:SetPar)");
#line 478 "instruments/plate49.instr"
  mccPoreP3_radius_p = radiusP;
#line 479 "instruments/plate49.instr"
  mccPoreP3_radius_m = radiusM;
#line 480 "instruments/plate49.instr"
  mccPoreP3_Z0 = FOCALLENGTH;
#line 481 "instruments/plate49.instr"
  mccPoreP3_xwidth = poreW;
#line 482 "instruments/plate49.instr"
  mccPoreP3_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP3_chamferwidth = 0;
#line 483 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP3_mirror_reflec, coating ? coating : "", 16384); else mccPoreP3_mirror_reflec[0]='\0';
#line 484 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP3_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP3_bottom_reflec[0]='\0';
#line 485 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP3_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP3_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP3_R_d = 1;
#line 486 "instruments/plate49.instr"
  mccPoreP3_absorb_sides = 0;
#line 18661 "instruments/plate49.c"

  SIG_MESSAGE("PoreP3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 488 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 488 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 488 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18671 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm3, mcrotaPoreP3);
  rot_transpose(mcrotaPoreP2, mctr1);
  rot_mul(mcrotaPoreP3, mctr1, mcrotrPoreP3);
  mctc1 = coords_set(
#line 487 "instruments/plate49.instr"
    0,
#line 487 "instruments/plate49.instr"
    radiusM,
#line 487 "instruments/plate49.instr"
    0);
#line 18682 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP3 = coords_add(mcposaPoreArm3, mctc2);
  mctc1 = coords_sub(mcposaPoreP2, mcposaPoreP3);
  mcposrPoreP3 = rot_apply(mcrotaPoreP3, mctc1);
  mcDEBUG_COMPONENT("PoreP3", mcposaPoreP3, mcrotaPoreP3)
  mccomp_posa[57] = mcposaPoreP3;
  mccomp_posr[57] = mcposrPoreP3;
  mcNCounter[57]  = mcPCounter[57] = mcP2Counter[57] = 0;
  mcAbsorbProp[57]= 0;
    /* Component PoreP4. */
  /* Setting parameters for component PoreP4. */
  SIG_MESSAGE("PoreP4 (Init:SetPar)");
#line 492 "instruments/plate49.instr"
  mccPoreP4_radius_p = radiusP;
#line 493 "instruments/plate49.instr"
  mccPoreP4_radius_m = radiusM;
#line 494 "instruments/plate49.instr"
  mccPoreP4_Z0 = FOCALLENGTH;
#line 495 "instruments/plate49.instr"
  mccPoreP4_xwidth = poreW;
#line 496 "instruments/plate49.instr"
  mccPoreP4_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP4_chamferwidth = 0;
#line 497 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP4_mirror_reflec, coating ? coating : "", 16384); else mccPoreP4_mirror_reflec[0]='\0';
#line 498 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP4_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP4_bottom_reflec[0]='\0';
#line 499 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP4_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP4_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP4_R_d = 1;
#line 500 "instruments/plate49.instr"
  mccPoreP4_absorb_sides = 0;
#line 18718 "instruments/plate49.c"

  SIG_MESSAGE("PoreP4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 502 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 502 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 502 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18728 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm4, mcrotaPoreP4);
  rot_transpose(mcrotaPoreP3, mctr1);
  rot_mul(mcrotaPoreP4, mctr1, mcrotrPoreP4);
  mctc1 = coords_set(
#line 501 "instruments/plate49.instr"
    0,
#line 501 "instruments/plate49.instr"
    radiusM,
#line 501 "instruments/plate49.instr"
    0);
#line 18739 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP4 = coords_add(mcposaPoreArm4, mctc2);
  mctc1 = coords_sub(mcposaPoreP3, mcposaPoreP4);
  mcposrPoreP4 = rot_apply(mcrotaPoreP4, mctc1);
  mcDEBUG_COMPONENT("PoreP4", mcposaPoreP4, mcrotaPoreP4)
  mccomp_posa[58] = mcposaPoreP4;
  mccomp_posr[58] = mcposrPoreP4;
  mcNCounter[58]  = mcPCounter[58] = mcP2Counter[58] = 0;
  mcAbsorbProp[58]= 0;
    /* Component PoreP5. */
  /* Setting parameters for component PoreP5. */
  SIG_MESSAGE("PoreP5 (Init:SetPar)");
#line 506 "instruments/plate49.instr"
  mccPoreP5_radius_p = radiusP;
#line 507 "instruments/plate49.instr"
  mccPoreP5_radius_m = radiusM;
#line 508 "instruments/plate49.instr"
  mccPoreP5_Z0 = FOCALLENGTH;
#line 509 "instruments/plate49.instr"
  mccPoreP5_xwidth = poreW;
#line 510 "instruments/plate49.instr"
  mccPoreP5_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP5_chamferwidth = 0;
#line 511 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP5_mirror_reflec, coating ? coating : "", 16384); else mccPoreP5_mirror_reflec[0]='\0';
#line 512 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP5_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP5_bottom_reflec[0]='\0';
#line 513 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP5_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP5_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP5_R_d = 1;
#line 514 "instruments/plate49.instr"
  mccPoreP5_absorb_sides = 0;
#line 18775 "instruments/plate49.c"

  SIG_MESSAGE("PoreP5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 516 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 516 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 516 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18785 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm5, mcrotaPoreP5);
  rot_transpose(mcrotaPoreP4, mctr1);
  rot_mul(mcrotaPoreP5, mctr1, mcrotrPoreP5);
  mctc1 = coords_set(
#line 515 "instruments/plate49.instr"
    0,
#line 515 "instruments/plate49.instr"
    radiusM,
#line 515 "instruments/plate49.instr"
    0);
#line 18796 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP5 = coords_add(mcposaPoreArm5, mctc2);
  mctc1 = coords_sub(mcposaPoreP4, mcposaPoreP5);
  mcposrPoreP5 = rot_apply(mcrotaPoreP5, mctc1);
  mcDEBUG_COMPONENT("PoreP5", mcposaPoreP5, mcrotaPoreP5)
  mccomp_posa[59] = mcposaPoreP5;
  mccomp_posr[59] = mcposrPoreP5;
  mcNCounter[59]  = mcPCounter[59] = mcP2Counter[59] = 0;
  mcAbsorbProp[59]= 0;
    /* Component PoreP6. */
  /* Setting parameters for component PoreP6. */
  SIG_MESSAGE("PoreP6 (Init:SetPar)");
#line 520 "instruments/plate49.instr"
  mccPoreP6_radius_p = radiusP;
#line 521 "instruments/plate49.instr"
  mccPoreP6_radius_m = radiusM;
#line 522 "instruments/plate49.instr"
  mccPoreP6_Z0 = FOCALLENGTH;
#line 523 "instruments/plate49.instr"
  mccPoreP6_xwidth = poreW;
#line 524 "instruments/plate49.instr"
  mccPoreP6_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP6_chamferwidth = 0;
#line 525 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP6_mirror_reflec, coating ? coating : "", 16384); else mccPoreP6_mirror_reflec[0]='\0';
#line 526 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP6_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP6_bottom_reflec[0]='\0';
#line 527 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP6_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP6_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP6_R_d = 1;
#line 528 "instruments/plate49.instr"
  mccPoreP6_absorb_sides = 0;
#line 18832 "instruments/plate49.c"

  SIG_MESSAGE("PoreP6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 530 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 530 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 530 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18842 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm6, mcrotaPoreP6);
  rot_transpose(mcrotaPoreP5, mctr1);
  rot_mul(mcrotaPoreP6, mctr1, mcrotrPoreP6);
  mctc1 = coords_set(
#line 529 "instruments/plate49.instr"
    0,
#line 529 "instruments/plate49.instr"
    radiusM,
#line 529 "instruments/plate49.instr"
    0);
#line 18853 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP6 = coords_add(mcposaPoreArm6, mctc2);
  mctc1 = coords_sub(mcposaPoreP5, mcposaPoreP6);
  mcposrPoreP6 = rot_apply(mcrotaPoreP6, mctc1);
  mcDEBUG_COMPONENT("PoreP6", mcposaPoreP6, mcrotaPoreP6)
  mccomp_posa[60] = mcposaPoreP6;
  mccomp_posr[60] = mcposrPoreP6;
  mcNCounter[60]  = mcPCounter[60] = mcP2Counter[60] = 0;
  mcAbsorbProp[60]= 0;
    /* Component PoreP7. */
  /* Setting parameters for component PoreP7. */
  SIG_MESSAGE("PoreP7 (Init:SetPar)");
#line 534 "instruments/plate49.instr"
  mccPoreP7_radius_p = radiusP;
#line 535 "instruments/plate49.instr"
  mccPoreP7_radius_m = radiusM;
#line 536 "instruments/plate49.instr"
  mccPoreP7_Z0 = FOCALLENGTH;
#line 537 "instruments/plate49.instr"
  mccPoreP7_xwidth = poreW;
#line 538 "instruments/plate49.instr"
  mccPoreP7_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP7_chamferwidth = 0;
#line 539 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP7_mirror_reflec, coating ? coating : "", 16384); else mccPoreP7_mirror_reflec[0]='\0';
#line 540 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP7_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP7_bottom_reflec[0]='\0';
#line 541 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP7_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP7_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP7_R_d = 1;
#line 542 "instruments/plate49.instr"
  mccPoreP7_absorb_sides = 0;
#line 18889 "instruments/plate49.c"

  SIG_MESSAGE("PoreP7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 544 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 544 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 544 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18899 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm7, mcrotaPoreP7);
  rot_transpose(mcrotaPoreP6, mctr1);
  rot_mul(mcrotaPoreP7, mctr1, mcrotrPoreP7);
  mctc1 = coords_set(
#line 543 "instruments/plate49.instr"
    0,
#line 543 "instruments/plate49.instr"
    radiusM,
#line 543 "instruments/plate49.instr"
    0);
#line 18910 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm7, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP7 = coords_add(mcposaPoreArm7, mctc2);
  mctc1 = coords_sub(mcposaPoreP6, mcposaPoreP7);
  mcposrPoreP7 = rot_apply(mcrotaPoreP7, mctc1);
  mcDEBUG_COMPONENT("PoreP7", mcposaPoreP7, mcrotaPoreP7)
  mccomp_posa[61] = mcposaPoreP7;
  mccomp_posr[61] = mcposrPoreP7;
  mcNCounter[61]  = mcPCounter[61] = mcP2Counter[61] = 0;
  mcAbsorbProp[61]= 0;
    /* Component PoreP8. */
  /* Setting parameters for component PoreP8. */
  SIG_MESSAGE("PoreP8 (Init:SetPar)");
#line 548 "instruments/plate49.instr"
  mccPoreP8_radius_p = radiusP;
#line 549 "instruments/plate49.instr"
  mccPoreP8_radius_m = radiusM;
#line 550 "instruments/plate49.instr"
  mccPoreP8_Z0 = FOCALLENGTH;
#line 551 "instruments/plate49.instr"
  mccPoreP8_xwidth = poreW;
#line 552 "instruments/plate49.instr"
  mccPoreP8_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP8_chamferwidth = 0;
#line 553 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP8_mirror_reflec, coating ? coating : "", 16384); else mccPoreP8_mirror_reflec[0]='\0';
#line 554 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP8_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP8_bottom_reflec[0]='\0';
#line 555 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP8_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP8_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP8_R_d = 1;
#line 556 "instruments/plate49.instr"
  mccPoreP8_absorb_sides = 0;
#line 18946 "instruments/plate49.c"

  SIG_MESSAGE("PoreP8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 558 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 558 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 558 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 18956 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm8, mcrotaPoreP8);
  rot_transpose(mcrotaPoreP7, mctr1);
  rot_mul(mcrotaPoreP8, mctr1, mcrotrPoreP8);
  mctc1 = coords_set(
#line 557 "instruments/plate49.instr"
    0,
#line 557 "instruments/plate49.instr"
    radiusM,
#line 557 "instruments/plate49.instr"
    0);
#line 18967 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm8, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP8 = coords_add(mcposaPoreArm8, mctc2);
  mctc1 = coords_sub(mcposaPoreP7, mcposaPoreP8);
  mcposrPoreP8 = rot_apply(mcrotaPoreP8, mctc1);
  mcDEBUG_COMPONENT("PoreP8", mcposaPoreP8, mcrotaPoreP8)
  mccomp_posa[62] = mcposaPoreP8;
  mccomp_posr[62] = mcposrPoreP8;
  mcNCounter[62]  = mcPCounter[62] = mcP2Counter[62] = 0;
  mcAbsorbProp[62]= 0;
    /* Component PoreP9. */
  /* Setting parameters for component PoreP9. */
  SIG_MESSAGE("PoreP9 (Init:SetPar)");
#line 562 "instruments/plate49.instr"
  mccPoreP9_radius_p = radiusP;
#line 563 "instruments/plate49.instr"
  mccPoreP9_radius_m = radiusM;
#line 564 "instruments/plate49.instr"
  mccPoreP9_Z0 = FOCALLENGTH;
#line 565 "instruments/plate49.instr"
  mccPoreP9_xwidth = poreW;
#line 566 "instruments/plate49.instr"
  mccPoreP9_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP9_chamferwidth = 0;
#line 567 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP9_mirror_reflec, coating ? coating : "", 16384); else mccPoreP9_mirror_reflec[0]='\0';
#line 568 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP9_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP9_bottom_reflec[0]='\0';
#line 569 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP9_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP9_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP9_R_d = 1;
#line 570 "instruments/plate49.instr"
  mccPoreP9_absorb_sides = 0;
#line 19003 "instruments/plate49.c"

  SIG_MESSAGE("PoreP9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 572 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 572 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 572 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19013 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm9, mcrotaPoreP9);
  rot_transpose(mcrotaPoreP8, mctr1);
  rot_mul(mcrotaPoreP9, mctr1, mcrotrPoreP9);
  mctc1 = coords_set(
#line 571 "instruments/plate49.instr"
    0,
#line 571 "instruments/plate49.instr"
    radiusM,
#line 571 "instruments/plate49.instr"
    0);
#line 19024 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm9, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP9 = coords_add(mcposaPoreArm9, mctc2);
  mctc1 = coords_sub(mcposaPoreP8, mcposaPoreP9);
  mcposrPoreP9 = rot_apply(mcrotaPoreP9, mctc1);
  mcDEBUG_COMPONENT("PoreP9", mcposaPoreP9, mcrotaPoreP9)
  mccomp_posa[63] = mcposaPoreP9;
  mccomp_posr[63] = mcposrPoreP9;
  mcNCounter[63]  = mcPCounter[63] = mcP2Counter[63] = 0;
  mcAbsorbProp[63]= 0;
    /* Component PoreP10. */
  /* Setting parameters for component PoreP10. */
  SIG_MESSAGE("PoreP10 (Init:SetPar)");
#line 576 "instruments/plate49.instr"
  mccPoreP10_radius_p = radiusP;
#line 577 "instruments/plate49.instr"
  mccPoreP10_radius_m = radiusM;
#line 578 "instruments/plate49.instr"
  mccPoreP10_Z0 = FOCALLENGTH;
#line 579 "instruments/plate49.instr"
  mccPoreP10_xwidth = poreW;
#line 580 "instruments/plate49.instr"
  mccPoreP10_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP10_chamferwidth = 0;
#line 581 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP10_mirror_reflec, coating ? coating : "", 16384); else mccPoreP10_mirror_reflec[0]='\0';
#line 582 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP10_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP10_bottom_reflec[0]='\0';
#line 583 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP10_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP10_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP10_R_d = 1;
#line 584 "instruments/plate49.instr"
  mccPoreP10_absorb_sides = 0;
#line 19060 "instruments/plate49.c"

  SIG_MESSAGE("PoreP10 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 586 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 586 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 586 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19070 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm10, mcrotaPoreP10);
  rot_transpose(mcrotaPoreP9, mctr1);
  rot_mul(mcrotaPoreP10, mctr1, mcrotrPoreP10);
  mctc1 = coords_set(
#line 585 "instruments/plate49.instr"
    0,
#line 585 "instruments/plate49.instr"
    radiusM,
#line 585 "instruments/plate49.instr"
    0);
#line 19081 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm10, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP10 = coords_add(mcposaPoreArm10, mctc2);
  mctc1 = coords_sub(mcposaPoreP9, mcposaPoreP10);
  mcposrPoreP10 = rot_apply(mcrotaPoreP10, mctc1);
  mcDEBUG_COMPONENT("PoreP10", mcposaPoreP10, mcrotaPoreP10)
  mccomp_posa[64] = mcposaPoreP10;
  mccomp_posr[64] = mcposrPoreP10;
  mcNCounter[64]  = mcPCounter[64] = mcP2Counter[64] = 0;
  mcAbsorbProp[64]= 0;
    /* Component PoreP11. */
  /* Setting parameters for component PoreP11. */
  SIG_MESSAGE("PoreP11 (Init:SetPar)");
#line 590 "instruments/plate49.instr"
  mccPoreP11_radius_p = radiusP;
#line 591 "instruments/plate49.instr"
  mccPoreP11_radius_m = radiusM;
#line 592 "instruments/plate49.instr"
  mccPoreP11_Z0 = FOCALLENGTH;
#line 593 "instruments/plate49.instr"
  mccPoreP11_xwidth = poreW;
#line 594 "instruments/plate49.instr"
  mccPoreP11_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP11_chamferwidth = 0;
#line 595 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP11_mirror_reflec, coating ? coating : "", 16384); else mccPoreP11_mirror_reflec[0]='\0';
#line 596 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP11_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP11_bottom_reflec[0]='\0';
#line 597 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP11_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP11_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP11_R_d = 1;
#line 598 "instruments/plate49.instr"
  mccPoreP11_absorb_sides = 0;
#line 19117 "instruments/plate49.c"

  SIG_MESSAGE("PoreP11 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 600 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 600 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 600 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19127 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm11, mcrotaPoreP11);
  rot_transpose(mcrotaPoreP10, mctr1);
  rot_mul(mcrotaPoreP11, mctr1, mcrotrPoreP11);
  mctc1 = coords_set(
#line 599 "instruments/plate49.instr"
    0,
#line 599 "instruments/plate49.instr"
    radiusM,
#line 599 "instruments/plate49.instr"
    0);
#line 19138 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm11, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP11 = coords_add(mcposaPoreArm11, mctc2);
  mctc1 = coords_sub(mcposaPoreP10, mcposaPoreP11);
  mcposrPoreP11 = rot_apply(mcrotaPoreP11, mctc1);
  mcDEBUG_COMPONENT("PoreP11", mcposaPoreP11, mcrotaPoreP11)
  mccomp_posa[65] = mcposaPoreP11;
  mccomp_posr[65] = mcposrPoreP11;
  mcNCounter[65]  = mcPCounter[65] = mcP2Counter[65] = 0;
  mcAbsorbProp[65]= 0;
    /* Component PoreP12. */
  /* Setting parameters for component PoreP12. */
  SIG_MESSAGE("PoreP12 (Init:SetPar)");
#line 604 "instruments/plate49.instr"
  mccPoreP12_radius_p = radiusP;
#line 605 "instruments/plate49.instr"
  mccPoreP12_radius_m = radiusM;
#line 606 "instruments/plate49.instr"
  mccPoreP12_Z0 = FOCALLENGTH;
#line 607 "instruments/plate49.instr"
  mccPoreP12_xwidth = poreW;
#line 608 "instruments/plate49.instr"
  mccPoreP12_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP12_chamferwidth = 0;
#line 609 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP12_mirror_reflec, coating ? coating : "", 16384); else mccPoreP12_mirror_reflec[0]='\0';
#line 610 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP12_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP12_bottom_reflec[0]='\0';
#line 611 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP12_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP12_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP12_R_d = 1;
#line 612 "instruments/plate49.instr"
  mccPoreP12_absorb_sides = 0;
#line 19174 "instruments/plate49.c"

  SIG_MESSAGE("PoreP12 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 614 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 614 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 614 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19184 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm12, mcrotaPoreP12);
  rot_transpose(mcrotaPoreP11, mctr1);
  rot_mul(mcrotaPoreP12, mctr1, mcrotrPoreP12);
  mctc1 = coords_set(
#line 613 "instruments/plate49.instr"
    0,
#line 613 "instruments/plate49.instr"
    radiusM,
#line 613 "instruments/plate49.instr"
    0);
#line 19195 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm12, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP12 = coords_add(mcposaPoreArm12, mctc2);
  mctc1 = coords_sub(mcposaPoreP11, mcposaPoreP12);
  mcposrPoreP12 = rot_apply(mcrotaPoreP12, mctc1);
  mcDEBUG_COMPONENT("PoreP12", mcposaPoreP12, mcrotaPoreP12)
  mccomp_posa[66] = mcposaPoreP12;
  mccomp_posr[66] = mcposrPoreP12;
  mcNCounter[66]  = mcPCounter[66] = mcP2Counter[66] = 0;
  mcAbsorbProp[66]= 0;
    /* Component PoreP13. */
  /* Setting parameters for component PoreP13. */
  SIG_MESSAGE("PoreP13 (Init:SetPar)");
#line 618 "instruments/plate49.instr"
  mccPoreP13_radius_p = radiusP;
#line 619 "instruments/plate49.instr"
  mccPoreP13_radius_m = radiusM;
#line 620 "instruments/plate49.instr"
  mccPoreP13_Z0 = FOCALLENGTH;
#line 621 "instruments/plate49.instr"
  mccPoreP13_xwidth = poreW;
#line 622 "instruments/plate49.instr"
  mccPoreP13_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP13_chamferwidth = 0;
#line 623 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP13_mirror_reflec, coating ? coating : "", 16384); else mccPoreP13_mirror_reflec[0]='\0';
#line 624 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP13_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP13_bottom_reflec[0]='\0';
#line 625 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP13_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP13_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP13_R_d = 1;
#line 626 "instruments/plate49.instr"
  mccPoreP13_absorb_sides = 0;
#line 19231 "instruments/plate49.c"

  SIG_MESSAGE("PoreP13 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 628 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 628 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 628 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19241 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm13, mcrotaPoreP13);
  rot_transpose(mcrotaPoreP12, mctr1);
  rot_mul(mcrotaPoreP13, mctr1, mcrotrPoreP13);
  mctc1 = coords_set(
#line 627 "instruments/plate49.instr"
    0,
#line 627 "instruments/plate49.instr"
    radiusM,
#line 627 "instruments/plate49.instr"
    0);
#line 19252 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm13, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP13 = coords_add(mcposaPoreArm13, mctc2);
  mctc1 = coords_sub(mcposaPoreP12, mcposaPoreP13);
  mcposrPoreP13 = rot_apply(mcrotaPoreP13, mctc1);
  mcDEBUG_COMPONENT("PoreP13", mcposaPoreP13, mcrotaPoreP13)
  mccomp_posa[67] = mcposaPoreP13;
  mccomp_posr[67] = mcposrPoreP13;
  mcNCounter[67]  = mcPCounter[67] = mcP2Counter[67] = 0;
  mcAbsorbProp[67]= 0;
    /* Component PoreP14. */
  /* Setting parameters for component PoreP14. */
  SIG_MESSAGE("PoreP14 (Init:SetPar)");
#line 632 "instruments/plate49.instr"
  mccPoreP14_radius_p = radiusP;
#line 633 "instruments/plate49.instr"
  mccPoreP14_radius_m = radiusM;
#line 634 "instruments/plate49.instr"
  mccPoreP14_Z0 = FOCALLENGTH;
#line 635 "instruments/plate49.instr"
  mccPoreP14_xwidth = poreW;
#line 636 "instruments/plate49.instr"
  mccPoreP14_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP14_chamferwidth = 0;
#line 637 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP14_mirror_reflec, coating ? coating : "", 16384); else mccPoreP14_mirror_reflec[0]='\0';
#line 638 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP14_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP14_bottom_reflec[0]='\0';
#line 639 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP14_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP14_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP14_R_d = 1;
#line 640 "instruments/plate49.instr"
  mccPoreP14_absorb_sides = 0;
#line 19288 "instruments/plate49.c"

  SIG_MESSAGE("PoreP14 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 642 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 642 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 642 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19298 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm14, mcrotaPoreP14);
  rot_transpose(mcrotaPoreP13, mctr1);
  rot_mul(mcrotaPoreP14, mctr1, mcrotrPoreP14);
  mctc1 = coords_set(
#line 641 "instruments/plate49.instr"
    0,
#line 641 "instruments/plate49.instr"
    radiusM,
#line 641 "instruments/plate49.instr"
    0);
#line 19309 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm14, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP14 = coords_add(mcposaPoreArm14, mctc2);
  mctc1 = coords_sub(mcposaPoreP13, mcposaPoreP14);
  mcposrPoreP14 = rot_apply(mcrotaPoreP14, mctc1);
  mcDEBUG_COMPONENT("PoreP14", mcposaPoreP14, mcrotaPoreP14)
  mccomp_posa[68] = mcposaPoreP14;
  mccomp_posr[68] = mcposrPoreP14;
  mcNCounter[68]  = mcPCounter[68] = mcP2Counter[68] = 0;
  mcAbsorbProp[68]= 0;
    /* Component PoreP15. */
  /* Setting parameters for component PoreP15. */
  SIG_MESSAGE("PoreP15 (Init:SetPar)");
#line 646 "instruments/plate49.instr"
  mccPoreP15_radius_p = radiusP;
#line 647 "instruments/plate49.instr"
  mccPoreP15_radius_m = radiusM;
#line 648 "instruments/plate49.instr"
  mccPoreP15_Z0 = FOCALLENGTH;
#line 649 "instruments/plate49.instr"
  mccPoreP15_xwidth = poreW;
#line 650 "instruments/plate49.instr"
  mccPoreP15_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP15_chamferwidth = 0;
#line 651 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP15_mirror_reflec, coating ? coating : "", 16384); else mccPoreP15_mirror_reflec[0]='\0';
#line 652 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP15_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP15_bottom_reflec[0]='\0';
#line 653 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP15_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP15_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP15_R_d = 1;
#line 654 "instruments/plate49.instr"
  mccPoreP15_absorb_sides = 0;
#line 19345 "instruments/plate49.c"

  SIG_MESSAGE("PoreP15 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 656 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 656 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 656 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19355 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm15, mcrotaPoreP15);
  rot_transpose(mcrotaPoreP14, mctr1);
  rot_mul(mcrotaPoreP15, mctr1, mcrotrPoreP15);
  mctc1 = coords_set(
#line 655 "instruments/plate49.instr"
    0,
#line 655 "instruments/plate49.instr"
    radiusM,
#line 655 "instruments/plate49.instr"
    0);
#line 19366 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm15, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP15 = coords_add(mcposaPoreArm15, mctc2);
  mctc1 = coords_sub(mcposaPoreP14, mcposaPoreP15);
  mcposrPoreP15 = rot_apply(mcrotaPoreP15, mctc1);
  mcDEBUG_COMPONENT("PoreP15", mcposaPoreP15, mcrotaPoreP15)
  mccomp_posa[69] = mcposaPoreP15;
  mccomp_posr[69] = mcposrPoreP15;
  mcNCounter[69]  = mcPCounter[69] = mcP2Counter[69] = 0;
  mcAbsorbProp[69]= 0;
    /* Component PoreP16. */
  /* Setting parameters for component PoreP16. */
  SIG_MESSAGE("PoreP16 (Init:SetPar)");
#line 660 "instruments/plate49.instr"
  mccPoreP16_radius_p = radiusP;
#line 661 "instruments/plate49.instr"
  mccPoreP16_radius_m = radiusM;
#line 662 "instruments/plate49.instr"
  mccPoreP16_Z0 = FOCALLENGTH;
#line 663 "instruments/plate49.instr"
  mccPoreP16_xwidth = poreW;
#line 664 "instruments/plate49.instr"
  mccPoreP16_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP16_chamferwidth = 0;
#line 665 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP16_mirror_reflec, coating ? coating : "", 16384); else mccPoreP16_mirror_reflec[0]='\0';
#line 666 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP16_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP16_bottom_reflec[0]='\0';
#line 667 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP16_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP16_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP16_R_d = 1;
#line 668 "instruments/plate49.instr"
  mccPoreP16_absorb_sides = 0;
#line 19402 "instruments/plate49.c"

  SIG_MESSAGE("PoreP16 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 670 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 670 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 670 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19412 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm16, mcrotaPoreP16);
  rot_transpose(mcrotaPoreP15, mctr1);
  rot_mul(mcrotaPoreP16, mctr1, mcrotrPoreP16);
  mctc1 = coords_set(
#line 669 "instruments/plate49.instr"
    0,
#line 669 "instruments/plate49.instr"
    radiusM,
#line 669 "instruments/plate49.instr"
    0);
#line 19423 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm16, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP16 = coords_add(mcposaPoreArm16, mctc2);
  mctc1 = coords_sub(mcposaPoreP15, mcposaPoreP16);
  mcposrPoreP16 = rot_apply(mcrotaPoreP16, mctc1);
  mcDEBUG_COMPONENT("PoreP16", mcposaPoreP16, mcrotaPoreP16)
  mccomp_posa[70] = mcposaPoreP16;
  mccomp_posr[70] = mcposrPoreP16;
  mcNCounter[70]  = mcPCounter[70] = mcP2Counter[70] = 0;
  mcAbsorbProp[70]= 0;
    /* Component PoreP17. */
  /* Setting parameters for component PoreP17. */
  SIG_MESSAGE("PoreP17 (Init:SetPar)");
#line 674 "instruments/plate49.instr"
  mccPoreP17_radius_p = radiusP;
#line 675 "instruments/plate49.instr"
  mccPoreP17_radius_m = radiusM;
#line 676 "instruments/plate49.instr"
  mccPoreP17_Z0 = FOCALLENGTH;
#line 677 "instruments/plate49.instr"
  mccPoreP17_xwidth = poreW;
#line 678 "instruments/plate49.instr"
  mccPoreP17_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP17_chamferwidth = 0;
#line 679 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP17_mirror_reflec, coating ? coating : "", 16384); else mccPoreP17_mirror_reflec[0]='\0';
#line 680 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP17_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP17_bottom_reflec[0]='\0';
#line 681 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP17_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP17_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP17_R_d = 1;
#line 682 "instruments/plate49.instr"
  mccPoreP17_absorb_sides = 0;
#line 19459 "instruments/plate49.c"

  SIG_MESSAGE("PoreP17 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 684 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 684 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 684 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19469 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm17, mcrotaPoreP17);
  rot_transpose(mcrotaPoreP16, mctr1);
  rot_mul(mcrotaPoreP17, mctr1, mcrotrPoreP17);
  mctc1 = coords_set(
#line 683 "instruments/plate49.instr"
    0,
#line 683 "instruments/plate49.instr"
    radiusM,
#line 683 "instruments/plate49.instr"
    0);
#line 19480 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm17, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP17 = coords_add(mcposaPoreArm17, mctc2);
  mctc1 = coords_sub(mcposaPoreP16, mcposaPoreP17);
  mcposrPoreP17 = rot_apply(mcrotaPoreP17, mctc1);
  mcDEBUG_COMPONENT("PoreP17", mcposaPoreP17, mcrotaPoreP17)
  mccomp_posa[71] = mcposaPoreP17;
  mccomp_posr[71] = mcposrPoreP17;
  mcNCounter[71]  = mcPCounter[71] = mcP2Counter[71] = 0;
  mcAbsorbProp[71]= 0;
    /* Component PoreP18. */
  /* Setting parameters for component PoreP18. */
  SIG_MESSAGE("PoreP18 (Init:SetPar)");
#line 688 "instruments/plate49.instr"
  mccPoreP18_radius_p = radiusP;
#line 689 "instruments/plate49.instr"
  mccPoreP18_radius_m = radiusM;
#line 690 "instruments/plate49.instr"
  mccPoreP18_Z0 = FOCALLENGTH;
#line 691 "instruments/plate49.instr"
  mccPoreP18_xwidth = poreW;
#line 692 "instruments/plate49.instr"
  mccPoreP18_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP18_chamferwidth = 0;
#line 693 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP18_mirror_reflec, coating ? coating : "", 16384); else mccPoreP18_mirror_reflec[0]='\0';
#line 694 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP18_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP18_bottom_reflec[0]='\0';
#line 695 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP18_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP18_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP18_R_d = 1;
#line 696 "instruments/plate49.instr"
  mccPoreP18_absorb_sides = 0;
#line 19516 "instruments/plate49.c"

  SIG_MESSAGE("PoreP18 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 698 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 698 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 698 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19526 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm18, mcrotaPoreP18);
  rot_transpose(mcrotaPoreP17, mctr1);
  rot_mul(mcrotaPoreP18, mctr1, mcrotrPoreP18);
  mctc1 = coords_set(
#line 697 "instruments/plate49.instr"
    0,
#line 697 "instruments/plate49.instr"
    radiusM,
#line 697 "instruments/plate49.instr"
    0);
#line 19537 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm18, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP18 = coords_add(mcposaPoreArm18, mctc2);
  mctc1 = coords_sub(mcposaPoreP17, mcposaPoreP18);
  mcposrPoreP18 = rot_apply(mcrotaPoreP18, mctc1);
  mcDEBUG_COMPONENT("PoreP18", mcposaPoreP18, mcrotaPoreP18)
  mccomp_posa[72] = mcposaPoreP18;
  mccomp_posr[72] = mcposrPoreP18;
  mcNCounter[72]  = mcPCounter[72] = mcP2Counter[72] = 0;
  mcAbsorbProp[72]= 0;
    /* Component PoreP19. */
  /* Setting parameters for component PoreP19. */
  SIG_MESSAGE("PoreP19 (Init:SetPar)");
#line 702 "instruments/plate49.instr"
  mccPoreP19_radius_p = radiusP;
#line 703 "instruments/plate49.instr"
  mccPoreP19_radius_m = radiusM;
#line 704 "instruments/plate49.instr"
  mccPoreP19_Z0 = FOCALLENGTH;
#line 705 "instruments/plate49.instr"
  mccPoreP19_xwidth = poreW;
#line 706 "instruments/plate49.instr"
  mccPoreP19_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP19_chamferwidth = 0;
#line 707 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP19_mirror_reflec, coating ? coating : "", 16384); else mccPoreP19_mirror_reflec[0]='\0';
#line 708 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP19_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP19_bottom_reflec[0]='\0';
#line 709 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP19_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP19_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP19_R_d = 1;
#line 710 "instruments/plate49.instr"
  mccPoreP19_absorb_sides = 0;
#line 19573 "instruments/plate49.c"

  SIG_MESSAGE("PoreP19 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 712 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 712 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 712 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19583 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm19, mcrotaPoreP19);
  rot_transpose(mcrotaPoreP18, mctr1);
  rot_mul(mcrotaPoreP19, mctr1, mcrotrPoreP19);
  mctc1 = coords_set(
#line 711 "instruments/plate49.instr"
    0,
#line 711 "instruments/plate49.instr"
    radiusM,
#line 711 "instruments/plate49.instr"
    0);
#line 19594 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm19, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP19 = coords_add(mcposaPoreArm19, mctc2);
  mctc1 = coords_sub(mcposaPoreP18, mcposaPoreP19);
  mcposrPoreP19 = rot_apply(mcrotaPoreP19, mctc1);
  mcDEBUG_COMPONENT("PoreP19", mcposaPoreP19, mcrotaPoreP19)
  mccomp_posa[73] = mcposaPoreP19;
  mccomp_posr[73] = mcposrPoreP19;
  mcNCounter[73]  = mcPCounter[73] = mcP2Counter[73] = 0;
  mcAbsorbProp[73]= 0;
    /* Component PoreP20. */
  /* Setting parameters for component PoreP20. */
  SIG_MESSAGE("PoreP20 (Init:SetPar)");
#line 716 "instruments/plate49.instr"
  mccPoreP20_radius_p = radiusP;
#line 717 "instruments/plate49.instr"
  mccPoreP20_radius_m = radiusM;
#line 718 "instruments/plate49.instr"
  mccPoreP20_Z0 = FOCALLENGTH;
#line 719 "instruments/plate49.instr"
  mccPoreP20_xwidth = poreW;
#line 720 "instruments/plate49.instr"
  mccPoreP20_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP20_chamferwidth = 0;
#line 721 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP20_mirror_reflec, coating ? coating : "", 16384); else mccPoreP20_mirror_reflec[0]='\0';
#line 722 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP20_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP20_bottom_reflec[0]='\0';
#line 723 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP20_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP20_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP20_R_d = 1;
#line 724 "instruments/plate49.instr"
  mccPoreP20_absorb_sides = 0;
#line 19630 "instruments/plate49.c"

  SIG_MESSAGE("PoreP20 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 726 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 726 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 726 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19640 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm20, mcrotaPoreP20);
  rot_transpose(mcrotaPoreP19, mctr1);
  rot_mul(mcrotaPoreP20, mctr1, mcrotrPoreP20);
  mctc1 = coords_set(
#line 725 "instruments/plate49.instr"
    0,
#line 725 "instruments/plate49.instr"
    radiusM,
#line 725 "instruments/plate49.instr"
    0);
#line 19651 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm20, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP20 = coords_add(mcposaPoreArm20, mctc2);
  mctc1 = coords_sub(mcposaPoreP19, mcposaPoreP20);
  mcposrPoreP20 = rot_apply(mcrotaPoreP20, mctc1);
  mcDEBUG_COMPONENT("PoreP20", mcposaPoreP20, mcrotaPoreP20)
  mccomp_posa[74] = mcposaPoreP20;
  mccomp_posr[74] = mcposrPoreP20;
  mcNCounter[74]  = mcPCounter[74] = mcP2Counter[74] = 0;
  mcAbsorbProp[74]= 0;
    /* Component PoreP21. */
  /* Setting parameters for component PoreP21. */
  SIG_MESSAGE("PoreP21 (Init:SetPar)");
#line 730 "instruments/plate49.instr"
  mccPoreP21_radius_p = radiusP;
#line 731 "instruments/plate49.instr"
  mccPoreP21_radius_m = radiusM;
#line 732 "instruments/plate49.instr"
  mccPoreP21_Z0 = FOCALLENGTH;
#line 733 "instruments/plate49.instr"
  mccPoreP21_xwidth = poreW;
#line 734 "instruments/plate49.instr"
  mccPoreP21_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP21_chamferwidth = 0;
#line 735 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP21_mirror_reflec, coating ? coating : "", 16384); else mccPoreP21_mirror_reflec[0]='\0';
#line 736 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP21_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP21_bottom_reflec[0]='\0';
#line 737 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP21_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP21_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP21_R_d = 1;
#line 738 "instruments/plate49.instr"
  mccPoreP21_absorb_sides = 0;
#line 19687 "instruments/plate49.c"

  SIG_MESSAGE("PoreP21 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 740 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 740 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 740 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19697 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm21, mcrotaPoreP21);
  rot_transpose(mcrotaPoreP20, mctr1);
  rot_mul(mcrotaPoreP21, mctr1, mcrotrPoreP21);
  mctc1 = coords_set(
#line 739 "instruments/plate49.instr"
    0,
#line 739 "instruments/plate49.instr"
    radiusM,
#line 739 "instruments/plate49.instr"
    0);
#line 19708 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm21, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP21 = coords_add(mcposaPoreArm21, mctc2);
  mctc1 = coords_sub(mcposaPoreP20, mcposaPoreP21);
  mcposrPoreP21 = rot_apply(mcrotaPoreP21, mctc1);
  mcDEBUG_COMPONENT("PoreP21", mcposaPoreP21, mcrotaPoreP21)
  mccomp_posa[75] = mcposaPoreP21;
  mccomp_posr[75] = mcposrPoreP21;
  mcNCounter[75]  = mcPCounter[75] = mcP2Counter[75] = 0;
  mcAbsorbProp[75]= 0;
    /* Component PoreP22. */
  /* Setting parameters for component PoreP22. */
  SIG_MESSAGE("PoreP22 (Init:SetPar)");
#line 744 "instruments/plate49.instr"
  mccPoreP22_radius_p = radiusP;
#line 745 "instruments/plate49.instr"
  mccPoreP22_radius_m = radiusM;
#line 746 "instruments/plate49.instr"
  mccPoreP22_Z0 = FOCALLENGTH;
#line 747 "instruments/plate49.instr"
  mccPoreP22_xwidth = poreW;
#line 748 "instruments/plate49.instr"
  mccPoreP22_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP22_chamferwidth = 0;
#line 749 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP22_mirror_reflec, coating ? coating : "", 16384); else mccPoreP22_mirror_reflec[0]='\0';
#line 750 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP22_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP22_bottom_reflec[0]='\0';
#line 751 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP22_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP22_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP22_R_d = 1;
#line 752 "instruments/plate49.instr"
  mccPoreP22_absorb_sides = 0;
#line 19744 "instruments/plate49.c"

  SIG_MESSAGE("PoreP22 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 754 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 754 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 754 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19754 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm22, mcrotaPoreP22);
  rot_transpose(mcrotaPoreP21, mctr1);
  rot_mul(mcrotaPoreP22, mctr1, mcrotrPoreP22);
  mctc1 = coords_set(
#line 753 "instruments/plate49.instr"
    0,
#line 753 "instruments/plate49.instr"
    radiusM,
#line 753 "instruments/plate49.instr"
    0);
#line 19765 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP22 = coords_add(mcposaPoreArm22, mctc2);
  mctc1 = coords_sub(mcposaPoreP21, mcposaPoreP22);
  mcposrPoreP22 = rot_apply(mcrotaPoreP22, mctc1);
  mcDEBUG_COMPONENT("PoreP22", mcposaPoreP22, mcrotaPoreP22)
  mccomp_posa[76] = mcposaPoreP22;
  mccomp_posr[76] = mcposrPoreP22;
  mcNCounter[76]  = mcPCounter[76] = mcP2Counter[76] = 0;
  mcAbsorbProp[76]= 0;
    /* Component PoreP23. */
  /* Setting parameters for component PoreP23. */
  SIG_MESSAGE("PoreP23 (Init:SetPar)");
#line 758 "instruments/plate49.instr"
  mccPoreP23_radius_p = radiusP;
#line 759 "instruments/plate49.instr"
  mccPoreP23_radius_m = radiusM;
#line 760 "instruments/plate49.instr"
  mccPoreP23_Z0 = FOCALLENGTH;
#line 761 "instruments/plate49.instr"
  mccPoreP23_xwidth = poreW;
#line 762 "instruments/plate49.instr"
  mccPoreP23_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP23_chamferwidth = 0;
#line 763 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP23_mirror_reflec, coating ? coating : "", 16384); else mccPoreP23_mirror_reflec[0]='\0';
#line 764 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP23_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP23_bottom_reflec[0]='\0';
#line 765 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP23_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP23_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP23_R_d = 1;
#line 766 "instruments/plate49.instr"
  mccPoreP23_absorb_sides = 0;
#line 19801 "instruments/plate49.c"

  SIG_MESSAGE("PoreP23 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 768 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 768 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 768 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19811 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm23, mcrotaPoreP23);
  rot_transpose(mcrotaPoreP22, mctr1);
  rot_mul(mcrotaPoreP23, mctr1, mcrotrPoreP23);
  mctc1 = coords_set(
#line 767 "instruments/plate49.instr"
    0,
#line 767 "instruments/plate49.instr"
    radiusM,
#line 767 "instruments/plate49.instr"
    0);
#line 19822 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm23, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP23 = coords_add(mcposaPoreArm23, mctc2);
  mctc1 = coords_sub(mcposaPoreP22, mcposaPoreP23);
  mcposrPoreP23 = rot_apply(mcrotaPoreP23, mctc1);
  mcDEBUG_COMPONENT("PoreP23", mcposaPoreP23, mcrotaPoreP23)
  mccomp_posa[77] = mcposaPoreP23;
  mccomp_posr[77] = mcposrPoreP23;
  mcNCounter[77]  = mcPCounter[77] = mcP2Counter[77] = 0;
  mcAbsorbProp[77]= 0;
    /* Component PoreP24. */
  /* Setting parameters for component PoreP24. */
  SIG_MESSAGE("PoreP24 (Init:SetPar)");
#line 772 "instruments/plate49.instr"
  mccPoreP24_radius_p = radiusP;
#line 773 "instruments/plate49.instr"
  mccPoreP24_radius_m = radiusM;
#line 774 "instruments/plate49.instr"
  mccPoreP24_Z0 = FOCALLENGTH;
#line 775 "instruments/plate49.instr"
  mccPoreP24_xwidth = poreW;
#line 776 "instruments/plate49.instr"
  mccPoreP24_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP24_chamferwidth = 0;
#line 777 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP24_mirror_reflec, coating ? coating : "", 16384); else mccPoreP24_mirror_reflec[0]='\0';
#line 778 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP24_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP24_bottom_reflec[0]='\0';
#line 779 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP24_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP24_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP24_R_d = 1;
#line 780 "instruments/plate49.instr"
  mccPoreP24_absorb_sides = 0;
#line 19858 "instruments/plate49.c"

  SIG_MESSAGE("PoreP24 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 782 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 782 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 782 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19868 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm24, mcrotaPoreP24);
  rot_transpose(mcrotaPoreP23, mctr1);
  rot_mul(mcrotaPoreP24, mctr1, mcrotrPoreP24);
  mctc1 = coords_set(
#line 781 "instruments/plate49.instr"
    0,
#line 781 "instruments/plate49.instr"
    radiusM,
#line 781 "instruments/plate49.instr"
    0);
#line 19879 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm24, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP24 = coords_add(mcposaPoreArm24, mctc2);
  mctc1 = coords_sub(mcposaPoreP23, mcposaPoreP24);
  mcposrPoreP24 = rot_apply(mcrotaPoreP24, mctc1);
  mcDEBUG_COMPONENT("PoreP24", mcposaPoreP24, mcrotaPoreP24)
  mccomp_posa[78] = mcposaPoreP24;
  mccomp_posr[78] = mcposrPoreP24;
  mcNCounter[78]  = mcPCounter[78] = mcP2Counter[78] = 0;
  mcAbsorbProp[78]= 0;
    /* Component PoreP25. */
  /* Setting parameters for component PoreP25. */
  SIG_MESSAGE("PoreP25 (Init:SetPar)");
#line 786 "instruments/plate49.instr"
  mccPoreP25_radius_p = radiusP;
#line 787 "instruments/plate49.instr"
  mccPoreP25_radius_m = radiusM;
#line 788 "instruments/plate49.instr"
  mccPoreP25_Z0 = FOCALLENGTH;
#line 789 "instruments/plate49.instr"
  mccPoreP25_xwidth = poreW;
#line 790 "instruments/plate49.instr"
  mccPoreP25_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP25_chamferwidth = 0;
#line 791 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP25_mirror_reflec, coating ? coating : "", 16384); else mccPoreP25_mirror_reflec[0]='\0';
#line 792 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP25_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP25_bottom_reflec[0]='\0';
#line 793 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP25_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP25_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP25_R_d = 1;
#line 794 "instruments/plate49.instr"
  mccPoreP25_absorb_sides = 0;
#line 19915 "instruments/plate49.c"

  SIG_MESSAGE("PoreP25 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 796 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 796 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 796 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19925 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm25, mcrotaPoreP25);
  rot_transpose(mcrotaPoreP24, mctr1);
  rot_mul(mcrotaPoreP25, mctr1, mcrotrPoreP25);
  mctc1 = coords_set(
#line 795 "instruments/plate49.instr"
    0,
#line 795 "instruments/plate49.instr"
    radiusM,
#line 795 "instruments/plate49.instr"
    0);
#line 19936 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP25 = coords_add(mcposaPoreArm25, mctc2);
  mctc1 = coords_sub(mcposaPoreP24, mcposaPoreP25);
  mcposrPoreP25 = rot_apply(mcrotaPoreP25, mctc1);
  mcDEBUG_COMPONENT("PoreP25", mcposaPoreP25, mcrotaPoreP25)
  mccomp_posa[79] = mcposaPoreP25;
  mccomp_posr[79] = mcposrPoreP25;
  mcNCounter[79]  = mcPCounter[79] = mcP2Counter[79] = 0;
  mcAbsorbProp[79]= 0;
    /* Component PoreP26. */
  /* Setting parameters for component PoreP26. */
  SIG_MESSAGE("PoreP26 (Init:SetPar)");
#line 800 "instruments/plate49.instr"
  mccPoreP26_radius_p = radiusP;
#line 801 "instruments/plate49.instr"
  mccPoreP26_radius_m = radiusM;
#line 802 "instruments/plate49.instr"
  mccPoreP26_Z0 = FOCALLENGTH;
#line 803 "instruments/plate49.instr"
  mccPoreP26_xwidth = poreW;
#line 804 "instruments/plate49.instr"
  mccPoreP26_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP26_chamferwidth = 0;
#line 805 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP26_mirror_reflec, coating ? coating : "", 16384); else mccPoreP26_mirror_reflec[0]='\0';
#line 806 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP26_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP26_bottom_reflec[0]='\0';
#line 807 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP26_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP26_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP26_R_d = 1;
#line 808 "instruments/plate49.instr"
  mccPoreP26_absorb_sides = 0;
#line 19972 "instruments/plate49.c"

  SIG_MESSAGE("PoreP26 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 810 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 810 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 810 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 19982 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm26, mcrotaPoreP26);
  rot_transpose(mcrotaPoreP25, mctr1);
  rot_mul(mcrotaPoreP26, mctr1, mcrotrPoreP26);
  mctc1 = coords_set(
#line 809 "instruments/plate49.instr"
    0,
#line 809 "instruments/plate49.instr"
    radiusM,
#line 809 "instruments/plate49.instr"
    0);
#line 19993 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm26, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP26 = coords_add(mcposaPoreArm26, mctc2);
  mctc1 = coords_sub(mcposaPoreP25, mcposaPoreP26);
  mcposrPoreP26 = rot_apply(mcrotaPoreP26, mctc1);
  mcDEBUG_COMPONENT("PoreP26", mcposaPoreP26, mcrotaPoreP26)
  mccomp_posa[80] = mcposaPoreP26;
  mccomp_posr[80] = mcposrPoreP26;
  mcNCounter[80]  = mcPCounter[80] = mcP2Counter[80] = 0;
  mcAbsorbProp[80]= 0;
    /* Component PoreP27. */
  /* Setting parameters for component PoreP27. */
  SIG_MESSAGE("PoreP27 (Init:SetPar)");
#line 814 "instruments/plate49.instr"
  mccPoreP27_radius_p = radiusP;
#line 815 "instruments/plate49.instr"
  mccPoreP27_radius_m = radiusM;
#line 816 "instruments/plate49.instr"
  mccPoreP27_Z0 = FOCALLENGTH;
#line 817 "instruments/plate49.instr"
  mccPoreP27_xwidth = poreW;
#line 818 "instruments/plate49.instr"
  mccPoreP27_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP27_chamferwidth = 0;
#line 819 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP27_mirror_reflec, coating ? coating : "", 16384); else mccPoreP27_mirror_reflec[0]='\0';
#line 820 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP27_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP27_bottom_reflec[0]='\0';
#line 821 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP27_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP27_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP27_R_d = 1;
#line 822 "instruments/plate49.instr"
  mccPoreP27_absorb_sides = 0;
#line 20029 "instruments/plate49.c"

  SIG_MESSAGE("PoreP27 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 824 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 824 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 824 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20039 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm27, mcrotaPoreP27);
  rot_transpose(mcrotaPoreP26, mctr1);
  rot_mul(mcrotaPoreP27, mctr1, mcrotrPoreP27);
  mctc1 = coords_set(
#line 823 "instruments/plate49.instr"
    0,
#line 823 "instruments/plate49.instr"
    radiusM,
#line 823 "instruments/plate49.instr"
    0);
#line 20050 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm27, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP27 = coords_add(mcposaPoreArm27, mctc2);
  mctc1 = coords_sub(mcposaPoreP26, mcposaPoreP27);
  mcposrPoreP27 = rot_apply(mcrotaPoreP27, mctc1);
  mcDEBUG_COMPONENT("PoreP27", mcposaPoreP27, mcrotaPoreP27)
  mccomp_posa[81] = mcposaPoreP27;
  mccomp_posr[81] = mcposrPoreP27;
  mcNCounter[81]  = mcPCounter[81] = mcP2Counter[81] = 0;
  mcAbsorbProp[81]= 0;
    /* Component PoreP28. */
  /* Setting parameters for component PoreP28. */
  SIG_MESSAGE("PoreP28 (Init:SetPar)");
#line 828 "instruments/plate49.instr"
  mccPoreP28_radius_p = radiusP;
#line 829 "instruments/plate49.instr"
  mccPoreP28_radius_m = radiusM;
#line 830 "instruments/plate49.instr"
  mccPoreP28_Z0 = FOCALLENGTH;
#line 831 "instruments/plate49.instr"
  mccPoreP28_xwidth = poreW;
#line 832 "instruments/plate49.instr"
  mccPoreP28_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP28_chamferwidth = 0;
#line 833 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP28_mirror_reflec, coating ? coating : "", 16384); else mccPoreP28_mirror_reflec[0]='\0';
#line 834 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP28_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP28_bottom_reflec[0]='\0';
#line 835 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP28_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP28_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP28_R_d = 1;
#line 836 "instruments/plate49.instr"
  mccPoreP28_absorb_sides = 0;
#line 20086 "instruments/plate49.c"

  SIG_MESSAGE("PoreP28 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 838 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 838 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 838 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20096 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm28, mcrotaPoreP28);
  rot_transpose(mcrotaPoreP27, mctr1);
  rot_mul(mcrotaPoreP28, mctr1, mcrotrPoreP28);
  mctc1 = coords_set(
#line 837 "instruments/plate49.instr"
    0,
#line 837 "instruments/plate49.instr"
    radiusM,
#line 837 "instruments/plate49.instr"
    0);
#line 20107 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm28, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP28 = coords_add(mcposaPoreArm28, mctc2);
  mctc1 = coords_sub(mcposaPoreP27, mcposaPoreP28);
  mcposrPoreP28 = rot_apply(mcrotaPoreP28, mctc1);
  mcDEBUG_COMPONENT("PoreP28", mcposaPoreP28, mcrotaPoreP28)
  mccomp_posa[82] = mcposaPoreP28;
  mccomp_posr[82] = mcposrPoreP28;
  mcNCounter[82]  = mcPCounter[82] = mcP2Counter[82] = 0;
  mcAbsorbProp[82]= 0;
    /* Component PoreP29. */
  /* Setting parameters for component PoreP29. */
  SIG_MESSAGE("PoreP29 (Init:SetPar)");
#line 842 "instruments/plate49.instr"
  mccPoreP29_radius_p = radiusP;
#line 843 "instruments/plate49.instr"
  mccPoreP29_radius_m = radiusM;
#line 844 "instruments/plate49.instr"
  mccPoreP29_Z0 = FOCALLENGTH;
#line 845 "instruments/plate49.instr"
  mccPoreP29_xwidth = poreW;
#line 846 "instruments/plate49.instr"
  mccPoreP29_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP29_chamferwidth = 0;
#line 847 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP29_mirror_reflec, coating ? coating : "", 16384); else mccPoreP29_mirror_reflec[0]='\0';
#line 848 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP29_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP29_bottom_reflec[0]='\0';
#line 849 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP29_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP29_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP29_R_d = 1;
#line 850 "instruments/plate49.instr"
  mccPoreP29_absorb_sides = 0;
#line 20143 "instruments/plate49.c"

  SIG_MESSAGE("PoreP29 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 852 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 852 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 852 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20153 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm29, mcrotaPoreP29);
  rot_transpose(mcrotaPoreP28, mctr1);
  rot_mul(mcrotaPoreP29, mctr1, mcrotrPoreP29);
  mctc1 = coords_set(
#line 851 "instruments/plate49.instr"
    0,
#line 851 "instruments/plate49.instr"
    radiusM,
#line 851 "instruments/plate49.instr"
    0);
#line 20164 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm29, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP29 = coords_add(mcposaPoreArm29, mctc2);
  mctc1 = coords_sub(mcposaPoreP28, mcposaPoreP29);
  mcposrPoreP29 = rot_apply(mcrotaPoreP29, mctc1);
  mcDEBUG_COMPONENT("PoreP29", mcposaPoreP29, mcrotaPoreP29)
  mccomp_posa[83] = mcposaPoreP29;
  mccomp_posr[83] = mcposrPoreP29;
  mcNCounter[83]  = mcPCounter[83] = mcP2Counter[83] = 0;
  mcAbsorbProp[83]= 0;
    /* Component PoreP30. */
  /* Setting parameters for component PoreP30. */
  SIG_MESSAGE("PoreP30 (Init:SetPar)");
#line 856 "instruments/plate49.instr"
  mccPoreP30_radius_p = radiusP;
#line 857 "instruments/plate49.instr"
  mccPoreP30_radius_m = radiusM;
#line 858 "instruments/plate49.instr"
  mccPoreP30_Z0 = FOCALLENGTH;
#line 859 "instruments/plate49.instr"
  mccPoreP30_xwidth = poreW;
#line 860 "instruments/plate49.instr"
  mccPoreP30_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP30_chamferwidth = 0;
#line 861 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP30_mirror_reflec, coating ? coating : "", 16384); else mccPoreP30_mirror_reflec[0]='\0';
#line 862 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP30_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP30_bottom_reflec[0]='\0';
#line 863 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP30_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP30_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP30_R_d = 1;
#line 864 "instruments/plate49.instr"
  mccPoreP30_absorb_sides = 0;
#line 20200 "instruments/plate49.c"

  SIG_MESSAGE("PoreP30 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 866 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 866 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 866 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20210 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm30, mcrotaPoreP30);
  rot_transpose(mcrotaPoreP29, mctr1);
  rot_mul(mcrotaPoreP30, mctr1, mcrotrPoreP30);
  mctc1 = coords_set(
#line 865 "instruments/plate49.instr"
    0,
#line 865 "instruments/plate49.instr"
    radiusM,
#line 865 "instruments/plate49.instr"
    0);
#line 20221 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP30 = coords_add(mcposaPoreArm30, mctc2);
  mctc1 = coords_sub(mcposaPoreP29, mcposaPoreP30);
  mcposrPoreP30 = rot_apply(mcrotaPoreP30, mctc1);
  mcDEBUG_COMPONENT("PoreP30", mcposaPoreP30, mcrotaPoreP30)
  mccomp_posa[84] = mcposaPoreP30;
  mccomp_posr[84] = mcposrPoreP30;
  mcNCounter[84]  = mcPCounter[84] = mcP2Counter[84] = 0;
  mcAbsorbProp[84]= 0;
    /* Component PoreP31. */
  /* Setting parameters for component PoreP31. */
  SIG_MESSAGE("PoreP31 (Init:SetPar)");
#line 870 "instruments/plate49.instr"
  mccPoreP31_radius_p = radiusP;
#line 871 "instruments/plate49.instr"
  mccPoreP31_radius_m = radiusM;
#line 872 "instruments/plate49.instr"
  mccPoreP31_Z0 = FOCALLENGTH;
#line 873 "instruments/plate49.instr"
  mccPoreP31_xwidth = poreW;
#line 874 "instruments/plate49.instr"
  mccPoreP31_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP31_chamferwidth = 0;
#line 875 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP31_mirror_reflec, coating ? coating : "", 16384); else mccPoreP31_mirror_reflec[0]='\0';
#line 876 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP31_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP31_bottom_reflec[0]='\0';
#line 877 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP31_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP31_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP31_R_d = 1;
#line 878 "instruments/plate49.instr"
  mccPoreP31_absorb_sides = 0;
#line 20257 "instruments/plate49.c"

  SIG_MESSAGE("PoreP31 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 880 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 880 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 880 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20267 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm31, mcrotaPoreP31);
  rot_transpose(mcrotaPoreP30, mctr1);
  rot_mul(mcrotaPoreP31, mctr1, mcrotrPoreP31);
  mctc1 = coords_set(
#line 879 "instruments/plate49.instr"
    0,
#line 879 "instruments/plate49.instr"
    radiusM,
#line 879 "instruments/plate49.instr"
    0);
#line 20278 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm31, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP31 = coords_add(mcposaPoreArm31, mctc2);
  mctc1 = coords_sub(mcposaPoreP30, mcposaPoreP31);
  mcposrPoreP31 = rot_apply(mcrotaPoreP31, mctc1);
  mcDEBUG_COMPONENT("PoreP31", mcposaPoreP31, mcrotaPoreP31)
  mccomp_posa[85] = mcposaPoreP31;
  mccomp_posr[85] = mcposrPoreP31;
  mcNCounter[85]  = mcPCounter[85] = mcP2Counter[85] = 0;
  mcAbsorbProp[85]= 0;
    /* Component PoreP32. */
  /* Setting parameters for component PoreP32. */
  SIG_MESSAGE("PoreP32 (Init:SetPar)");
#line 884 "instruments/plate49.instr"
  mccPoreP32_radius_p = radiusP;
#line 885 "instruments/plate49.instr"
  mccPoreP32_radius_m = radiusM;
#line 886 "instruments/plate49.instr"
  mccPoreP32_Z0 = FOCALLENGTH;
#line 887 "instruments/plate49.instr"
  mccPoreP32_xwidth = poreW;
#line 888 "instruments/plate49.instr"
  mccPoreP32_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP32_chamferwidth = 0;
#line 889 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP32_mirror_reflec, coating ? coating : "", 16384); else mccPoreP32_mirror_reflec[0]='\0';
#line 890 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP32_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP32_bottom_reflec[0]='\0';
#line 891 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP32_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP32_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP32_R_d = 1;
#line 892 "instruments/plate49.instr"
  mccPoreP32_absorb_sides = 0;
#line 20314 "instruments/plate49.c"

  SIG_MESSAGE("PoreP32 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 894 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 894 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 894 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20324 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm32, mcrotaPoreP32);
  rot_transpose(mcrotaPoreP31, mctr1);
  rot_mul(mcrotaPoreP32, mctr1, mcrotrPoreP32);
  mctc1 = coords_set(
#line 893 "instruments/plate49.instr"
    0,
#line 893 "instruments/plate49.instr"
    radiusM,
#line 893 "instruments/plate49.instr"
    0);
#line 20335 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm32, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP32 = coords_add(mcposaPoreArm32, mctc2);
  mctc1 = coords_sub(mcposaPoreP31, mcposaPoreP32);
  mcposrPoreP32 = rot_apply(mcrotaPoreP32, mctc1);
  mcDEBUG_COMPONENT("PoreP32", mcposaPoreP32, mcrotaPoreP32)
  mccomp_posa[86] = mcposaPoreP32;
  mccomp_posr[86] = mcposrPoreP32;
  mcNCounter[86]  = mcPCounter[86] = mcP2Counter[86] = 0;
  mcAbsorbProp[86]= 0;
    /* Component PoreP33. */
  /* Setting parameters for component PoreP33. */
  SIG_MESSAGE("PoreP33 (Init:SetPar)");
#line 898 "instruments/plate49.instr"
  mccPoreP33_radius_p = radiusP;
#line 899 "instruments/plate49.instr"
  mccPoreP33_radius_m = radiusM;
#line 900 "instruments/plate49.instr"
  mccPoreP33_Z0 = FOCALLENGTH;
#line 901 "instruments/plate49.instr"
  mccPoreP33_xwidth = poreW;
#line 902 "instruments/plate49.instr"
  mccPoreP33_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP33_chamferwidth = 0;
#line 903 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP33_mirror_reflec, coating ? coating : "", 16384); else mccPoreP33_mirror_reflec[0]='\0';
#line 904 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP33_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP33_bottom_reflec[0]='\0';
#line 905 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP33_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP33_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP33_R_d = 1;
#line 906 "instruments/plate49.instr"
  mccPoreP33_absorb_sides = 0;
#line 20371 "instruments/plate49.c"

  SIG_MESSAGE("PoreP33 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 908 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 908 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 908 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20381 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm33, mcrotaPoreP33);
  rot_transpose(mcrotaPoreP32, mctr1);
  rot_mul(mcrotaPoreP33, mctr1, mcrotrPoreP33);
  mctc1 = coords_set(
#line 907 "instruments/plate49.instr"
    0,
#line 907 "instruments/plate49.instr"
    radiusM,
#line 907 "instruments/plate49.instr"
    0);
#line 20392 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm33, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP33 = coords_add(mcposaPoreArm33, mctc2);
  mctc1 = coords_sub(mcposaPoreP32, mcposaPoreP33);
  mcposrPoreP33 = rot_apply(mcrotaPoreP33, mctc1);
  mcDEBUG_COMPONENT("PoreP33", mcposaPoreP33, mcrotaPoreP33)
  mccomp_posa[87] = mcposaPoreP33;
  mccomp_posr[87] = mcposrPoreP33;
  mcNCounter[87]  = mcPCounter[87] = mcP2Counter[87] = 0;
  mcAbsorbProp[87]= 0;
    /* Component PoreP34. */
  /* Setting parameters for component PoreP34. */
  SIG_MESSAGE("PoreP34 (Init:SetPar)");
#line 912 "instruments/plate49.instr"
  mccPoreP34_radius_p = radiusP;
#line 913 "instruments/plate49.instr"
  mccPoreP34_radius_m = radiusM;
#line 914 "instruments/plate49.instr"
  mccPoreP34_Z0 = FOCALLENGTH;
#line 915 "instruments/plate49.instr"
  mccPoreP34_xwidth = poreW;
#line 916 "instruments/plate49.instr"
  mccPoreP34_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP34_chamferwidth = 0;
#line 917 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP34_mirror_reflec, coating ? coating : "", 16384); else mccPoreP34_mirror_reflec[0]='\0';
#line 918 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP34_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP34_bottom_reflec[0]='\0';
#line 919 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP34_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP34_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP34_R_d = 1;
#line 920 "instruments/plate49.instr"
  mccPoreP34_absorb_sides = 0;
#line 20428 "instruments/plate49.c"

  SIG_MESSAGE("PoreP34 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 922 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 922 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 922 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20438 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm34, mcrotaPoreP34);
  rot_transpose(mcrotaPoreP33, mctr1);
  rot_mul(mcrotaPoreP34, mctr1, mcrotrPoreP34);
  mctc1 = coords_set(
#line 921 "instruments/plate49.instr"
    0,
#line 921 "instruments/plate49.instr"
    radiusM,
#line 921 "instruments/plate49.instr"
    0);
#line 20449 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm34, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP34 = coords_add(mcposaPoreArm34, mctc2);
  mctc1 = coords_sub(mcposaPoreP33, mcposaPoreP34);
  mcposrPoreP34 = rot_apply(mcrotaPoreP34, mctc1);
  mcDEBUG_COMPONENT("PoreP34", mcposaPoreP34, mcrotaPoreP34)
  mccomp_posa[88] = mcposaPoreP34;
  mccomp_posr[88] = mcposrPoreP34;
  mcNCounter[88]  = mcPCounter[88] = mcP2Counter[88] = 0;
  mcAbsorbProp[88]= 0;
    /* Component PoreP35. */
  /* Setting parameters for component PoreP35. */
  SIG_MESSAGE("PoreP35 (Init:SetPar)");
#line 926 "instruments/plate49.instr"
  mccPoreP35_radius_p = radiusP;
#line 927 "instruments/plate49.instr"
  mccPoreP35_radius_m = radiusM;
#line 928 "instruments/plate49.instr"
  mccPoreP35_Z0 = FOCALLENGTH;
#line 929 "instruments/plate49.instr"
  mccPoreP35_xwidth = poreW;
#line 930 "instruments/plate49.instr"
  mccPoreP35_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP35_chamferwidth = 0;
#line 931 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP35_mirror_reflec, coating ? coating : "", 16384); else mccPoreP35_mirror_reflec[0]='\0';
#line 932 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP35_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP35_bottom_reflec[0]='\0';
#line 933 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP35_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP35_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP35_R_d = 1;
#line 934 "instruments/plate49.instr"
  mccPoreP35_absorb_sides = 0;
#line 20485 "instruments/plate49.c"

  SIG_MESSAGE("PoreP35 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 936 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 936 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 936 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20495 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm35, mcrotaPoreP35);
  rot_transpose(mcrotaPoreP34, mctr1);
  rot_mul(mcrotaPoreP35, mctr1, mcrotrPoreP35);
  mctc1 = coords_set(
#line 935 "instruments/plate49.instr"
    0,
#line 935 "instruments/plate49.instr"
    radiusM,
#line 935 "instruments/plate49.instr"
    0);
#line 20506 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm35, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP35 = coords_add(mcposaPoreArm35, mctc2);
  mctc1 = coords_sub(mcposaPoreP34, mcposaPoreP35);
  mcposrPoreP35 = rot_apply(mcrotaPoreP35, mctc1);
  mcDEBUG_COMPONENT("PoreP35", mcposaPoreP35, mcrotaPoreP35)
  mccomp_posa[89] = mcposaPoreP35;
  mccomp_posr[89] = mcposrPoreP35;
  mcNCounter[89]  = mcPCounter[89] = mcP2Counter[89] = 0;
  mcAbsorbProp[89]= 0;
    /* Component PoreP36. */
  /* Setting parameters for component PoreP36. */
  SIG_MESSAGE("PoreP36 (Init:SetPar)");
#line 940 "instruments/plate49.instr"
  mccPoreP36_radius_p = radiusP;
#line 941 "instruments/plate49.instr"
  mccPoreP36_radius_m = radiusM;
#line 942 "instruments/plate49.instr"
  mccPoreP36_Z0 = FOCALLENGTH;
#line 943 "instruments/plate49.instr"
  mccPoreP36_xwidth = poreW;
#line 944 "instruments/plate49.instr"
  mccPoreP36_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP36_chamferwidth = 0;
#line 945 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP36_mirror_reflec, coating ? coating : "", 16384); else mccPoreP36_mirror_reflec[0]='\0';
#line 946 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP36_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP36_bottom_reflec[0]='\0';
#line 947 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP36_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP36_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP36_R_d = 1;
#line 948 "instruments/plate49.instr"
  mccPoreP36_absorb_sides = 0;
#line 20542 "instruments/plate49.c"

  SIG_MESSAGE("PoreP36 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 950 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 950 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 950 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20552 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm36, mcrotaPoreP36);
  rot_transpose(mcrotaPoreP35, mctr1);
  rot_mul(mcrotaPoreP36, mctr1, mcrotrPoreP36);
  mctc1 = coords_set(
#line 949 "instruments/plate49.instr"
    0,
#line 949 "instruments/plate49.instr"
    radiusM,
#line 949 "instruments/plate49.instr"
    0);
#line 20563 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm36, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP36 = coords_add(mcposaPoreArm36, mctc2);
  mctc1 = coords_sub(mcposaPoreP35, mcposaPoreP36);
  mcposrPoreP36 = rot_apply(mcrotaPoreP36, mctc1);
  mcDEBUG_COMPONENT("PoreP36", mcposaPoreP36, mcrotaPoreP36)
  mccomp_posa[90] = mcposaPoreP36;
  mccomp_posr[90] = mcposrPoreP36;
  mcNCounter[90]  = mcPCounter[90] = mcP2Counter[90] = 0;
  mcAbsorbProp[90]= 0;
    /* Component PoreP37. */
  /* Setting parameters for component PoreP37. */
  SIG_MESSAGE("PoreP37 (Init:SetPar)");
#line 954 "instruments/plate49.instr"
  mccPoreP37_radius_p = radiusP;
#line 955 "instruments/plate49.instr"
  mccPoreP37_radius_m = radiusM;
#line 956 "instruments/plate49.instr"
  mccPoreP37_Z0 = FOCALLENGTH;
#line 957 "instruments/plate49.instr"
  mccPoreP37_xwidth = poreW;
#line 958 "instruments/plate49.instr"
  mccPoreP37_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP37_chamferwidth = 0;
#line 959 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP37_mirror_reflec, coating ? coating : "", 16384); else mccPoreP37_mirror_reflec[0]='\0';
#line 960 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP37_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP37_bottom_reflec[0]='\0';
#line 961 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP37_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP37_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP37_R_d = 1;
#line 962 "instruments/plate49.instr"
  mccPoreP37_absorb_sides = 0;
#line 20599 "instruments/plate49.c"

  SIG_MESSAGE("PoreP37 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 964 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 964 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 964 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20609 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm37, mcrotaPoreP37);
  rot_transpose(mcrotaPoreP36, mctr1);
  rot_mul(mcrotaPoreP37, mctr1, mcrotrPoreP37);
  mctc1 = coords_set(
#line 963 "instruments/plate49.instr"
    0,
#line 963 "instruments/plate49.instr"
    radiusM,
#line 963 "instruments/plate49.instr"
    0);
#line 20620 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm37, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP37 = coords_add(mcposaPoreArm37, mctc2);
  mctc1 = coords_sub(mcposaPoreP36, mcposaPoreP37);
  mcposrPoreP37 = rot_apply(mcrotaPoreP37, mctc1);
  mcDEBUG_COMPONENT("PoreP37", mcposaPoreP37, mcrotaPoreP37)
  mccomp_posa[91] = mcposaPoreP37;
  mccomp_posr[91] = mcposrPoreP37;
  mcNCounter[91]  = mcPCounter[91] = mcP2Counter[91] = 0;
  mcAbsorbProp[91]= 0;
    /* Component PoreP38. */
  /* Setting parameters for component PoreP38. */
  SIG_MESSAGE("PoreP38 (Init:SetPar)");
#line 968 "instruments/plate49.instr"
  mccPoreP38_radius_p = radiusP;
#line 969 "instruments/plate49.instr"
  mccPoreP38_radius_m = radiusM;
#line 970 "instruments/plate49.instr"
  mccPoreP38_Z0 = FOCALLENGTH;
#line 971 "instruments/plate49.instr"
  mccPoreP38_xwidth = poreW;
#line 972 "instruments/plate49.instr"
  mccPoreP38_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP38_chamferwidth = 0;
#line 973 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP38_mirror_reflec, coating ? coating : "", 16384); else mccPoreP38_mirror_reflec[0]='\0';
#line 974 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP38_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP38_bottom_reflec[0]='\0';
#line 975 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP38_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP38_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP38_R_d = 1;
#line 976 "instruments/plate49.instr"
  mccPoreP38_absorb_sides = 0;
#line 20656 "instruments/plate49.c"

  SIG_MESSAGE("PoreP38 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 978 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 978 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 978 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20666 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm38, mcrotaPoreP38);
  rot_transpose(mcrotaPoreP37, mctr1);
  rot_mul(mcrotaPoreP38, mctr1, mcrotrPoreP38);
  mctc1 = coords_set(
#line 977 "instruments/plate49.instr"
    0,
#line 977 "instruments/plate49.instr"
    radiusM,
#line 977 "instruments/plate49.instr"
    0);
#line 20677 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm38, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP38 = coords_add(mcposaPoreArm38, mctc2);
  mctc1 = coords_sub(mcposaPoreP37, mcposaPoreP38);
  mcposrPoreP38 = rot_apply(mcrotaPoreP38, mctc1);
  mcDEBUG_COMPONENT("PoreP38", mcposaPoreP38, mcrotaPoreP38)
  mccomp_posa[92] = mcposaPoreP38;
  mccomp_posr[92] = mcposrPoreP38;
  mcNCounter[92]  = mcPCounter[92] = mcP2Counter[92] = 0;
  mcAbsorbProp[92]= 0;
    /* Component PoreP39. */
  /* Setting parameters for component PoreP39. */
  SIG_MESSAGE("PoreP39 (Init:SetPar)");
#line 982 "instruments/plate49.instr"
  mccPoreP39_radius_p = radiusP;
#line 983 "instruments/plate49.instr"
  mccPoreP39_radius_m = radiusM;
#line 984 "instruments/plate49.instr"
  mccPoreP39_Z0 = FOCALLENGTH;
#line 985 "instruments/plate49.instr"
  mccPoreP39_xwidth = poreW;
#line 986 "instruments/plate49.instr"
  mccPoreP39_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP39_chamferwidth = 0;
#line 987 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP39_mirror_reflec, coating ? coating : "", 16384); else mccPoreP39_mirror_reflec[0]='\0';
#line 988 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP39_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP39_bottom_reflec[0]='\0';
#line 989 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP39_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP39_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP39_R_d = 1;
#line 990 "instruments/plate49.instr"
  mccPoreP39_absorb_sides = 0;
#line 20713 "instruments/plate49.c"

  SIG_MESSAGE("PoreP39 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 992 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 992 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 992 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20723 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm39, mcrotaPoreP39);
  rot_transpose(mcrotaPoreP38, mctr1);
  rot_mul(mcrotaPoreP39, mctr1, mcrotrPoreP39);
  mctc1 = coords_set(
#line 991 "instruments/plate49.instr"
    0,
#line 991 "instruments/plate49.instr"
    radiusM,
#line 991 "instruments/plate49.instr"
    0);
#line 20734 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm39, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP39 = coords_add(mcposaPoreArm39, mctc2);
  mctc1 = coords_sub(mcposaPoreP38, mcposaPoreP39);
  mcposrPoreP39 = rot_apply(mcrotaPoreP39, mctc1);
  mcDEBUG_COMPONENT("PoreP39", mcposaPoreP39, mcrotaPoreP39)
  mccomp_posa[93] = mcposaPoreP39;
  mccomp_posr[93] = mcposrPoreP39;
  mcNCounter[93]  = mcPCounter[93] = mcP2Counter[93] = 0;
  mcAbsorbProp[93]= 0;
    /* Component PoreP40. */
  /* Setting parameters for component PoreP40. */
  SIG_MESSAGE("PoreP40 (Init:SetPar)");
#line 996 "instruments/plate49.instr"
  mccPoreP40_radius_p = radiusP;
#line 997 "instruments/plate49.instr"
  mccPoreP40_radius_m = radiusM;
#line 998 "instruments/plate49.instr"
  mccPoreP40_Z0 = FOCALLENGTH;
#line 999 "instruments/plate49.instr"
  mccPoreP40_xwidth = poreW;
#line 1000 "instruments/plate49.instr"
  mccPoreP40_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP40_chamferwidth = 0;
#line 1001 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP40_mirror_reflec, coating ? coating : "", 16384); else mccPoreP40_mirror_reflec[0]='\0';
#line 1002 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP40_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP40_bottom_reflec[0]='\0';
#line 1003 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP40_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP40_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP40_R_d = 1;
#line 1004 "instruments/plate49.instr"
  mccPoreP40_absorb_sides = 0;
#line 20770 "instruments/plate49.c"

  SIG_MESSAGE("PoreP40 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1006 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1006 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1006 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20780 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm40, mcrotaPoreP40);
  rot_transpose(mcrotaPoreP39, mctr1);
  rot_mul(mcrotaPoreP40, mctr1, mcrotrPoreP40);
  mctc1 = coords_set(
#line 1005 "instruments/plate49.instr"
    0,
#line 1005 "instruments/plate49.instr"
    radiusM,
#line 1005 "instruments/plate49.instr"
    0);
#line 20791 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm40, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP40 = coords_add(mcposaPoreArm40, mctc2);
  mctc1 = coords_sub(mcposaPoreP39, mcposaPoreP40);
  mcposrPoreP40 = rot_apply(mcrotaPoreP40, mctc1);
  mcDEBUG_COMPONENT("PoreP40", mcposaPoreP40, mcrotaPoreP40)
  mccomp_posa[94] = mcposaPoreP40;
  mccomp_posr[94] = mcposrPoreP40;
  mcNCounter[94]  = mcPCounter[94] = mcP2Counter[94] = 0;
  mcAbsorbProp[94]= 0;
    /* Component PoreP41. */
  /* Setting parameters for component PoreP41. */
  SIG_MESSAGE("PoreP41 (Init:SetPar)");
#line 1010 "instruments/plate49.instr"
  mccPoreP41_radius_p = radiusP;
#line 1011 "instruments/plate49.instr"
  mccPoreP41_radius_m = radiusM;
#line 1012 "instruments/plate49.instr"
  mccPoreP41_Z0 = FOCALLENGTH;
#line 1013 "instruments/plate49.instr"
  mccPoreP41_xwidth = poreW;
#line 1014 "instruments/plate49.instr"
  mccPoreP41_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP41_chamferwidth = 0;
#line 1015 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP41_mirror_reflec, coating ? coating : "", 16384); else mccPoreP41_mirror_reflec[0]='\0';
#line 1016 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP41_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP41_bottom_reflec[0]='\0';
#line 1017 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP41_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP41_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP41_R_d = 1;
#line 1018 "instruments/plate49.instr"
  mccPoreP41_absorb_sides = 0;
#line 20827 "instruments/plate49.c"

  SIG_MESSAGE("PoreP41 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1020 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1020 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1020 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20837 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm41, mcrotaPoreP41);
  rot_transpose(mcrotaPoreP40, mctr1);
  rot_mul(mcrotaPoreP41, mctr1, mcrotrPoreP41);
  mctc1 = coords_set(
#line 1019 "instruments/plate49.instr"
    0,
#line 1019 "instruments/plate49.instr"
    radiusM,
#line 1019 "instruments/plate49.instr"
    0);
#line 20848 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm41, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP41 = coords_add(mcposaPoreArm41, mctc2);
  mctc1 = coords_sub(mcposaPoreP40, mcposaPoreP41);
  mcposrPoreP41 = rot_apply(mcrotaPoreP41, mctc1);
  mcDEBUG_COMPONENT("PoreP41", mcposaPoreP41, mcrotaPoreP41)
  mccomp_posa[95] = mcposaPoreP41;
  mccomp_posr[95] = mcposrPoreP41;
  mcNCounter[95]  = mcPCounter[95] = mcP2Counter[95] = 0;
  mcAbsorbProp[95]= 0;
    /* Component PoreP42. */
  /* Setting parameters for component PoreP42. */
  SIG_MESSAGE("PoreP42 (Init:SetPar)");
#line 1024 "instruments/plate49.instr"
  mccPoreP42_radius_p = radiusP;
#line 1025 "instruments/plate49.instr"
  mccPoreP42_radius_m = radiusM;
#line 1026 "instruments/plate49.instr"
  mccPoreP42_Z0 = FOCALLENGTH;
#line 1027 "instruments/plate49.instr"
  mccPoreP42_xwidth = poreW;
#line 1028 "instruments/plate49.instr"
  mccPoreP42_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP42_chamferwidth = 0;
#line 1029 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP42_mirror_reflec, coating ? coating : "", 16384); else mccPoreP42_mirror_reflec[0]='\0';
#line 1030 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP42_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP42_bottom_reflec[0]='\0';
#line 1031 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP42_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP42_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP42_R_d = 1;
#line 1032 "instruments/plate49.instr"
  mccPoreP42_absorb_sides = 0;
#line 20884 "instruments/plate49.c"

  SIG_MESSAGE("PoreP42 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1034 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1034 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1034 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20894 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm42, mcrotaPoreP42);
  rot_transpose(mcrotaPoreP41, mctr1);
  rot_mul(mcrotaPoreP42, mctr1, mcrotrPoreP42);
  mctc1 = coords_set(
#line 1033 "instruments/plate49.instr"
    0,
#line 1033 "instruments/plate49.instr"
    radiusM,
#line 1033 "instruments/plate49.instr"
    0);
#line 20905 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm42, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP42 = coords_add(mcposaPoreArm42, mctc2);
  mctc1 = coords_sub(mcposaPoreP41, mcposaPoreP42);
  mcposrPoreP42 = rot_apply(mcrotaPoreP42, mctc1);
  mcDEBUG_COMPONENT("PoreP42", mcposaPoreP42, mcrotaPoreP42)
  mccomp_posa[96] = mcposaPoreP42;
  mccomp_posr[96] = mcposrPoreP42;
  mcNCounter[96]  = mcPCounter[96] = mcP2Counter[96] = 0;
  mcAbsorbProp[96]= 0;
    /* Component PoreP43. */
  /* Setting parameters for component PoreP43. */
  SIG_MESSAGE("PoreP43 (Init:SetPar)");
#line 1038 "instruments/plate49.instr"
  mccPoreP43_radius_p = radiusP;
#line 1039 "instruments/plate49.instr"
  mccPoreP43_radius_m = radiusM;
#line 1040 "instruments/plate49.instr"
  mccPoreP43_Z0 = FOCALLENGTH;
#line 1041 "instruments/plate49.instr"
  mccPoreP43_xwidth = poreW;
#line 1042 "instruments/plate49.instr"
  mccPoreP43_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP43_chamferwidth = 0;
#line 1043 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP43_mirror_reflec, coating ? coating : "", 16384); else mccPoreP43_mirror_reflec[0]='\0';
#line 1044 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP43_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP43_bottom_reflec[0]='\0';
#line 1045 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP43_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP43_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP43_R_d = 1;
#line 1046 "instruments/plate49.instr"
  mccPoreP43_absorb_sides = 0;
#line 20941 "instruments/plate49.c"

  SIG_MESSAGE("PoreP43 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1048 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1048 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1048 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 20951 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm43, mcrotaPoreP43);
  rot_transpose(mcrotaPoreP42, mctr1);
  rot_mul(mcrotaPoreP43, mctr1, mcrotrPoreP43);
  mctc1 = coords_set(
#line 1047 "instruments/plate49.instr"
    0,
#line 1047 "instruments/plate49.instr"
    radiusM,
#line 1047 "instruments/plate49.instr"
    0);
#line 20962 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm43, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP43 = coords_add(mcposaPoreArm43, mctc2);
  mctc1 = coords_sub(mcposaPoreP42, mcposaPoreP43);
  mcposrPoreP43 = rot_apply(mcrotaPoreP43, mctc1);
  mcDEBUG_COMPONENT("PoreP43", mcposaPoreP43, mcrotaPoreP43)
  mccomp_posa[97] = mcposaPoreP43;
  mccomp_posr[97] = mcposrPoreP43;
  mcNCounter[97]  = mcPCounter[97] = mcP2Counter[97] = 0;
  mcAbsorbProp[97]= 0;
    /* Component PoreP44. */
  /* Setting parameters for component PoreP44. */
  SIG_MESSAGE("PoreP44 (Init:SetPar)");
#line 1052 "instruments/plate49.instr"
  mccPoreP44_radius_p = radiusP;
#line 1053 "instruments/plate49.instr"
  mccPoreP44_radius_m = radiusM;
#line 1054 "instruments/plate49.instr"
  mccPoreP44_Z0 = FOCALLENGTH;
#line 1055 "instruments/plate49.instr"
  mccPoreP44_xwidth = poreW;
#line 1056 "instruments/plate49.instr"
  mccPoreP44_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP44_chamferwidth = 0;
#line 1057 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP44_mirror_reflec, coating ? coating : "", 16384); else mccPoreP44_mirror_reflec[0]='\0';
#line 1058 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP44_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP44_bottom_reflec[0]='\0';
#line 1059 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP44_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP44_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP44_R_d = 1;
#line 1060 "instruments/plate49.instr"
  mccPoreP44_absorb_sides = 0;
#line 20998 "instruments/plate49.c"

  SIG_MESSAGE("PoreP44 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1062 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1062 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1062 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21008 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm44, mcrotaPoreP44);
  rot_transpose(mcrotaPoreP43, mctr1);
  rot_mul(mcrotaPoreP44, mctr1, mcrotrPoreP44);
  mctc1 = coords_set(
#line 1061 "instruments/plate49.instr"
    0,
#line 1061 "instruments/plate49.instr"
    radiusM,
#line 1061 "instruments/plate49.instr"
    0);
#line 21019 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm44, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP44 = coords_add(mcposaPoreArm44, mctc2);
  mctc1 = coords_sub(mcposaPoreP43, mcposaPoreP44);
  mcposrPoreP44 = rot_apply(mcrotaPoreP44, mctc1);
  mcDEBUG_COMPONENT("PoreP44", mcposaPoreP44, mcrotaPoreP44)
  mccomp_posa[98] = mcposaPoreP44;
  mccomp_posr[98] = mcposrPoreP44;
  mcNCounter[98]  = mcPCounter[98] = mcP2Counter[98] = 0;
  mcAbsorbProp[98]= 0;
    /* Component PoreP45. */
  /* Setting parameters for component PoreP45. */
  SIG_MESSAGE("PoreP45 (Init:SetPar)");
#line 1066 "instruments/plate49.instr"
  mccPoreP45_radius_p = radiusP;
#line 1067 "instruments/plate49.instr"
  mccPoreP45_radius_m = radiusM;
#line 1068 "instruments/plate49.instr"
  mccPoreP45_Z0 = FOCALLENGTH;
#line 1069 "instruments/plate49.instr"
  mccPoreP45_xwidth = poreW;
#line 1070 "instruments/plate49.instr"
  mccPoreP45_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP45_chamferwidth = 0;
#line 1071 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP45_mirror_reflec, coating ? coating : "", 16384); else mccPoreP45_mirror_reflec[0]='\0';
#line 1072 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP45_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP45_bottom_reflec[0]='\0';
#line 1073 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP45_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP45_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP45_R_d = 1;
#line 1074 "instruments/plate49.instr"
  mccPoreP45_absorb_sides = 0;
#line 21055 "instruments/plate49.c"

  SIG_MESSAGE("PoreP45 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1076 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1076 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1076 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21065 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm45, mcrotaPoreP45);
  rot_transpose(mcrotaPoreP44, mctr1);
  rot_mul(mcrotaPoreP45, mctr1, mcrotrPoreP45);
  mctc1 = coords_set(
#line 1075 "instruments/plate49.instr"
    0,
#line 1075 "instruments/plate49.instr"
    radiusM,
#line 1075 "instruments/plate49.instr"
    0);
#line 21076 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm45, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP45 = coords_add(mcposaPoreArm45, mctc2);
  mctc1 = coords_sub(mcposaPoreP44, mcposaPoreP45);
  mcposrPoreP45 = rot_apply(mcrotaPoreP45, mctc1);
  mcDEBUG_COMPONENT("PoreP45", mcposaPoreP45, mcrotaPoreP45)
  mccomp_posa[99] = mcposaPoreP45;
  mccomp_posr[99] = mcposrPoreP45;
  mcNCounter[99]  = mcPCounter[99] = mcP2Counter[99] = 0;
  mcAbsorbProp[99]= 0;
    /* Component PoreP46. */
  /* Setting parameters for component PoreP46. */
  SIG_MESSAGE("PoreP46 (Init:SetPar)");
#line 1080 "instruments/plate49.instr"
  mccPoreP46_radius_p = radiusP;
#line 1081 "instruments/plate49.instr"
  mccPoreP46_radius_m = radiusM;
#line 1082 "instruments/plate49.instr"
  mccPoreP46_Z0 = FOCALLENGTH;
#line 1083 "instruments/plate49.instr"
  mccPoreP46_xwidth = poreW;
#line 1084 "instruments/plate49.instr"
  mccPoreP46_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP46_chamferwidth = 0;
#line 1085 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP46_mirror_reflec, coating ? coating : "", 16384); else mccPoreP46_mirror_reflec[0]='\0';
#line 1086 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP46_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP46_bottom_reflec[0]='\0';
#line 1087 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP46_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP46_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP46_R_d = 1;
#line 1088 "instruments/plate49.instr"
  mccPoreP46_absorb_sides = 0;
#line 21112 "instruments/plate49.c"

  SIG_MESSAGE("PoreP46 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1090 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1090 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1090 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21122 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm46, mcrotaPoreP46);
  rot_transpose(mcrotaPoreP45, mctr1);
  rot_mul(mcrotaPoreP46, mctr1, mcrotrPoreP46);
  mctc1 = coords_set(
#line 1089 "instruments/plate49.instr"
    0,
#line 1089 "instruments/plate49.instr"
    radiusM,
#line 1089 "instruments/plate49.instr"
    0);
#line 21133 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm46, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP46 = coords_add(mcposaPoreArm46, mctc2);
  mctc1 = coords_sub(mcposaPoreP45, mcposaPoreP46);
  mcposrPoreP46 = rot_apply(mcrotaPoreP46, mctc1);
  mcDEBUG_COMPONENT("PoreP46", mcposaPoreP46, mcrotaPoreP46)
  mccomp_posa[100] = mcposaPoreP46;
  mccomp_posr[100] = mcposrPoreP46;
  mcNCounter[100]  = mcPCounter[100] = mcP2Counter[100] = 0;
  mcAbsorbProp[100]= 0;
    /* Component PoreP47. */
  /* Setting parameters for component PoreP47. */
  SIG_MESSAGE("PoreP47 (Init:SetPar)");
#line 1094 "instruments/plate49.instr"
  mccPoreP47_radius_p = radiusP;
#line 1095 "instruments/plate49.instr"
  mccPoreP47_radius_m = radiusM;
#line 1096 "instruments/plate49.instr"
  mccPoreP47_Z0 = FOCALLENGTH;
#line 1097 "instruments/plate49.instr"
  mccPoreP47_xwidth = poreW;
#line 1098 "instruments/plate49.instr"
  mccPoreP47_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP47_chamferwidth = 0;
#line 1099 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP47_mirror_reflec, coating ? coating : "", 16384); else mccPoreP47_mirror_reflec[0]='\0';
#line 1100 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP47_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP47_bottom_reflec[0]='\0';
#line 1101 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP47_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP47_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP47_R_d = 1;
#line 1102 "instruments/plate49.instr"
  mccPoreP47_absorb_sides = 0;
#line 21169 "instruments/plate49.c"

  SIG_MESSAGE("PoreP47 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1104 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1104 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1104 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21179 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm47, mcrotaPoreP47);
  rot_transpose(mcrotaPoreP46, mctr1);
  rot_mul(mcrotaPoreP47, mctr1, mcrotrPoreP47);
  mctc1 = coords_set(
#line 1103 "instruments/plate49.instr"
    0,
#line 1103 "instruments/plate49.instr"
    radiusM,
#line 1103 "instruments/plate49.instr"
    0);
#line 21190 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm47, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP47 = coords_add(mcposaPoreArm47, mctc2);
  mctc1 = coords_sub(mcposaPoreP46, mcposaPoreP47);
  mcposrPoreP47 = rot_apply(mcrotaPoreP47, mctc1);
  mcDEBUG_COMPONENT("PoreP47", mcposaPoreP47, mcrotaPoreP47)
  mccomp_posa[101] = mcposaPoreP47;
  mccomp_posr[101] = mcposrPoreP47;
  mcNCounter[101]  = mcPCounter[101] = mcP2Counter[101] = 0;
  mcAbsorbProp[101]= 0;
    /* Component PoreP48. */
  /* Setting parameters for component PoreP48. */
  SIG_MESSAGE("PoreP48 (Init:SetPar)");
#line 1108 "instruments/plate49.instr"
  mccPoreP48_radius_p = radiusP;
#line 1109 "instruments/plate49.instr"
  mccPoreP48_radius_m = radiusM;
#line 1110 "instruments/plate49.instr"
  mccPoreP48_Z0 = FOCALLENGTH;
#line 1111 "instruments/plate49.instr"
  mccPoreP48_xwidth = poreW;
#line 1112 "instruments/plate49.instr"
  mccPoreP48_yheight = poreH;
#line 53 "instruments/plate49.instr"
  mccPoreP48_chamferwidth = 0;
#line 1113 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreP48_mirror_reflec, coating ? coating : "", 16384); else mccPoreP48_mirror_reflec[0]='\0';
#line 1114 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP48_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP48_bottom_reflec[0]='\0';
#line 1115 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreP48_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreP48_side_reflec[0]='\0';
#line 53 "instruments/plate49.instr"
  mccPoreP48_R_d = 1;
#line 1116 "instruments/plate49.instr"
  mccPoreP48_absorb_sides = 0;
#line 21226 "instruments/plate49.c"

  SIG_MESSAGE("PoreP48 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1118 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1118 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1118 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21236 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm48, mcrotaPoreP48);
  rot_transpose(mcrotaPoreP47, mctr1);
  rot_mul(mcrotaPoreP48, mctr1, mcrotrPoreP48);
  mctc1 = coords_set(
#line 1117 "instruments/plate49.instr"
    0,
#line 1117 "instruments/plate49.instr"
    radiusM,
#line 1117 "instruments/plate49.instr"
    0);
#line 21247 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm48, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreP48 = coords_add(mcposaPoreArm48, mctc2);
  mctc1 = coords_sub(mcposaPoreP47, mcposaPoreP48);
  mcposrPoreP48 = rot_apply(mcrotaPoreP48, mctc1);
  mcDEBUG_COMPONENT("PoreP48", mcposaPoreP48, mcrotaPoreP48)
  mccomp_posa[102] = mcposaPoreP48;
  mccomp_posr[102] = mcposrPoreP48;
  mcNCounter[102]  = mcPCounter[102] = mcP2Counter[102] = 0;
  mcAbsorbProp[102]= 0;
    /* Component PoreH0. */
  /* Setting parameters for component PoreH0. */
  SIG_MESSAGE("PoreH0 (Init:SetPar)");
#line 1128 "instruments/plate49.instr"
  mccPoreH0_radius_m = radiusM;
#line 1127 "instruments/plate49.instr"
  mccPoreH0_radius_h = radiusH;
#line 1129 "instruments/plate49.instr"
  mccPoreH0_Z0 = FOCALLENGTH;
#line 1130 "instruments/plate49.instr"
  mccPoreH0_xwidth = poreW;
#line 1131 "instruments/plate49.instr"
  mccPoreH0_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH0_chamferwidth = 0;
#line 1132 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH0_mirror_reflec, coating ? coating : "", 16384); else mccPoreH0_mirror_reflec[0]='\0';
#line 1133 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH0_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH0_bottom_reflec[0]='\0';
#line 1134 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH0_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH0_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH0_R_d = 1;
#line 1135 "instruments/plate49.instr"
  mccPoreH0_absorb_sides = 0;
#line 21283 "instruments/plate49.c"

  SIG_MESSAGE("PoreH0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1137 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1137 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1137 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21293 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm0, mcrotaPoreH0);
  rot_transpose(mcrotaPoreP48, mctr1);
  rot_mul(mcrotaPoreH0, mctr1, mcrotrPoreH0);
  mctc1 = coords_set(
#line 1136 "instruments/plate49.instr"
    0,
#line 1136 "instruments/plate49.instr"
    radiusM,
#line 1136 "instruments/plate49.instr"
    0);
#line 21304 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH0 = coords_add(mcposaPoreArm0, mctc2);
  mctc1 = coords_sub(mcposaPoreP48, mcposaPoreH0);
  mcposrPoreH0 = rot_apply(mcrotaPoreH0, mctc1);
  mcDEBUG_COMPONENT("PoreH0", mcposaPoreH0, mcrotaPoreH0)
  mccomp_posa[103] = mcposaPoreH0;
  mccomp_posr[103] = mcposrPoreH0;
  mcNCounter[103]  = mcPCounter[103] = mcP2Counter[103] = 0;
  mcAbsorbProp[103]= 0;
    /* Component PoreH1. */
  /* Setting parameters for component PoreH1. */
  SIG_MESSAGE("PoreH1 (Init:SetPar)");
#line 1142 "instruments/plate49.instr"
  mccPoreH1_radius_m = radiusM;
#line 1141 "instruments/plate49.instr"
  mccPoreH1_radius_h = radiusH;
#line 1143 "instruments/plate49.instr"
  mccPoreH1_Z0 = FOCALLENGTH;
#line 1144 "instruments/plate49.instr"
  mccPoreH1_xwidth = poreW;
#line 1145 "instruments/plate49.instr"
  mccPoreH1_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH1_chamferwidth = 0;
#line 1146 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH1_mirror_reflec, coating ? coating : "", 16384); else mccPoreH1_mirror_reflec[0]='\0';
#line 1147 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH1_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH1_bottom_reflec[0]='\0';
#line 1148 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH1_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH1_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH1_R_d = 1;
#line 1149 "instruments/plate49.instr"
  mccPoreH1_absorb_sides = 0;
#line 21340 "instruments/plate49.c"

  SIG_MESSAGE("PoreH1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1151 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1151 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1151 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21350 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm1, mcrotaPoreH1);
  rot_transpose(mcrotaPoreH0, mctr1);
  rot_mul(mcrotaPoreH1, mctr1, mcrotrPoreH1);
  mctc1 = coords_set(
#line 1150 "instruments/plate49.instr"
    0,
#line 1150 "instruments/plate49.instr"
    radiusM,
#line 1150 "instruments/plate49.instr"
    0);
#line 21361 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH1 = coords_add(mcposaPoreArm1, mctc2);
  mctc1 = coords_sub(mcposaPoreH0, mcposaPoreH1);
  mcposrPoreH1 = rot_apply(mcrotaPoreH1, mctc1);
  mcDEBUG_COMPONENT("PoreH1", mcposaPoreH1, mcrotaPoreH1)
  mccomp_posa[104] = mcposaPoreH1;
  mccomp_posr[104] = mcposrPoreH1;
  mcNCounter[104]  = mcPCounter[104] = mcP2Counter[104] = 0;
  mcAbsorbProp[104]= 0;
    /* Component PoreH2. */
  /* Setting parameters for component PoreH2. */
  SIG_MESSAGE("PoreH2 (Init:SetPar)");
#line 1156 "instruments/plate49.instr"
  mccPoreH2_radius_m = radiusM;
#line 1155 "instruments/plate49.instr"
  mccPoreH2_radius_h = radiusH;
#line 1157 "instruments/plate49.instr"
  mccPoreH2_Z0 = FOCALLENGTH;
#line 1158 "instruments/plate49.instr"
  mccPoreH2_xwidth = poreW;
#line 1159 "instruments/plate49.instr"
  mccPoreH2_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH2_chamferwidth = 0;
#line 1160 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH2_mirror_reflec, coating ? coating : "", 16384); else mccPoreH2_mirror_reflec[0]='\0';
#line 1161 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH2_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH2_bottom_reflec[0]='\0';
#line 1162 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH2_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH2_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH2_R_d = 1;
#line 1163 "instruments/plate49.instr"
  mccPoreH2_absorb_sides = 0;
#line 21397 "instruments/plate49.c"

  SIG_MESSAGE("PoreH2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1165 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1165 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1165 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21407 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm2, mcrotaPoreH2);
  rot_transpose(mcrotaPoreH1, mctr1);
  rot_mul(mcrotaPoreH2, mctr1, mcrotrPoreH2);
  mctc1 = coords_set(
#line 1164 "instruments/plate49.instr"
    0,
#line 1164 "instruments/plate49.instr"
    radiusM,
#line 1164 "instruments/plate49.instr"
    0);
#line 21418 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH2 = coords_add(mcposaPoreArm2, mctc2);
  mctc1 = coords_sub(mcposaPoreH1, mcposaPoreH2);
  mcposrPoreH2 = rot_apply(mcrotaPoreH2, mctc1);
  mcDEBUG_COMPONENT("PoreH2", mcposaPoreH2, mcrotaPoreH2)
  mccomp_posa[105] = mcposaPoreH2;
  mccomp_posr[105] = mcposrPoreH2;
  mcNCounter[105]  = mcPCounter[105] = mcP2Counter[105] = 0;
  mcAbsorbProp[105]= 0;
    /* Component PoreH3. */
  /* Setting parameters for component PoreH3. */
  SIG_MESSAGE("PoreH3 (Init:SetPar)");
#line 1170 "instruments/plate49.instr"
  mccPoreH3_radius_m = radiusM;
#line 1169 "instruments/plate49.instr"
  mccPoreH3_radius_h = radiusH;
#line 1171 "instruments/plate49.instr"
  mccPoreH3_Z0 = FOCALLENGTH;
#line 1172 "instruments/plate49.instr"
  mccPoreH3_xwidth = poreW;
#line 1173 "instruments/plate49.instr"
  mccPoreH3_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH3_chamferwidth = 0;
#line 1174 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH3_mirror_reflec, coating ? coating : "", 16384); else mccPoreH3_mirror_reflec[0]='\0';
#line 1175 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH3_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH3_bottom_reflec[0]='\0';
#line 1176 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH3_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH3_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH3_R_d = 1;
#line 1177 "instruments/plate49.instr"
  mccPoreH3_absorb_sides = 0;
#line 21454 "instruments/plate49.c"

  SIG_MESSAGE("PoreH3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1179 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1179 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1179 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21464 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm3, mcrotaPoreH3);
  rot_transpose(mcrotaPoreH2, mctr1);
  rot_mul(mcrotaPoreH3, mctr1, mcrotrPoreH3);
  mctc1 = coords_set(
#line 1178 "instruments/plate49.instr"
    0,
#line 1178 "instruments/plate49.instr"
    radiusM,
#line 1178 "instruments/plate49.instr"
    0);
#line 21475 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH3 = coords_add(mcposaPoreArm3, mctc2);
  mctc1 = coords_sub(mcposaPoreH2, mcposaPoreH3);
  mcposrPoreH3 = rot_apply(mcrotaPoreH3, mctc1);
  mcDEBUG_COMPONENT("PoreH3", mcposaPoreH3, mcrotaPoreH3)
  mccomp_posa[106] = mcposaPoreH3;
  mccomp_posr[106] = mcposrPoreH3;
  mcNCounter[106]  = mcPCounter[106] = mcP2Counter[106] = 0;
  mcAbsorbProp[106]= 0;
    /* Component PoreH4. */
  /* Setting parameters for component PoreH4. */
  SIG_MESSAGE("PoreH4 (Init:SetPar)");
#line 1184 "instruments/plate49.instr"
  mccPoreH4_radius_m = radiusM;
#line 1183 "instruments/plate49.instr"
  mccPoreH4_radius_h = radiusH;
#line 1185 "instruments/plate49.instr"
  mccPoreH4_Z0 = FOCALLENGTH;
#line 1186 "instruments/plate49.instr"
  mccPoreH4_xwidth = poreW;
#line 1187 "instruments/plate49.instr"
  mccPoreH4_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH4_chamferwidth = 0;
#line 1188 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH4_mirror_reflec, coating ? coating : "", 16384); else mccPoreH4_mirror_reflec[0]='\0';
#line 1189 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH4_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH4_bottom_reflec[0]='\0';
#line 1190 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH4_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH4_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH4_R_d = 1;
#line 1191 "instruments/plate49.instr"
  mccPoreH4_absorb_sides = 0;
#line 21511 "instruments/plate49.c"

  SIG_MESSAGE("PoreH4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1193 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1193 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1193 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21521 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm4, mcrotaPoreH4);
  rot_transpose(mcrotaPoreH3, mctr1);
  rot_mul(mcrotaPoreH4, mctr1, mcrotrPoreH4);
  mctc1 = coords_set(
#line 1192 "instruments/plate49.instr"
    0,
#line 1192 "instruments/plate49.instr"
    radiusM,
#line 1192 "instruments/plate49.instr"
    0);
#line 21532 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH4 = coords_add(mcposaPoreArm4, mctc2);
  mctc1 = coords_sub(mcposaPoreH3, mcposaPoreH4);
  mcposrPoreH4 = rot_apply(mcrotaPoreH4, mctc1);
  mcDEBUG_COMPONENT("PoreH4", mcposaPoreH4, mcrotaPoreH4)
  mccomp_posa[107] = mcposaPoreH4;
  mccomp_posr[107] = mcposrPoreH4;
  mcNCounter[107]  = mcPCounter[107] = mcP2Counter[107] = 0;
  mcAbsorbProp[107]= 0;
    /* Component PoreH5. */
  /* Setting parameters for component PoreH5. */
  SIG_MESSAGE("PoreH5 (Init:SetPar)");
#line 1198 "instruments/plate49.instr"
  mccPoreH5_radius_m = radiusM;
#line 1197 "instruments/plate49.instr"
  mccPoreH5_radius_h = radiusH;
#line 1199 "instruments/plate49.instr"
  mccPoreH5_Z0 = FOCALLENGTH;
#line 1200 "instruments/plate49.instr"
  mccPoreH5_xwidth = poreW;
#line 1201 "instruments/plate49.instr"
  mccPoreH5_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH5_chamferwidth = 0;
#line 1202 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH5_mirror_reflec, coating ? coating : "", 16384); else mccPoreH5_mirror_reflec[0]='\0';
#line 1203 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH5_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH5_bottom_reflec[0]='\0';
#line 1204 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH5_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH5_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH5_R_d = 1;
#line 1205 "instruments/plate49.instr"
  mccPoreH5_absorb_sides = 0;
#line 21568 "instruments/plate49.c"

  SIG_MESSAGE("PoreH5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1207 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1207 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1207 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21578 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm5, mcrotaPoreH5);
  rot_transpose(mcrotaPoreH4, mctr1);
  rot_mul(mcrotaPoreH5, mctr1, mcrotrPoreH5);
  mctc1 = coords_set(
#line 1206 "instruments/plate49.instr"
    0,
#line 1206 "instruments/plate49.instr"
    radiusM,
#line 1206 "instruments/plate49.instr"
    0);
#line 21589 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH5 = coords_add(mcposaPoreArm5, mctc2);
  mctc1 = coords_sub(mcposaPoreH4, mcposaPoreH5);
  mcposrPoreH5 = rot_apply(mcrotaPoreH5, mctc1);
  mcDEBUG_COMPONENT("PoreH5", mcposaPoreH5, mcrotaPoreH5)
  mccomp_posa[108] = mcposaPoreH5;
  mccomp_posr[108] = mcposrPoreH5;
  mcNCounter[108]  = mcPCounter[108] = mcP2Counter[108] = 0;
  mcAbsorbProp[108]= 0;
    /* Component PoreH6. */
  /* Setting parameters for component PoreH6. */
  SIG_MESSAGE("PoreH6 (Init:SetPar)");
#line 1212 "instruments/plate49.instr"
  mccPoreH6_radius_m = radiusM;
#line 1211 "instruments/plate49.instr"
  mccPoreH6_radius_h = radiusH;
#line 1213 "instruments/plate49.instr"
  mccPoreH6_Z0 = FOCALLENGTH;
#line 1214 "instruments/plate49.instr"
  mccPoreH6_xwidth = poreW;
#line 1215 "instruments/plate49.instr"
  mccPoreH6_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH6_chamferwidth = 0;
#line 1216 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH6_mirror_reflec, coating ? coating : "", 16384); else mccPoreH6_mirror_reflec[0]='\0';
#line 1217 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH6_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH6_bottom_reflec[0]='\0';
#line 1218 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH6_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH6_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH6_R_d = 1;
#line 1219 "instruments/plate49.instr"
  mccPoreH6_absorb_sides = 0;
#line 21625 "instruments/plate49.c"

  SIG_MESSAGE("PoreH6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1221 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1221 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1221 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21635 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm6, mcrotaPoreH6);
  rot_transpose(mcrotaPoreH5, mctr1);
  rot_mul(mcrotaPoreH6, mctr1, mcrotrPoreH6);
  mctc1 = coords_set(
#line 1220 "instruments/plate49.instr"
    0,
#line 1220 "instruments/plate49.instr"
    radiusM,
#line 1220 "instruments/plate49.instr"
    0);
#line 21646 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH6 = coords_add(mcposaPoreArm6, mctc2);
  mctc1 = coords_sub(mcposaPoreH5, mcposaPoreH6);
  mcposrPoreH6 = rot_apply(mcrotaPoreH6, mctc1);
  mcDEBUG_COMPONENT("PoreH6", mcposaPoreH6, mcrotaPoreH6)
  mccomp_posa[109] = mcposaPoreH6;
  mccomp_posr[109] = mcposrPoreH6;
  mcNCounter[109]  = mcPCounter[109] = mcP2Counter[109] = 0;
  mcAbsorbProp[109]= 0;
    /* Component PoreH7. */
  /* Setting parameters for component PoreH7. */
  SIG_MESSAGE("PoreH7 (Init:SetPar)");
#line 1226 "instruments/plate49.instr"
  mccPoreH7_radius_m = radiusM;
#line 1225 "instruments/plate49.instr"
  mccPoreH7_radius_h = radiusH;
#line 1227 "instruments/plate49.instr"
  mccPoreH7_Z0 = FOCALLENGTH;
#line 1228 "instruments/plate49.instr"
  mccPoreH7_xwidth = poreW;
#line 1229 "instruments/plate49.instr"
  mccPoreH7_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH7_chamferwidth = 0;
#line 1230 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH7_mirror_reflec, coating ? coating : "", 16384); else mccPoreH7_mirror_reflec[0]='\0';
#line 1231 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH7_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH7_bottom_reflec[0]='\0';
#line 1232 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH7_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH7_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH7_R_d = 1;
#line 1233 "instruments/plate49.instr"
  mccPoreH7_absorb_sides = 0;
#line 21682 "instruments/plate49.c"

  SIG_MESSAGE("PoreH7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1235 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1235 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1235 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21692 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm7, mcrotaPoreH7);
  rot_transpose(mcrotaPoreH6, mctr1);
  rot_mul(mcrotaPoreH7, mctr1, mcrotrPoreH7);
  mctc1 = coords_set(
#line 1234 "instruments/plate49.instr"
    0,
#line 1234 "instruments/plate49.instr"
    radiusM,
#line 1234 "instruments/plate49.instr"
    0);
#line 21703 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm7, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH7 = coords_add(mcposaPoreArm7, mctc2);
  mctc1 = coords_sub(mcposaPoreH6, mcposaPoreH7);
  mcposrPoreH7 = rot_apply(mcrotaPoreH7, mctc1);
  mcDEBUG_COMPONENT("PoreH7", mcposaPoreH7, mcrotaPoreH7)
  mccomp_posa[110] = mcposaPoreH7;
  mccomp_posr[110] = mcposrPoreH7;
  mcNCounter[110]  = mcPCounter[110] = mcP2Counter[110] = 0;
  mcAbsorbProp[110]= 0;
    /* Component PoreH8. */
  /* Setting parameters for component PoreH8. */
  SIG_MESSAGE("PoreH8 (Init:SetPar)");
#line 1240 "instruments/plate49.instr"
  mccPoreH8_radius_m = radiusM;
#line 1239 "instruments/plate49.instr"
  mccPoreH8_radius_h = radiusH;
#line 1241 "instruments/plate49.instr"
  mccPoreH8_Z0 = FOCALLENGTH;
#line 1242 "instruments/plate49.instr"
  mccPoreH8_xwidth = poreW;
#line 1243 "instruments/plate49.instr"
  mccPoreH8_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH8_chamferwidth = 0;
#line 1244 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH8_mirror_reflec, coating ? coating : "", 16384); else mccPoreH8_mirror_reflec[0]='\0';
#line 1245 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH8_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH8_bottom_reflec[0]='\0';
#line 1246 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH8_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH8_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH8_R_d = 1;
#line 1247 "instruments/plate49.instr"
  mccPoreH8_absorb_sides = 0;
#line 21739 "instruments/plate49.c"

  SIG_MESSAGE("PoreH8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1249 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1249 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1249 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21749 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm8, mcrotaPoreH8);
  rot_transpose(mcrotaPoreH7, mctr1);
  rot_mul(mcrotaPoreH8, mctr1, mcrotrPoreH8);
  mctc1 = coords_set(
#line 1248 "instruments/plate49.instr"
    0,
#line 1248 "instruments/plate49.instr"
    radiusM,
#line 1248 "instruments/plate49.instr"
    0);
#line 21760 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm8, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH8 = coords_add(mcposaPoreArm8, mctc2);
  mctc1 = coords_sub(mcposaPoreH7, mcposaPoreH8);
  mcposrPoreH8 = rot_apply(mcrotaPoreH8, mctc1);
  mcDEBUG_COMPONENT("PoreH8", mcposaPoreH8, mcrotaPoreH8)
  mccomp_posa[111] = mcposaPoreH8;
  mccomp_posr[111] = mcposrPoreH8;
  mcNCounter[111]  = mcPCounter[111] = mcP2Counter[111] = 0;
  mcAbsorbProp[111]= 0;
    /* Component PoreH9. */
  /* Setting parameters for component PoreH9. */
  SIG_MESSAGE("PoreH9 (Init:SetPar)");
#line 1254 "instruments/plate49.instr"
  mccPoreH9_radius_m = radiusM;
#line 1253 "instruments/plate49.instr"
  mccPoreH9_radius_h = radiusH;
#line 1255 "instruments/plate49.instr"
  mccPoreH9_Z0 = FOCALLENGTH;
#line 1256 "instruments/plate49.instr"
  mccPoreH9_xwidth = poreW;
#line 1257 "instruments/plate49.instr"
  mccPoreH9_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH9_chamferwidth = 0;
#line 1258 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH9_mirror_reflec, coating ? coating : "", 16384); else mccPoreH9_mirror_reflec[0]='\0';
#line 1259 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH9_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH9_bottom_reflec[0]='\0';
#line 1260 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH9_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH9_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH9_R_d = 1;
#line 1261 "instruments/plate49.instr"
  mccPoreH9_absorb_sides = 0;
#line 21796 "instruments/plate49.c"

  SIG_MESSAGE("PoreH9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1263 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1263 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1263 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21806 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm9, mcrotaPoreH9);
  rot_transpose(mcrotaPoreH8, mctr1);
  rot_mul(mcrotaPoreH9, mctr1, mcrotrPoreH9);
  mctc1 = coords_set(
#line 1262 "instruments/plate49.instr"
    0,
#line 1262 "instruments/plate49.instr"
    radiusM,
#line 1262 "instruments/plate49.instr"
    0);
#line 21817 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm9, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH9 = coords_add(mcposaPoreArm9, mctc2);
  mctc1 = coords_sub(mcposaPoreH8, mcposaPoreH9);
  mcposrPoreH9 = rot_apply(mcrotaPoreH9, mctc1);
  mcDEBUG_COMPONENT("PoreH9", mcposaPoreH9, mcrotaPoreH9)
  mccomp_posa[112] = mcposaPoreH9;
  mccomp_posr[112] = mcposrPoreH9;
  mcNCounter[112]  = mcPCounter[112] = mcP2Counter[112] = 0;
  mcAbsorbProp[112]= 0;
    /* Component PoreH10. */
  /* Setting parameters for component PoreH10. */
  SIG_MESSAGE("PoreH10 (Init:SetPar)");
#line 1268 "instruments/plate49.instr"
  mccPoreH10_radius_m = radiusM;
#line 1267 "instruments/plate49.instr"
  mccPoreH10_radius_h = radiusH;
#line 1269 "instruments/plate49.instr"
  mccPoreH10_Z0 = FOCALLENGTH;
#line 1270 "instruments/plate49.instr"
  mccPoreH10_xwidth = poreW;
#line 1271 "instruments/plate49.instr"
  mccPoreH10_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH10_chamferwidth = 0;
#line 1272 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH10_mirror_reflec, coating ? coating : "", 16384); else mccPoreH10_mirror_reflec[0]='\0';
#line 1273 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH10_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH10_bottom_reflec[0]='\0';
#line 1274 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH10_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH10_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH10_R_d = 1;
#line 1275 "instruments/plate49.instr"
  mccPoreH10_absorb_sides = 0;
#line 21853 "instruments/plate49.c"

  SIG_MESSAGE("PoreH10 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1277 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1277 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1277 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21863 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm10, mcrotaPoreH10);
  rot_transpose(mcrotaPoreH9, mctr1);
  rot_mul(mcrotaPoreH10, mctr1, mcrotrPoreH10);
  mctc1 = coords_set(
#line 1276 "instruments/plate49.instr"
    0,
#line 1276 "instruments/plate49.instr"
    radiusM,
#line 1276 "instruments/plate49.instr"
    0);
#line 21874 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm10, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH10 = coords_add(mcposaPoreArm10, mctc2);
  mctc1 = coords_sub(mcposaPoreH9, mcposaPoreH10);
  mcposrPoreH10 = rot_apply(mcrotaPoreH10, mctc1);
  mcDEBUG_COMPONENT("PoreH10", mcposaPoreH10, mcrotaPoreH10)
  mccomp_posa[113] = mcposaPoreH10;
  mccomp_posr[113] = mcposrPoreH10;
  mcNCounter[113]  = mcPCounter[113] = mcP2Counter[113] = 0;
  mcAbsorbProp[113]= 0;
    /* Component PoreH11. */
  /* Setting parameters for component PoreH11. */
  SIG_MESSAGE("PoreH11 (Init:SetPar)");
#line 1282 "instruments/plate49.instr"
  mccPoreH11_radius_m = radiusM;
#line 1281 "instruments/plate49.instr"
  mccPoreH11_radius_h = radiusH;
#line 1283 "instruments/plate49.instr"
  mccPoreH11_Z0 = FOCALLENGTH;
#line 1284 "instruments/plate49.instr"
  mccPoreH11_xwidth = poreW;
#line 1285 "instruments/plate49.instr"
  mccPoreH11_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH11_chamferwidth = 0;
#line 1286 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH11_mirror_reflec, coating ? coating : "", 16384); else mccPoreH11_mirror_reflec[0]='\0';
#line 1287 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH11_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH11_bottom_reflec[0]='\0';
#line 1288 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH11_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH11_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH11_R_d = 1;
#line 1289 "instruments/plate49.instr"
  mccPoreH11_absorb_sides = 0;
#line 21910 "instruments/plate49.c"

  SIG_MESSAGE("PoreH11 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1291 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1291 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1291 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21920 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm11, mcrotaPoreH11);
  rot_transpose(mcrotaPoreH10, mctr1);
  rot_mul(mcrotaPoreH11, mctr1, mcrotrPoreH11);
  mctc1 = coords_set(
#line 1290 "instruments/plate49.instr"
    0,
#line 1290 "instruments/plate49.instr"
    radiusM,
#line 1290 "instruments/plate49.instr"
    0);
#line 21931 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm11, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH11 = coords_add(mcposaPoreArm11, mctc2);
  mctc1 = coords_sub(mcposaPoreH10, mcposaPoreH11);
  mcposrPoreH11 = rot_apply(mcrotaPoreH11, mctc1);
  mcDEBUG_COMPONENT("PoreH11", mcposaPoreH11, mcrotaPoreH11)
  mccomp_posa[114] = mcposaPoreH11;
  mccomp_posr[114] = mcposrPoreH11;
  mcNCounter[114]  = mcPCounter[114] = mcP2Counter[114] = 0;
  mcAbsorbProp[114]= 0;
    /* Component PoreH12. */
  /* Setting parameters for component PoreH12. */
  SIG_MESSAGE("PoreH12 (Init:SetPar)");
#line 1296 "instruments/plate49.instr"
  mccPoreH12_radius_m = radiusM;
#line 1295 "instruments/plate49.instr"
  mccPoreH12_radius_h = radiusH;
#line 1297 "instruments/plate49.instr"
  mccPoreH12_Z0 = FOCALLENGTH;
#line 1298 "instruments/plate49.instr"
  mccPoreH12_xwidth = poreW;
#line 1299 "instruments/plate49.instr"
  mccPoreH12_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH12_chamferwidth = 0;
#line 1300 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH12_mirror_reflec, coating ? coating : "", 16384); else mccPoreH12_mirror_reflec[0]='\0';
#line 1301 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH12_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH12_bottom_reflec[0]='\0';
#line 1302 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH12_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH12_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH12_R_d = 1;
#line 1303 "instruments/plate49.instr"
  mccPoreH12_absorb_sides = 0;
#line 21967 "instruments/plate49.c"

  SIG_MESSAGE("PoreH12 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1305 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1305 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1305 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 21977 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm12, mcrotaPoreH12);
  rot_transpose(mcrotaPoreH11, mctr1);
  rot_mul(mcrotaPoreH12, mctr1, mcrotrPoreH12);
  mctc1 = coords_set(
#line 1304 "instruments/plate49.instr"
    0,
#line 1304 "instruments/plate49.instr"
    radiusM,
#line 1304 "instruments/plate49.instr"
    0);
#line 21988 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm12, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH12 = coords_add(mcposaPoreArm12, mctc2);
  mctc1 = coords_sub(mcposaPoreH11, mcposaPoreH12);
  mcposrPoreH12 = rot_apply(mcrotaPoreH12, mctc1);
  mcDEBUG_COMPONENT("PoreH12", mcposaPoreH12, mcrotaPoreH12)
  mccomp_posa[115] = mcposaPoreH12;
  mccomp_posr[115] = mcposrPoreH12;
  mcNCounter[115]  = mcPCounter[115] = mcP2Counter[115] = 0;
  mcAbsorbProp[115]= 0;
    /* Component PoreH13. */
  /* Setting parameters for component PoreH13. */
  SIG_MESSAGE("PoreH13 (Init:SetPar)");
#line 1310 "instruments/plate49.instr"
  mccPoreH13_radius_m = radiusM;
#line 1309 "instruments/plate49.instr"
  mccPoreH13_radius_h = radiusH;
#line 1311 "instruments/plate49.instr"
  mccPoreH13_Z0 = FOCALLENGTH;
#line 1312 "instruments/plate49.instr"
  mccPoreH13_xwidth = poreW;
#line 1313 "instruments/plate49.instr"
  mccPoreH13_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH13_chamferwidth = 0;
#line 1314 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH13_mirror_reflec, coating ? coating : "", 16384); else mccPoreH13_mirror_reflec[0]='\0';
#line 1315 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH13_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH13_bottom_reflec[0]='\0';
#line 1316 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH13_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH13_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH13_R_d = 1;
#line 1317 "instruments/plate49.instr"
  mccPoreH13_absorb_sides = 0;
#line 22024 "instruments/plate49.c"

  SIG_MESSAGE("PoreH13 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1319 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1319 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1319 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22034 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm13, mcrotaPoreH13);
  rot_transpose(mcrotaPoreH12, mctr1);
  rot_mul(mcrotaPoreH13, mctr1, mcrotrPoreH13);
  mctc1 = coords_set(
#line 1318 "instruments/plate49.instr"
    0,
#line 1318 "instruments/plate49.instr"
    radiusM,
#line 1318 "instruments/plate49.instr"
    0);
#line 22045 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm13, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH13 = coords_add(mcposaPoreArm13, mctc2);
  mctc1 = coords_sub(mcposaPoreH12, mcposaPoreH13);
  mcposrPoreH13 = rot_apply(mcrotaPoreH13, mctc1);
  mcDEBUG_COMPONENT("PoreH13", mcposaPoreH13, mcrotaPoreH13)
  mccomp_posa[116] = mcposaPoreH13;
  mccomp_posr[116] = mcposrPoreH13;
  mcNCounter[116]  = mcPCounter[116] = mcP2Counter[116] = 0;
  mcAbsorbProp[116]= 0;
    /* Component PoreH14. */
  /* Setting parameters for component PoreH14. */
  SIG_MESSAGE("PoreH14 (Init:SetPar)");
#line 1324 "instruments/plate49.instr"
  mccPoreH14_radius_m = radiusM;
#line 1323 "instruments/plate49.instr"
  mccPoreH14_radius_h = radiusH;
#line 1325 "instruments/plate49.instr"
  mccPoreH14_Z0 = FOCALLENGTH;
#line 1326 "instruments/plate49.instr"
  mccPoreH14_xwidth = poreW;
#line 1327 "instruments/plate49.instr"
  mccPoreH14_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH14_chamferwidth = 0;
#line 1328 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH14_mirror_reflec, coating ? coating : "", 16384); else mccPoreH14_mirror_reflec[0]='\0';
#line 1329 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH14_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH14_bottom_reflec[0]='\0';
#line 1330 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH14_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH14_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH14_R_d = 1;
#line 1331 "instruments/plate49.instr"
  mccPoreH14_absorb_sides = 0;
#line 22081 "instruments/plate49.c"

  SIG_MESSAGE("PoreH14 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1333 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1333 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1333 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22091 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm14, mcrotaPoreH14);
  rot_transpose(mcrotaPoreH13, mctr1);
  rot_mul(mcrotaPoreH14, mctr1, mcrotrPoreH14);
  mctc1 = coords_set(
#line 1332 "instruments/plate49.instr"
    0,
#line 1332 "instruments/plate49.instr"
    radiusM,
#line 1332 "instruments/plate49.instr"
    0);
#line 22102 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm14, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH14 = coords_add(mcposaPoreArm14, mctc2);
  mctc1 = coords_sub(mcposaPoreH13, mcposaPoreH14);
  mcposrPoreH14 = rot_apply(mcrotaPoreH14, mctc1);
  mcDEBUG_COMPONENT("PoreH14", mcposaPoreH14, mcrotaPoreH14)
  mccomp_posa[117] = mcposaPoreH14;
  mccomp_posr[117] = mcposrPoreH14;
  mcNCounter[117]  = mcPCounter[117] = mcP2Counter[117] = 0;
  mcAbsorbProp[117]= 0;
    /* Component PoreH15. */
  /* Setting parameters for component PoreH15. */
  SIG_MESSAGE("PoreH15 (Init:SetPar)");
#line 1338 "instruments/plate49.instr"
  mccPoreH15_radius_m = radiusM;
#line 1337 "instruments/plate49.instr"
  mccPoreH15_radius_h = radiusH;
#line 1339 "instruments/plate49.instr"
  mccPoreH15_Z0 = FOCALLENGTH;
#line 1340 "instruments/plate49.instr"
  mccPoreH15_xwidth = poreW;
#line 1341 "instruments/plate49.instr"
  mccPoreH15_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH15_chamferwidth = 0;
#line 1342 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH15_mirror_reflec, coating ? coating : "", 16384); else mccPoreH15_mirror_reflec[0]='\0';
#line 1343 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH15_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH15_bottom_reflec[0]='\0';
#line 1344 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH15_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH15_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH15_R_d = 1;
#line 1345 "instruments/plate49.instr"
  mccPoreH15_absorb_sides = 0;
#line 22138 "instruments/plate49.c"

  SIG_MESSAGE("PoreH15 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1347 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1347 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1347 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22148 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm15, mcrotaPoreH15);
  rot_transpose(mcrotaPoreH14, mctr1);
  rot_mul(mcrotaPoreH15, mctr1, mcrotrPoreH15);
  mctc1 = coords_set(
#line 1346 "instruments/plate49.instr"
    0,
#line 1346 "instruments/plate49.instr"
    radiusM,
#line 1346 "instruments/plate49.instr"
    0);
#line 22159 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm15, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH15 = coords_add(mcposaPoreArm15, mctc2);
  mctc1 = coords_sub(mcposaPoreH14, mcposaPoreH15);
  mcposrPoreH15 = rot_apply(mcrotaPoreH15, mctc1);
  mcDEBUG_COMPONENT("PoreH15", mcposaPoreH15, mcrotaPoreH15)
  mccomp_posa[118] = mcposaPoreH15;
  mccomp_posr[118] = mcposrPoreH15;
  mcNCounter[118]  = mcPCounter[118] = mcP2Counter[118] = 0;
  mcAbsorbProp[118]= 0;
    /* Component PoreH16. */
  /* Setting parameters for component PoreH16. */
  SIG_MESSAGE("PoreH16 (Init:SetPar)");
#line 1352 "instruments/plate49.instr"
  mccPoreH16_radius_m = radiusM;
#line 1351 "instruments/plate49.instr"
  mccPoreH16_radius_h = radiusH;
#line 1353 "instruments/plate49.instr"
  mccPoreH16_Z0 = FOCALLENGTH;
#line 1354 "instruments/plate49.instr"
  mccPoreH16_xwidth = poreW;
#line 1355 "instruments/plate49.instr"
  mccPoreH16_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH16_chamferwidth = 0;
#line 1356 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH16_mirror_reflec, coating ? coating : "", 16384); else mccPoreH16_mirror_reflec[0]='\0';
#line 1357 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH16_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH16_bottom_reflec[0]='\0';
#line 1358 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH16_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH16_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH16_R_d = 1;
#line 1359 "instruments/plate49.instr"
  mccPoreH16_absorb_sides = 0;
#line 22195 "instruments/plate49.c"

  SIG_MESSAGE("PoreH16 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1361 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1361 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1361 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22205 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm16, mcrotaPoreH16);
  rot_transpose(mcrotaPoreH15, mctr1);
  rot_mul(mcrotaPoreH16, mctr1, mcrotrPoreH16);
  mctc1 = coords_set(
#line 1360 "instruments/plate49.instr"
    0,
#line 1360 "instruments/plate49.instr"
    radiusM,
#line 1360 "instruments/plate49.instr"
    0);
#line 22216 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm16, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH16 = coords_add(mcposaPoreArm16, mctc2);
  mctc1 = coords_sub(mcposaPoreH15, mcposaPoreH16);
  mcposrPoreH16 = rot_apply(mcrotaPoreH16, mctc1);
  mcDEBUG_COMPONENT("PoreH16", mcposaPoreH16, mcrotaPoreH16)
  mccomp_posa[119] = mcposaPoreH16;
  mccomp_posr[119] = mcposrPoreH16;
  mcNCounter[119]  = mcPCounter[119] = mcP2Counter[119] = 0;
  mcAbsorbProp[119]= 0;
    /* Component PoreH17. */
  /* Setting parameters for component PoreH17. */
  SIG_MESSAGE("PoreH17 (Init:SetPar)");
#line 1366 "instruments/plate49.instr"
  mccPoreH17_radius_m = radiusM;
#line 1365 "instruments/plate49.instr"
  mccPoreH17_radius_h = radiusH;
#line 1367 "instruments/plate49.instr"
  mccPoreH17_Z0 = FOCALLENGTH;
#line 1368 "instruments/plate49.instr"
  mccPoreH17_xwidth = poreW;
#line 1369 "instruments/plate49.instr"
  mccPoreH17_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH17_chamferwidth = 0;
#line 1370 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH17_mirror_reflec, coating ? coating : "", 16384); else mccPoreH17_mirror_reflec[0]='\0';
#line 1371 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH17_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH17_bottom_reflec[0]='\0';
#line 1372 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH17_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH17_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH17_R_d = 1;
#line 1373 "instruments/plate49.instr"
  mccPoreH17_absorb_sides = 0;
#line 22252 "instruments/plate49.c"

  SIG_MESSAGE("PoreH17 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1375 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1375 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1375 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22262 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm17, mcrotaPoreH17);
  rot_transpose(mcrotaPoreH16, mctr1);
  rot_mul(mcrotaPoreH17, mctr1, mcrotrPoreH17);
  mctc1 = coords_set(
#line 1374 "instruments/plate49.instr"
    0,
#line 1374 "instruments/plate49.instr"
    radiusM,
#line 1374 "instruments/plate49.instr"
    0);
#line 22273 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm17, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH17 = coords_add(mcposaPoreArm17, mctc2);
  mctc1 = coords_sub(mcposaPoreH16, mcposaPoreH17);
  mcposrPoreH17 = rot_apply(mcrotaPoreH17, mctc1);
  mcDEBUG_COMPONENT("PoreH17", mcposaPoreH17, mcrotaPoreH17)
  mccomp_posa[120] = mcposaPoreH17;
  mccomp_posr[120] = mcposrPoreH17;
  mcNCounter[120]  = mcPCounter[120] = mcP2Counter[120] = 0;
  mcAbsorbProp[120]= 0;
    /* Component PoreH18. */
  /* Setting parameters for component PoreH18. */
  SIG_MESSAGE("PoreH18 (Init:SetPar)");
#line 1380 "instruments/plate49.instr"
  mccPoreH18_radius_m = radiusM;
#line 1379 "instruments/plate49.instr"
  mccPoreH18_radius_h = radiusH;
#line 1381 "instruments/plate49.instr"
  mccPoreH18_Z0 = FOCALLENGTH;
#line 1382 "instruments/plate49.instr"
  mccPoreH18_xwidth = poreW;
#line 1383 "instruments/plate49.instr"
  mccPoreH18_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH18_chamferwidth = 0;
#line 1384 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH18_mirror_reflec, coating ? coating : "", 16384); else mccPoreH18_mirror_reflec[0]='\0';
#line 1385 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH18_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH18_bottom_reflec[0]='\0';
#line 1386 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH18_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH18_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH18_R_d = 1;
#line 1387 "instruments/plate49.instr"
  mccPoreH18_absorb_sides = 0;
#line 22309 "instruments/plate49.c"

  SIG_MESSAGE("PoreH18 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1389 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1389 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1389 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22319 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm18, mcrotaPoreH18);
  rot_transpose(mcrotaPoreH17, mctr1);
  rot_mul(mcrotaPoreH18, mctr1, mcrotrPoreH18);
  mctc1 = coords_set(
#line 1388 "instruments/plate49.instr"
    0,
#line 1388 "instruments/plate49.instr"
    radiusM,
#line 1388 "instruments/plate49.instr"
    0);
#line 22330 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm18, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH18 = coords_add(mcposaPoreArm18, mctc2);
  mctc1 = coords_sub(mcposaPoreH17, mcposaPoreH18);
  mcposrPoreH18 = rot_apply(mcrotaPoreH18, mctc1);
  mcDEBUG_COMPONENT("PoreH18", mcposaPoreH18, mcrotaPoreH18)
  mccomp_posa[121] = mcposaPoreH18;
  mccomp_posr[121] = mcposrPoreH18;
  mcNCounter[121]  = mcPCounter[121] = mcP2Counter[121] = 0;
  mcAbsorbProp[121]= 0;
    /* Component PoreH19. */
  /* Setting parameters for component PoreH19. */
  SIG_MESSAGE("PoreH19 (Init:SetPar)");
#line 1394 "instruments/plate49.instr"
  mccPoreH19_radius_m = radiusM;
#line 1393 "instruments/plate49.instr"
  mccPoreH19_radius_h = radiusH;
#line 1395 "instruments/plate49.instr"
  mccPoreH19_Z0 = FOCALLENGTH;
#line 1396 "instruments/plate49.instr"
  mccPoreH19_xwidth = poreW;
#line 1397 "instruments/plate49.instr"
  mccPoreH19_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH19_chamferwidth = 0;
#line 1398 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH19_mirror_reflec, coating ? coating : "", 16384); else mccPoreH19_mirror_reflec[0]='\0';
#line 1399 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH19_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH19_bottom_reflec[0]='\0';
#line 1400 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH19_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH19_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH19_R_d = 1;
#line 1401 "instruments/plate49.instr"
  mccPoreH19_absorb_sides = 0;
#line 22366 "instruments/plate49.c"

  SIG_MESSAGE("PoreH19 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1403 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1403 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1403 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22376 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm19, mcrotaPoreH19);
  rot_transpose(mcrotaPoreH18, mctr1);
  rot_mul(mcrotaPoreH19, mctr1, mcrotrPoreH19);
  mctc1 = coords_set(
#line 1402 "instruments/plate49.instr"
    0,
#line 1402 "instruments/plate49.instr"
    radiusM,
#line 1402 "instruments/plate49.instr"
    0);
#line 22387 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm19, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH19 = coords_add(mcposaPoreArm19, mctc2);
  mctc1 = coords_sub(mcposaPoreH18, mcposaPoreH19);
  mcposrPoreH19 = rot_apply(mcrotaPoreH19, mctc1);
  mcDEBUG_COMPONENT("PoreH19", mcposaPoreH19, mcrotaPoreH19)
  mccomp_posa[122] = mcposaPoreH19;
  mccomp_posr[122] = mcposrPoreH19;
  mcNCounter[122]  = mcPCounter[122] = mcP2Counter[122] = 0;
  mcAbsorbProp[122]= 0;
    /* Component PoreH20. */
  /* Setting parameters for component PoreH20. */
  SIG_MESSAGE("PoreH20 (Init:SetPar)");
#line 1408 "instruments/plate49.instr"
  mccPoreH20_radius_m = radiusM;
#line 1407 "instruments/plate49.instr"
  mccPoreH20_radius_h = radiusH;
#line 1409 "instruments/plate49.instr"
  mccPoreH20_Z0 = FOCALLENGTH;
#line 1410 "instruments/plate49.instr"
  mccPoreH20_xwidth = poreW;
#line 1411 "instruments/plate49.instr"
  mccPoreH20_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH20_chamferwidth = 0;
#line 1412 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH20_mirror_reflec, coating ? coating : "", 16384); else mccPoreH20_mirror_reflec[0]='\0';
#line 1413 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH20_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH20_bottom_reflec[0]='\0';
#line 1414 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH20_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH20_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH20_R_d = 1;
#line 1415 "instruments/plate49.instr"
  mccPoreH20_absorb_sides = 0;
#line 22423 "instruments/plate49.c"

  SIG_MESSAGE("PoreH20 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1417 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1417 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1417 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22433 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm20, mcrotaPoreH20);
  rot_transpose(mcrotaPoreH19, mctr1);
  rot_mul(mcrotaPoreH20, mctr1, mcrotrPoreH20);
  mctc1 = coords_set(
#line 1416 "instruments/plate49.instr"
    0,
#line 1416 "instruments/plate49.instr"
    radiusM,
#line 1416 "instruments/plate49.instr"
    0);
#line 22444 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm20, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH20 = coords_add(mcposaPoreArm20, mctc2);
  mctc1 = coords_sub(mcposaPoreH19, mcposaPoreH20);
  mcposrPoreH20 = rot_apply(mcrotaPoreH20, mctc1);
  mcDEBUG_COMPONENT("PoreH20", mcposaPoreH20, mcrotaPoreH20)
  mccomp_posa[123] = mcposaPoreH20;
  mccomp_posr[123] = mcposrPoreH20;
  mcNCounter[123]  = mcPCounter[123] = mcP2Counter[123] = 0;
  mcAbsorbProp[123]= 0;
    /* Component PoreH21. */
  /* Setting parameters for component PoreH21. */
  SIG_MESSAGE("PoreH21 (Init:SetPar)");
#line 1422 "instruments/plate49.instr"
  mccPoreH21_radius_m = radiusM;
#line 1421 "instruments/plate49.instr"
  mccPoreH21_radius_h = radiusH;
#line 1423 "instruments/plate49.instr"
  mccPoreH21_Z0 = FOCALLENGTH;
#line 1424 "instruments/plate49.instr"
  mccPoreH21_xwidth = poreW;
#line 1425 "instruments/plate49.instr"
  mccPoreH21_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH21_chamferwidth = 0;
#line 1426 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH21_mirror_reflec, coating ? coating : "", 16384); else mccPoreH21_mirror_reflec[0]='\0';
#line 1427 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH21_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH21_bottom_reflec[0]='\0';
#line 1428 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH21_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH21_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH21_R_d = 1;
#line 1429 "instruments/plate49.instr"
  mccPoreH21_absorb_sides = 0;
#line 22480 "instruments/plate49.c"

  SIG_MESSAGE("PoreH21 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1431 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1431 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1431 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22490 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm21, mcrotaPoreH21);
  rot_transpose(mcrotaPoreH20, mctr1);
  rot_mul(mcrotaPoreH21, mctr1, mcrotrPoreH21);
  mctc1 = coords_set(
#line 1430 "instruments/plate49.instr"
    0,
#line 1430 "instruments/plate49.instr"
    radiusM,
#line 1430 "instruments/plate49.instr"
    0);
#line 22501 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm21, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH21 = coords_add(mcposaPoreArm21, mctc2);
  mctc1 = coords_sub(mcposaPoreH20, mcposaPoreH21);
  mcposrPoreH21 = rot_apply(mcrotaPoreH21, mctc1);
  mcDEBUG_COMPONENT("PoreH21", mcposaPoreH21, mcrotaPoreH21)
  mccomp_posa[124] = mcposaPoreH21;
  mccomp_posr[124] = mcposrPoreH21;
  mcNCounter[124]  = mcPCounter[124] = mcP2Counter[124] = 0;
  mcAbsorbProp[124]= 0;
    /* Component PoreH22. */
  /* Setting parameters for component PoreH22. */
  SIG_MESSAGE("PoreH22 (Init:SetPar)");
#line 1436 "instruments/plate49.instr"
  mccPoreH22_radius_m = radiusM;
#line 1435 "instruments/plate49.instr"
  mccPoreH22_radius_h = radiusH;
#line 1437 "instruments/plate49.instr"
  mccPoreH22_Z0 = FOCALLENGTH;
#line 1438 "instruments/plate49.instr"
  mccPoreH22_xwidth = poreW;
#line 1439 "instruments/plate49.instr"
  mccPoreH22_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH22_chamferwidth = 0;
#line 1440 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH22_mirror_reflec, coating ? coating : "", 16384); else mccPoreH22_mirror_reflec[0]='\0';
#line 1441 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH22_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH22_bottom_reflec[0]='\0';
#line 1442 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH22_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH22_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH22_R_d = 1;
#line 1443 "instruments/plate49.instr"
  mccPoreH22_absorb_sides = 0;
#line 22537 "instruments/plate49.c"

  SIG_MESSAGE("PoreH22 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1445 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1445 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1445 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22547 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm22, mcrotaPoreH22);
  rot_transpose(mcrotaPoreH21, mctr1);
  rot_mul(mcrotaPoreH22, mctr1, mcrotrPoreH22);
  mctc1 = coords_set(
#line 1444 "instruments/plate49.instr"
    0,
#line 1444 "instruments/plate49.instr"
    radiusM,
#line 1444 "instruments/plate49.instr"
    0);
#line 22558 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH22 = coords_add(mcposaPoreArm22, mctc2);
  mctc1 = coords_sub(mcposaPoreH21, mcposaPoreH22);
  mcposrPoreH22 = rot_apply(mcrotaPoreH22, mctc1);
  mcDEBUG_COMPONENT("PoreH22", mcposaPoreH22, mcrotaPoreH22)
  mccomp_posa[125] = mcposaPoreH22;
  mccomp_posr[125] = mcposrPoreH22;
  mcNCounter[125]  = mcPCounter[125] = mcP2Counter[125] = 0;
  mcAbsorbProp[125]= 0;
    /* Component PoreH23. */
  /* Setting parameters for component PoreH23. */
  SIG_MESSAGE("PoreH23 (Init:SetPar)");
#line 1450 "instruments/plate49.instr"
  mccPoreH23_radius_m = radiusM;
#line 1449 "instruments/plate49.instr"
  mccPoreH23_radius_h = radiusH;
#line 1451 "instruments/plate49.instr"
  mccPoreH23_Z0 = FOCALLENGTH;
#line 1452 "instruments/plate49.instr"
  mccPoreH23_xwidth = poreW;
#line 1453 "instruments/plate49.instr"
  mccPoreH23_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH23_chamferwidth = 0;
#line 1454 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH23_mirror_reflec, coating ? coating : "", 16384); else mccPoreH23_mirror_reflec[0]='\0';
#line 1455 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH23_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH23_bottom_reflec[0]='\0';
#line 1456 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH23_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH23_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH23_R_d = 1;
#line 1457 "instruments/plate49.instr"
  mccPoreH23_absorb_sides = 0;
#line 22594 "instruments/plate49.c"

  SIG_MESSAGE("PoreH23 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1459 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1459 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1459 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22604 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm23, mcrotaPoreH23);
  rot_transpose(mcrotaPoreH22, mctr1);
  rot_mul(mcrotaPoreH23, mctr1, mcrotrPoreH23);
  mctc1 = coords_set(
#line 1458 "instruments/plate49.instr"
    0,
#line 1458 "instruments/plate49.instr"
    radiusM,
#line 1458 "instruments/plate49.instr"
    0);
#line 22615 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm23, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH23 = coords_add(mcposaPoreArm23, mctc2);
  mctc1 = coords_sub(mcposaPoreH22, mcposaPoreH23);
  mcposrPoreH23 = rot_apply(mcrotaPoreH23, mctc1);
  mcDEBUG_COMPONENT("PoreH23", mcposaPoreH23, mcrotaPoreH23)
  mccomp_posa[126] = mcposaPoreH23;
  mccomp_posr[126] = mcposrPoreH23;
  mcNCounter[126]  = mcPCounter[126] = mcP2Counter[126] = 0;
  mcAbsorbProp[126]= 0;
    /* Component PoreH24. */
  /* Setting parameters for component PoreH24. */
  SIG_MESSAGE("PoreH24 (Init:SetPar)");
#line 1464 "instruments/plate49.instr"
  mccPoreH24_radius_m = radiusM;
#line 1463 "instruments/plate49.instr"
  mccPoreH24_radius_h = radiusH;
#line 1465 "instruments/plate49.instr"
  mccPoreH24_Z0 = FOCALLENGTH;
#line 1466 "instruments/plate49.instr"
  mccPoreH24_xwidth = poreW;
#line 1467 "instruments/plate49.instr"
  mccPoreH24_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH24_chamferwidth = 0;
#line 1468 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH24_mirror_reflec, coating ? coating : "", 16384); else mccPoreH24_mirror_reflec[0]='\0';
#line 1469 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH24_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH24_bottom_reflec[0]='\0';
#line 1470 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH24_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH24_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH24_R_d = 1;
#line 1471 "instruments/plate49.instr"
  mccPoreH24_absorb_sides = 0;
#line 22651 "instruments/plate49.c"

  SIG_MESSAGE("PoreH24 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1473 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1473 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1473 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22661 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm24, mcrotaPoreH24);
  rot_transpose(mcrotaPoreH23, mctr1);
  rot_mul(mcrotaPoreH24, mctr1, mcrotrPoreH24);
  mctc1 = coords_set(
#line 1472 "instruments/plate49.instr"
    0,
#line 1472 "instruments/plate49.instr"
    radiusM,
#line 1472 "instruments/plate49.instr"
    0);
#line 22672 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm24, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH24 = coords_add(mcposaPoreArm24, mctc2);
  mctc1 = coords_sub(mcposaPoreH23, mcposaPoreH24);
  mcposrPoreH24 = rot_apply(mcrotaPoreH24, mctc1);
  mcDEBUG_COMPONENT("PoreH24", mcposaPoreH24, mcrotaPoreH24)
  mccomp_posa[127] = mcposaPoreH24;
  mccomp_posr[127] = mcposrPoreH24;
  mcNCounter[127]  = mcPCounter[127] = mcP2Counter[127] = 0;
  mcAbsorbProp[127]= 0;
    /* Component PoreH25. */
  /* Setting parameters for component PoreH25. */
  SIG_MESSAGE("PoreH25 (Init:SetPar)");
#line 1478 "instruments/plate49.instr"
  mccPoreH25_radius_m = radiusM;
#line 1477 "instruments/plate49.instr"
  mccPoreH25_radius_h = radiusH;
#line 1479 "instruments/plate49.instr"
  mccPoreH25_Z0 = FOCALLENGTH;
#line 1480 "instruments/plate49.instr"
  mccPoreH25_xwidth = poreW;
#line 1481 "instruments/plate49.instr"
  mccPoreH25_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH25_chamferwidth = 0;
#line 1482 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH25_mirror_reflec, coating ? coating : "", 16384); else mccPoreH25_mirror_reflec[0]='\0';
#line 1483 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH25_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH25_bottom_reflec[0]='\0';
#line 1484 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH25_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH25_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH25_R_d = 1;
#line 1485 "instruments/plate49.instr"
  mccPoreH25_absorb_sides = 0;
#line 22708 "instruments/plate49.c"

  SIG_MESSAGE("PoreH25 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1487 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1487 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1487 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22718 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm25, mcrotaPoreH25);
  rot_transpose(mcrotaPoreH24, mctr1);
  rot_mul(mcrotaPoreH25, mctr1, mcrotrPoreH25);
  mctc1 = coords_set(
#line 1486 "instruments/plate49.instr"
    0,
#line 1486 "instruments/plate49.instr"
    radiusM,
#line 1486 "instruments/plate49.instr"
    0);
#line 22729 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH25 = coords_add(mcposaPoreArm25, mctc2);
  mctc1 = coords_sub(mcposaPoreH24, mcposaPoreH25);
  mcposrPoreH25 = rot_apply(mcrotaPoreH25, mctc1);
  mcDEBUG_COMPONENT("PoreH25", mcposaPoreH25, mcrotaPoreH25)
  mccomp_posa[128] = mcposaPoreH25;
  mccomp_posr[128] = mcposrPoreH25;
  mcNCounter[128]  = mcPCounter[128] = mcP2Counter[128] = 0;
  mcAbsorbProp[128]= 0;
    /* Component PoreH26. */
  /* Setting parameters for component PoreH26. */
  SIG_MESSAGE("PoreH26 (Init:SetPar)");
#line 1492 "instruments/plate49.instr"
  mccPoreH26_radius_m = radiusM;
#line 1491 "instruments/plate49.instr"
  mccPoreH26_radius_h = radiusH;
#line 1493 "instruments/plate49.instr"
  mccPoreH26_Z0 = FOCALLENGTH;
#line 1494 "instruments/plate49.instr"
  mccPoreH26_xwidth = poreW;
#line 1495 "instruments/plate49.instr"
  mccPoreH26_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH26_chamferwidth = 0;
#line 1496 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH26_mirror_reflec, coating ? coating : "", 16384); else mccPoreH26_mirror_reflec[0]='\0';
#line 1497 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH26_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH26_bottom_reflec[0]='\0';
#line 1498 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH26_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH26_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH26_R_d = 1;
#line 1499 "instruments/plate49.instr"
  mccPoreH26_absorb_sides = 0;
#line 22765 "instruments/plate49.c"

  SIG_MESSAGE("PoreH26 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1501 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1501 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1501 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22775 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm26, mcrotaPoreH26);
  rot_transpose(mcrotaPoreH25, mctr1);
  rot_mul(mcrotaPoreH26, mctr1, mcrotrPoreH26);
  mctc1 = coords_set(
#line 1500 "instruments/plate49.instr"
    0,
#line 1500 "instruments/plate49.instr"
    radiusM,
#line 1500 "instruments/plate49.instr"
    0);
#line 22786 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm26, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH26 = coords_add(mcposaPoreArm26, mctc2);
  mctc1 = coords_sub(mcposaPoreH25, mcposaPoreH26);
  mcposrPoreH26 = rot_apply(mcrotaPoreH26, mctc1);
  mcDEBUG_COMPONENT("PoreH26", mcposaPoreH26, mcrotaPoreH26)
  mccomp_posa[129] = mcposaPoreH26;
  mccomp_posr[129] = mcposrPoreH26;
  mcNCounter[129]  = mcPCounter[129] = mcP2Counter[129] = 0;
  mcAbsorbProp[129]= 0;
    /* Component PoreH27. */
  /* Setting parameters for component PoreH27. */
  SIG_MESSAGE("PoreH27 (Init:SetPar)");
#line 1506 "instruments/plate49.instr"
  mccPoreH27_radius_m = radiusM;
#line 1505 "instruments/plate49.instr"
  mccPoreH27_radius_h = radiusH;
#line 1507 "instruments/plate49.instr"
  mccPoreH27_Z0 = FOCALLENGTH;
#line 1508 "instruments/plate49.instr"
  mccPoreH27_xwidth = poreW;
#line 1509 "instruments/plate49.instr"
  mccPoreH27_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH27_chamferwidth = 0;
#line 1510 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH27_mirror_reflec, coating ? coating : "", 16384); else mccPoreH27_mirror_reflec[0]='\0';
#line 1511 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH27_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH27_bottom_reflec[0]='\0';
#line 1512 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH27_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH27_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH27_R_d = 1;
#line 1513 "instruments/plate49.instr"
  mccPoreH27_absorb_sides = 0;
#line 22822 "instruments/plate49.c"

  SIG_MESSAGE("PoreH27 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1515 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1515 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1515 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22832 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm27, mcrotaPoreH27);
  rot_transpose(mcrotaPoreH26, mctr1);
  rot_mul(mcrotaPoreH27, mctr1, mcrotrPoreH27);
  mctc1 = coords_set(
#line 1514 "instruments/plate49.instr"
    0,
#line 1514 "instruments/plate49.instr"
    radiusM,
#line 1514 "instruments/plate49.instr"
    0);
#line 22843 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm27, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH27 = coords_add(mcposaPoreArm27, mctc2);
  mctc1 = coords_sub(mcposaPoreH26, mcposaPoreH27);
  mcposrPoreH27 = rot_apply(mcrotaPoreH27, mctc1);
  mcDEBUG_COMPONENT("PoreH27", mcposaPoreH27, mcrotaPoreH27)
  mccomp_posa[130] = mcposaPoreH27;
  mccomp_posr[130] = mcposrPoreH27;
  mcNCounter[130]  = mcPCounter[130] = mcP2Counter[130] = 0;
  mcAbsorbProp[130]= 0;
    /* Component PoreH28. */
  /* Setting parameters for component PoreH28. */
  SIG_MESSAGE("PoreH28 (Init:SetPar)");
#line 1520 "instruments/plate49.instr"
  mccPoreH28_radius_m = radiusM;
#line 1519 "instruments/plate49.instr"
  mccPoreH28_radius_h = radiusH;
#line 1521 "instruments/plate49.instr"
  mccPoreH28_Z0 = FOCALLENGTH;
#line 1522 "instruments/plate49.instr"
  mccPoreH28_xwidth = poreW;
#line 1523 "instruments/plate49.instr"
  mccPoreH28_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH28_chamferwidth = 0;
#line 1524 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH28_mirror_reflec, coating ? coating : "", 16384); else mccPoreH28_mirror_reflec[0]='\0';
#line 1525 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH28_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH28_bottom_reflec[0]='\0';
#line 1526 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH28_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH28_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH28_R_d = 1;
#line 1527 "instruments/plate49.instr"
  mccPoreH28_absorb_sides = 0;
#line 22879 "instruments/plate49.c"

  SIG_MESSAGE("PoreH28 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1529 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1529 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1529 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22889 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm28, mcrotaPoreH28);
  rot_transpose(mcrotaPoreH27, mctr1);
  rot_mul(mcrotaPoreH28, mctr1, mcrotrPoreH28);
  mctc1 = coords_set(
#line 1528 "instruments/plate49.instr"
    0,
#line 1528 "instruments/plate49.instr"
    radiusM,
#line 1528 "instruments/plate49.instr"
    0);
#line 22900 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm28, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH28 = coords_add(mcposaPoreArm28, mctc2);
  mctc1 = coords_sub(mcposaPoreH27, mcposaPoreH28);
  mcposrPoreH28 = rot_apply(mcrotaPoreH28, mctc1);
  mcDEBUG_COMPONENT("PoreH28", mcposaPoreH28, mcrotaPoreH28)
  mccomp_posa[131] = mcposaPoreH28;
  mccomp_posr[131] = mcposrPoreH28;
  mcNCounter[131]  = mcPCounter[131] = mcP2Counter[131] = 0;
  mcAbsorbProp[131]= 0;
    /* Component PoreH29. */
  /* Setting parameters for component PoreH29. */
  SIG_MESSAGE("PoreH29 (Init:SetPar)");
#line 1534 "instruments/plate49.instr"
  mccPoreH29_radius_m = radiusM;
#line 1533 "instruments/plate49.instr"
  mccPoreH29_radius_h = radiusH;
#line 1535 "instruments/plate49.instr"
  mccPoreH29_Z0 = FOCALLENGTH;
#line 1536 "instruments/plate49.instr"
  mccPoreH29_xwidth = poreW;
#line 1537 "instruments/plate49.instr"
  mccPoreH29_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH29_chamferwidth = 0;
#line 1538 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH29_mirror_reflec, coating ? coating : "", 16384); else mccPoreH29_mirror_reflec[0]='\0';
#line 1539 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH29_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH29_bottom_reflec[0]='\0';
#line 1540 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH29_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH29_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH29_R_d = 1;
#line 1541 "instruments/plate49.instr"
  mccPoreH29_absorb_sides = 0;
#line 22936 "instruments/plate49.c"

  SIG_MESSAGE("PoreH29 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1543 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1543 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1543 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 22946 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm29, mcrotaPoreH29);
  rot_transpose(mcrotaPoreH28, mctr1);
  rot_mul(mcrotaPoreH29, mctr1, mcrotrPoreH29);
  mctc1 = coords_set(
#line 1542 "instruments/plate49.instr"
    0,
#line 1542 "instruments/plate49.instr"
    radiusM,
#line 1542 "instruments/plate49.instr"
    0);
#line 22957 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm29, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH29 = coords_add(mcposaPoreArm29, mctc2);
  mctc1 = coords_sub(mcposaPoreH28, mcposaPoreH29);
  mcposrPoreH29 = rot_apply(mcrotaPoreH29, mctc1);
  mcDEBUG_COMPONENT("PoreH29", mcposaPoreH29, mcrotaPoreH29)
  mccomp_posa[132] = mcposaPoreH29;
  mccomp_posr[132] = mcposrPoreH29;
  mcNCounter[132]  = mcPCounter[132] = mcP2Counter[132] = 0;
  mcAbsorbProp[132]= 0;
    /* Component PoreH30. */
  /* Setting parameters for component PoreH30. */
  SIG_MESSAGE("PoreH30 (Init:SetPar)");
#line 1548 "instruments/plate49.instr"
  mccPoreH30_radius_m = radiusM;
#line 1547 "instruments/plate49.instr"
  mccPoreH30_radius_h = radiusH;
#line 1549 "instruments/plate49.instr"
  mccPoreH30_Z0 = FOCALLENGTH;
#line 1550 "instruments/plate49.instr"
  mccPoreH30_xwidth = poreW;
#line 1551 "instruments/plate49.instr"
  mccPoreH30_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH30_chamferwidth = 0;
#line 1552 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH30_mirror_reflec, coating ? coating : "", 16384); else mccPoreH30_mirror_reflec[0]='\0';
#line 1553 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH30_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH30_bottom_reflec[0]='\0';
#line 1554 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH30_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH30_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH30_R_d = 1;
#line 1555 "instruments/plate49.instr"
  mccPoreH30_absorb_sides = 0;
#line 22993 "instruments/plate49.c"

  SIG_MESSAGE("PoreH30 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1557 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1557 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1557 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23003 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm30, mcrotaPoreH30);
  rot_transpose(mcrotaPoreH29, mctr1);
  rot_mul(mcrotaPoreH30, mctr1, mcrotrPoreH30);
  mctc1 = coords_set(
#line 1556 "instruments/plate49.instr"
    0,
#line 1556 "instruments/plate49.instr"
    radiusM,
#line 1556 "instruments/plate49.instr"
    0);
#line 23014 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH30 = coords_add(mcposaPoreArm30, mctc2);
  mctc1 = coords_sub(mcposaPoreH29, mcposaPoreH30);
  mcposrPoreH30 = rot_apply(mcrotaPoreH30, mctc1);
  mcDEBUG_COMPONENT("PoreH30", mcposaPoreH30, mcrotaPoreH30)
  mccomp_posa[133] = mcposaPoreH30;
  mccomp_posr[133] = mcposrPoreH30;
  mcNCounter[133]  = mcPCounter[133] = mcP2Counter[133] = 0;
  mcAbsorbProp[133]= 0;
    /* Component PoreH31. */
  /* Setting parameters for component PoreH31. */
  SIG_MESSAGE("PoreH31 (Init:SetPar)");
#line 1562 "instruments/plate49.instr"
  mccPoreH31_radius_m = radiusM;
#line 1561 "instruments/plate49.instr"
  mccPoreH31_radius_h = radiusH;
#line 1563 "instruments/plate49.instr"
  mccPoreH31_Z0 = FOCALLENGTH;
#line 1564 "instruments/plate49.instr"
  mccPoreH31_xwidth = poreW;
#line 1565 "instruments/plate49.instr"
  mccPoreH31_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH31_chamferwidth = 0;
#line 1566 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH31_mirror_reflec, coating ? coating : "", 16384); else mccPoreH31_mirror_reflec[0]='\0';
#line 1567 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH31_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH31_bottom_reflec[0]='\0';
#line 1568 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH31_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH31_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH31_R_d = 1;
#line 1569 "instruments/plate49.instr"
  mccPoreH31_absorb_sides = 0;
#line 23050 "instruments/plate49.c"

  SIG_MESSAGE("PoreH31 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1571 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1571 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1571 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23060 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm31, mcrotaPoreH31);
  rot_transpose(mcrotaPoreH30, mctr1);
  rot_mul(mcrotaPoreH31, mctr1, mcrotrPoreH31);
  mctc1 = coords_set(
#line 1570 "instruments/plate49.instr"
    0,
#line 1570 "instruments/plate49.instr"
    radiusM,
#line 1570 "instruments/plate49.instr"
    0);
#line 23071 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm31, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH31 = coords_add(mcposaPoreArm31, mctc2);
  mctc1 = coords_sub(mcposaPoreH30, mcposaPoreH31);
  mcposrPoreH31 = rot_apply(mcrotaPoreH31, mctc1);
  mcDEBUG_COMPONENT("PoreH31", mcposaPoreH31, mcrotaPoreH31)
  mccomp_posa[134] = mcposaPoreH31;
  mccomp_posr[134] = mcposrPoreH31;
  mcNCounter[134]  = mcPCounter[134] = mcP2Counter[134] = 0;
  mcAbsorbProp[134]= 0;
    /* Component PoreH32. */
  /* Setting parameters for component PoreH32. */
  SIG_MESSAGE("PoreH32 (Init:SetPar)");
#line 1576 "instruments/plate49.instr"
  mccPoreH32_radius_m = radiusM;
#line 1575 "instruments/plate49.instr"
  mccPoreH32_radius_h = radiusH;
#line 1577 "instruments/plate49.instr"
  mccPoreH32_Z0 = FOCALLENGTH;
#line 1578 "instruments/plate49.instr"
  mccPoreH32_xwidth = poreW;
#line 1579 "instruments/plate49.instr"
  mccPoreH32_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH32_chamferwidth = 0;
#line 1580 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH32_mirror_reflec, coating ? coating : "", 16384); else mccPoreH32_mirror_reflec[0]='\0';
#line 1581 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH32_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH32_bottom_reflec[0]='\0';
#line 1582 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH32_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH32_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH32_R_d = 1;
#line 1583 "instruments/plate49.instr"
  mccPoreH32_absorb_sides = 0;
#line 23107 "instruments/plate49.c"

  SIG_MESSAGE("PoreH32 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1585 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1585 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1585 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23117 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm32, mcrotaPoreH32);
  rot_transpose(mcrotaPoreH31, mctr1);
  rot_mul(mcrotaPoreH32, mctr1, mcrotrPoreH32);
  mctc1 = coords_set(
#line 1584 "instruments/plate49.instr"
    0,
#line 1584 "instruments/plate49.instr"
    radiusM,
#line 1584 "instruments/plate49.instr"
    0);
#line 23128 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm32, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH32 = coords_add(mcposaPoreArm32, mctc2);
  mctc1 = coords_sub(mcposaPoreH31, mcposaPoreH32);
  mcposrPoreH32 = rot_apply(mcrotaPoreH32, mctc1);
  mcDEBUG_COMPONENT("PoreH32", mcposaPoreH32, mcrotaPoreH32)
  mccomp_posa[135] = mcposaPoreH32;
  mccomp_posr[135] = mcposrPoreH32;
  mcNCounter[135]  = mcPCounter[135] = mcP2Counter[135] = 0;
  mcAbsorbProp[135]= 0;
    /* Component PoreH33. */
  /* Setting parameters for component PoreH33. */
  SIG_MESSAGE("PoreH33 (Init:SetPar)");
#line 1590 "instruments/plate49.instr"
  mccPoreH33_radius_m = radiusM;
#line 1589 "instruments/plate49.instr"
  mccPoreH33_radius_h = radiusH;
#line 1591 "instruments/plate49.instr"
  mccPoreH33_Z0 = FOCALLENGTH;
#line 1592 "instruments/plate49.instr"
  mccPoreH33_xwidth = poreW;
#line 1593 "instruments/plate49.instr"
  mccPoreH33_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH33_chamferwidth = 0;
#line 1594 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH33_mirror_reflec, coating ? coating : "", 16384); else mccPoreH33_mirror_reflec[0]='\0';
#line 1595 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH33_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH33_bottom_reflec[0]='\0';
#line 1596 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH33_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH33_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH33_R_d = 1;
#line 1597 "instruments/plate49.instr"
  mccPoreH33_absorb_sides = 0;
#line 23164 "instruments/plate49.c"

  SIG_MESSAGE("PoreH33 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1599 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1599 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1599 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23174 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm33, mcrotaPoreH33);
  rot_transpose(mcrotaPoreH32, mctr1);
  rot_mul(mcrotaPoreH33, mctr1, mcrotrPoreH33);
  mctc1 = coords_set(
#line 1598 "instruments/plate49.instr"
    0,
#line 1598 "instruments/plate49.instr"
    radiusM,
#line 1598 "instruments/plate49.instr"
    0);
#line 23185 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm33, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH33 = coords_add(mcposaPoreArm33, mctc2);
  mctc1 = coords_sub(mcposaPoreH32, mcposaPoreH33);
  mcposrPoreH33 = rot_apply(mcrotaPoreH33, mctc1);
  mcDEBUG_COMPONENT("PoreH33", mcposaPoreH33, mcrotaPoreH33)
  mccomp_posa[136] = mcposaPoreH33;
  mccomp_posr[136] = mcposrPoreH33;
  mcNCounter[136]  = mcPCounter[136] = mcP2Counter[136] = 0;
  mcAbsorbProp[136]= 0;
    /* Component PoreH34. */
  /* Setting parameters for component PoreH34. */
  SIG_MESSAGE("PoreH34 (Init:SetPar)");
#line 1604 "instruments/plate49.instr"
  mccPoreH34_radius_m = radiusM;
#line 1603 "instruments/plate49.instr"
  mccPoreH34_radius_h = radiusH;
#line 1605 "instruments/plate49.instr"
  mccPoreH34_Z0 = FOCALLENGTH;
#line 1606 "instruments/plate49.instr"
  mccPoreH34_xwidth = poreW;
#line 1607 "instruments/plate49.instr"
  mccPoreH34_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH34_chamferwidth = 0;
#line 1608 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH34_mirror_reflec, coating ? coating : "", 16384); else mccPoreH34_mirror_reflec[0]='\0';
#line 1609 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH34_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH34_bottom_reflec[0]='\0';
#line 1610 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH34_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH34_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH34_R_d = 1;
#line 1611 "instruments/plate49.instr"
  mccPoreH34_absorb_sides = 0;
#line 23221 "instruments/plate49.c"

  SIG_MESSAGE("PoreH34 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1613 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1613 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1613 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23231 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm34, mcrotaPoreH34);
  rot_transpose(mcrotaPoreH33, mctr1);
  rot_mul(mcrotaPoreH34, mctr1, mcrotrPoreH34);
  mctc1 = coords_set(
#line 1612 "instruments/plate49.instr"
    0,
#line 1612 "instruments/plate49.instr"
    radiusM,
#line 1612 "instruments/plate49.instr"
    0);
#line 23242 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm34, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH34 = coords_add(mcposaPoreArm34, mctc2);
  mctc1 = coords_sub(mcposaPoreH33, mcposaPoreH34);
  mcposrPoreH34 = rot_apply(mcrotaPoreH34, mctc1);
  mcDEBUG_COMPONENT("PoreH34", mcposaPoreH34, mcrotaPoreH34)
  mccomp_posa[137] = mcposaPoreH34;
  mccomp_posr[137] = mcposrPoreH34;
  mcNCounter[137]  = mcPCounter[137] = mcP2Counter[137] = 0;
  mcAbsorbProp[137]= 0;
    /* Component PoreH35. */
  /* Setting parameters for component PoreH35. */
  SIG_MESSAGE("PoreH35 (Init:SetPar)");
#line 1618 "instruments/plate49.instr"
  mccPoreH35_radius_m = radiusM;
#line 1617 "instruments/plate49.instr"
  mccPoreH35_radius_h = radiusH;
#line 1619 "instruments/plate49.instr"
  mccPoreH35_Z0 = FOCALLENGTH;
#line 1620 "instruments/plate49.instr"
  mccPoreH35_xwidth = poreW;
#line 1621 "instruments/plate49.instr"
  mccPoreH35_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH35_chamferwidth = 0;
#line 1622 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH35_mirror_reflec, coating ? coating : "", 16384); else mccPoreH35_mirror_reflec[0]='\0';
#line 1623 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH35_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH35_bottom_reflec[0]='\0';
#line 1624 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH35_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH35_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH35_R_d = 1;
#line 1625 "instruments/plate49.instr"
  mccPoreH35_absorb_sides = 0;
#line 23278 "instruments/plate49.c"

  SIG_MESSAGE("PoreH35 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1627 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1627 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1627 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23288 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm35, mcrotaPoreH35);
  rot_transpose(mcrotaPoreH34, mctr1);
  rot_mul(mcrotaPoreH35, mctr1, mcrotrPoreH35);
  mctc1 = coords_set(
#line 1626 "instruments/plate49.instr"
    0,
#line 1626 "instruments/plate49.instr"
    radiusM,
#line 1626 "instruments/plate49.instr"
    0);
#line 23299 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm35, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH35 = coords_add(mcposaPoreArm35, mctc2);
  mctc1 = coords_sub(mcposaPoreH34, mcposaPoreH35);
  mcposrPoreH35 = rot_apply(mcrotaPoreH35, mctc1);
  mcDEBUG_COMPONENT("PoreH35", mcposaPoreH35, mcrotaPoreH35)
  mccomp_posa[138] = mcposaPoreH35;
  mccomp_posr[138] = mcposrPoreH35;
  mcNCounter[138]  = mcPCounter[138] = mcP2Counter[138] = 0;
  mcAbsorbProp[138]= 0;
    /* Component PoreH36. */
  /* Setting parameters for component PoreH36. */
  SIG_MESSAGE("PoreH36 (Init:SetPar)");
#line 1632 "instruments/plate49.instr"
  mccPoreH36_radius_m = radiusM;
#line 1631 "instruments/plate49.instr"
  mccPoreH36_radius_h = radiusH;
#line 1633 "instruments/plate49.instr"
  mccPoreH36_Z0 = FOCALLENGTH;
#line 1634 "instruments/plate49.instr"
  mccPoreH36_xwidth = poreW;
#line 1635 "instruments/plate49.instr"
  mccPoreH36_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH36_chamferwidth = 0;
#line 1636 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH36_mirror_reflec, coating ? coating : "", 16384); else mccPoreH36_mirror_reflec[0]='\0';
#line 1637 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH36_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH36_bottom_reflec[0]='\0';
#line 1638 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH36_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH36_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH36_R_d = 1;
#line 1639 "instruments/plate49.instr"
  mccPoreH36_absorb_sides = 0;
#line 23335 "instruments/plate49.c"

  SIG_MESSAGE("PoreH36 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1641 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1641 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1641 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23345 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm36, mcrotaPoreH36);
  rot_transpose(mcrotaPoreH35, mctr1);
  rot_mul(mcrotaPoreH36, mctr1, mcrotrPoreH36);
  mctc1 = coords_set(
#line 1640 "instruments/plate49.instr"
    0,
#line 1640 "instruments/plate49.instr"
    radiusM,
#line 1640 "instruments/plate49.instr"
    0);
#line 23356 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm36, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH36 = coords_add(mcposaPoreArm36, mctc2);
  mctc1 = coords_sub(mcposaPoreH35, mcposaPoreH36);
  mcposrPoreH36 = rot_apply(mcrotaPoreH36, mctc1);
  mcDEBUG_COMPONENT("PoreH36", mcposaPoreH36, mcrotaPoreH36)
  mccomp_posa[139] = mcposaPoreH36;
  mccomp_posr[139] = mcposrPoreH36;
  mcNCounter[139]  = mcPCounter[139] = mcP2Counter[139] = 0;
  mcAbsorbProp[139]= 0;
    /* Component PoreH37. */
  /* Setting parameters for component PoreH37. */
  SIG_MESSAGE("PoreH37 (Init:SetPar)");
#line 1646 "instruments/plate49.instr"
  mccPoreH37_radius_m = radiusM;
#line 1645 "instruments/plate49.instr"
  mccPoreH37_radius_h = radiusH;
#line 1647 "instruments/plate49.instr"
  mccPoreH37_Z0 = FOCALLENGTH;
#line 1648 "instruments/plate49.instr"
  mccPoreH37_xwidth = poreW;
#line 1649 "instruments/plate49.instr"
  mccPoreH37_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH37_chamferwidth = 0;
#line 1650 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH37_mirror_reflec, coating ? coating : "", 16384); else mccPoreH37_mirror_reflec[0]='\0';
#line 1651 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH37_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH37_bottom_reflec[0]='\0';
#line 1652 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH37_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH37_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH37_R_d = 1;
#line 1653 "instruments/plate49.instr"
  mccPoreH37_absorb_sides = 0;
#line 23392 "instruments/plate49.c"

  SIG_MESSAGE("PoreH37 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1655 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1655 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1655 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23402 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm37, mcrotaPoreH37);
  rot_transpose(mcrotaPoreH36, mctr1);
  rot_mul(mcrotaPoreH37, mctr1, mcrotrPoreH37);
  mctc1 = coords_set(
#line 1654 "instruments/plate49.instr"
    0,
#line 1654 "instruments/plate49.instr"
    radiusM,
#line 1654 "instruments/plate49.instr"
    0);
#line 23413 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm37, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH37 = coords_add(mcposaPoreArm37, mctc2);
  mctc1 = coords_sub(mcposaPoreH36, mcposaPoreH37);
  mcposrPoreH37 = rot_apply(mcrotaPoreH37, mctc1);
  mcDEBUG_COMPONENT("PoreH37", mcposaPoreH37, mcrotaPoreH37)
  mccomp_posa[140] = mcposaPoreH37;
  mccomp_posr[140] = mcposrPoreH37;
  mcNCounter[140]  = mcPCounter[140] = mcP2Counter[140] = 0;
  mcAbsorbProp[140]= 0;
    /* Component PoreH38. */
  /* Setting parameters for component PoreH38. */
  SIG_MESSAGE("PoreH38 (Init:SetPar)");
#line 1660 "instruments/plate49.instr"
  mccPoreH38_radius_m = radiusM;
#line 1659 "instruments/plate49.instr"
  mccPoreH38_radius_h = radiusH;
#line 1661 "instruments/plate49.instr"
  mccPoreH38_Z0 = FOCALLENGTH;
#line 1662 "instruments/plate49.instr"
  mccPoreH38_xwidth = poreW;
#line 1663 "instruments/plate49.instr"
  mccPoreH38_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH38_chamferwidth = 0;
#line 1664 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH38_mirror_reflec, coating ? coating : "", 16384); else mccPoreH38_mirror_reflec[0]='\0';
#line 1665 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH38_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH38_bottom_reflec[0]='\0';
#line 1666 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH38_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH38_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH38_R_d = 1;
#line 1667 "instruments/plate49.instr"
  mccPoreH38_absorb_sides = 0;
#line 23449 "instruments/plate49.c"

  SIG_MESSAGE("PoreH38 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1669 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1669 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1669 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23459 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm38, mcrotaPoreH38);
  rot_transpose(mcrotaPoreH37, mctr1);
  rot_mul(mcrotaPoreH38, mctr1, mcrotrPoreH38);
  mctc1 = coords_set(
#line 1668 "instruments/plate49.instr"
    0,
#line 1668 "instruments/plate49.instr"
    radiusM,
#line 1668 "instruments/plate49.instr"
    0);
#line 23470 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm38, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH38 = coords_add(mcposaPoreArm38, mctc2);
  mctc1 = coords_sub(mcposaPoreH37, mcposaPoreH38);
  mcposrPoreH38 = rot_apply(mcrotaPoreH38, mctc1);
  mcDEBUG_COMPONENT("PoreH38", mcposaPoreH38, mcrotaPoreH38)
  mccomp_posa[141] = mcposaPoreH38;
  mccomp_posr[141] = mcposrPoreH38;
  mcNCounter[141]  = mcPCounter[141] = mcP2Counter[141] = 0;
  mcAbsorbProp[141]= 0;
    /* Component PoreH39. */
  /* Setting parameters for component PoreH39. */
  SIG_MESSAGE("PoreH39 (Init:SetPar)");
#line 1674 "instruments/plate49.instr"
  mccPoreH39_radius_m = radiusM;
#line 1673 "instruments/plate49.instr"
  mccPoreH39_radius_h = radiusH;
#line 1675 "instruments/plate49.instr"
  mccPoreH39_Z0 = FOCALLENGTH;
#line 1676 "instruments/plate49.instr"
  mccPoreH39_xwidth = poreW;
#line 1677 "instruments/plate49.instr"
  mccPoreH39_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH39_chamferwidth = 0;
#line 1678 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH39_mirror_reflec, coating ? coating : "", 16384); else mccPoreH39_mirror_reflec[0]='\0';
#line 1679 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH39_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH39_bottom_reflec[0]='\0';
#line 1680 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH39_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH39_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH39_R_d = 1;
#line 1681 "instruments/plate49.instr"
  mccPoreH39_absorb_sides = 0;
#line 23506 "instruments/plate49.c"

  SIG_MESSAGE("PoreH39 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1683 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1683 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1683 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23516 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm39, mcrotaPoreH39);
  rot_transpose(mcrotaPoreH38, mctr1);
  rot_mul(mcrotaPoreH39, mctr1, mcrotrPoreH39);
  mctc1 = coords_set(
#line 1682 "instruments/plate49.instr"
    0,
#line 1682 "instruments/plate49.instr"
    radiusM,
#line 1682 "instruments/plate49.instr"
    0);
#line 23527 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm39, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH39 = coords_add(mcposaPoreArm39, mctc2);
  mctc1 = coords_sub(mcposaPoreH38, mcposaPoreH39);
  mcposrPoreH39 = rot_apply(mcrotaPoreH39, mctc1);
  mcDEBUG_COMPONENT("PoreH39", mcposaPoreH39, mcrotaPoreH39)
  mccomp_posa[142] = mcposaPoreH39;
  mccomp_posr[142] = mcposrPoreH39;
  mcNCounter[142]  = mcPCounter[142] = mcP2Counter[142] = 0;
  mcAbsorbProp[142]= 0;
    /* Component PoreH40. */
  /* Setting parameters for component PoreH40. */
  SIG_MESSAGE("PoreH40 (Init:SetPar)");
#line 1688 "instruments/plate49.instr"
  mccPoreH40_radius_m = radiusM;
#line 1687 "instruments/plate49.instr"
  mccPoreH40_radius_h = radiusH;
#line 1689 "instruments/plate49.instr"
  mccPoreH40_Z0 = FOCALLENGTH;
#line 1690 "instruments/plate49.instr"
  mccPoreH40_xwidth = poreW;
#line 1691 "instruments/plate49.instr"
  mccPoreH40_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH40_chamferwidth = 0;
#line 1692 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH40_mirror_reflec, coating ? coating : "", 16384); else mccPoreH40_mirror_reflec[0]='\0';
#line 1693 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH40_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH40_bottom_reflec[0]='\0';
#line 1694 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH40_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH40_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH40_R_d = 1;
#line 1695 "instruments/plate49.instr"
  mccPoreH40_absorb_sides = 0;
#line 23563 "instruments/plate49.c"

  SIG_MESSAGE("PoreH40 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1697 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1697 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1697 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23573 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm40, mcrotaPoreH40);
  rot_transpose(mcrotaPoreH39, mctr1);
  rot_mul(mcrotaPoreH40, mctr1, mcrotrPoreH40);
  mctc1 = coords_set(
#line 1696 "instruments/plate49.instr"
    0,
#line 1696 "instruments/plate49.instr"
    radiusM,
#line 1696 "instruments/plate49.instr"
    0);
#line 23584 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm40, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH40 = coords_add(mcposaPoreArm40, mctc2);
  mctc1 = coords_sub(mcposaPoreH39, mcposaPoreH40);
  mcposrPoreH40 = rot_apply(mcrotaPoreH40, mctc1);
  mcDEBUG_COMPONENT("PoreH40", mcposaPoreH40, mcrotaPoreH40)
  mccomp_posa[143] = mcposaPoreH40;
  mccomp_posr[143] = mcposrPoreH40;
  mcNCounter[143]  = mcPCounter[143] = mcP2Counter[143] = 0;
  mcAbsorbProp[143]= 0;
    /* Component PoreH41. */
  /* Setting parameters for component PoreH41. */
  SIG_MESSAGE("PoreH41 (Init:SetPar)");
#line 1702 "instruments/plate49.instr"
  mccPoreH41_radius_m = radiusM;
#line 1701 "instruments/plate49.instr"
  mccPoreH41_radius_h = radiusH;
#line 1703 "instruments/plate49.instr"
  mccPoreH41_Z0 = FOCALLENGTH;
#line 1704 "instruments/plate49.instr"
  mccPoreH41_xwidth = poreW;
#line 1705 "instruments/plate49.instr"
  mccPoreH41_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH41_chamferwidth = 0;
#line 1706 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH41_mirror_reflec, coating ? coating : "", 16384); else mccPoreH41_mirror_reflec[0]='\0';
#line 1707 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH41_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH41_bottom_reflec[0]='\0';
#line 1708 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH41_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH41_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH41_R_d = 1;
#line 1709 "instruments/plate49.instr"
  mccPoreH41_absorb_sides = 0;
#line 23620 "instruments/plate49.c"

  SIG_MESSAGE("PoreH41 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1711 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1711 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1711 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23630 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm41, mcrotaPoreH41);
  rot_transpose(mcrotaPoreH40, mctr1);
  rot_mul(mcrotaPoreH41, mctr1, mcrotrPoreH41);
  mctc1 = coords_set(
#line 1710 "instruments/plate49.instr"
    0,
#line 1710 "instruments/plate49.instr"
    radiusM,
#line 1710 "instruments/plate49.instr"
    0);
#line 23641 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm41, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH41 = coords_add(mcposaPoreArm41, mctc2);
  mctc1 = coords_sub(mcposaPoreH40, mcposaPoreH41);
  mcposrPoreH41 = rot_apply(mcrotaPoreH41, mctc1);
  mcDEBUG_COMPONENT("PoreH41", mcposaPoreH41, mcrotaPoreH41)
  mccomp_posa[144] = mcposaPoreH41;
  mccomp_posr[144] = mcposrPoreH41;
  mcNCounter[144]  = mcPCounter[144] = mcP2Counter[144] = 0;
  mcAbsorbProp[144]= 0;
    /* Component PoreH42. */
  /* Setting parameters for component PoreH42. */
  SIG_MESSAGE("PoreH42 (Init:SetPar)");
#line 1716 "instruments/plate49.instr"
  mccPoreH42_radius_m = radiusM;
#line 1715 "instruments/plate49.instr"
  mccPoreH42_radius_h = radiusH;
#line 1717 "instruments/plate49.instr"
  mccPoreH42_Z0 = FOCALLENGTH;
#line 1718 "instruments/plate49.instr"
  mccPoreH42_xwidth = poreW;
#line 1719 "instruments/plate49.instr"
  mccPoreH42_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH42_chamferwidth = 0;
#line 1720 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH42_mirror_reflec, coating ? coating : "", 16384); else mccPoreH42_mirror_reflec[0]='\0';
#line 1721 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH42_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH42_bottom_reflec[0]='\0';
#line 1722 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH42_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH42_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH42_R_d = 1;
#line 1723 "instruments/plate49.instr"
  mccPoreH42_absorb_sides = 0;
#line 23677 "instruments/plate49.c"

  SIG_MESSAGE("PoreH42 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1725 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1725 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1725 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23687 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm42, mcrotaPoreH42);
  rot_transpose(mcrotaPoreH41, mctr1);
  rot_mul(mcrotaPoreH42, mctr1, mcrotrPoreH42);
  mctc1 = coords_set(
#line 1724 "instruments/plate49.instr"
    0,
#line 1724 "instruments/plate49.instr"
    radiusM,
#line 1724 "instruments/plate49.instr"
    0);
#line 23698 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm42, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH42 = coords_add(mcposaPoreArm42, mctc2);
  mctc1 = coords_sub(mcposaPoreH41, mcposaPoreH42);
  mcposrPoreH42 = rot_apply(mcrotaPoreH42, mctc1);
  mcDEBUG_COMPONENT("PoreH42", mcposaPoreH42, mcrotaPoreH42)
  mccomp_posa[145] = mcposaPoreH42;
  mccomp_posr[145] = mcposrPoreH42;
  mcNCounter[145]  = mcPCounter[145] = mcP2Counter[145] = 0;
  mcAbsorbProp[145]= 0;
    /* Component PoreH43. */
  /* Setting parameters for component PoreH43. */
  SIG_MESSAGE("PoreH43 (Init:SetPar)");
#line 1730 "instruments/plate49.instr"
  mccPoreH43_radius_m = radiusM;
#line 1729 "instruments/plate49.instr"
  mccPoreH43_radius_h = radiusH;
#line 1731 "instruments/plate49.instr"
  mccPoreH43_Z0 = FOCALLENGTH;
#line 1732 "instruments/plate49.instr"
  mccPoreH43_xwidth = poreW;
#line 1733 "instruments/plate49.instr"
  mccPoreH43_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH43_chamferwidth = 0;
#line 1734 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH43_mirror_reflec, coating ? coating : "", 16384); else mccPoreH43_mirror_reflec[0]='\0';
#line 1735 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH43_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH43_bottom_reflec[0]='\0';
#line 1736 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH43_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH43_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH43_R_d = 1;
#line 1737 "instruments/plate49.instr"
  mccPoreH43_absorb_sides = 0;
#line 23734 "instruments/plate49.c"

  SIG_MESSAGE("PoreH43 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1739 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1739 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1739 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23744 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm43, mcrotaPoreH43);
  rot_transpose(mcrotaPoreH42, mctr1);
  rot_mul(mcrotaPoreH43, mctr1, mcrotrPoreH43);
  mctc1 = coords_set(
#line 1738 "instruments/plate49.instr"
    0,
#line 1738 "instruments/plate49.instr"
    radiusM,
#line 1738 "instruments/plate49.instr"
    0);
#line 23755 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm43, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH43 = coords_add(mcposaPoreArm43, mctc2);
  mctc1 = coords_sub(mcposaPoreH42, mcposaPoreH43);
  mcposrPoreH43 = rot_apply(mcrotaPoreH43, mctc1);
  mcDEBUG_COMPONENT("PoreH43", mcposaPoreH43, mcrotaPoreH43)
  mccomp_posa[146] = mcposaPoreH43;
  mccomp_posr[146] = mcposrPoreH43;
  mcNCounter[146]  = mcPCounter[146] = mcP2Counter[146] = 0;
  mcAbsorbProp[146]= 0;
    /* Component PoreH44. */
  /* Setting parameters for component PoreH44. */
  SIG_MESSAGE("PoreH44 (Init:SetPar)");
#line 1744 "instruments/plate49.instr"
  mccPoreH44_radius_m = radiusM;
#line 1743 "instruments/plate49.instr"
  mccPoreH44_radius_h = radiusH;
#line 1745 "instruments/plate49.instr"
  mccPoreH44_Z0 = FOCALLENGTH;
#line 1746 "instruments/plate49.instr"
  mccPoreH44_xwidth = poreW;
#line 1747 "instruments/plate49.instr"
  mccPoreH44_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH44_chamferwidth = 0;
#line 1748 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH44_mirror_reflec, coating ? coating : "", 16384); else mccPoreH44_mirror_reflec[0]='\0';
#line 1749 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH44_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH44_bottom_reflec[0]='\0';
#line 1750 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH44_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH44_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH44_R_d = 1;
#line 1751 "instruments/plate49.instr"
  mccPoreH44_absorb_sides = 0;
#line 23791 "instruments/plate49.c"

  SIG_MESSAGE("PoreH44 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1753 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1753 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1753 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23801 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm44, mcrotaPoreH44);
  rot_transpose(mcrotaPoreH43, mctr1);
  rot_mul(mcrotaPoreH44, mctr1, mcrotrPoreH44);
  mctc1 = coords_set(
#line 1752 "instruments/plate49.instr"
    0,
#line 1752 "instruments/plate49.instr"
    radiusM,
#line 1752 "instruments/plate49.instr"
    0);
#line 23812 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm44, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH44 = coords_add(mcposaPoreArm44, mctc2);
  mctc1 = coords_sub(mcposaPoreH43, mcposaPoreH44);
  mcposrPoreH44 = rot_apply(mcrotaPoreH44, mctc1);
  mcDEBUG_COMPONENT("PoreH44", mcposaPoreH44, mcrotaPoreH44)
  mccomp_posa[147] = mcposaPoreH44;
  mccomp_posr[147] = mcposrPoreH44;
  mcNCounter[147]  = mcPCounter[147] = mcP2Counter[147] = 0;
  mcAbsorbProp[147]= 0;
    /* Component PoreH45. */
  /* Setting parameters for component PoreH45. */
  SIG_MESSAGE("PoreH45 (Init:SetPar)");
#line 1758 "instruments/plate49.instr"
  mccPoreH45_radius_m = radiusM;
#line 1757 "instruments/plate49.instr"
  mccPoreH45_radius_h = radiusH;
#line 1759 "instruments/plate49.instr"
  mccPoreH45_Z0 = FOCALLENGTH;
#line 1760 "instruments/plate49.instr"
  mccPoreH45_xwidth = poreW;
#line 1761 "instruments/plate49.instr"
  mccPoreH45_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH45_chamferwidth = 0;
#line 1762 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH45_mirror_reflec, coating ? coating : "", 16384); else mccPoreH45_mirror_reflec[0]='\0';
#line 1763 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH45_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH45_bottom_reflec[0]='\0';
#line 1764 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH45_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH45_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH45_R_d = 1;
#line 1765 "instruments/plate49.instr"
  mccPoreH45_absorb_sides = 0;
#line 23848 "instruments/plate49.c"

  SIG_MESSAGE("PoreH45 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1767 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1767 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1767 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23858 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm45, mcrotaPoreH45);
  rot_transpose(mcrotaPoreH44, mctr1);
  rot_mul(mcrotaPoreH45, mctr1, mcrotrPoreH45);
  mctc1 = coords_set(
#line 1766 "instruments/plate49.instr"
    0,
#line 1766 "instruments/plate49.instr"
    radiusM,
#line 1766 "instruments/plate49.instr"
    0);
#line 23869 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm45, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH45 = coords_add(mcposaPoreArm45, mctc2);
  mctc1 = coords_sub(mcposaPoreH44, mcposaPoreH45);
  mcposrPoreH45 = rot_apply(mcrotaPoreH45, mctc1);
  mcDEBUG_COMPONENT("PoreH45", mcposaPoreH45, mcrotaPoreH45)
  mccomp_posa[148] = mcposaPoreH45;
  mccomp_posr[148] = mcposrPoreH45;
  mcNCounter[148]  = mcPCounter[148] = mcP2Counter[148] = 0;
  mcAbsorbProp[148]= 0;
    /* Component PoreH46. */
  /* Setting parameters for component PoreH46. */
  SIG_MESSAGE("PoreH46 (Init:SetPar)");
#line 1772 "instruments/plate49.instr"
  mccPoreH46_radius_m = radiusM;
#line 1771 "instruments/plate49.instr"
  mccPoreH46_radius_h = radiusH;
#line 1773 "instruments/plate49.instr"
  mccPoreH46_Z0 = FOCALLENGTH;
#line 1774 "instruments/plate49.instr"
  mccPoreH46_xwidth = poreW;
#line 1775 "instruments/plate49.instr"
  mccPoreH46_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH46_chamferwidth = 0;
#line 1776 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH46_mirror_reflec, coating ? coating : "", 16384); else mccPoreH46_mirror_reflec[0]='\0';
#line 1777 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH46_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH46_bottom_reflec[0]='\0';
#line 1778 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH46_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH46_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH46_R_d = 1;
#line 1779 "instruments/plate49.instr"
  mccPoreH46_absorb_sides = 0;
#line 23905 "instruments/plate49.c"

  SIG_MESSAGE("PoreH46 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1781 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1781 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1781 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23915 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm46, mcrotaPoreH46);
  rot_transpose(mcrotaPoreH45, mctr1);
  rot_mul(mcrotaPoreH46, mctr1, mcrotrPoreH46);
  mctc1 = coords_set(
#line 1780 "instruments/plate49.instr"
    0,
#line 1780 "instruments/plate49.instr"
    radiusM,
#line 1780 "instruments/plate49.instr"
    0);
#line 23926 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm46, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH46 = coords_add(mcposaPoreArm46, mctc2);
  mctc1 = coords_sub(mcposaPoreH45, mcposaPoreH46);
  mcposrPoreH46 = rot_apply(mcrotaPoreH46, mctc1);
  mcDEBUG_COMPONENT("PoreH46", mcposaPoreH46, mcrotaPoreH46)
  mccomp_posa[149] = mcposaPoreH46;
  mccomp_posr[149] = mcposrPoreH46;
  mcNCounter[149]  = mcPCounter[149] = mcP2Counter[149] = 0;
  mcAbsorbProp[149]= 0;
    /* Component PoreH47. */
  /* Setting parameters for component PoreH47. */
  SIG_MESSAGE("PoreH47 (Init:SetPar)");
#line 1786 "instruments/plate49.instr"
  mccPoreH47_radius_m = radiusM;
#line 1785 "instruments/plate49.instr"
  mccPoreH47_radius_h = radiusH;
#line 1787 "instruments/plate49.instr"
  mccPoreH47_Z0 = FOCALLENGTH;
#line 1788 "instruments/plate49.instr"
  mccPoreH47_xwidth = poreW;
#line 1789 "instruments/plate49.instr"
  mccPoreH47_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH47_chamferwidth = 0;
#line 1790 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH47_mirror_reflec, coating ? coating : "", 16384); else mccPoreH47_mirror_reflec[0]='\0';
#line 1791 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH47_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH47_bottom_reflec[0]='\0';
#line 1792 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH47_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH47_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH47_R_d = 1;
#line 1793 "instruments/plate49.instr"
  mccPoreH47_absorb_sides = 0;
#line 23962 "instruments/plate49.c"

  SIG_MESSAGE("PoreH47 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1795 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1795 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1795 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 23972 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm47, mcrotaPoreH47);
  rot_transpose(mcrotaPoreH46, mctr1);
  rot_mul(mcrotaPoreH47, mctr1, mcrotrPoreH47);
  mctc1 = coords_set(
#line 1794 "instruments/plate49.instr"
    0,
#line 1794 "instruments/plate49.instr"
    radiusM,
#line 1794 "instruments/plate49.instr"
    0);
#line 23983 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm47, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH47 = coords_add(mcposaPoreArm47, mctc2);
  mctc1 = coords_sub(mcposaPoreH46, mcposaPoreH47);
  mcposrPoreH47 = rot_apply(mcrotaPoreH47, mctc1);
  mcDEBUG_COMPONENT("PoreH47", mcposaPoreH47, mcrotaPoreH47)
  mccomp_posa[150] = mcposaPoreH47;
  mccomp_posr[150] = mcposrPoreH47;
  mcNCounter[150]  = mcPCounter[150] = mcP2Counter[150] = 0;
  mcAbsorbProp[150]= 0;
    /* Component PoreH48. */
  /* Setting parameters for component PoreH48. */
  SIG_MESSAGE("PoreH48 (Init:SetPar)");
#line 1800 "instruments/plate49.instr"
  mccPoreH48_radius_m = radiusM;
#line 1799 "instruments/plate49.instr"
  mccPoreH48_radius_h = radiusH;
#line 1801 "instruments/plate49.instr"
  mccPoreH48_Z0 = FOCALLENGTH;
#line 1802 "instruments/plate49.instr"
  mccPoreH48_xwidth = poreW;
#line 1803 "instruments/plate49.instr"
  mccPoreH48_yheight = poreH;
#line 51 "instruments/plate49.instr"
  mccPoreH48_chamferwidth = 0;
#line 1804 "instruments/plate49.instr"
  if(coating) strncpy(mccPoreH48_mirror_reflec, coating ? coating : "", 16384); else mccPoreH48_mirror_reflec[0]='\0';
#line 1805 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH48_bottom_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH48_bottom_reflec[0]='\0';
#line 1806 "instruments/plate49.instr"
  if(coatingSide) strncpy(mccPoreH48_side_reflec, coatingSide ? coatingSide : "", 16384); else mccPoreH48_side_reflec[0]='\0';
#line 51 "instruments/plate49.instr"
  mccPoreH48_R_d = 1;
#line 1807 "instruments/plate49.instr"
  mccPoreH48_absorb_sides = 0;
#line 24019 "instruments/plate49.c"

  SIG_MESSAGE("PoreH48 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1809 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1809 "instruments/plate49.instr"
    (0)*DEG2RAD,
#line 1809 "instruments/plate49.instr"
    (0)*DEG2RAD);
#line 24029 "instruments/plate49.c"
  rot_mul(mctr1, mcrotaPoreArm48, mcrotaPoreH48);
  rot_transpose(mcrotaPoreH47, mctr1);
  rot_mul(mcrotaPoreH48, mctr1, mcrotrPoreH48);
  mctc1 = coords_set(
#line 1808 "instruments/plate49.instr"
    0,
#line 1808 "instruments/plate49.instr"
    radiusM,
#line 1808 "instruments/plate49.instr"
    0);
#line 24040 "instruments/plate49.c"
  rot_transpose(mcrotaPoreArm48, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPoreH48 = coords_add(mcposaPoreArm48, mctc2);
  mctc1 = coords_sub(mcposaPoreH47, mcposaPoreH48);
  mcposrPoreH48 = rot_apply(mcrotaPoreH48, mctc1);
  mcDEBUG_COMPONENT("PoreH48", mcposaPoreH48, mcrotaPoreH48)
  mccomp_posa[151] = mcposaPoreH48;
  mccomp_posr[151] = mcposrPoreH48;
  mcNCounter[151]  = mcPCounter[151] = mcP2Counter[151] = 0;
  mcAbsorbProp[151]= 0;
    /* Component monitorAfter. */
  /* Setting parameters for component monitorAfter. */
  SIG_MESSAGE("monitorAfter (Init:SetPar)");
#line 56 "instruments/plate49.instr"
  mccmonitorAfter_xmin = -0.05;
#line 56 "instruments/plate49.instr"
  mccmonitorAfter_xmax = 0.05;
#line 56 "instruments/plate49.instr"
  mccmonitorAfter_ymin = -0.05;
#line 56 "instruments/plate49.instr"
  mccmonitorAfter_ymax = 0.05;
#line 1817 "instruments/plate49.instr"
  mccmonitorAfter_xwidth = wideSize;
#line 1818 "instruments/plate49.instr"
  mccmonitorAfter_yheight = wideSize;
#line 56 "instruments/plate49.instr"
  mccmonitorAfter_radius = 0;
#line 24068 "instruments/plate49.c"

  SIG_MESSAGE("monitorAfter (Init:Place/Rotate)");
  rot_set_rotation(mcrotamonitorAfter,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24075 "instruments/plate49.c"
  rot_transpose(mcrotaPoreH48, mctr1);
  rot_mul(mcrotamonitorAfter, mctr1, mcrotrmonitorAfter);
  mcposamonitorAfter = coords_set(
#line 1820 "instruments/plate49.instr"
    0,
#line 1820 "instruments/plate49.instr"
    0,
#line 1820 "instruments/plate49.instr"
    0.15);
#line 24085 "instruments/plate49.c"
  mctc1 = coords_sub(mcposaPoreH48, mcposamonitorAfter);
  mcposrmonitorAfter = rot_apply(mcrotamonitorAfter, mctc1);
  mcDEBUG_COMPONENT("monitorAfter", mcposamonitorAfter, mcrotamonitorAfter)
  mccomp_posa[152] = mcposamonitorAfter;
  mccomp_posr[152] = mcposrmonitorAfter;
  mcNCounter[152]  = mcPCounter[152] = mcP2Counter[152] = 0;
  mcAbsorbProp[152]= 0;
    /* Component endMonitorWide. */
  /* Setting parameters for component endMonitorWide. */
  SIG_MESSAGE("endMonitorWide (Init:SetPar)");
#line 56 "instruments/plate49.instr"
  mccendMonitorWide_xmin = -0.05;
#line 56 "instruments/plate49.instr"
  mccendMonitorWide_xmax = 0.05;
#line 56 "instruments/plate49.instr"
  mccendMonitorWide_ymin = -0.05;
#line 56 "instruments/plate49.instr"
  mccendMonitorWide_ymax = 0.05;
#line 1844 "instruments/plate49.instr"
  mccendMonitorWide_xwidth = wideSize;
#line 1845 "instruments/plate49.instr"
  mccendMonitorWide_yheight = wideSize;
#line 56 "instruments/plate49.instr"
  mccendMonitorWide_radius = 0;
#line 24110 "instruments/plate49.c"

  SIG_MESSAGE("endMonitorWide (Init:Place/Rotate)");
  rot_set_rotation(mcrotaendMonitorWide,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24117 "instruments/plate49.c"
  rot_transpose(mcrotamonitorAfter, mctr1);
  rot_mul(mcrotaendMonitorWide, mctr1, mcrotrendMonitorWide);
  mcposaendMonitorWide = coords_set(
#line 1847 "instruments/plate49.instr"
    0,
#line 1847 "instruments/plate49.instr"
    0,
#line 1847 "instruments/plate49.instr"
    focalLength);
#line 24127 "instruments/plate49.c"
  mctc1 = coords_sub(mcposamonitorAfter, mcposaendMonitorWide);
  mcposrendMonitorWide = rot_apply(mcrotaendMonitorWide, mctc1);
  mcDEBUG_COMPONENT("endMonitorWide", mcposaendMonitorWide, mcrotaendMonitorWide)
  mccomp_posa[153] = mcposaendMonitorWide;
  mccomp_posr[153] = mcposrendMonitorWide;
  mcNCounter[153]  = mcPCounter[153] = mcP2Counter[153] = 0;
  mcAbsorbProp[153]= 0;
  /* Component initializations. */
  /* Initializations for component origin. */
  SIG_MESSAGE("origin (Init)");
#define mccompcurname  origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define profile mccorigin_profile
#define IntermediateCnts mccorigin_IntermediateCnts
#define StartTime mccorigin_StartTime
#define EndTime mccorigin_EndTime
#define percent mccorigin_percent
#define flag_save mccorigin_flag_save
#define minutes mccorigin_minutes
#line 63 "/usr/share/mcxtrace/1.4/misc/Progress_bar.comp"
{
  fprintf(stdout, "[%s] Initialize\n", mcinstrument_name);
  if (percent*mcget_ncount()/100 < 1e5) {
    percent=1e5*100.0/mcget_ncount();
  }
}
#line 24155 "instruments/plate49.c"
#undef minutes
#undef flag_save
#undef percent
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef profile
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ThetaArm. */
  SIG_MESSAGE("ThetaArm (Init)");

  /* Initializations for component srcDirectional. */
  SIG_MESSAGE("srcDirectional (Init)");
#define mccompcurname  srcDirectional
#define mccompcurtype  Source_div
#define mccompcurindex 3
#define spectrum_file mccsrcDirectional_spectrum_file
#define prms mccsrcDirectional_prms
#define p_init mccsrcDirectional_p_init
#define dist mccsrcDirectional_dist
#define xwidth mccsrcDirectional_xwidth
#define yheight mccsrcDirectional_yheight
#define focus_aw mccsrcDirectional_focus_aw
#define focus_ah mccsrcDirectional_focus_ah
#define E0 mccsrcDirectional_E0
#define dE mccsrcDirectional_dE
#define lambda0 mccsrcDirectional_lambda0
#define dlambda mccsrcDirectional_dlambda
#define flux mccsrcDirectional_flux
#define gauss mccsrcDirectional_gauss
#define gauss_a mccsrcDirectional_gauss_a
#define randomphase mccsrcDirectional_randomphase
#define phase mccsrcDirectional_phase
#line 77 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
{

  prms.xmin=-xwidth/2.0;
  prms.ymin=-yheight/2.0;
  prms.xmax=xwidth/2.0;
  prms.ymax=yheight/2.0;
  
  if (spectrum_file){
    /*read spectrum from file*/
    int status=0;
    if ( (status=Table_Read(&(prms.T),spectrum_file,0))==-1){
      fprintf(stderr,"Source_div(%s) Error: Could not parse file \"%s\"\n",NAME_CURRENT_COMP,spectrum_file?spectrum_file:"");
      exit(-1);
    }
    /*data is now in table t*/
    /*integrate to get total flux, assuming raw numbers have been corrected for measuring aperture*/
    int i;
    prms.pint=0;
    t_Table *T=&(prms.T);
    for (i=0;i<prms.T.rows-1;i++){
      prms.pint+=((T->data[i*T->columns+1]+T->data[(i+1)*T->columns+1])/2.0)*(T->data[(i+1)*T->columns]-T->data[i*T->columns]); 
    }
    printf("Source_div(%s) Integrated intensity radiated is %g pht/s\n",NAME_CURRENT_COMP,prms.pint);
    if(E0) printf("Source_div(%s) E0!=0 -> assuming intensity spectrum is parametrized by energy [keV]\n",NAME_CURRENT_COMP);
  }else if (!E0 && !lambda0){
    fprintf(stderr,"Source_div(%s): Error: Must specify either wavelength or energy distribution\n",NAME_CURRENT_COMP);
    exit(0);  
  }  

  /*calculate the X-ray weight from the flux*/
  if (flux){
    prms.pmul=flux;
  }else{
    prms.pmul=1;
  }
  prms.pmul*=1.0/((double) mcget_ncount());


}
#line 24232 "instruments/plate49.c"
#undef phase
#undef randomphase
#undef gauss_a
#undef gauss
#undef flux
#undef dlambda
#undef lambda0
#undef dE
#undef E0
#undef focus_ah
#undef focus_aw
#undef yheight
#undef xwidth
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component srcDirectionalWide. */
  SIG_MESSAGE("srcDirectionalWide (Init)");
#define mccompcurname  srcDirectionalWide
#define mccompcurtype  Source_div
#define mccompcurindex 4
#define spectrum_file mccsrcDirectionalWide_spectrum_file
#define prms mccsrcDirectionalWide_prms
#define p_init mccsrcDirectionalWide_p_init
#define dist mccsrcDirectionalWide_dist
#define xwidth mccsrcDirectionalWide_xwidth
#define yheight mccsrcDirectionalWide_yheight
#define focus_aw mccsrcDirectionalWide_focus_aw
#define focus_ah mccsrcDirectionalWide_focus_ah
#define E0 mccsrcDirectionalWide_E0
#define dE mccsrcDirectionalWide_dE
#define lambda0 mccsrcDirectionalWide_lambda0
#define dlambda mccsrcDirectionalWide_dlambda
#define flux mccsrcDirectionalWide_flux
#define gauss mccsrcDirectionalWide_gauss
#define gauss_a mccsrcDirectionalWide_gauss_a
#define randomphase mccsrcDirectionalWide_randomphase
#define phase mccsrcDirectionalWide_phase
#line 77 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
{

  prms.xmin=-xwidth/2.0;
  prms.ymin=-yheight/2.0;
  prms.xmax=xwidth/2.0;
  prms.ymax=yheight/2.0;
  
  if (spectrum_file){
    /*read spectrum from file*/
    int status=0;
    if ( (status=Table_Read(&(prms.T),spectrum_file,0))==-1){
      fprintf(stderr,"Source_div(%s) Error: Could not parse file \"%s\"\n",NAME_CURRENT_COMP,spectrum_file?spectrum_file:"");
      exit(-1);
    }
    /*data is now in table t*/
    /*integrate to get total flux, assuming raw numbers have been corrected for measuring aperture*/
    int i;
    prms.pint=0;
    t_Table *T=&(prms.T);
    for (i=0;i<prms.T.rows-1;i++){
      prms.pint+=((T->data[i*T->columns+1]+T->data[(i+1)*T->columns+1])/2.0)*(T->data[(i+1)*T->columns]-T->data[i*T->columns]); 
    }
    printf("Source_div(%s) Integrated intensity radiated is %g pht/s\n",NAME_CURRENT_COMP,prms.pint);
    if(E0) printf("Source_div(%s) E0!=0 -> assuming intensity spectrum is parametrized by energy [keV]\n",NAME_CURRENT_COMP);
  }else if (!E0 && !lambda0){
    fprintf(stderr,"Source_div(%s): Error: Must specify either wavelength or energy distribution\n",NAME_CURRENT_COMP);
    exit(0);  
  }  

  /*calculate the X-ray weight from the flux*/
  if (flux){
    prms.pmul=flux;
  }else{
    prms.pmul=1;
  }
  prms.pmul*=1.0/((double) mcget_ncount());


}
#line 24316 "instruments/plate49.c"
#undef phase
#undef randomphase
#undef gauss_a
#undef gauss
#undef flux
#undef dlambda
#undef lambda0
#undef dE
#undef E0
#undef focus_ah
#undef focus_aw
#undef yheight
#undef xwidth
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreArm0. */
  SIG_MESSAGE("PoreArm0 (Init)");

  /* Initializations for component PoreArm1. */
  SIG_MESSAGE("PoreArm1 (Init)");

  /* Initializations for component PoreArm2. */
  SIG_MESSAGE("PoreArm2 (Init)");

  /* Initializations for component PoreArm3. */
  SIG_MESSAGE("PoreArm3 (Init)");

  /* Initializations for component PoreArm4. */
  SIG_MESSAGE("PoreArm4 (Init)");

  /* Initializations for component PoreArm5. */
  SIG_MESSAGE("PoreArm5 (Init)");

  /* Initializations for component PoreArm6. */
  SIG_MESSAGE("PoreArm6 (Init)");

  /* Initializations for component PoreArm7. */
  SIG_MESSAGE("PoreArm7 (Init)");

  /* Initializations for component PoreArm8. */
  SIG_MESSAGE("PoreArm8 (Init)");

  /* Initializations for component PoreArm9. */
  SIG_MESSAGE("PoreArm9 (Init)");

  /* Initializations for component PoreArm10. */
  SIG_MESSAGE("PoreArm10 (Init)");

  /* Initializations for component PoreArm11. */
  SIG_MESSAGE("PoreArm11 (Init)");

  /* Initializations for component PoreArm12. */
  SIG_MESSAGE("PoreArm12 (Init)");

  /* Initializations for component PoreArm13. */
  SIG_MESSAGE("PoreArm13 (Init)");

  /* Initializations for component PoreArm14. */
  SIG_MESSAGE("PoreArm14 (Init)");

  /* Initializations for component PoreArm15. */
  SIG_MESSAGE("PoreArm15 (Init)");

  /* Initializations for component PoreArm16. */
  SIG_MESSAGE("PoreArm16 (Init)");

  /* Initializations for component PoreArm17. */
  SIG_MESSAGE("PoreArm17 (Init)");

  /* Initializations for component PoreArm18. */
  SIG_MESSAGE("PoreArm18 (Init)");

  /* Initializations for component PoreArm19. */
  SIG_MESSAGE("PoreArm19 (Init)");

  /* Initializations for component PoreArm20. */
  SIG_MESSAGE("PoreArm20 (Init)");

  /* Initializations for component PoreArm21. */
  SIG_MESSAGE("PoreArm21 (Init)");

  /* Initializations for component PoreArm22. */
  SIG_MESSAGE("PoreArm22 (Init)");

  /* Initializations for component PoreArm23. */
  SIG_MESSAGE("PoreArm23 (Init)");

  /* Initializations for component PoreArm24. */
  SIG_MESSAGE("PoreArm24 (Init)");

  /* Initializations for component PoreArm25. */
  SIG_MESSAGE("PoreArm25 (Init)");

  /* Initializations for component PoreArm26. */
  SIG_MESSAGE("PoreArm26 (Init)");

  /* Initializations for component PoreArm27. */
  SIG_MESSAGE("PoreArm27 (Init)");

  /* Initializations for component PoreArm28. */
  SIG_MESSAGE("PoreArm28 (Init)");

  /* Initializations for component PoreArm29. */
  SIG_MESSAGE("PoreArm29 (Init)");

  /* Initializations for component PoreArm30. */
  SIG_MESSAGE("PoreArm30 (Init)");

  /* Initializations for component PoreArm31. */
  SIG_MESSAGE("PoreArm31 (Init)");

  /* Initializations for component PoreArm32. */
  SIG_MESSAGE("PoreArm32 (Init)");

  /* Initializations for component PoreArm33. */
  SIG_MESSAGE("PoreArm33 (Init)");

  /* Initializations for component PoreArm34. */
  SIG_MESSAGE("PoreArm34 (Init)");

  /* Initializations for component PoreArm35. */
  SIG_MESSAGE("PoreArm35 (Init)");

  /* Initializations for component PoreArm36. */
  SIG_MESSAGE("PoreArm36 (Init)");

  /* Initializations for component PoreArm37. */
  SIG_MESSAGE("PoreArm37 (Init)");

  /* Initializations for component PoreArm38. */
  SIG_MESSAGE("PoreArm38 (Init)");

  /* Initializations for component PoreArm39. */
  SIG_MESSAGE("PoreArm39 (Init)");

  /* Initializations for component PoreArm40. */
  SIG_MESSAGE("PoreArm40 (Init)");

  /* Initializations for component PoreArm41. */
  SIG_MESSAGE("PoreArm41 (Init)");

  /* Initializations for component PoreArm42. */
  SIG_MESSAGE("PoreArm42 (Init)");

  /* Initializations for component PoreArm43. */
  SIG_MESSAGE("PoreArm43 (Init)");

  /* Initializations for component PoreArm44. */
  SIG_MESSAGE("PoreArm44 (Init)");

  /* Initializations for component PoreArm45. */
  SIG_MESSAGE("PoreArm45 (Init)");

  /* Initializations for component PoreArm46. */
  SIG_MESSAGE("PoreArm46 (Init)");

  /* Initializations for component PoreArm47. */
  SIG_MESSAGE("PoreArm47 (Init)");

  /* Initializations for component PoreArm48. */
  SIG_MESSAGE("PoreArm48 (Init)");

  /* Initializations for component PoreP0. */
  SIG_MESSAGE("PoreP0 (Init)");
#define mccompcurname  PoreP0
#define mccompcurtype  Pore_p_group
#define mccompcurindex 54
#define nLeft mccPoreP0_nLeft
#define nRight mccPoreP0_nRight
#define nExit mccPoreP0_nExit
#define nTop mccPoreP0_nTop
#define nBottom mccPoreP0_nBottom
#define wLeft mccPoreP0_wLeft
#define wRight mccPoreP0_wRight
#define wExit mccPoreP0_wExit
#define wall mccPoreP0_wall
#define zentry mccPoreP0_zentry
#define reflec_top_table mccPoreP0_reflec_top_table
#define reflec_bottom_table mccPoreP0_reflec_bottom_table
#define reflec_side_table mccPoreP0_reflec_side_table
#define ref_prms mccPoreP0_ref_prms
#define radius_p mccPoreP0_radius_p
#define radius_m mccPoreP0_radius_m
#define Z0 mccPoreP0_Z0
#define xwidth mccPoreP0_xwidth
#define yheight mccPoreP0_yheight
#define chamferwidth mccPoreP0_chamferwidth
#define mirror_reflec mccPoreP0_mirror_reflec
#define bottom_reflec mccPoreP0_bottom_reflec
#define side_reflec mccPoreP0_side_reflec
#define R_d mccPoreP0_R_d
#define absorb_sides mccPoreP0_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 24605 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP1. */
  SIG_MESSAGE("PoreP1 (Init)");
#define mccompcurname  PoreP1
#define mccompcurtype  Pore_p_group
#define mccompcurindex 55
#define nLeft mccPoreP1_nLeft
#define nRight mccPoreP1_nRight
#define nExit mccPoreP1_nExit
#define nTop mccPoreP1_nTop
#define nBottom mccPoreP1_nBottom
#define wLeft mccPoreP1_wLeft
#define wRight mccPoreP1_wRight
#define wExit mccPoreP1_wExit
#define wall mccPoreP1_wall
#define zentry mccPoreP1_zentry
#define reflec_top_table mccPoreP1_reflec_top_table
#define reflec_bottom_table mccPoreP1_reflec_bottom_table
#define reflec_side_table mccPoreP1_reflec_side_table
#define ref_prms mccPoreP1_ref_prms
#define radius_p mccPoreP1_radius_p
#define radius_m mccPoreP1_radius_m
#define Z0 mccPoreP1_Z0
#define xwidth mccPoreP1_xwidth
#define yheight mccPoreP1_yheight
#define chamferwidth mccPoreP1_chamferwidth
#define mirror_reflec mccPoreP1_mirror_reflec
#define bottom_reflec mccPoreP1_bottom_reflec
#define side_reflec mccPoreP1_side_reflec
#define R_d mccPoreP1_R_d
#define absorb_sides mccPoreP1_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 24755 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP2. */
  SIG_MESSAGE("PoreP2 (Init)");
#define mccompcurname  PoreP2
#define mccompcurtype  Pore_p_group
#define mccompcurindex 56
#define nLeft mccPoreP2_nLeft
#define nRight mccPoreP2_nRight
#define nExit mccPoreP2_nExit
#define nTop mccPoreP2_nTop
#define nBottom mccPoreP2_nBottom
#define wLeft mccPoreP2_wLeft
#define wRight mccPoreP2_wRight
#define wExit mccPoreP2_wExit
#define wall mccPoreP2_wall
#define zentry mccPoreP2_zentry
#define reflec_top_table mccPoreP2_reflec_top_table
#define reflec_bottom_table mccPoreP2_reflec_bottom_table
#define reflec_side_table mccPoreP2_reflec_side_table
#define ref_prms mccPoreP2_ref_prms
#define radius_p mccPoreP2_radius_p
#define radius_m mccPoreP2_radius_m
#define Z0 mccPoreP2_Z0
#define xwidth mccPoreP2_xwidth
#define yheight mccPoreP2_yheight
#define chamferwidth mccPoreP2_chamferwidth
#define mirror_reflec mccPoreP2_mirror_reflec
#define bottom_reflec mccPoreP2_bottom_reflec
#define side_reflec mccPoreP2_side_reflec
#define R_d mccPoreP2_R_d
#define absorb_sides mccPoreP2_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 24905 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP3. */
  SIG_MESSAGE("PoreP3 (Init)");
#define mccompcurname  PoreP3
#define mccompcurtype  Pore_p_group
#define mccompcurindex 57
#define nLeft mccPoreP3_nLeft
#define nRight mccPoreP3_nRight
#define nExit mccPoreP3_nExit
#define nTop mccPoreP3_nTop
#define nBottom mccPoreP3_nBottom
#define wLeft mccPoreP3_wLeft
#define wRight mccPoreP3_wRight
#define wExit mccPoreP3_wExit
#define wall mccPoreP3_wall
#define zentry mccPoreP3_zentry
#define reflec_top_table mccPoreP3_reflec_top_table
#define reflec_bottom_table mccPoreP3_reflec_bottom_table
#define reflec_side_table mccPoreP3_reflec_side_table
#define ref_prms mccPoreP3_ref_prms
#define radius_p mccPoreP3_radius_p
#define radius_m mccPoreP3_radius_m
#define Z0 mccPoreP3_Z0
#define xwidth mccPoreP3_xwidth
#define yheight mccPoreP3_yheight
#define chamferwidth mccPoreP3_chamferwidth
#define mirror_reflec mccPoreP3_mirror_reflec
#define bottom_reflec mccPoreP3_bottom_reflec
#define side_reflec mccPoreP3_side_reflec
#define R_d mccPoreP3_R_d
#define absorb_sides mccPoreP3_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 25055 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP4. */
  SIG_MESSAGE("PoreP4 (Init)");
#define mccompcurname  PoreP4
#define mccompcurtype  Pore_p_group
#define mccompcurindex 58
#define nLeft mccPoreP4_nLeft
#define nRight mccPoreP4_nRight
#define nExit mccPoreP4_nExit
#define nTop mccPoreP4_nTop
#define nBottom mccPoreP4_nBottom
#define wLeft mccPoreP4_wLeft
#define wRight mccPoreP4_wRight
#define wExit mccPoreP4_wExit
#define wall mccPoreP4_wall
#define zentry mccPoreP4_zentry
#define reflec_top_table mccPoreP4_reflec_top_table
#define reflec_bottom_table mccPoreP4_reflec_bottom_table
#define reflec_side_table mccPoreP4_reflec_side_table
#define ref_prms mccPoreP4_ref_prms
#define radius_p mccPoreP4_radius_p
#define radius_m mccPoreP4_radius_m
#define Z0 mccPoreP4_Z0
#define xwidth mccPoreP4_xwidth
#define yheight mccPoreP4_yheight
#define chamferwidth mccPoreP4_chamferwidth
#define mirror_reflec mccPoreP4_mirror_reflec
#define bottom_reflec mccPoreP4_bottom_reflec
#define side_reflec mccPoreP4_side_reflec
#define R_d mccPoreP4_R_d
#define absorb_sides mccPoreP4_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 25205 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP5. */
  SIG_MESSAGE("PoreP5 (Init)");
#define mccompcurname  PoreP5
#define mccompcurtype  Pore_p_group
#define mccompcurindex 59
#define nLeft mccPoreP5_nLeft
#define nRight mccPoreP5_nRight
#define nExit mccPoreP5_nExit
#define nTop mccPoreP5_nTop
#define nBottom mccPoreP5_nBottom
#define wLeft mccPoreP5_wLeft
#define wRight mccPoreP5_wRight
#define wExit mccPoreP5_wExit
#define wall mccPoreP5_wall
#define zentry mccPoreP5_zentry
#define reflec_top_table mccPoreP5_reflec_top_table
#define reflec_bottom_table mccPoreP5_reflec_bottom_table
#define reflec_side_table mccPoreP5_reflec_side_table
#define ref_prms mccPoreP5_ref_prms
#define radius_p mccPoreP5_radius_p
#define radius_m mccPoreP5_radius_m
#define Z0 mccPoreP5_Z0
#define xwidth mccPoreP5_xwidth
#define yheight mccPoreP5_yheight
#define chamferwidth mccPoreP5_chamferwidth
#define mirror_reflec mccPoreP5_mirror_reflec
#define bottom_reflec mccPoreP5_bottom_reflec
#define side_reflec mccPoreP5_side_reflec
#define R_d mccPoreP5_R_d
#define absorb_sides mccPoreP5_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 25355 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP6. */
  SIG_MESSAGE("PoreP6 (Init)");
#define mccompcurname  PoreP6
#define mccompcurtype  Pore_p_group
#define mccompcurindex 60
#define nLeft mccPoreP6_nLeft
#define nRight mccPoreP6_nRight
#define nExit mccPoreP6_nExit
#define nTop mccPoreP6_nTop
#define nBottom mccPoreP6_nBottom
#define wLeft mccPoreP6_wLeft
#define wRight mccPoreP6_wRight
#define wExit mccPoreP6_wExit
#define wall mccPoreP6_wall
#define zentry mccPoreP6_zentry
#define reflec_top_table mccPoreP6_reflec_top_table
#define reflec_bottom_table mccPoreP6_reflec_bottom_table
#define reflec_side_table mccPoreP6_reflec_side_table
#define ref_prms mccPoreP6_ref_prms
#define radius_p mccPoreP6_radius_p
#define radius_m mccPoreP6_radius_m
#define Z0 mccPoreP6_Z0
#define xwidth mccPoreP6_xwidth
#define yheight mccPoreP6_yheight
#define chamferwidth mccPoreP6_chamferwidth
#define mirror_reflec mccPoreP6_mirror_reflec
#define bottom_reflec mccPoreP6_bottom_reflec
#define side_reflec mccPoreP6_side_reflec
#define R_d mccPoreP6_R_d
#define absorb_sides mccPoreP6_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 25505 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP7. */
  SIG_MESSAGE("PoreP7 (Init)");
#define mccompcurname  PoreP7
#define mccompcurtype  Pore_p_group
#define mccompcurindex 61
#define nLeft mccPoreP7_nLeft
#define nRight mccPoreP7_nRight
#define nExit mccPoreP7_nExit
#define nTop mccPoreP7_nTop
#define nBottom mccPoreP7_nBottom
#define wLeft mccPoreP7_wLeft
#define wRight mccPoreP7_wRight
#define wExit mccPoreP7_wExit
#define wall mccPoreP7_wall
#define zentry mccPoreP7_zentry
#define reflec_top_table mccPoreP7_reflec_top_table
#define reflec_bottom_table mccPoreP7_reflec_bottom_table
#define reflec_side_table mccPoreP7_reflec_side_table
#define ref_prms mccPoreP7_ref_prms
#define radius_p mccPoreP7_radius_p
#define radius_m mccPoreP7_radius_m
#define Z0 mccPoreP7_Z0
#define xwidth mccPoreP7_xwidth
#define yheight mccPoreP7_yheight
#define chamferwidth mccPoreP7_chamferwidth
#define mirror_reflec mccPoreP7_mirror_reflec
#define bottom_reflec mccPoreP7_bottom_reflec
#define side_reflec mccPoreP7_side_reflec
#define R_d mccPoreP7_R_d
#define absorb_sides mccPoreP7_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 25655 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP8. */
  SIG_MESSAGE("PoreP8 (Init)");
#define mccompcurname  PoreP8
#define mccompcurtype  Pore_p_group
#define mccompcurindex 62
#define nLeft mccPoreP8_nLeft
#define nRight mccPoreP8_nRight
#define nExit mccPoreP8_nExit
#define nTop mccPoreP8_nTop
#define nBottom mccPoreP8_nBottom
#define wLeft mccPoreP8_wLeft
#define wRight mccPoreP8_wRight
#define wExit mccPoreP8_wExit
#define wall mccPoreP8_wall
#define zentry mccPoreP8_zentry
#define reflec_top_table mccPoreP8_reflec_top_table
#define reflec_bottom_table mccPoreP8_reflec_bottom_table
#define reflec_side_table mccPoreP8_reflec_side_table
#define ref_prms mccPoreP8_ref_prms
#define radius_p mccPoreP8_radius_p
#define radius_m mccPoreP8_radius_m
#define Z0 mccPoreP8_Z0
#define xwidth mccPoreP8_xwidth
#define yheight mccPoreP8_yheight
#define chamferwidth mccPoreP8_chamferwidth
#define mirror_reflec mccPoreP8_mirror_reflec
#define bottom_reflec mccPoreP8_bottom_reflec
#define side_reflec mccPoreP8_side_reflec
#define R_d mccPoreP8_R_d
#define absorb_sides mccPoreP8_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 25805 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP9. */
  SIG_MESSAGE("PoreP9 (Init)");
#define mccompcurname  PoreP9
#define mccompcurtype  Pore_p_group
#define mccompcurindex 63
#define nLeft mccPoreP9_nLeft
#define nRight mccPoreP9_nRight
#define nExit mccPoreP9_nExit
#define nTop mccPoreP9_nTop
#define nBottom mccPoreP9_nBottom
#define wLeft mccPoreP9_wLeft
#define wRight mccPoreP9_wRight
#define wExit mccPoreP9_wExit
#define wall mccPoreP9_wall
#define zentry mccPoreP9_zentry
#define reflec_top_table mccPoreP9_reflec_top_table
#define reflec_bottom_table mccPoreP9_reflec_bottom_table
#define reflec_side_table mccPoreP9_reflec_side_table
#define ref_prms mccPoreP9_ref_prms
#define radius_p mccPoreP9_radius_p
#define radius_m mccPoreP9_radius_m
#define Z0 mccPoreP9_Z0
#define xwidth mccPoreP9_xwidth
#define yheight mccPoreP9_yheight
#define chamferwidth mccPoreP9_chamferwidth
#define mirror_reflec mccPoreP9_mirror_reflec
#define bottom_reflec mccPoreP9_bottom_reflec
#define side_reflec mccPoreP9_side_reflec
#define R_d mccPoreP9_R_d
#define absorb_sides mccPoreP9_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 25955 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP10. */
  SIG_MESSAGE("PoreP10 (Init)");
#define mccompcurname  PoreP10
#define mccompcurtype  Pore_p_group
#define mccompcurindex 64
#define nLeft mccPoreP10_nLeft
#define nRight mccPoreP10_nRight
#define nExit mccPoreP10_nExit
#define nTop mccPoreP10_nTop
#define nBottom mccPoreP10_nBottom
#define wLeft mccPoreP10_wLeft
#define wRight mccPoreP10_wRight
#define wExit mccPoreP10_wExit
#define wall mccPoreP10_wall
#define zentry mccPoreP10_zentry
#define reflec_top_table mccPoreP10_reflec_top_table
#define reflec_bottom_table mccPoreP10_reflec_bottom_table
#define reflec_side_table mccPoreP10_reflec_side_table
#define ref_prms mccPoreP10_ref_prms
#define radius_p mccPoreP10_radius_p
#define radius_m mccPoreP10_radius_m
#define Z0 mccPoreP10_Z0
#define xwidth mccPoreP10_xwidth
#define yheight mccPoreP10_yheight
#define chamferwidth mccPoreP10_chamferwidth
#define mirror_reflec mccPoreP10_mirror_reflec
#define bottom_reflec mccPoreP10_bottom_reflec
#define side_reflec mccPoreP10_side_reflec
#define R_d mccPoreP10_R_d
#define absorb_sides mccPoreP10_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 26105 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP11. */
  SIG_MESSAGE("PoreP11 (Init)");
#define mccompcurname  PoreP11
#define mccompcurtype  Pore_p_group
#define mccompcurindex 65
#define nLeft mccPoreP11_nLeft
#define nRight mccPoreP11_nRight
#define nExit mccPoreP11_nExit
#define nTop mccPoreP11_nTop
#define nBottom mccPoreP11_nBottom
#define wLeft mccPoreP11_wLeft
#define wRight mccPoreP11_wRight
#define wExit mccPoreP11_wExit
#define wall mccPoreP11_wall
#define zentry mccPoreP11_zentry
#define reflec_top_table mccPoreP11_reflec_top_table
#define reflec_bottom_table mccPoreP11_reflec_bottom_table
#define reflec_side_table mccPoreP11_reflec_side_table
#define ref_prms mccPoreP11_ref_prms
#define radius_p mccPoreP11_radius_p
#define radius_m mccPoreP11_radius_m
#define Z0 mccPoreP11_Z0
#define xwidth mccPoreP11_xwidth
#define yheight mccPoreP11_yheight
#define chamferwidth mccPoreP11_chamferwidth
#define mirror_reflec mccPoreP11_mirror_reflec
#define bottom_reflec mccPoreP11_bottom_reflec
#define side_reflec mccPoreP11_side_reflec
#define R_d mccPoreP11_R_d
#define absorb_sides mccPoreP11_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 26255 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP12. */
  SIG_MESSAGE("PoreP12 (Init)");
#define mccompcurname  PoreP12
#define mccompcurtype  Pore_p_group
#define mccompcurindex 66
#define nLeft mccPoreP12_nLeft
#define nRight mccPoreP12_nRight
#define nExit mccPoreP12_nExit
#define nTop mccPoreP12_nTop
#define nBottom mccPoreP12_nBottom
#define wLeft mccPoreP12_wLeft
#define wRight mccPoreP12_wRight
#define wExit mccPoreP12_wExit
#define wall mccPoreP12_wall
#define zentry mccPoreP12_zentry
#define reflec_top_table mccPoreP12_reflec_top_table
#define reflec_bottom_table mccPoreP12_reflec_bottom_table
#define reflec_side_table mccPoreP12_reflec_side_table
#define ref_prms mccPoreP12_ref_prms
#define radius_p mccPoreP12_radius_p
#define radius_m mccPoreP12_radius_m
#define Z0 mccPoreP12_Z0
#define xwidth mccPoreP12_xwidth
#define yheight mccPoreP12_yheight
#define chamferwidth mccPoreP12_chamferwidth
#define mirror_reflec mccPoreP12_mirror_reflec
#define bottom_reflec mccPoreP12_bottom_reflec
#define side_reflec mccPoreP12_side_reflec
#define R_d mccPoreP12_R_d
#define absorb_sides mccPoreP12_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 26405 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP13. */
  SIG_MESSAGE("PoreP13 (Init)");
#define mccompcurname  PoreP13
#define mccompcurtype  Pore_p_group
#define mccompcurindex 67
#define nLeft mccPoreP13_nLeft
#define nRight mccPoreP13_nRight
#define nExit mccPoreP13_nExit
#define nTop mccPoreP13_nTop
#define nBottom mccPoreP13_nBottom
#define wLeft mccPoreP13_wLeft
#define wRight mccPoreP13_wRight
#define wExit mccPoreP13_wExit
#define wall mccPoreP13_wall
#define zentry mccPoreP13_zentry
#define reflec_top_table mccPoreP13_reflec_top_table
#define reflec_bottom_table mccPoreP13_reflec_bottom_table
#define reflec_side_table mccPoreP13_reflec_side_table
#define ref_prms mccPoreP13_ref_prms
#define radius_p mccPoreP13_radius_p
#define radius_m mccPoreP13_radius_m
#define Z0 mccPoreP13_Z0
#define xwidth mccPoreP13_xwidth
#define yheight mccPoreP13_yheight
#define chamferwidth mccPoreP13_chamferwidth
#define mirror_reflec mccPoreP13_mirror_reflec
#define bottom_reflec mccPoreP13_bottom_reflec
#define side_reflec mccPoreP13_side_reflec
#define R_d mccPoreP13_R_d
#define absorb_sides mccPoreP13_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 26555 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP14. */
  SIG_MESSAGE("PoreP14 (Init)");
#define mccompcurname  PoreP14
#define mccompcurtype  Pore_p_group
#define mccompcurindex 68
#define nLeft mccPoreP14_nLeft
#define nRight mccPoreP14_nRight
#define nExit mccPoreP14_nExit
#define nTop mccPoreP14_nTop
#define nBottom mccPoreP14_nBottom
#define wLeft mccPoreP14_wLeft
#define wRight mccPoreP14_wRight
#define wExit mccPoreP14_wExit
#define wall mccPoreP14_wall
#define zentry mccPoreP14_zentry
#define reflec_top_table mccPoreP14_reflec_top_table
#define reflec_bottom_table mccPoreP14_reflec_bottom_table
#define reflec_side_table mccPoreP14_reflec_side_table
#define ref_prms mccPoreP14_ref_prms
#define radius_p mccPoreP14_radius_p
#define radius_m mccPoreP14_radius_m
#define Z0 mccPoreP14_Z0
#define xwidth mccPoreP14_xwidth
#define yheight mccPoreP14_yheight
#define chamferwidth mccPoreP14_chamferwidth
#define mirror_reflec mccPoreP14_mirror_reflec
#define bottom_reflec mccPoreP14_bottom_reflec
#define side_reflec mccPoreP14_side_reflec
#define R_d mccPoreP14_R_d
#define absorb_sides mccPoreP14_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 26705 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP15. */
  SIG_MESSAGE("PoreP15 (Init)");
#define mccompcurname  PoreP15
#define mccompcurtype  Pore_p_group
#define mccompcurindex 69
#define nLeft mccPoreP15_nLeft
#define nRight mccPoreP15_nRight
#define nExit mccPoreP15_nExit
#define nTop mccPoreP15_nTop
#define nBottom mccPoreP15_nBottom
#define wLeft mccPoreP15_wLeft
#define wRight mccPoreP15_wRight
#define wExit mccPoreP15_wExit
#define wall mccPoreP15_wall
#define zentry mccPoreP15_zentry
#define reflec_top_table mccPoreP15_reflec_top_table
#define reflec_bottom_table mccPoreP15_reflec_bottom_table
#define reflec_side_table mccPoreP15_reflec_side_table
#define ref_prms mccPoreP15_ref_prms
#define radius_p mccPoreP15_radius_p
#define radius_m mccPoreP15_radius_m
#define Z0 mccPoreP15_Z0
#define xwidth mccPoreP15_xwidth
#define yheight mccPoreP15_yheight
#define chamferwidth mccPoreP15_chamferwidth
#define mirror_reflec mccPoreP15_mirror_reflec
#define bottom_reflec mccPoreP15_bottom_reflec
#define side_reflec mccPoreP15_side_reflec
#define R_d mccPoreP15_R_d
#define absorb_sides mccPoreP15_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 26855 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP16. */
  SIG_MESSAGE("PoreP16 (Init)");
#define mccompcurname  PoreP16
#define mccompcurtype  Pore_p_group
#define mccompcurindex 70
#define nLeft mccPoreP16_nLeft
#define nRight mccPoreP16_nRight
#define nExit mccPoreP16_nExit
#define nTop mccPoreP16_nTop
#define nBottom mccPoreP16_nBottom
#define wLeft mccPoreP16_wLeft
#define wRight mccPoreP16_wRight
#define wExit mccPoreP16_wExit
#define wall mccPoreP16_wall
#define zentry mccPoreP16_zentry
#define reflec_top_table mccPoreP16_reflec_top_table
#define reflec_bottom_table mccPoreP16_reflec_bottom_table
#define reflec_side_table mccPoreP16_reflec_side_table
#define ref_prms mccPoreP16_ref_prms
#define radius_p mccPoreP16_radius_p
#define radius_m mccPoreP16_radius_m
#define Z0 mccPoreP16_Z0
#define xwidth mccPoreP16_xwidth
#define yheight mccPoreP16_yheight
#define chamferwidth mccPoreP16_chamferwidth
#define mirror_reflec mccPoreP16_mirror_reflec
#define bottom_reflec mccPoreP16_bottom_reflec
#define side_reflec mccPoreP16_side_reflec
#define R_d mccPoreP16_R_d
#define absorb_sides mccPoreP16_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 27005 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP17. */
  SIG_MESSAGE("PoreP17 (Init)");
#define mccompcurname  PoreP17
#define mccompcurtype  Pore_p_group
#define mccompcurindex 71
#define nLeft mccPoreP17_nLeft
#define nRight mccPoreP17_nRight
#define nExit mccPoreP17_nExit
#define nTop mccPoreP17_nTop
#define nBottom mccPoreP17_nBottom
#define wLeft mccPoreP17_wLeft
#define wRight mccPoreP17_wRight
#define wExit mccPoreP17_wExit
#define wall mccPoreP17_wall
#define zentry mccPoreP17_zentry
#define reflec_top_table mccPoreP17_reflec_top_table
#define reflec_bottom_table mccPoreP17_reflec_bottom_table
#define reflec_side_table mccPoreP17_reflec_side_table
#define ref_prms mccPoreP17_ref_prms
#define radius_p mccPoreP17_radius_p
#define radius_m mccPoreP17_radius_m
#define Z0 mccPoreP17_Z0
#define xwidth mccPoreP17_xwidth
#define yheight mccPoreP17_yheight
#define chamferwidth mccPoreP17_chamferwidth
#define mirror_reflec mccPoreP17_mirror_reflec
#define bottom_reflec mccPoreP17_bottom_reflec
#define side_reflec mccPoreP17_side_reflec
#define R_d mccPoreP17_R_d
#define absorb_sides mccPoreP17_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 27155 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP18. */
  SIG_MESSAGE("PoreP18 (Init)");
#define mccompcurname  PoreP18
#define mccompcurtype  Pore_p_group
#define mccompcurindex 72
#define nLeft mccPoreP18_nLeft
#define nRight mccPoreP18_nRight
#define nExit mccPoreP18_nExit
#define nTop mccPoreP18_nTop
#define nBottom mccPoreP18_nBottom
#define wLeft mccPoreP18_wLeft
#define wRight mccPoreP18_wRight
#define wExit mccPoreP18_wExit
#define wall mccPoreP18_wall
#define zentry mccPoreP18_zentry
#define reflec_top_table mccPoreP18_reflec_top_table
#define reflec_bottom_table mccPoreP18_reflec_bottom_table
#define reflec_side_table mccPoreP18_reflec_side_table
#define ref_prms mccPoreP18_ref_prms
#define radius_p mccPoreP18_radius_p
#define radius_m mccPoreP18_radius_m
#define Z0 mccPoreP18_Z0
#define xwidth mccPoreP18_xwidth
#define yheight mccPoreP18_yheight
#define chamferwidth mccPoreP18_chamferwidth
#define mirror_reflec mccPoreP18_mirror_reflec
#define bottom_reflec mccPoreP18_bottom_reflec
#define side_reflec mccPoreP18_side_reflec
#define R_d mccPoreP18_R_d
#define absorb_sides mccPoreP18_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 27305 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP19. */
  SIG_MESSAGE("PoreP19 (Init)");
#define mccompcurname  PoreP19
#define mccompcurtype  Pore_p_group
#define mccompcurindex 73
#define nLeft mccPoreP19_nLeft
#define nRight mccPoreP19_nRight
#define nExit mccPoreP19_nExit
#define nTop mccPoreP19_nTop
#define nBottom mccPoreP19_nBottom
#define wLeft mccPoreP19_wLeft
#define wRight mccPoreP19_wRight
#define wExit mccPoreP19_wExit
#define wall mccPoreP19_wall
#define zentry mccPoreP19_zentry
#define reflec_top_table mccPoreP19_reflec_top_table
#define reflec_bottom_table mccPoreP19_reflec_bottom_table
#define reflec_side_table mccPoreP19_reflec_side_table
#define ref_prms mccPoreP19_ref_prms
#define radius_p mccPoreP19_radius_p
#define radius_m mccPoreP19_radius_m
#define Z0 mccPoreP19_Z0
#define xwidth mccPoreP19_xwidth
#define yheight mccPoreP19_yheight
#define chamferwidth mccPoreP19_chamferwidth
#define mirror_reflec mccPoreP19_mirror_reflec
#define bottom_reflec mccPoreP19_bottom_reflec
#define side_reflec mccPoreP19_side_reflec
#define R_d mccPoreP19_R_d
#define absorb_sides mccPoreP19_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 27455 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP20. */
  SIG_MESSAGE("PoreP20 (Init)");
#define mccompcurname  PoreP20
#define mccompcurtype  Pore_p_group
#define mccompcurindex 74
#define nLeft mccPoreP20_nLeft
#define nRight mccPoreP20_nRight
#define nExit mccPoreP20_nExit
#define nTop mccPoreP20_nTop
#define nBottom mccPoreP20_nBottom
#define wLeft mccPoreP20_wLeft
#define wRight mccPoreP20_wRight
#define wExit mccPoreP20_wExit
#define wall mccPoreP20_wall
#define zentry mccPoreP20_zentry
#define reflec_top_table mccPoreP20_reflec_top_table
#define reflec_bottom_table mccPoreP20_reflec_bottom_table
#define reflec_side_table mccPoreP20_reflec_side_table
#define ref_prms mccPoreP20_ref_prms
#define radius_p mccPoreP20_radius_p
#define radius_m mccPoreP20_radius_m
#define Z0 mccPoreP20_Z0
#define xwidth mccPoreP20_xwidth
#define yheight mccPoreP20_yheight
#define chamferwidth mccPoreP20_chamferwidth
#define mirror_reflec mccPoreP20_mirror_reflec
#define bottom_reflec mccPoreP20_bottom_reflec
#define side_reflec mccPoreP20_side_reflec
#define R_d mccPoreP20_R_d
#define absorb_sides mccPoreP20_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 27605 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP21. */
  SIG_MESSAGE("PoreP21 (Init)");
#define mccompcurname  PoreP21
#define mccompcurtype  Pore_p_group
#define mccompcurindex 75
#define nLeft mccPoreP21_nLeft
#define nRight mccPoreP21_nRight
#define nExit mccPoreP21_nExit
#define nTop mccPoreP21_nTop
#define nBottom mccPoreP21_nBottom
#define wLeft mccPoreP21_wLeft
#define wRight mccPoreP21_wRight
#define wExit mccPoreP21_wExit
#define wall mccPoreP21_wall
#define zentry mccPoreP21_zentry
#define reflec_top_table mccPoreP21_reflec_top_table
#define reflec_bottom_table mccPoreP21_reflec_bottom_table
#define reflec_side_table mccPoreP21_reflec_side_table
#define ref_prms mccPoreP21_ref_prms
#define radius_p mccPoreP21_radius_p
#define radius_m mccPoreP21_radius_m
#define Z0 mccPoreP21_Z0
#define xwidth mccPoreP21_xwidth
#define yheight mccPoreP21_yheight
#define chamferwidth mccPoreP21_chamferwidth
#define mirror_reflec mccPoreP21_mirror_reflec
#define bottom_reflec mccPoreP21_bottom_reflec
#define side_reflec mccPoreP21_side_reflec
#define R_d mccPoreP21_R_d
#define absorb_sides mccPoreP21_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 27755 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP22. */
  SIG_MESSAGE("PoreP22 (Init)");
#define mccompcurname  PoreP22
#define mccompcurtype  Pore_p_group
#define mccompcurindex 76
#define nLeft mccPoreP22_nLeft
#define nRight mccPoreP22_nRight
#define nExit mccPoreP22_nExit
#define nTop mccPoreP22_nTop
#define nBottom mccPoreP22_nBottom
#define wLeft mccPoreP22_wLeft
#define wRight mccPoreP22_wRight
#define wExit mccPoreP22_wExit
#define wall mccPoreP22_wall
#define zentry mccPoreP22_zentry
#define reflec_top_table mccPoreP22_reflec_top_table
#define reflec_bottom_table mccPoreP22_reflec_bottom_table
#define reflec_side_table mccPoreP22_reflec_side_table
#define ref_prms mccPoreP22_ref_prms
#define radius_p mccPoreP22_radius_p
#define radius_m mccPoreP22_radius_m
#define Z0 mccPoreP22_Z0
#define xwidth mccPoreP22_xwidth
#define yheight mccPoreP22_yheight
#define chamferwidth mccPoreP22_chamferwidth
#define mirror_reflec mccPoreP22_mirror_reflec
#define bottom_reflec mccPoreP22_bottom_reflec
#define side_reflec mccPoreP22_side_reflec
#define R_d mccPoreP22_R_d
#define absorb_sides mccPoreP22_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 27905 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP23. */
  SIG_MESSAGE("PoreP23 (Init)");
#define mccompcurname  PoreP23
#define mccompcurtype  Pore_p_group
#define mccompcurindex 77
#define nLeft mccPoreP23_nLeft
#define nRight mccPoreP23_nRight
#define nExit mccPoreP23_nExit
#define nTop mccPoreP23_nTop
#define nBottom mccPoreP23_nBottom
#define wLeft mccPoreP23_wLeft
#define wRight mccPoreP23_wRight
#define wExit mccPoreP23_wExit
#define wall mccPoreP23_wall
#define zentry mccPoreP23_zentry
#define reflec_top_table mccPoreP23_reflec_top_table
#define reflec_bottom_table mccPoreP23_reflec_bottom_table
#define reflec_side_table mccPoreP23_reflec_side_table
#define ref_prms mccPoreP23_ref_prms
#define radius_p mccPoreP23_radius_p
#define radius_m mccPoreP23_radius_m
#define Z0 mccPoreP23_Z0
#define xwidth mccPoreP23_xwidth
#define yheight mccPoreP23_yheight
#define chamferwidth mccPoreP23_chamferwidth
#define mirror_reflec mccPoreP23_mirror_reflec
#define bottom_reflec mccPoreP23_bottom_reflec
#define side_reflec mccPoreP23_side_reflec
#define R_d mccPoreP23_R_d
#define absorb_sides mccPoreP23_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 28055 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP24. */
  SIG_MESSAGE("PoreP24 (Init)");
#define mccompcurname  PoreP24
#define mccompcurtype  Pore_p_group
#define mccompcurindex 78
#define nLeft mccPoreP24_nLeft
#define nRight mccPoreP24_nRight
#define nExit mccPoreP24_nExit
#define nTop mccPoreP24_nTop
#define nBottom mccPoreP24_nBottom
#define wLeft mccPoreP24_wLeft
#define wRight mccPoreP24_wRight
#define wExit mccPoreP24_wExit
#define wall mccPoreP24_wall
#define zentry mccPoreP24_zentry
#define reflec_top_table mccPoreP24_reflec_top_table
#define reflec_bottom_table mccPoreP24_reflec_bottom_table
#define reflec_side_table mccPoreP24_reflec_side_table
#define ref_prms mccPoreP24_ref_prms
#define radius_p mccPoreP24_radius_p
#define radius_m mccPoreP24_radius_m
#define Z0 mccPoreP24_Z0
#define xwidth mccPoreP24_xwidth
#define yheight mccPoreP24_yheight
#define chamferwidth mccPoreP24_chamferwidth
#define mirror_reflec mccPoreP24_mirror_reflec
#define bottom_reflec mccPoreP24_bottom_reflec
#define side_reflec mccPoreP24_side_reflec
#define R_d mccPoreP24_R_d
#define absorb_sides mccPoreP24_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 28205 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP25. */
  SIG_MESSAGE("PoreP25 (Init)");
#define mccompcurname  PoreP25
#define mccompcurtype  Pore_p_group
#define mccompcurindex 79
#define nLeft mccPoreP25_nLeft
#define nRight mccPoreP25_nRight
#define nExit mccPoreP25_nExit
#define nTop mccPoreP25_nTop
#define nBottom mccPoreP25_nBottom
#define wLeft mccPoreP25_wLeft
#define wRight mccPoreP25_wRight
#define wExit mccPoreP25_wExit
#define wall mccPoreP25_wall
#define zentry mccPoreP25_zentry
#define reflec_top_table mccPoreP25_reflec_top_table
#define reflec_bottom_table mccPoreP25_reflec_bottom_table
#define reflec_side_table mccPoreP25_reflec_side_table
#define ref_prms mccPoreP25_ref_prms
#define radius_p mccPoreP25_radius_p
#define radius_m mccPoreP25_radius_m
#define Z0 mccPoreP25_Z0
#define xwidth mccPoreP25_xwidth
#define yheight mccPoreP25_yheight
#define chamferwidth mccPoreP25_chamferwidth
#define mirror_reflec mccPoreP25_mirror_reflec
#define bottom_reflec mccPoreP25_bottom_reflec
#define side_reflec mccPoreP25_side_reflec
#define R_d mccPoreP25_R_d
#define absorb_sides mccPoreP25_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 28355 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP26. */
  SIG_MESSAGE("PoreP26 (Init)");
#define mccompcurname  PoreP26
#define mccompcurtype  Pore_p_group
#define mccompcurindex 80
#define nLeft mccPoreP26_nLeft
#define nRight mccPoreP26_nRight
#define nExit mccPoreP26_nExit
#define nTop mccPoreP26_nTop
#define nBottom mccPoreP26_nBottom
#define wLeft mccPoreP26_wLeft
#define wRight mccPoreP26_wRight
#define wExit mccPoreP26_wExit
#define wall mccPoreP26_wall
#define zentry mccPoreP26_zentry
#define reflec_top_table mccPoreP26_reflec_top_table
#define reflec_bottom_table mccPoreP26_reflec_bottom_table
#define reflec_side_table mccPoreP26_reflec_side_table
#define ref_prms mccPoreP26_ref_prms
#define radius_p mccPoreP26_radius_p
#define radius_m mccPoreP26_radius_m
#define Z0 mccPoreP26_Z0
#define xwidth mccPoreP26_xwidth
#define yheight mccPoreP26_yheight
#define chamferwidth mccPoreP26_chamferwidth
#define mirror_reflec mccPoreP26_mirror_reflec
#define bottom_reflec mccPoreP26_bottom_reflec
#define side_reflec mccPoreP26_side_reflec
#define R_d mccPoreP26_R_d
#define absorb_sides mccPoreP26_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 28505 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP27. */
  SIG_MESSAGE("PoreP27 (Init)");
#define mccompcurname  PoreP27
#define mccompcurtype  Pore_p_group
#define mccompcurindex 81
#define nLeft mccPoreP27_nLeft
#define nRight mccPoreP27_nRight
#define nExit mccPoreP27_nExit
#define nTop mccPoreP27_nTop
#define nBottom mccPoreP27_nBottom
#define wLeft mccPoreP27_wLeft
#define wRight mccPoreP27_wRight
#define wExit mccPoreP27_wExit
#define wall mccPoreP27_wall
#define zentry mccPoreP27_zentry
#define reflec_top_table mccPoreP27_reflec_top_table
#define reflec_bottom_table mccPoreP27_reflec_bottom_table
#define reflec_side_table mccPoreP27_reflec_side_table
#define ref_prms mccPoreP27_ref_prms
#define radius_p mccPoreP27_radius_p
#define radius_m mccPoreP27_radius_m
#define Z0 mccPoreP27_Z0
#define xwidth mccPoreP27_xwidth
#define yheight mccPoreP27_yheight
#define chamferwidth mccPoreP27_chamferwidth
#define mirror_reflec mccPoreP27_mirror_reflec
#define bottom_reflec mccPoreP27_bottom_reflec
#define side_reflec mccPoreP27_side_reflec
#define R_d mccPoreP27_R_d
#define absorb_sides mccPoreP27_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 28655 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP28. */
  SIG_MESSAGE("PoreP28 (Init)");
#define mccompcurname  PoreP28
#define mccompcurtype  Pore_p_group
#define mccompcurindex 82
#define nLeft mccPoreP28_nLeft
#define nRight mccPoreP28_nRight
#define nExit mccPoreP28_nExit
#define nTop mccPoreP28_nTop
#define nBottom mccPoreP28_nBottom
#define wLeft mccPoreP28_wLeft
#define wRight mccPoreP28_wRight
#define wExit mccPoreP28_wExit
#define wall mccPoreP28_wall
#define zentry mccPoreP28_zentry
#define reflec_top_table mccPoreP28_reflec_top_table
#define reflec_bottom_table mccPoreP28_reflec_bottom_table
#define reflec_side_table mccPoreP28_reflec_side_table
#define ref_prms mccPoreP28_ref_prms
#define radius_p mccPoreP28_radius_p
#define radius_m mccPoreP28_radius_m
#define Z0 mccPoreP28_Z0
#define xwidth mccPoreP28_xwidth
#define yheight mccPoreP28_yheight
#define chamferwidth mccPoreP28_chamferwidth
#define mirror_reflec mccPoreP28_mirror_reflec
#define bottom_reflec mccPoreP28_bottom_reflec
#define side_reflec mccPoreP28_side_reflec
#define R_d mccPoreP28_R_d
#define absorb_sides mccPoreP28_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 28805 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP29. */
  SIG_MESSAGE("PoreP29 (Init)");
#define mccompcurname  PoreP29
#define mccompcurtype  Pore_p_group
#define mccompcurindex 83
#define nLeft mccPoreP29_nLeft
#define nRight mccPoreP29_nRight
#define nExit mccPoreP29_nExit
#define nTop mccPoreP29_nTop
#define nBottom mccPoreP29_nBottom
#define wLeft mccPoreP29_wLeft
#define wRight mccPoreP29_wRight
#define wExit mccPoreP29_wExit
#define wall mccPoreP29_wall
#define zentry mccPoreP29_zentry
#define reflec_top_table mccPoreP29_reflec_top_table
#define reflec_bottom_table mccPoreP29_reflec_bottom_table
#define reflec_side_table mccPoreP29_reflec_side_table
#define ref_prms mccPoreP29_ref_prms
#define radius_p mccPoreP29_radius_p
#define radius_m mccPoreP29_radius_m
#define Z0 mccPoreP29_Z0
#define xwidth mccPoreP29_xwidth
#define yheight mccPoreP29_yheight
#define chamferwidth mccPoreP29_chamferwidth
#define mirror_reflec mccPoreP29_mirror_reflec
#define bottom_reflec mccPoreP29_bottom_reflec
#define side_reflec mccPoreP29_side_reflec
#define R_d mccPoreP29_R_d
#define absorb_sides mccPoreP29_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 28955 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP30. */
  SIG_MESSAGE("PoreP30 (Init)");
#define mccompcurname  PoreP30
#define mccompcurtype  Pore_p_group
#define mccompcurindex 84
#define nLeft mccPoreP30_nLeft
#define nRight mccPoreP30_nRight
#define nExit mccPoreP30_nExit
#define nTop mccPoreP30_nTop
#define nBottom mccPoreP30_nBottom
#define wLeft mccPoreP30_wLeft
#define wRight mccPoreP30_wRight
#define wExit mccPoreP30_wExit
#define wall mccPoreP30_wall
#define zentry mccPoreP30_zentry
#define reflec_top_table mccPoreP30_reflec_top_table
#define reflec_bottom_table mccPoreP30_reflec_bottom_table
#define reflec_side_table mccPoreP30_reflec_side_table
#define ref_prms mccPoreP30_ref_prms
#define radius_p mccPoreP30_radius_p
#define radius_m mccPoreP30_radius_m
#define Z0 mccPoreP30_Z0
#define xwidth mccPoreP30_xwidth
#define yheight mccPoreP30_yheight
#define chamferwidth mccPoreP30_chamferwidth
#define mirror_reflec mccPoreP30_mirror_reflec
#define bottom_reflec mccPoreP30_bottom_reflec
#define side_reflec mccPoreP30_side_reflec
#define R_d mccPoreP30_R_d
#define absorb_sides mccPoreP30_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 29105 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP31. */
  SIG_MESSAGE("PoreP31 (Init)");
#define mccompcurname  PoreP31
#define mccompcurtype  Pore_p_group
#define mccompcurindex 85
#define nLeft mccPoreP31_nLeft
#define nRight mccPoreP31_nRight
#define nExit mccPoreP31_nExit
#define nTop mccPoreP31_nTop
#define nBottom mccPoreP31_nBottom
#define wLeft mccPoreP31_wLeft
#define wRight mccPoreP31_wRight
#define wExit mccPoreP31_wExit
#define wall mccPoreP31_wall
#define zentry mccPoreP31_zentry
#define reflec_top_table mccPoreP31_reflec_top_table
#define reflec_bottom_table mccPoreP31_reflec_bottom_table
#define reflec_side_table mccPoreP31_reflec_side_table
#define ref_prms mccPoreP31_ref_prms
#define radius_p mccPoreP31_radius_p
#define radius_m mccPoreP31_radius_m
#define Z0 mccPoreP31_Z0
#define xwidth mccPoreP31_xwidth
#define yheight mccPoreP31_yheight
#define chamferwidth mccPoreP31_chamferwidth
#define mirror_reflec mccPoreP31_mirror_reflec
#define bottom_reflec mccPoreP31_bottom_reflec
#define side_reflec mccPoreP31_side_reflec
#define R_d mccPoreP31_R_d
#define absorb_sides mccPoreP31_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 29255 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP32. */
  SIG_MESSAGE("PoreP32 (Init)");
#define mccompcurname  PoreP32
#define mccompcurtype  Pore_p_group
#define mccompcurindex 86
#define nLeft mccPoreP32_nLeft
#define nRight mccPoreP32_nRight
#define nExit mccPoreP32_nExit
#define nTop mccPoreP32_nTop
#define nBottom mccPoreP32_nBottom
#define wLeft mccPoreP32_wLeft
#define wRight mccPoreP32_wRight
#define wExit mccPoreP32_wExit
#define wall mccPoreP32_wall
#define zentry mccPoreP32_zentry
#define reflec_top_table mccPoreP32_reflec_top_table
#define reflec_bottom_table mccPoreP32_reflec_bottom_table
#define reflec_side_table mccPoreP32_reflec_side_table
#define ref_prms mccPoreP32_ref_prms
#define radius_p mccPoreP32_radius_p
#define radius_m mccPoreP32_radius_m
#define Z0 mccPoreP32_Z0
#define xwidth mccPoreP32_xwidth
#define yheight mccPoreP32_yheight
#define chamferwidth mccPoreP32_chamferwidth
#define mirror_reflec mccPoreP32_mirror_reflec
#define bottom_reflec mccPoreP32_bottom_reflec
#define side_reflec mccPoreP32_side_reflec
#define R_d mccPoreP32_R_d
#define absorb_sides mccPoreP32_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 29405 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP33. */
  SIG_MESSAGE("PoreP33 (Init)");
#define mccompcurname  PoreP33
#define mccompcurtype  Pore_p_group
#define mccompcurindex 87
#define nLeft mccPoreP33_nLeft
#define nRight mccPoreP33_nRight
#define nExit mccPoreP33_nExit
#define nTop mccPoreP33_nTop
#define nBottom mccPoreP33_nBottom
#define wLeft mccPoreP33_wLeft
#define wRight mccPoreP33_wRight
#define wExit mccPoreP33_wExit
#define wall mccPoreP33_wall
#define zentry mccPoreP33_zentry
#define reflec_top_table mccPoreP33_reflec_top_table
#define reflec_bottom_table mccPoreP33_reflec_bottom_table
#define reflec_side_table mccPoreP33_reflec_side_table
#define ref_prms mccPoreP33_ref_prms
#define radius_p mccPoreP33_radius_p
#define radius_m mccPoreP33_radius_m
#define Z0 mccPoreP33_Z0
#define xwidth mccPoreP33_xwidth
#define yheight mccPoreP33_yheight
#define chamferwidth mccPoreP33_chamferwidth
#define mirror_reflec mccPoreP33_mirror_reflec
#define bottom_reflec mccPoreP33_bottom_reflec
#define side_reflec mccPoreP33_side_reflec
#define R_d mccPoreP33_R_d
#define absorb_sides mccPoreP33_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 29555 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP34. */
  SIG_MESSAGE("PoreP34 (Init)");
#define mccompcurname  PoreP34
#define mccompcurtype  Pore_p_group
#define mccompcurindex 88
#define nLeft mccPoreP34_nLeft
#define nRight mccPoreP34_nRight
#define nExit mccPoreP34_nExit
#define nTop mccPoreP34_nTop
#define nBottom mccPoreP34_nBottom
#define wLeft mccPoreP34_wLeft
#define wRight mccPoreP34_wRight
#define wExit mccPoreP34_wExit
#define wall mccPoreP34_wall
#define zentry mccPoreP34_zentry
#define reflec_top_table mccPoreP34_reflec_top_table
#define reflec_bottom_table mccPoreP34_reflec_bottom_table
#define reflec_side_table mccPoreP34_reflec_side_table
#define ref_prms mccPoreP34_ref_prms
#define radius_p mccPoreP34_radius_p
#define radius_m mccPoreP34_radius_m
#define Z0 mccPoreP34_Z0
#define xwidth mccPoreP34_xwidth
#define yheight mccPoreP34_yheight
#define chamferwidth mccPoreP34_chamferwidth
#define mirror_reflec mccPoreP34_mirror_reflec
#define bottom_reflec mccPoreP34_bottom_reflec
#define side_reflec mccPoreP34_side_reflec
#define R_d mccPoreP34_R_d
#define absorb_sides mccPoreP34_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 29705 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP35. */
  SIG_MESSAGE("PoreP35 (Init)");
#define mccompcurname  PoreP35
#define mccompcurtype  Pore_p_group
#define mccompcurindex 89
#define nLeft mccPoreP35_nLeft
#define nRight mccPoreP35_nRight
#define nExit mccPoreP35_nExit
#define nTop mccPoreP35_nTop
#define nBottom mccPoreP35_nBottom
#define wLeft mccPoreP35_wLeft
#define wRight mccPoreP35_wRight
#define wExit mccPoreP35_wExit
#define wall mccPoreP35_wall
#define zentry mccPoreP35_zentry
#define reflec_top_table mccPoreP35_reflec_top_table
#define reflec_bottom_table mccPoreP35_reflec_bottom_table
#define reflec_side_table mccPoreP35_reflec_side_table
#define ref_prms mccPoreP35_ref_prms
#define radius_p mccPoreP35_radius_p
#define radius_m mccPoreP35_radius_m
#define Z0 mccPoreP35_Z0
#define xwidth mccPoreP35_xwidth
#define yheight mccPoreP35_yheight
#define chamferwidth mccPoreP35_chamferwidth
#define mirror_reflec mccPoreP35_mirror_reflec
#define bottom_reflec mccPoreP35_bottom_reflec
#define side_reflec mccPoreP35_side_reflec
#define R_d mccPoreP35_R_d
#define absorb_sides mccPoreP35_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 29855 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP36. */
  SIG_MESSAGE("PoreP36 (Init)");
#define mccompcurname  PoreP36
#define mccompcurtype  Pore_p_group
#define mccompcurindex 90
#define nLeft mccPoreP36_nLeft
#define nRight mccPoreP36_nRight
#define nExit mccPoreP36_nExit
#define nTop mccPoreP36_nTop
#define nBottom mccPoreP36_nBottom
#define wLeft mccPoreP36_wLeft
#define wRight mccPoreP36_wRight
#define wExit mccPoreP36_wExit
#define wall mccPoreP36_wall
#define zentry mccPoreP36_zentry
#define reflec_top_table mccPoreP36_reflec_top_table
#define reflec_bottom_table mccPoreP36_reflec_bottom_table
#define reflec_side_table mccPoreP36_reflec_side_table
#define ref_prms mccPoreP36_ref_prms
#define radius_p mccPoreP36_radius_p
#define radius_m mccPoreP36_radius_m
#define Z0 mccPoreP36_Z0
#define xwidth mccPoreP36_xwidth
#define yheight mccPoreP36_yheight
#define chamferwidth mccPoreP36_chamferwidth
#define mirror_reflec mccPoreP36_mirror_reflec
#define bottom_reflec mccPoreP36_bottom_reflec
#define side_reflec mccPoreP36_side_reflec
#define R_d mccPoreP36_R_d
#define absorb_sides mccPoreP36_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 30005 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP37. */
  SIG_MESSAGE("PoreP37 (Init)");
#define mccompcurname  PoreP37
#define mccompcurtype  Pore_p_group
#define mccompcurindex 91
#define nLeft mccPoreP37_nLeft
#define nRight mccPoreP37_nRight
#define nExit mccPoreP37_nExit
#define nTop mccPoreP37_nTop
#define nBottom mccPoreP37_nBottom
#define wLeft mccPoreP37_wLeft
#define wRight mccPoreP37_wRight
#define wExit mccPoreP37_wExit
#define wall mccPoreP37_wall
#define zentry mccPoreP37_zentry
#define reflec_top_table mccPoreP37_reflec_top_table
#define reflec_bottom_table mccPoreP37_reflec_bottom_table
#define reflec_side_table mccPoreP37_reflec_side_table
#define ref_prms mccPoreP37_ref_prms
#define radius_p mccPoreP37_radius_p
#define radius_m mccPoreP37_radius_m
#define Z0 mccPoreP37_Z0
#define xwidth mccPoreP37_xwidth
#define yheight mccPoreP37_yheight
#define chamferwidth mccPoreP37_chamferwidth
#define mirror_reflec mccPoreP37_mirror_reflec
#define bottom_reflec mccPoreP37_bottom_reflec
#define side_reflec mccPoreP37_side_reflec
#define R_d mccPoreP37_R_d
#define absorb_sides mccPoreP37_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 30155 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP38. */
  SIG_MESSAGE("PoreP38 (Init)");
#define mccompcurname  PoreP38
#define mccompcurtype  Pore_p_group
#define mccompcurindex 92
#define nLeft mccPoreP38_nLeft
#define nRight mccPoreP38_nRight
#define nExit mccPoreP38_nExit
#define nTop mccPoreP38_nTop
#define nBottom mccPoreP38_nBottom
#define wLeft mccPoreP38_wLeft
#define wRight mccPoreP38_wRight
#define wExit mccPoreP38_wExit
#define wall mccPoreP38_wall
#define zentry mccPoreP38_zentry
#define reflec_top_table mccPoreP38_reflec_top_table
#define reflec_bottom_table mccPoreP38_reflec_bottom_table
#define reflec_side_table mccPoreP38_reflec_side_table
#define ref_prms mccPoreP38_ref_prms
#define radius_p mccPoreP38_radius_p
#define radius_m mccPoreP38_radius_m
#define Z0 mccPoreP38_Z0
#define xwidth mccPoreP38_xwidth
#define yheight mccPoreP38_yheight
#define chamferwidth mccPoreP38_chamferwidth
#define mirror_reflec mccPoreP38_mirror_reflec
#define bottom_reflec mccPoreP38_bottom_reflec
#define side_reflec mccPoreP38_side_reflec
#define R_d mccPoreP38_R_d
#define absorb_sides mccPoreP38_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 30305 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP39. */
  SIG_MESSAGE("PoreP39 (Init)");
#define mccompcurname  PoreP39
#define mccompcurtype  Pore_p_group
#define mccompcurindex 93
#define nLeft mccPoreP39_nLeft
#define nRight mccPoreP39_nRight
#define nExit mccPoreP39_nExit
#define nTop mccPoreP39_nTop
#define nBottom mccPoreP39_nBottom
#define wLeft mccPoreP39_wLeft
#define wRight mccPoreP39_wRight
#define wExit mccPoreP39_wExit
#define wall mccPoreP39_wall
#define zentry mccPoreP39_zentry
#define reflec_top_table mccPoreP39_reflec_top_table
#define reflec_bottom_table mccPoreP39_reflec_bottom_table
#define reflec_side_table mccPoreP39_reflec_side_table
#define ref_prms mccPoreP39_ref_prms
#define radius_p mccPoreP39_radius_p
#define radius_m mccPoreP39_radius_m
#define Z0 mccPoreP39_Z0
#define xwidth mccPoreP39_xwidth
#define yheight mccPoreP39_yheight
#define chamferwidth mccPoreP39_chamferwidth
#define mirror_reflec mccPoreP39_mirror_reflec
#define bottom_reflec mccPoreP39_bottom_reflec
#define side_reflec mccPoreP39_side_reflec
#define R_d mccPoreP39_R_d
#define absorb_sides mccPoreP39_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 30455 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP40. */
  SIG_MESSAGE("PoreP40 (Init)");
#define mccompcurname  PoreP40
#define mccompcurtype  Pore_p_group
#define mccompcurindex 94
#define nLeft mccPoreP40_nLeft
#define nRight mccPoreP40_nRight
#define nExit mccPoreP40_nExit
#define nTop mccPoreP40_nTop
#define nBottom mccPoreP40_nBottom
#define wLeft mccPoreP40_wLeft
#define wRight mccPoreP40_wRight
#define wExit mccPoreP40_wExit
#define wall mccPoreP40_wall
#define zentry mccPoreP40_zentry
#define reflec_top_table mccPoreP40_reflec_top_table
#define reflec_bottom_table mccPoreP40_reflec_bottom_table
#define reflec_side_table mccPoreP40_reflec_side_table
#define ref_prms mccPoreP40_ref_prms
#define radius_p mccPoreP40_radius_p
#define radius_m mccPoreP40_radius_m
#define Z0 mccPoreP40_Z0
#define xwidth mccPoreP40_xwidth
#define yheight mccPoreP40_yheight
#define chamferwidth mccPoreP40_chamferwidth
#define mirror_reflec mccPoreP40_mirror_reflec
#define bottom_reflec mccPoreP40_bottom_reflec
#define side_reflec mccPoreP40_side_reflec
#define R_d mccPoreP40_R_d
#define absorb_sides mccPoreP40_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 30605 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP41. */
  SIG_MESSAGE("PoreP41 (Init)");
#define mccompcurname  PoreP41
#define mccompcurtype  Pore_p_group
#define mccompcurindex 95
#define nLeft mccPoreP41_nLeft
#define nRight mccPoreP41_nRight
#define nExit mccPoreP41_nExit
#define nTop mccPoreP41_nTop
#define nBottom mccPoreP41_nBottom
#define wLeft mccPoreP41_wLeft
#define wRight mccPoreP41_wRight
#define wExit mccPoreP41_wExit
#define wall mccPoreP41_wall
#define zentry mccPoreP41_zentry
#define reflec_top_table mccPoreP41_reflec_top_table
#define reflec_bottom_table mccPoreP41_reflec_bottom_table
#define reflec_side_table mccPoreP41_reflec_side_table
#define ref_prms mccPoreP41_ref_prms
#define radius_p mccPoreP41_radius_p
#define radius_m mccPoreP41_radius_m
#define Z0 mccPoreP41_Z0
#define xwidth mccPoreP41_xwidth
#define yheight mccPoreP41_yheight
#define chamferwidth mccPoreP41_chamferwidth
#define mirror_reflec mccPoreP41_mirror_reflec
#define bottom_reflec mccPoreP41_bottom_reflec
#define side_reflec mccPoreP41_side_reflec
#define R_d mccPoreP41_R_d
#define absorb_sides mccPoreP41_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 30755 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP42. */
  SIG_MESSAGE("PoreP42 (Init)");
#define mccompcurname  PoreP42
#define mccompcurtype  Pore_p_group
#define mccompcurindex 96
#define nLeft mccPoreP42_nLeft
#define nRight mccPoreP42_nRight
#define nExit mccPoreP42_nExit
#define nTop mccPoreP42_nTop
#define nBottom mccPoreP42_nBottom
#define wLeft mccPoreP42_wLeft
#define wRight mccPoreP42_wRight
#define wExit mccPoreP42_wExit
#define wall mccPoreP42_wall
#define zentry mccPoreP42_zentry
#define reflec_top_table mccPoreP42_reflec_top_table
#define reflec_bottom_table mccPoreP42_reflec_bottom_table
#define reflec_side_table mccPoreP42_reflec_side_table
#define ref_prms mccPoreP42_ref_prms
#define radius_p mccPoreP42_radius_p
#define radius_m mccPoreP42_radius_m
#define Z0 mccPoreP42_Z0
#define xwidth mccPoreP42_xwidth
#define yheight mccPoreP42_yheight
#define chamferwidth mccPoreP42_chamferwidth
#define mirror_reflec mccPoreP42_mirror_reflec
#define bottom_reflec mccPoreP42_bottom_reflec
#define side_reflec mccPoreP42_side_reflec
#define R_d mccPoreP42_R_d
#define absorb_sides mccPoreP42_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 30905 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP43. */
  SIG_MESSAGE("PoreP43 (Init)");
#define mccompcurname  PoreP43
#define mccompcurtype  Pore_p_group
#define mccompcurindex 97
#define nLeft mccPoreP43_nLeft
#define nRight mccPoreP43_nRight
#define nExit mccPoreP43_nExit
#define nTop mccPoreP43_nTop
#define nBottom mccPoreP43_nBottom
#define wLeft mccPoreP43_wLeft
#define wRight mccPoreP43_wRight
#define wExit mccPoreP43_wExit
#define wall mccPoreP43_wall
#define zentry mccPoreP43_zentry
#define reflec_top_table mccPoreP43_reflec_top_table
#define reflec_bottom_table mccPoreP43_reflec_bottom_table
#define reflec_side_table mccPoreP43_reflec_side_table
#define ref_prms mccPoreP43_ref_prms
#define radius_p mccPoreP43_radius_p
#define radius_m mccPoreP43_radius_m
#define Z0 mccPoreP43_Z0
#define xwidth mccPoreP43_xwidth
#define yheight mccPoreP43_yheight
#define chamferwidth mccPoreP43_chamferwidth
#define mirror_reflec mccPoreP43_mirror_reflec
#define bottom_reflec mccPoreP43_bottom_reflec
#define side_reflec mccPoreP43_side_reflec
#define R_d mccPoreP43_R_d
#define absorb_sides mccPoreP43_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 31055 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP44. */
  SIG_MESSAGE("PoreP44 (Init)");
#define mccompcurname  PoreP44
#define mccompcurtype  Pore_p_group
#define mccompcurindex 98
#define nLeft mccPoreP44_nLeft
#define nRight mccPoreP44_nRight
#define nExit mccPoreP44_nExit
#define nTop mccPoreP44_nTop
#define nBottom mccPoreP44_nBottom
#define wLeft mccPoreP44_wLeft
#define wRight mccPoreP44_wRight
#define wExit mccPoreP44_wExit
#define wall mccPoreP44_wall
#define zentry mccPoreP44_zentry
#define reflec_top_table mccPoreP44_reflec_top_table
#define reflec_bottom_table mccPoreP44_reflec_bottom_table
#define reflec_side_table mccPoreP44_reflec_side_table
#define ref_prms mccPoreP44_ref_prms
#define radius_p mccPoreP44_radius_p
#define radius_m mccPoreP44_radius_m
#define Z0 mccPoreP44_Z0
#define xwidth mccPoreP44_xwidth
#define yheight mccPoreP44_yheight
#define chamferwidth mccPoreP44_chamferwidth
#define mirror_reflec mccPoreP44_mirror_reflec
#define bottom_reflec mccPoreP44_bottom_reflec
#define side_reflec mccPoreP44_side_reflec
#define R_d mccPoreP44_R_d
#define absorb_sides mccPoreP44_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 31205 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP45. */
  SIG_MESSAGE("PoreP45 (Init)");
#define mccompcurname  PoreP45
#define mccompcurtype  Pore_p_group
#define mccompcurindex 99
#define nLeft mccPoreP45_nLeft
#define nRight mccPoreP45_nRight
#define nExit mccPoreP45_nExit
#define nTop mccPoreP45_nTop
#define nBottom mccPoreP45_nBottom
#define wLeft mccPoreP45_wLeft
#define wRight mccPoreP45_wRight
#define wExit mccPoreP45_wExit
#define wall mccPoreP45_wall
#define zentry mccPoreP45_zentry
#define reflec_top_table mccPoreP45_reflec_top_table
#define reflec_bottom_table mccPoreP45_reflec_bottom_table
#define reflec_side_table mccPoreP45_reflec_side_table
#define ref_prms mccPoreP45_ref_prms
#define radius_p mccPoreP45_radius_p
#define radius_m mccPoreP45_radius_m
#define Z0 mccPoreP45_Z0
#define xwidth mccPoreP45_xwidth
#define yheight mccPoreP45_yheight
#define chamferwidth mccPoreP45_chamferwidth
#define mirror_reflec mccPoreP45_mirror_reflec
#define bottom_reflec mccPoreP45_bottom_reflec
#define side_reflec mccPoreP45_side_reflec
#define R_d mccPoreP45_R_d
#define absorb_sides mccPoreP45_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 31355 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP46. */
  SIG_MESSAGE("PoreP46 (Init)");
#define mccompcurname  PoreP46
#define mccompcurtype  Pore_p_group
#define mccompcurindex 100
#define nLeft mccPoreP46_nLeft
#define nRight mccPoreP46_nRight
#define nExit mccPoreP46_nExit
#define nTop mccPoreP46_nTop
#define nBottom mccPoreP46_nBottom
#define wLeft mccPoreP46_wLeft
#define wRight mccPoreP46_wRight
#define wExit mccPoreP46_wExit
#define wall mccPoreP46_wall
#define zentry mccPoreP46_zentry
#define reflec_top_table mccPoreP46_reflec_top_table
#define reflec_bottom_table mccPoreP46_reflec_bottom_table
#define reflec_side_table mccPoreP46_reflec_side_table
#define ref_prms mccPoreP46_ref_prms
#define radius_p mccPoreP46_radius_p
#define radius_m mccPoreP46_radius_m
#define Z0 mccPoreP46_Z0
#define xwidth mccPoreP46_xwidth
#define yheight mccPoreP46_yheight
#define chamferwidth mccPoreP46_chamferwidth
#define mirror_reflec mccPoreP46_mirror_reflec
#define bottom_reflec mccPoreP46_bottom_reflec
#define side_reflec mccPoreP46_side_reflec
#define R_d mccPoreP46_R_d
#define absorb_sides mccPoreP46_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 31505 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP47. */
  SIG_MESSAGE("PoreP47 (Init)");
#define mccompcurname  PoreP47
#define mccompcurtype  Pore_p_group
#define mccompcurindex 101
#define nLeft mccPoreP47_nLeft
#define nRight mccPoreP47_nRight
#define nExit mccPoreP47_nExit
#define nTop mccPoreP47_nTop
#define nBottom mccPoreP47_nBottom
#define wLeft mccPoreP47_wLeft
#define wRight mccPoreP47_wRight
#define wExit mccPoreP47_wExit
#define wall mccPoreP47_wall
#define zentry mccPoreP47_zentry
#define reflec_top_table mccPoreP47_reflec_top_table
#define reflec_bottom_table mccPoreP47_reflec_bottom_table
#define reflec_side_table mccPoreP47_reflec_side_table
#define ref_prms mccPoreP47_ref_prms
#define radius_p mccPoreP47_radius_p
#define radius_m mccPoreP47_radius_m
#define Z0 mccPoreP47_Z0
#define xwidth mccPoreP47_xwidth
#define yheight mccPoreP47_yheight
#define chamferwidth mccPoreP47_chamferwidth
#define mirror_reflec mccPoreP47_mirror_reflec
#define bottom_reflec mccPoreP47_bottom_reflec
#define side_reflec mccPoreP47_side_reflec
#define R_d mccPoreP47_R_d
#define absorb_sides mccPoreP47_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 31655 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreP48. */
  SIG_MESSAGE("PoreP48 (Init)");
#define mccompcurname  PoreP48
#define mccompcurtype  Pore_p_group
#define mccompcurindex 102
#define nLeft mccPoreP48_nLeft
#define nRight mccPoreP48_nRight
#define nExit mccPoreP48_nExit
#define nTop mccPoreP48_nTop
#define nBottom mccPoreP48_nBottom
#define wLeft mccPoreP48_wLeft
#define wRight mccPoreP48_wRight
#define wExit mccPoreP48_wExit
#define wall mccPoreP48_wall
#define zentry mccPoreP48_zentry
#define reflec_top_table mccPoreP48_reflec_top_table
#define reflec_bottom_table mccPoreP48_reflec_bottom_table
#define reflec_side_table mccPoreP48_reflec_side_table
#define ref_prms mccPoreP48_ref_prms
#define radius_p mccPoreP48_radius_p
#define radius_m mccPoreP48_radius_m
#define Z0 mccPoreP48_Z0
#define xwidth mccPoreP48_xwidth
#define yheight mccPoreP48_yheight
#define chamferwidth mccPoreP48_chamferwidth
#define mirror_reflec mccPoreP48_mirror_reflec
#define bottom_reflec mccPoreP48_bottom_reflec
#define side_reflec mccPoreP48_side_reflec
#define R_d mccPoreP48_R_d
#define absorb_sides mccPoreP48_absorb_sides
#line 133 "Pore_p_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                //printf("%g %g %d %d\n",(ref_prms[i].e_max-ref_prms[i].e_min), (tp->rows-1)*ref_prms[i].e_step, (int)(ref_prms[i].e_max-ref_prms[i].e_min), (int)((tp->rows-1)*ref_prms[i].e_step));
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0,Z;
    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*solve to get the z-coordinate of the entry plane, assuming radius_1 to be bigger*/
    Z=(pow(radius_p,2.0) - pow(P,2.0)- C0 ) /(2*P);
    zentry=Z0-Z;
    //intersect_wolterI=pore_p_intersect_paraboloid;

    /*side wall, entry, and exit planes*/
    //angle between the y-z plane and the left plane
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=-radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=sin(thetawx);
    nRight[2]=0;
    wRight[0]=radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;

    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=-1;
    wExit[0]=wExit[1]=0;wExit[2]=zentry;


    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=wExit[2]=0;

}
#line 31805 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_m
#undef radius_p
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH0. */
  SIG_MESSAGE("PoreH0 (Init)");
#define mccompcurname  PoreH0
#define mccompcurtype  Pore_h_group
#define mccompcurindex 103
#define nLeft mccPoreH0_nLeft
#define nRight mccPoreH0_nRight
#define nExit mccPoreH0_nExit
#define wLeft mccPoreH0_wLeft
#define wRight mccPoreH0_wRight
#define wExit mccPoreH0_wExit
#define wall mccPoreH0_wall
#define nTop mccPoreH0_nTop
#define nBottom mccPoreH0_nBottom
#define zexit mccPoreH0_zexit
#define zentry mccPoreH0_zentry
#define intersect_wolterI mccPoreH0_intersect_wolterI
#define reflec_side_table mccPoreH0_reflec_side_table
#define reflec_top_table mccPoreH0_reflec_top_table
#define reflec_bottom_table mccPoreH0_reflec_bottom_table
#define ref_prms mccPoreH0_ref_prms
#define radius_m mccPoreH0_radius_m
#define radius_h mccPoreH0_radius_h
#define Z0 mccPoreH0_Z0
#define xwidth mccPoreH0_xwidth
#define yheight mccPoreH0_yheight
#define chamferwidth mccPoreH0_chamferwidth
#define mirror_reflec mccPoreH0_mirror_reflec
#define bottom_reflec mccPoreH0_bottom_reflec
#define side_reflec mccPoreH0_side_reflec
#define R_d mccPoreH0_R_d
#define absorb_sides mccPoreH0_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 31968 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH1. */
  SIG_MESSAGE("PoreH1 (Init)");
#define mccompcurname  PoreH1
#define mccompcurtype  Pore_h_group
#define mccompcurindex 104
#define nLeft mccPoreH1_nLeft
#define nRight mccPoreH1_nRight
#define nExit mccPoreH1_nExit
#define wLeft mccPoreH1_wLeft
#define wRight mccPoreH1_wRight
#define wExit mccPoreH1_wExit
#define wall mccPoreH1_wall
#define nTop mccPoreH1_nTop
#define nBottom mccPoreH1_nBottom
#define zexit mccPoreH1_zexit
#define zentry mccPoreH1_zentry
#define intersect_wolterI mccPoreH1_intersect_wolterI
#define reflec_side_table mccPoreH1_reflec_side_table
#define reflec_top_table mccPoreH1_reflec_top_table
#define reflec_bottom_table mccPoreH1_reflec_bottom_table
#define ref_prms mccPoreH1_ref_prms
#define radius_m mccPoreH1_radius_m
#define radius_h mccPoreH1_radius_h
#define Z0 mccPoreH1_Z0
#define xwidth mccPoreH1_xwidth
#define yheight mccPoreH1_yheight
#define chamferwidth mccPoreH1_chamferwidth
#define mirror_reflec mccPoreH1_mirror_reflec
#define bottom_reflec mccPoreH1_bottom_reflec
#define side_reflec mccPoreH1_side_reflec
#define R_d mccPoreH1_R_d
#define absorb_sides mccPoreH1_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 32133 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH2. */
  SIG_MESSAGE("PoreH2 (Init)");
#define mccompcurname  PoreH2
#define mccompcurtype  Pore_h_group
#define mccompcurindex 105
#define nLeft mccPoreH2_nLeft
#define nRight mccPoreH2_nRight
#define nExit mccPoreH2_nExit
#define wLeft mccPoreH2_wLeft
#define wRight mccPoreH2_wRight
#define wExit mccPoreH2_wExit
#define wall mccPoreH2_wall
#define nTop mccPoreH2_nTop
#define nBottom mccPoreH2_nBottom
#define zexit mccPoreH2_zexit
#define zentry mccPoreH2_zentry
#define intersect_wolterI mccPoreH2_intersect_wolterI
#define reflec_side_table mccPoreH2_reflec_side_table
#define reflec_top_table mccPoreH2_reflec_top_table
#define reflec_bottom_table mccPoreH2_reflec_bottom_table
#define ref_prms mccPoreH2_ref_prms
#define radius_m mccPoreH2_radius_m
#define radius_h mccPoreH2_radius_h
#define Z0 mccPoreH2_Z0
#define xwidth mccPoreH2_xwidth
#define yheight mccPoreH2_yheight
#define chamferwidth mccPoreH2_chamferwidth
#define mirror_reflec mccPoreH2_mirror_reflec
#define bottom_reflec mccPoreH2_bottom_reflec
#define side_reflec mccPoreH2_side_reflec
#define R_d mccPoreH2_R_d
#define absorb_sides mccPoreH2_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 32298 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH3. */
  SIG_MESSAGE("PoreH3 (Init)");
#define mccompcurname  PoreH3
#define mccompcurtype  Pore_h_group
#define mccompcurindex 106
#define nLeft mccPoreH3_nLeft
#define nRight mccPoreH3_nRight
#define nExit mccPoreH3_nExit
#define wLeft mccPoreH3_wLeft
#define wRight mccPoreH3_wRight
#define wExit mccPoreH3_wExit
#define wall mccPoreH3_wall
#define nTop mccPoreH3_nTop
#define nBottom mccPoreH3_nBottom
#define zexit mccPoreH3_zexit
#define zentry mccPoreH3_zentry
#define intersect_wolterI mccPoreH3_intersect_wolterI
#define reflec_side_table mccPoreH3_reflec_side_table
#define reflec_top_table mccPoreH3_reflec_top_table
#define reflec_bottom_table mccPoreH3_reflec_bottom_table
#define ref_prms mccPoreH3_ref_prms
#define radius_m mccPoreH3_radius_m
#define radius_h mccPoreH3_radius_h
#define Z0 mccPoreH3_Z0
#define xwidth mccPoreH3_xwidth
#define yheight mccPoreH3_yheight
#define chamferwidth mccPoreH3_chamferwidth
#define mirror_reflec mccPoreH3_mirror_reflec
#define bottom_reflec mccPoreH3_bottom_reflec
#define side_reflec mccPoreH3_side_reflec
#define R_d mccPoreH3_R_d
#define absorb_sides mccPoreH3_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 32463 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH4. */
  SIG_MESSAGE("PoreH4 (Init)");
#define mccompcurname  PoreH4
#define mccompcurtype  Pore_h_group
#define mccompcurindex 107
#define nLeft mccPoreH4_nLeft
#define nRight mccPoreH4_nRight
#define nExit mccPoreH4_nExit
#define wLeft mccPoreH4_wLeft
#define wRight mccPoreH4_wRight
#define wExit mccPoreH4_wExit
#define wall mccPoreH4_wall
#define nTop mccPoreH4_nTop
#define nBottom mccPoreH4_nBottom
#define zexit mccPoreH4_zexit
#define zentry mccPoreH4_zentry
#define intersect_wolterI mccPoreH4_intersect_wolterI
#define reflec_side_table mccPoreH4_reflec_side_table
#define reflec_top_table mccPoreH4_reflec_top_table
#define reflec_bottom_table mccPoreH4_reflec_bottom_table
#define ref_prms mccPoreH4_ref_prms
#define radius_m mccPoreH4_radius_m
#define radius_h mccPoreH4_radius_h
#define Z0 mccPoreH4_Z0
#define xwidth mccPoreH4_xwidth
#define yheight mccPoreH4_yheight
#define chamferwidth mccPoreH4_chamferwidth
#define mirror_reflec mccPoreH4_mirror_reflec
#define bottom_reflec mccPoreH4_bottom_reflec
#define side_reflec mccPoreH4_side_reflec
#define R_d mccPoreH4_R_d
#define absorb_sides mccPoreH4_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 32628 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH5. */
  SIG_MESSAGE("PoreH5 (Init)");
#define mccompcurname  PoreH5
#define mccompcurtype  Pore_h_group
#define mccompcurindex 108
#define nLeft mccPoreH5_nLeft
#define nRight mccPoreH5_nRight
#define nExit mccPoreH5_nExit
#define wLeft mccPoreH5_wLeft
#define wRight mccPoreH5_wRight
#define wExit mccPoreH5_wExit
#define wall mccPoreH5_wall
#define nTop mccPoreH5_nTop
#define nBottom mccPoreH5_nBottom
#define zexit mccPoreH5_zexit
#define zentry mccPoreH5_zentry
#define intersect_wolterI mccPoreH5_intersect_wolterI
#define reflec_side_table mccPoreH5_reflec_side_table
#define reflec_top_table mccPoreH5_reflec_top_table
#define reflec_bottom_table mccPoreH5_reflec_bottom_table
#define ref_prms mccPoreH5_ref_prms
#define radius_m mccPoreH5_radius_m
#define radius_h mccPoreH5_radius_h
#define Z0 mccPoreH5_Z0
#define xwidth mccPoreH5_xwidth
#define yheight mccPoreH5_yheight
#define chamferwidth mccPoreH5_chamferwidth
#define mirror_reflec mccPoreH5_mirror_reflec
#define bottom_reflec mccPoreH5_bottom_reflec
#define side_reflec mccPoreH5_side_reflec
#define R_d mccPoreH5_R_d
#define absorb_sides mccPoreH5_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 32793 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH6. */
  SIG_MESSAGE("PoreH6 (Init)");
#define mccompcurname  PoreH6
#define mccompcurtype  Pore_h_group
#define mccompcurindex 109
#define nLeft mccPoreH6_nLeft
#define nRight mccPoreH6_nRight
#define nExit mccPoreH6_nExit
#define wLeft mccPoreH6_wLeft
#define wRight mccPoreH6_wRight
#define wExit mccPoreH6_wExit
#define wall mccPoreH6_wall
#define nTop mccPoreH6_nTop
#define nBottom mccPoreH6_nBottom
#define zexit mccPoreH6_zexit
#define zentry mccPoreH6_zentry
#define intersect_wolterI mccPoreH6_intersect_wolterI
#define reflec_side_table mccPoreH6_reflec_side_table
#define reflec_top_table mccPoreH6_reflec_top_table
#define reflec_bottom_table mccPoreH6_reflec_bottom_table
#define ref_prms mccPoreH6_ref_prms
#define radius_m mccPoreH6_radius_m
#define radius_h mccPoreH6_radius_h
#define Z0 mccPoreH6_Z0
#define xwidth mccPoreH6_xwidth
#define yheight mccPoreH6_yheight
#define chamferwidth mccPoreH6_chamferwidth
#define mirror_reflec mccPoreH6_mirror_reflec
#define bottom_reflec mccPoreH6_bottom_reflec
#define side_reflec mccPoreH6_side_reflec
#define R_d mccPoreH6_R_d
#define absorb_sides mccPoreH6_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 32958 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH7. */
  SIG_MESSAGE("PoreH7 (Init)");
#define mccompcurname  PoreH7
#define mccompcurtype  Pore_h_group
#define mccompcurindex 110
#define nLeft mccPoreH7_nLeft
#define nRight mccPoreH7_nRight
#define nExit mccPoreH7_nExit
#define wLeft mccPoreH7_wLeft
#define wRight mccPoreH7_wRight
#define wExit mccPoreH7_wExit
#define wall mccPoreH7_wall
#define nTop mccPoreH7_nTop
#define nBottom mccPoreH7_nBottom
#define zexit mccPoreH7_zexit
#define zentry mccPoreH7_zentry
#define intersect_wolterI mccPoreH7_intersect_wolterI
#define reflec_side_table mccPoreH7_reflec_side_table
#define reflec_top_table mccPoreH7_reflec_top_table
#define reflec_bottom_table mccPoreH7_reflec_bottom_table
#define ref_prms mccPoreH7_ref_prms
#define radius_m mccPoreH7_radius_m
#define radius_h mccPoreH7_radius_h
#define Z0 mccPoreH7_Z0
#define xwidth mccPoreH7_xwidth
#define yheight mccPoreH7_yheight
#define chamferwidth mccPoreH7_chamferwidth
#define mirror_reflec mccPoreH7_mirror_reflec
#define bottom_reflec mccPoreH7_bottom_reflec
#define side_reflec mccPoreH7_side_reflec
#define R_d mccPoreH7_R_d
#define absorb_sides mccPoreH7_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 33123 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH8. */
  SIG_MESSAGE("PoreH8 (Init)");
#define mccompcurname  PoreH8
#define mccompcurtype  Pore_h_group
#define mccompcurindex 111
#define nLeft mccPoreH8_nLeft
#define nRight mccPoreH8_nRight
#define nExit mccPoreH8_nExit
#define wLeft mccPoreH8_wLeft
#define wRight mccPoreH8_wRight
#define wExit mccPoreH8_wExit
#define wall mccPoreH8_wall
#define nTop mccPoreH8_nTop
#define nBottom mccPoreH8_nBottom
#define zexit mccPoreH8_zexit
#define zentry mccPoreH8_zentry
#define intersect_wolterI mccPoreH8_intersect_wolterI
#define reflec_side_table mccPoreH8_reflec_side_table
#define reflec_top_table mccPoreH8_reflec_top_table
#define reflec_bottom_table mccPoreH8_reflec_bottom_table
#define ref_prms mccPoreH8_ref_prms
#define radius_m mccPoreH8_radius_m
#define radius_h mccPoreH8_radius_h
#define Z0 mccPoreH8_Z0
#define xwidth mccPoreH8_xwidth
#define yheight mccPoreH8_yheight
#define chamferwidth mccPoreH8_chamferwidth
#define mirror_reflec mccPoreH8_mirror_reflec
#define bottom_reflec mccPoreH8_bottom_reflec
#define side_reflec mccPoreH8_side_reflec
#define R_d mccPoreH8_R_d
#define absorb_sides mccPoreH8_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 33288 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH9. */
  SIG_MESSAGE("PoreH9 (Init)");
#define mccompcurname  PoreH9
#define mccompcurtype  Pore_h_group
#define mccompcurindex 112
#define nLeft mccPoreH9_nLeft
#define nRight mccPoreH9_nRight
#define nExit mccPoreH9_nExit
#define wLeft mccPoreH9_wLeft
#define wRight mccPoreH9_wRight
#define wExit mccPoreH9_wExit
#define wall mccPoreH9_wall
#define nTop mccPoreH9_nTop
#define nBottom mccPoreH9_nBottom
#define zexit mccPoreH9_zexit
#define zentry mccPoreH9_zentry
#define intersect_wolterI mccPoreH9_intersect_wolterI
#define reflec_side_table mccPoreH9_reflec_side_table
#define reflec_top_table mccPoreH9_reflec_top_table
#define reflec_bottom_table mccPoreH9_reflec_bottom_table
#define ref_prms mccPoreH9_ref_prms
#define radius_m mccPoreH9_radius_m
#define radius_h mccPoreH9_radius_h
#define Z0 mccPoreH9_Z0
#define xwidth mccPoreH9_xwidth
#define yheight mccPoreH9_yheight
#define chamferwidth mccPoreH9_chamferwidth
#define mirror_reflec mccPoreH9_mirror_reflec
#define bottom_reflec mccPoreH9_bottom_reflec
#define side_reflec mccPoreH9_side_reflec
#define R_d mccPoreH9_R_d
#define absorb_sides mccPoreH9_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 33453 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH10. */
  SIG_MESSAGE("PoreH10 (Init)");
#define mccompcurname  PoreH10
#define mccompcurtype  Pore_h_group
#define mccompcurindex 113
#define nLeft mccPoreH10_nLeft
#define nRight mccPoreH10_nRight
#define nExit mccPoreH10_nExit
#define wLeft mccPoreH10_wLeft
#define wRight mccPoreH10_wRight
#define wExit mccPoreH10_wExit
#define wall mccPoreH10_wall
#define nTop mccPoreH10_nTop
#define nBottom mccPoreH10_nBottom
#define zexit mccPoreH10_zexit
#define zentry mccPoreH10_zentry
#define intersect_wolterI mccPoreH10_intersect_wolterI
#define reflec_side_table mccPoreH10_reflec_side_table
#define reflec_top_table mccPoreH10_reflec_top_table
#define reflec_bottom_table mccPoreH10_reflec_bottom_table
#define ref_prms mccPoreH10_ref_prms
#define radius_m mccPoreH10_radius_m
#define radius_h mccPoreH10_radius_h
#define Z0 mccPoreH10_Z0
#define xwidth mccPoreH10_xwidth
#define yheight mccPoreH10_yheight
#define chamferwidth mccPoreH10_chamferwidth
#define mirror_reflec mccPoreH10_mirror_reflec
#define bottom_reflec mccPoreH10_bottom_reflec
#define side_reflec mccPoreH10_side_reflec
#define R_d mccPoreH10_R_d
#define absorb_sides mccPoreH10_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 33618 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH11. */
  SIG_MESSAGE("PoreH11 (Init)");
#define mccompcurname  PoreH11
#define mccompcurtype  Pore_h_group
#define mccompcurindex 114
#define nLeft mccPoreH11_nLeft
#define nRight mccPoreH11_nRight
#define nExit mccPoreH11_nExit
#define wLeft mccPoreH11_wLeft
#define wRight mccPoreH11_wRight
#define wExit mccPoreH11_wExit
#define wall mccPoreH11_wall
#define nTop mccPoreH11_nTop
#define nBottom mccPoreH11_nBottom
#define zexit mccPoreH11_zexit
#define zentry mccPoreH11_zentry
#define intersect_wolterI mccPoreH11_intersect_wolterI
#define reflec_side_table mccPoreH11_reflec_side_table
#define reflec_top_table mccPoreH11_reflec_top_table
#define reflec_bottom_table mccPoreH11_reflec_bottom_table
#define ref_prms mccPoreH11_ref_prms
#define radius_m mccPoreH11_radius_m
#define radius_h mccPoreH11_radius_h
#define Z0 mccPoreH11_Z0
#define xwidth mccPoreH11_xwidth
#define yheight mccPoreH11_yheight
#define chamferwidth mccPoreH11_chamferwidth
#define mirror_reflec mccPoreH11_mirror_reflec
#define bottom_reflec mccPoreH11_bottom_reflec
#define side_reflec mccPoreH11_side_reflec
#define R_d mccPoreH11_R_d
#define absorb_sides mccPoreH11_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 33783 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH12. */
  SIG_MESSAGE("PoreH12 (Init)");
#define mccompcurname  PoreH12
#define mccompcurtype  Pore_h_group
#define mccompcurindex 115
#define nLeft mccPoreH12_nLeft
#define nRight mccPoreH12_nRight
#define nExit mccPoreH12_nExit
#define wLeft mccPoreH12_wLeft
#define wRight mccPoreH12_wRight
#define wExit mccPoreH12_wExit
#define wall mccPoreH12_wall
#define nTop mccPoreH12_nTop
#define nBottom mccPoreH12_nBottom
#define zexit mccPoreH12_zexit
#define zentry mccPoreH12_zentry
#define intersect_wolterI mccPoreH12_intersect_wolterI
#define reflec_side_table mccPoreH12_reflec_side_table
#define reflec_top_table mccPoreH12_reflec_top_table
#define reflec_bottom_table mccPoreH12_reflec_bottom_table
#define ref_prms mccPoreH12_ref_prms
#define radius_m mccPoreH12_radius_m
#define radius_h mccPoreH12_radius_h
#define Z0 mccPoreH12_Z0
#define xwidth mccPoreH12_xwidth
#define yheight mccPoreH12_yheight
#define chamferwidth mccPoreH12_chamferwidth
#define mirror_reflec mccPoreH12_mirror_reflec
#define bottom_reflec mccPoreH12_bottom_reflec
#define side_reflec mccPoreH12_side_reflec
#define R_d mccPoreH12_R_d
#define absorb_sides mccPoreH12_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 33948 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH13. */
  SIG_MESSAGE("PoreH13 (Init)");
#define mccompcurname  PoreH13
#define mccompcurtype  Pore_h_group
#define mccompcurindex 116
#define nLeft mccPoreH13_nLeft
#define nRight mccPoreH13_nRight
#define nExit mccPoreH13_nExit
#define wLeft mccPoreH13_wLeft
#define wRight mccPoreH13_wRight
#define wExit mccPoreH13_wExit
#define wall mccPoreH13_wall
#define nTop mccPoreH13_nTop
#define nBottom mccPoreH13_nBottom
#define zexit mccPoreH13_zexit
#define zentry mccPoreH13_zentry
#define intersect_wolterI mccPoreH13_intersect_wolterI
#define reflec_side_table mccPoreH13_reflec_side_table
#define reflec_top_table mccPoreH13_reflec_top_table
#define reflec_bottom_table mccPoreH13_reflec_bottom_table
#define ref_prms mccPoreH13_ref_prms
#define radius_m mccPoreH13_radius_m
#define radius_h mccPoreH13_radius_h
#define Z0 mccPoreH13_Z0
#define xwidth mccPoreH13_xwidth
#define yheight mccPoreH13_yheight
#define chamferwidth mccPoreH13_chamferwidth
#define mirror_reflec mccPoreH13_mirror_reflec
#define bottom_reflec mccPoreH13_bottom_reflec
#define side_reflec mccPoreH13_side_reflec
#define R_d mccPoreH13_R_d
#define absorb_sides mccPoreH13_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 34113 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH14. */
  SIG_MESSAGE("PoreH14 (Init)");
#define mccompcurname  PoreH14
#define mccompcurtype  Pore_h_group
#define mccompcurindex 117
#define nLeft mccPoreH14_nLeft
#define nRight mccPoreH14_nRight
#define nExit mccPoreH14_nExit
#define wLeft mccPoreH14_wLeft
#define wRight mccPoreH14_wRight
#define wExit mccPoreH14_wExit
#define wall mccPoreH14_wall
#define nTop mccPoreH14_nTop
#define nBottom mccPoreH14_nBottom
#define zexit mccPoreH14_zexit
#define zentry mccPoreH14_zentry
#define intersect_wolterI mccPoreH14_intersect_wolterI
#define reflec_side_table mccPoreH14_reflec_side_table
#define reflec_top_table mccPoreH14_reflec_top_table
#define reflec_bottom_table mccPoreH14_reflec_bottom_table
#define ref_prms mccPoreH14_ref_prms
#define radius_m mccPoreH14_radius_m
#define radius_h mccPoreH14_radius_h
#define Z0 mccPoreH14_Z0
#define xwidth mccPoreH14_xwidth
#define yheight mccPoreH14_yheight
#define chamferwidth mccPoreH14_chamferwidth
#define mirror_reflec mccPoreH14_mirror_reflec
#define bottom_reflec mccPoreH14_bottom_reflec
#define side_reflec mccPoreH14_side_reflec
#define R_d mccPoreH14_R_d
#define absorb_sides mccPoreH14_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 34278 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH15. */
  SIG_MESSAGE("PoreH15 (Init)");
#define mccompcurname  PoreH15
#define mccompcurtype  Pore_h_group
#define mccompcurindex 118
#define nLeft mccPoreH15_nLeft
#define nRight mccPoreH15_nRight
#define nExit mccPoreH15_nExit
#define wLeft mccPoreH15_wLeft
#define wRight mccPoreH15_wRight
#define wExit mccPoreH15_wExit
#define wall mccPoreH15_wall
#define nTop mccPoreH15_nTop
#define nBottom mccPoreH15_nBottom
#define zexit mccPoreH15_zexit
#define zentry mccPoreH15_zentry
#define intersect_wolterI mccPoreH15_intersect_wolterI
#define reflec_side_table mccPoreH15_reflec_side_table
#define reflec_top_table mccPoreH15_reflec_top_table
#define reflec_bottom_table mccPoreH15_reflec_bottom_table
#define ref_prms mccPoreH15_ref_prms
#define radius_m mccPoreH15_radius_m
#define radius_h mccPoreH15_radius_h
#define Z0 mccPoreH15_Z0
#define xwidth mccPoreH15_xwidth
#define yheight mccPoreH15_yheight
#define chamferwidth mccPoreH15_chamferwidth
#define mirror_reflec mccPoreH15_mirror_reflec
#define bottom_reflec mccPoreH15_bottom_reflec
#define side_reflec mccPoreH15_side_reflec
#define R_d mccPoreH15_R_d
#define absorb_sides mccPoreH15_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 34443 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH16. */
  SIG_MESSAGE("PoreH16 (Init)");
#define mccompcurname  PoreH16
#define mccompcurtype  Pore_h_group
#define mccompcurindex 119
#define nLeft mccPoreH16_nLeft
#define nRight mccPoreH16_nRight
#define nExit mccPoreH16_nExit
#define wLeft mccPoreH16_wLeft
#define wRight mccPoreH16_wRight
#define wExit mccPoreH16_wExit
#define wall mccPoreH16_wall
#define nTop mccPoreH16_nTop
#define nBottom mccPoreH16_nBottom
#define zexit mccPoreH16_zexit
#define zentry mccPoreH16_zentry
#define intersect_wolterI mccPoreH16_intersect_wolterI
#define reflec_side_table mccPoreH16_reflec_side_table
#define reflec_top_table mccPoreH16_reflec_top_table
#define reflec_bottom_table mccPoreH16_reflec_bottom_table
#define ref_prms mccPoreH16_ref_prms
#define radius_m mccPoreH16_radius_m
#define radius_h mccPoreH16_radius_h
#define Z0 mccPoreH16_Z0
#define xwidth mccPoreH16_xwidth
#define yheight mccPoreH16_yheight
#define chamferwidth mccPoreH16_chamferwidth
#define mirror_reflec mccPoreH16_mirror_reflec
#define bottom_reflec mccPoreH16_bottom_reflec
#define side_reflec mccPoreH16_side_reflec
#define R_d mccPoreH16_R_d
#define absorb_sides mccPoreH16_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 34608 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH17. */
  SIG_MESSAGE("PoreH17 (Init)");
#define mccompcurname  PoreH17
#define mccompcurtype  Pore_h_group
#define mccompcurindex 120
#define nLeft mccPoreH17_nLeft
#define nRight mccPoreH17_nRight
#define nExit mccPoreH17_nExit
#define wLeft mccPoreH17_wLeft
#define wRight mccPoreH17_wRight
#define wExit mccPoreH17_wExit
#define wall mccPoreH17_wall
#define nTop mccPoreH17_nTop
#define nBottom mccPoreH17_nBottom
#define zexit mccPoreH17_zexit
#define zentry mccPoreH17_zentry
#define intersect_wolterI mccPoreH17_intersect_wolterI
#define reflec_side_table mccPoreH17_reflec_side_table
#define reflec_top_table mccPoreH17_reflec_top_table
#define reflec_bottom_table mccPoreH17_reflec_bottom_table
#define ref_prms mccPoreH17_ref_prms
#define radius_m mccPoreH17_radius_m
#define radius_h mccPoreH17_radius_h
#define Z0 mccPoreH17_Z0
#define xwidth mccPoreH17_xwidth
#define yheight mccPoreH17_yheight
#define chamferwidth mccPoreH17_chamferwidth
#define mirror_reflec mccPoreH17_mirror_reflec
#define bottom_reflec mccPoreH17_bottom_reflec
#define side_reflec mccPoreH17_side_reflec
#define R_d mccPoreH17_R_d
#define absorb_sides mccPoreH17_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 34773 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH18. */
  SIG_MESSAGE("PoreH18 (Init)");
#define mccompcurname  PoreH18
#define mccompcurtype  Pore_h_group
#define mccompcurindex 121
#define nLeft mccPoreH18_nLeft
#define nRight mccPoreH18_nRight
#define nExit mccPoreH18_nExit
#define wLeft mccPoreH18_wLeft
#define wRight mccPoreH18_wRight
#define wExit mccPoreH18_wExit
#define wall mccPoreH18_wall
#define nTop mccPoreH18_nTop
#define nBottom mccPoreH18_nBottom
#define zexit mccPoreH18_zexit
#define zentry mccPoreH18_zentry
#define intersect_wolterI mccPoreH18_intersect_wolterI
#define reflec_side_table mccPoreH18_reflec_side_table
#define reflec_top_table mccPoreH18_reflec_top_table
#define reflec_bottom_table mccPoreH18_reflec_bottom_table
#define ref_prms mccPoreH18_ref_prms
#define radius_m mccPoreH18_radius_m
#define radius_h mccPoreH18_radius_h
#define Z0 mccPoreH18_Z0
#define xwidth mccPoreH18_xwidth
#define yheight mccPoreH18_yheight
#define chamferwidth mccPoreH18_chamferwidth
#define mirror_reflec mccPoreH18_mirror_reflec
#define bottom_reflec mccPoreH18_bottom_reflec
#define side_reflec mccPoreH18_side_reflec
#define R_d mccPoreH18_R_d
#define absorb_sides mccPoreH18_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 34938 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH19. */
  SIG_MESSAGE("PoreH19 (Init)");
#define mccompcurname  PoreH19
#define mccompcurtype  Pore_h_group
#define mccompcurindex 122
#define nLeft mccPoreH19_nLeft
#define nRight mccPoreH19_nRight
#define nExit mccPoreH19_nExit
#define wLeft mccPoreH19_wLeft
#define wRight mccPoreH19_wRight
#define wExit mccPoreH19_wExit
#define wall mccPoreH19_wall
#define nTop mccPoreH19_nTop
#define nBottom mccPoreH19_nBottom
#define zexit mccPoreH19_zexit
#define zentry mccPoreH19_zentry
#define intersect_wolterI mccPoreH19_intersect_wolterI
#define reflec_side_table mccPoreH19_reflec_side_table
#define reflec_top_table mccPoreH19_reflec_top_table
#define reflec_bottom_table mccPoreH19_reflec_bottom_table
#define ref_prms mccPoreH19_ref_prms
#define radius_m mccPoreH19_radius_m
#define radius_h mccPoreH19_radius_h
#define Z0 mccPoreH19_Z0
#define xwidth mccPoreH19_xwidth
#define yheight mccPoreH19_yheight
#define chamferwidth mccPoreH19_chamferwidth
#define mirror_reflec mccPoreH19_mirror_reflec
#define bottom_reflec mccPoreH19_bottom_reflec
#define side_reflec mccPoreH19_side_reflec
#define R_d mccPoreH19_R_d
#define absorb_sides mccPoreH19_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 35103 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH20. */
  SIG_MESSAGE("PoreH20 (Init)");
#define mccompcurname  PoreH20
#define mccompcurtype  Pore_h_group
#define mccompcurindex 123
#define nLeft mccPoreH20_nLeft
#define nRight mccPoreH20_nRight
#define nExit mccPoreH20_nExit
#define wLeft mccPoreH20_wLeft
#define wRight mccPoreH20_wRight
#define wExit mccPoreH20_wExit
#define wall mccPoreH20_wall
#define nTop mccPoreH20_nTop
#define nBottom mccPoreH20_nBottom
#define zexit mccPoreH20_zexit
#define zentry mccPoreH20_zentry
#define intersect_wolterI mccPoreH20_intersect_wolterI
#define reflec_side_table mccPoreH20_reflec_side_table
#define reflec_top_table mccPoreH20_reflec_top_table
#define reflec_bottom_table mccPoreH20_reflec_bottom_table
#define ref_prms mccPoreH20_ref_prms
#define radius_m mccPoreH20_radius_m
#define radius_h mccPoreH20_radius_h
#define Z0 mccPoreH20_Z0
#define xwidth mccPoreH20_xwidth
#define yheight mccPoreH20_yheight
#define chamferwidth mccPoreH20_chamferwidth
#define mirror_reflec mccPoreH20_mirror_reflec
#define bottom_reflec mccPoreH20_bottom_reflec
#define side_reflec mccPoreH20_side_reflec
#define R_d mccPoreH20_R_d
#define absorb_sides mccPoreH20_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 35268 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH21. */
  SIG_MESSAGE("PoreH21 (Init)");
#define mccompcurname  PoreH21
#define mccompcurtype  Pore_h_group
#define mccompcurindex 124
#define nLeft mccPoreH21_nLeft
#define nRight mccPoreH21_nRight
#define nExit mccPoreH21_nExit
#define wLeft mccPoreH21_wLeft
#define wRight mccPoreH21_wRight
#define wExit mccPoreH21_wExit
#define wall mccPoreH21_wall
#define nTop mccPoreH21_nTop
#define nBottom mccPoreH21_nBottom
#define zexit mccPoreH21_zexit
#define zentry mccPoreH21_zentry
#define intersect_wolterI mccPoreH21_intersect_wolterI
#define reflec_side_table mccPoreH21_reflec_side_table
#define reflec_top_table mccPoreH21_reflec_top_table
#define reflec_bottom_table mccPoreH21_reflec_bottom_table
#define ref_prms mccPoreH21_ref_prms
#define radius_m mccPoreH21_radius_m
#define radius_h mccPoreH21_radius_h
#define Z0 mccPoreH21_Z0
#define xwidth mccPoreH21_xwidth
#define yheight mccPoreH21_yheight
#define chamferwidth mccPoreH21_chamferwidth
#define mirror_reflec mccPoreH21_mirror_reflec
#define bottom_reflec mccPoreH21_bottom_reflec
#define side_reflec mccPoreH21_side_reflec
#define R_d mccPoreH21_R_d
#define absorb_sides mccPoreH21_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 35433 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH22. */
  SIG_MESSAGE("PoreH22 (Init)");
#define mccompcurname  PoreH22
#define mccompcurtype  Pore_h_group
#define mccompcurindex 125
#define nLeft mccPoreH22_nLeft
#define nRight mccPoreH22_nRight
#define nExit mccPoreH22_nExit
#define wLeft mccPoreH22_wLeft
#define wRight mccPoreH22_wRight
#define wExit mccPoreH22_wExit
#define wall mccPoreH22_wall
#define nTop mccPoreH22_nTop
#define nBottom mccPoreH22_nBottom
#define zexit mccPoreH22_zexit
#define zentry mccPoreH22_zentry
#define intersect_wolterI mccPoreH22_intersect_wolterI
#define reflec_side_table mccPoreH22_reflec_side_table
#define reflec_top_table mccPoreH22_reflec_top_table
#define reflec_bottom_table mccPoreH22_reflec_bottom_table
#define ref_prms mccPoreH22_ref_prms
#define radius_m mccPoreH22_radius_m
#define radius_h mccPoreH22_radius_h
#define Z0 mccPoreH22_Z0
#define xwidth mccPoreH22_xwidth
#define yheight mccPoreH22_yheight
#define chamferwidth mccPoreH22_chamferwidth
#define mirror_reflec mccPoreH22_mirror_reflec
#define bottom_reflec mccPoreH22_bottom_reflec
#define side_reflec mccPoreH22_side_reflec
#define R_d mccPoreH22_R_d
#define absorb_sides mccPoreH22_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 35598 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH23. */
  SIG_MESSAGE("PoreH23 (Init)");
#define mccompcurname  PoreH23
#define mccompcurtype  Pore_h_group
#define mccompcurindex 126
#define nLeft mccPoreH23_nLeft
#define nRight mccPoreH23_nRight
#define nExit mccPoreH23_nExit
#define wLeft mccPoreH23_wLeft
#define wRight mccPoreH23_wRight
#define wExit mccPoreH23_wExit
#define wall mccPoreH23_wall
#define nTop mccPoreH23_nTop
#define nBottom mccPoreH23_nBottom
#define zexit mccPoreH23_zexit
#define zentry mccPoreH23_zentry
#define intersect_wolterI mccPoreH23_intersect_wolterI
#define reflec_side_table mccPoreH23_reflec_side_table
#define reflec_top_table mccPoreH23_reflec_top_table
#define reflec_bottom_table mccPoreH23_reflec_bottom_table
#define ref_prms mccPoreH23_ref_prms
#define radius_m mccPoreH23_radius_m
#define radius_h mccPoreH23_radius_h
#define Z0 mccPoreH23_Z0
#define xwidth mccPoreH23_xwidth
#define yheight mccPoreH23_yheight
#define chamferwidth mccPoreH23_chamferwidth
#define mirror_reflec mccPoreH23_mirror_reflec
#define bottom_reflec mccPoreH23_bottom_reflec
#define side_reflec mccPoreH23_side_reflec
#define R_d mccPoreH23_R_d
#define absorb_sides mccPoreH23_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 35763 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH24. */
  SIG_MESSAGE("PoreH24 (Init)");
#define mccompcurname  PoreH24
#define mccompcurtype  Pore_h_group
#define mccompcurindex 127
#define nLeft mccPoreH24_nLeft
#define nRight mccPoreH24_nRight
#define nExit mccPoreH24_nExit
#define wLeft mccPoreH24_wLeft
#define wRight mccPoreH24_wRight
#define wExit mccPoreH24_wExit
#define wall mccPoreH24_wall
#define nTop mccPoreH24_nTop
#define nBottom mccPoreH24_nBottom
#define zexit mccPoreH24_zexit
#define zentry mccPoreH24_zentry
#define intersect_wolterI mccPoreH24_intersect_wolterI
#define reflec_side_table mccPoreH24_reflec_side_table
#define reflec_top_table mccPoreH24_reflec_top_table
#define reflec_bottom_table mccPoreH24_reflec_bottom_table
#define ref_prms mccPoreH24_ref_prms
#define radius_m mccPoreH24_radius_m
#define radius_h mccPoreH24_radius_h
#define Z0 mccPoreH24_Z0
#define xwidth mccPoreH24_xwidth
#define yheight mccPoreH24_yheight
#define chamferwidth mccPoreH24_chamferwidth
#define mirror_reflec mccPoreH24_mirror_reflec
#define bottom_reflec mccPoreH24_bottom_reflec
#define side_reflec mccPoreH24_side_reflec
#define R_d mccPoreH24_R_d
#define absorb_sides mccPoreH24_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 35928 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH25. */
  SIG_MESSAGE("PoreH25 (Init)");
#define mccompcurname  PoreH25
#define mccompcurtype  Pore_h_group
#define mccompcurindex 128
#define nLeft mccPoreH25_nLeft
#define nRight mccPoreH25_nRight
#define nExit mccPoreH25_nExit
#define wLeft mccPoreH25_wLeft
#define wRight mccPoreH25_wRight
#define wExit mccPoreH25_wExit
#define wall mccPoreH25_wall
#define nTop mccPoreH25_nTop
#define nBottom mccPoreH25_nBottom
#define zexit mccPoreH25_zexit
#define zentry mccPoreH25_zentry
#define intersect_wolterI mccPoreH25_intersect_wolterI
#define reflec_side_table mccPoreH25_reflec_side_table
#define reflec_top_table mccPoreH25_reflec_top_table
#define reflec_bottom_table mccPoreH25_reflec_bottom_table
#define ref_prms mccPoreH25_ref_prms
#define radius_m mccPoreH25_radius_m
#define radius_h mccPoreH25_radius_h
#define Z0 mccPoreH25_Z0
#define xwidth mccPoreH25_xwidth
#define yheight mccPoreH25_yheight
#define chamferwidth mccPoreH25_chamferwidth
#define mirror_reflec mccPoreH25_mirror_reflec
#define bottom_reflec mccPoreH25_bottom_reflec
#define side_reflec mccPoreH25_side_reflec
#define R_d mccPoreH25_R_d
#define absorb_sides mccPoreH25_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 36093 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH26. */
  SIG_MESSAGE("PoreH26 (Init)");
#define mccompcurname  PoreH26
#define mccompcurtype  Pore_h_group
#define mccompcurindex 129
#define nLeft mccPoreH26_nLeft
#define nRight mccPoreH26_nRight
#define nExit mccPoreH26_nExit
#define wLeft mccPoreH26_wLeft
#define wRight mccPoreH26_wRight
#define wExit mccPoreH26_wExit
#define wall mccPoreH26_wall
#define nTop mccPoreH26_nTop
#define nBottom mccPoreH26_nBottom
#define zexit mccPoreH26_zexit
#define zentry mccPoreH26_zentry
#define intersect_wolterI mccPoreH26_intersect_wolterI
#define reflec_side_table mccPoreH26_reflec_side_table
#define reflec_top_table mccPoreH26_reflec_top_table
#define reflec_bottom_table mccPoreH26_reflec_bottom_table
#define ref_prms mccPoreH26_ref_prms
#define radius_m mccPoreH26_radius_m
#define radius_h mccPoreH26_radius_h
#define Z0 mccPoreH26_Z0
#define xwidth mccPoreH26_xwidth
#define yheight mccPoreH26_yheight
#define chamferwidth mccPoreH26_chamferwidth
#define mirror_reflec mccPoreH26_mirror_reflec
#define bottom_reflec mccPoreH26_bottom_reflec
#define side_reflec mccPoreH26_side_reflec
#define R_d mccPoreH26_R_d
#define absorb_sides mccPoreH26_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 36258 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH27. */
  SIG_MESSAGE("PoreH27 (Init)");
#define mccompcurname  PoreH27
#define mccompcurtype  Pore_h_group
#define mccompcurindex 130
#define nLeft mccPoreH27_nLeft
#define nRight mccPoreH27_nRight
#define nExit mccPoreH27_nExit
#define wLeft mccPoreH27_wLeft
#define wRight mccPoreH27_wRight
#define wExit mccPoreH27_wExit
#define wall mccPoreH27_wall
#define nTop mccPoreH27_nTop
#define nBottom mccPoreH27_nBottom
#define zexit mccPoreH27_zexit
#define zentry mccPoreH27_zentry
#define intersect_wolterI mccPoreH27_intersect_wolterI
#define reflec_side_table mccPoreH27_reflec_side_table
#define reflec_top_table mccPoreH27_reflec_top_table
#define reflec_bottom_table mccPoreH27_reflec_bottom_table
#define ref_prms mccPoreH27_ref_prms
#define radius_m mccPoreH27_radius_m
#define radius_h mccPoreH27_radius_h
#define Z0 mccPoreH27_Z0
#define xwidth mccPoreH27_xwidth
#define yheight mccPoreH27_yheight
#define chamferwidth mccPoreH27_chamferwidth
#define mirror_reflec mccPoreH27_mirror_reflec
#define bottom_reflec mccPoreH27_bottom_reflec
#define side_reflec mccPoreH27_side_reflec
#define R_d mccPoreH27_R_d
#define absorb_sides mccPoreH27_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 36423 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH28. */
  SIG_MESSAGE("PoreH28 (Init)");
#define mccompcurname  PoreH28
#define mccompcurtype  Pore_h_group
#define mccompcurindex 131
#define nLeft mccPoreH28_nLeft
#define nRight mccPoreH28_nRight
#define nExit mccPoreH28_nExit
#define wLeft mccPoreH28_wLeft
#define wRight mccPoreH28_wRight
#define wExit mccPoreH28_wExit
#define wall mccPoreH28_wall
#define nTop mccPoreH28_nTop
#define nBottom mccPoreH28_nBottom
#define zexit mccPoreH28_zexit
#define zentry mccPoreH28_zentry
#define intersect_wolterI mccPoreH28_intersect_wolterI
#define reflec_side_table mccPoreH28_reflec_side_table
#define reflec_top_table mccPoreH28_reflec_top_table
#define reflec_bottom_table mccPoreH28_reflec_bottom_table
#define ref_prms mccPoreH28_ref_prms
#define radius_m mccPoreH28_radius_m
#define radius_h mccPoreH28_radius_h
#define Z0 mccPoreH28_Z0
#define xwidth mccPoreH28_xwidth
#define yheight mccPoreH28_yheight
#define chamferwidth mccPoreH28_chamferwidth
#define mirror_reflec mccPoreH28_mirror_reflec
#define bottom_reflec mccPoreH28_bottom_reflec
#define side_reflec mccPoreH28_side_reflec
#define R_d mccPoreH28_R_d
#define absorb_sides mccPoreH28_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 36588 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH29. */
  SIG_MESSAGE("PoreH29 (Init)");
#define mccompcurname  PoreH29
#define mccompcurtype  Pore_h_group
#define mccompcurindex 132
#define nLeft mccPoreH29_nLeft
#define nRight mccPoreH29_nRight
#define nExit mccPoreH29_nExit
#define wLeft mccPoreH29_wLeft
#define wRight mccPoreH29_wRight
#define wExit mccPoreH29_wExit
#define wall mccPoreH29_wall
#define nTop mccPoreH29_nTop
#define nBottom mccPoreH29_nBottom
#define zexit mccPoreH29_zexit
#define zentry mccPoreH29_zentry
#define intersect_wolterI mccPoreH29_intersect_wolterI
#define reflec_side_table mccPoreH29_reflec_side_table
#define reflec_top_table mccPoreH29_reflec_top_table
#define reflec_bottom_table mccPoreH29_reflec_bottom_table
#define ref_prms mccPoreH29_ref_prms
#define radius_m mccPoreH29_radius_m
#define radius_h mccPoreH29_radius_h
#define Z0 mccPoreH29_Z0
#define xwidth mccPoreH29_xwidth
#define yheight mccPoreH29_yheight
#define chamferwidth mccPoreH29_chamferwidth
#define mirror_reflec mccPoreH29_mirror_reflec
#define bottom_reflec mccPoreH29_bottom_reflec
#define side_reflec mccPoreH29_side_reflec
#define R_d mccPoreH29_R_d
#define absorb_sides mccPoreH29_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 36753 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH30. */
  SIG_MESSAGE("PoreH30 (Init)");
#define mccompcurname  PoreH30
#define mccompcurtype  Pore_h_group
#define mccompcurindex 133
#define nLeft mccPoreH30_nLeft
#define nRight mccPoreH30_nRight
#define nExit mccPoreH30_nExit
#define wLeft mccPoreH30_wLeft
#define wRight mccPoreH30_wRight
#define wExit mccPoreH30_wExit
#define wall mccPoreH30_wall
#define nTop mccPoreH30_nTop
#define nBottom mccPoreH30_nBottom
#define zexit mccPoreH30_zexit
#define zentry mccPoreH30_zentry
#define intersect_wolterI mccPoreH30_intersect_wolterI
#define reflec_side_table mccPoreH30_reflec_side_table
#define reflec_top_table mccPoreH30_reflec_top_table
#define reflec_bottom_table mccPoreH30_reflec_bottom_table
#define ref_prms mccPoreH30_ref_prms
#define radius_m mccPoreH30_radius_m
#define radius_h mccPoreH30_radius_h
#define Z0 mccPoreH30_Z0
#define xwidth mccPoreH30_xwidth
#define yheight mccPoreH30_yheight
#define chamferwidth mccPoreH30_chamferwidth
#define mirror_reflec mccPoreH30_mirror_reflec
#define bottom_reflec mccPoreH30_bottom_reflec
#define side_reflec mccPoreH30_side_reflec
#define R_d mccPoreH30_R_d
#define absorb_sides mccPoreH30_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 36918 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH31. */
  SIG_MESSAGE("PoreH31 (Init)");
#define mccompcurname  PoreH31
#define mccompcurtype  Pore_h_group
#define mccompcurindex 134
#define nLeft mccPoreH31_nLeft
#define nRight mccPoreH31_nRight
#define nExit mccPoreH31_nExit
#define wLeft mccPoreH31_wLeft
#define wRight mccPoreH31_wRight
#define wExit mccPoreH31_wExit
#define wall mccPoreH31_wall
#define nTop mccPoreH31_nTop
#define nBottom mccPoreH31_nBottom
#define zexit mccPoreH31_zexit
#define zentry mccPoreH31_zentry
#define intersect_wolterI mccPoreH31_intersect_wolterI
#define reflec_side_table mccPoreH31_reflec_side_table
#define reflec_top_table mccPoreH31_reflec_top_table
#define reflec_bottom_table mccPoreH31_reflec_bottom_table
#define ref_prms mccPoreH31_ref_prms
#define radius_m mccPoreH31_radius_m
#define radius_h mccPoreH31_radius_h
#define Z0 mccPoreH31_Z0
#define xwidth mccPoreH31_xwidth
#define yheight mccPoreH31_yheight
#define chamferwidth mccPoreH31_chamferwidth
#define mirror_reflec mccPoreH31_mirror_reflec
#define bottom_reflec mccPoreH31_bottom_reflec
#define side_reflec mccPoreH31_side_reflec
#define R_d mccPoreH31_R_d
#define absorb_sides mccPoreH31_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 37083 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH32. */
  SIG_MESSAGE("PoreH32 (Init)");
#define mccompcurname  PoreH32
#define mccompcurtype  Pore_h_group
#define mccompcurindex 135
#define nLeft mccPoreH32_nLeft
#define nRight mccPoreH32_nRight
#define nExit mccPoreH32_nExit
#define wLeft mccPoreH32_wLeft
#define wRight mccPoreH32_wRight
#define wExit mccPoreH32_wExit
#define wall mccPoreH32_wall
#define nTop mccPoreH32_nTop
#define nBottom mccPoreH32_nBottom
#define zexit mccPoreH32_zexit
#define zentry mccPoreH32_zentry
#define intersect_wolterI mccPoreH32_intersect_wolterI
#define reflec_side_table mccPoreH32_reflec_side_table
#define reflec_top_table mccPoreH32_reflec_top_table
#define reflec_bottom_table mccPoreH32_reflec_bottom_table
#define ref_prms mccPoreH32_ref_prms
#define radius_m mccPoreH32_radius_m
#define radius_h mccPoreH32_radius_h
#define Z0 mccPoreH32_Z0
#define xwidth mccPoreH32_xwidth
#define yheight mccPoreH32_yheight
#define chamferwidth mccPoreH32_chamferwidth
#define mirror_reflec mccPoreH32_mirror_reflec
#define bottom_reflec mccPoreH32_bottom_reflec
#define side_reflec mccPoreH32_side_reflec
#define R_d mccPoreH32_R_d
#define absorb_sides mccPoreH32_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 37248 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH33. */
  SIG_MESSAGE("PoreH33 (Init)");
#define mccompcurname  PoreH33
#define mccompcurtype  Pore_h_group
#define mccompcurindex 136
#define nLeft mccPoreH33_nLeft
#define nRight mccPoreH33_nRight
#define nExit mccPoreH33_nExit
#define wLeft mccPoreH33_wLeft
#define wRight mccPoreH33_wRight
#define wExit mccPoreH33_wExit
#define wall mccPoreH33_wall
#define nTop mccPoreH33_nTop
#define nBottom mccPoreH33_nBottom
#define zexit mccPoreH33_zexit
#define zentry mccPoreH33_zentry
#define intersect_wolterI mccPoreH33_intersect_wolterI
#define reflec_side_table mccPoreH33_reflec_side_table
#define reflec_top_table mccPoreH33_reflec_top_table
#define reflec_bottom_table mccPoreH33_reflec_bottom_table
#define ref_prms mccPoreH33_ref_prms
#define radius_m mccPoreH33_radius_m
#define radius_h mccPoreH33_radius_h
#define Z0 mccPoreH33_Z0
#define xwidth mccPoreH33_xwidth
#define yheight mccPoreH33_yheight
#define chamferwidth mccPoreH33_chamferwidth
#define mirror_reflec mccPoreH33_mirror_reflec
#define bottom_reflec mccPoreH33_bottom_reflec
#define side_reflec mccPoreH33_side_reflec
#define R_d mccPoreH33_R_d
#define absorb_sides mccPoreH33_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 37413 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH34. */
  SIG_MESSAGE("PoreH34 (Init)");
#define mccompcurname  PoreH34
#define mccompcurtype  Pore_h_group
#define mccompcurindex 137
#define nLeft mccPoreH34_nLeft
#define nRight mccPoreH34_nRight
#define nExit mccPoreH34_nExit
#define wLeft mccPoreH34_wLeft
#define wRight mccPoreH34_wRight
#define wExit mccPoreH34_wExit
#define wall mccPoreH34_wall
#define nTop mccPoreH34_nTop
#define nBottom mccPoreH34_nBottom
#define zexit mccPoreH34_zexit
#define zentry mccPoreH34_zentry
#define intersect_wolterI mccPoreH34_intersect_wolterI
#define reflec_side_table mccPoreH34_reflec_side_table
#define reflec_top_table mccPoreH34_reflec_top_table
#define reflec_bottom_table mccPoreH34_reflec_bottom_table
#define ref_prms mccPoreH34_ref_prms
#define radius_m mccPoreH34_radius_m
#define radius_h mccPoreH34_radius_h
#define Z0 mccPoreH34_Z0
#define xwidth mccPoreH34_xwidth
#define yheight mccPoreH34_yheight
#define chamferwidth mccPoreH34_chamferwidth
#define mirror_reflec mccPoreH34_mirror_reflec
#define bottom_reflec mccPoreH34_bottom_reflec
#define side_reflec mccPoreH34_side_reflec
#define R_d mccPoreH34_R_d
#define absorb_sides mccPoreH34_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 37578 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH35. */
  SIG_MESSAGE("PoreH35 (Init)");
#define mccompcurname  PoreH35
#define mccompcurtype  Pore_h_group
#define mccompcurindex 138
#define nLeft mccPoreH35_nLeft
#define nRight mccPoreH35_nRight
#define nExit mccPoreH35_nExit
#define wLeft mccPoreH35_wLeft
#define wRight mccPoreH35_wRight
#define wExit mccPoreH35_wExit
#define wall mccPoreH35_wall
#define nTop mccPoreH35_nTop
#define nBottom mccPoreH35_nBottom
#define zexit mccPoreH35_zexit
#define zentry mccPoreH35_zentry
#define intersect_wolterI mccPoreH35_intersect_wolterI
#define reflec_side_table mccPoreH35_reflec_side_table
#define reflec_top_table mccPoreH35_reflec_top_table
#define reflec_bottom_table mccPoreH35_reflec_bottom_table
#define ref_prms mccPoreH35_ref_prms
#define radius_m mccPoreH35_radius_m
#define radius_h mccPoreH35_radius_h
#define Z0 mccPoreH35_Z0
#define xwidth mccPoreH35_xwidth
#define yheight mccPoreH35_yheight
#define chamferwidth mccPoreH35_chamferwidth
#define mirror_reflec mccPoreH35_mirror_reflec
#define bottom_reflec mccPoreH35_bottom_reflec
#define side_reflec mccPoreH35_side_reflec
#define R_d mccPoreH35_R_d
#define absorb_sides mccPoreH35_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 37743 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH36. */
  SIG_MESSAGE("PoreH36 (Init)");
#define mccompcurname  PoreH36
#define mccompcurtype  Pore_h_group
#define mccompcurindex 139
#define nLeft mccPoreH36_nLeft
#define nRight mccPoreH36_nRight
#define nExit mccPoreH36_nExit
#define wLeft mccPoreH36_wLeft
#define wRight mccPoreH36_wRight
#define wExit mccPoreH36_wExit
#define wall mccPoreH36_wall
#define nTop mccPoreH36_nTop
#define nBottom mccPoreH36_nBottom
#define zexit mccPoreH36_zexit
#define zentry mccPoreH36_zentry
#define intersect_wolterI mccPoreH36_intersect_wolterI
#define reflec_side_table mccPoreH36_reflec_side_table
#define reflec_top_table mccPoreH36_reflec_top_table
#define reflec_bottom_table mccPoreH36_reflec_bottom_table
#define ref_prms mccPoreH36_ref_prms
#define radius_m mccPoreH36_radius_m
#define radius_h mccPoreH36_radius_h
#define Z0 mccPoreH36_Z0
#define xwidth mccPoreH36_xwidth
#define yheight mccPoreH36_yheight
#define chamferwidth mccPoreH36_chamferwidth
#define mirror_reflec mccPoreH36_mirror_reflec
#define bottom_reflec mccPoreH36_bottom_reflec
#define side_reflec mccPoreH36_side_reflec
#define R_d mccPoreH36_R_d
#define absorb_sides mccPoreH36_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 37908 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH37. */
  SIG_MESSAGE("PoreH37 (Init)");
#define mccompcurname  PoreH37
#define mccompcurtype  Pore_h_group
#define mccompcurindex 140
#define nLeft mccPoreH37_nLeft
#define nRight mccPoreH37_nRight
#define nExit mccPoreH37_nExit
#define wLeft mccPoreH37_wLeft
#define wRight mccPoreH37_wRight
#define wExit mccPoreH37_wExit
#define wall mccPoreH37_wall
#define nTop mccPoreH37_nTop
#define nBottom mccPoreH37_nBottom
#define zexit mccPoreH37_zexit
#define zentry mccPoreH37_zentry
#define intersect_wolterI mccPoreH37_intersect_wolterI
#define reflec_side_table mccPoreH37_reflec_side_table
#define reflec_top_table mccPoreH37_reflec_top_table
#define reflec_bottom_table mccPoreH37_reflec_bottom_table
#define ref_prms mccPoreH37_ref_prms
#define radius_m mccPoreH37_radius_m
#define radius_h mccPoreH37_radius_h
#define Z0 mccPoreH37_Z0
#define xwidth mccPoreH37_xwidth
#define yheight mccPoreH37_yheight
#define chamferwidth mccPoreH37_chamferwidth
#define mirror_reflec mccPoreH37_mirror_reflec
#define bottom_reflec mccPoreH37_bottom_reflec
#define side_reflec mccPoreH37_side_reflec
#define R_d mccPoreH37_R_d
#define absorb_sides mccPoreH37_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 38073 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH38. */
  SIG_MESSAGE("PoreH38 (Init)");
#define mccompcurname  PoreH38
#define mccompcurtype  Pore_h_group
#define mccompcurindex 141
#define nLeft mccPoreH38_nLeft
#define nRight mccPoreH38_nRight
#define nExit mccPoreH38_nExit
#define wLeft mccPoreH38_wLeft
#define wRight mccPoreH38_wRight
#define wExit mccPoreH38_wExit
#define wall mccPoreH38_wall
#define nTop mccPoreH38_nTop
#define nBottom mccPoreH38_nBottom
#define zexit mccPoreH38_zexit
#define zentry mccPoreH38_zentry
#define intersect_wolterI mccPoreH38_intersect_wolterI
#define reflec_side_table mccPoreH38_reflec_side_table
#define reflec_top_table mccPoreH38_reflec_top_table
#define reflec_bottom_table mccPoreH38_reflec_bottom_table
#define ref_prms mccPoreH38_ref_prms
#define radius_m mccPoreH38_radius_m
#define radius_h mccPoreH38_radius_h
#define Z0 mccPoreH38_Z0
#define xwidth mccPoreH38_xwidth
#define yheight mccPoreH38_yheight
#define chamferwidth mccPoreH38_chamferwidth
#define mirror_reflec mccPoreH38_mirror_reflec
#define bottom_reflec mccPoreH38_bottom_reflec
#define side_reflec mccPoreH38_side_reflec
#define R_d mccPoreH38_R_d
#define absorb_sides mccPoreH38_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 38238 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH39. */
  SIG_MESSAGE("PoreH39 (Init)");
#define mccompcurname  PoreH39
#define mccompcurtype  Pore_h_group
#define mccompcurindex 142
#define nLeft mccPoreH39_nLeft
#define nRight mccPoreH39_nRight
#define nExit mccPoreH39_nExit
#define wLeft mccPoreH39_wLeft
#define wRight mccPoreH39_wRight
#define wExit mccPoreH39_wExit
#define wall mccPoreH39_wall
#define nTop mccPoreH39_nTop
#define nBottom mccPoreH39_nBottom
#define zexit mccPoreH39_zexit
#define zentry mccPoreH39_zentry
#define intersect_wolterI mccPoreH39_intersect_wolterI
#define reflec_side_table mccPoreH39_reflec_side_table
#define reflec_top_table mccPoreH39_reflec_top_table
#define reflec_bottom_table mccPoreH39_reflec_bottom_table
#define ref_prms mccPoreH39_ref_prms
#define radius_m mccPoreH39_radius_m
#define radius_h mccPoreH39_radius_h
#define Z0 mccPoreH39_Z0
#define xwidth mccPoreH39_xwidth
#define yheight mccPoreH39_yheight
#define chamferwidth mccPoreH39_chamferwidth
#define mirror_reflec mccPoreH39_mirror_reflec
#define bottom_reflec mccPoreH39_bottom_reflec
#define side_reflec mccPoreH39_side_reflec
#define R_d mccPoreH39_R_d
#define absorb_sides mccPoreH39_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 38403 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH40. */
  SIG_MESSAGE("PoreH40 (Init)");
#define mccompcurname  PoreH40
#define mccompcurtype  Pore_h_group
#define mccompcurindex 143
#define nLeft mccPoreH40_nLeft
#define nRight mccPoreH40_nRight
#define nExit mccPoreH40_nExit
#define wLeft mccPoreH40_wLeft
#define wRight mccPoreH40_wRight
#define wExit mccPoreH40_wExit
#define wall mccPoreH40_wall
#define nTop mccPoreH40_nTop
#define nBottom mccPoreH40_nBottom
#define zexit mccPoreH40_zexit
#define zentry mccPoreH40_zentry
#define intersect_wolterI mccPoreH40_intersect_wolterI
#define reflec_side_table mccPoreH40_reflec_side_table
#define reflec_top_table mccPoreH40_reflec_top_table
#define reflec_bottom_table mccPoreH40_reflec_bottom_table
#define ref_prms mccPoreH40_ref_prms
#define radius_m mccPoreH40_radius_m
#define radius_h mccPoreH40_radius_h
#define Z0 mccPoreH40_Z0
#define xwidth mccPoreH40_xwidth
#define yheight mccPoreH40_yheight
#define chamferwidth mccPoreH40_chamferwidth
#define mirror_reflec mccPoreH40_mirror_reflec
#define bottom_reflec mccPoreH40_bottom_reflec
#define side_reflec mccPoreH40_side_reflec
#define R_d mccPoreH40_R_d
#define absorb_sides mccPoreH40_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 38568 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH41. */
  SIG_MESSAGE("PoreH41 (Init)");
#define mccompcurname  PoreH41
#define mccompcurtype  Pore_h_group
#define mccompcurindex 144
#define nLeft mccPoreH41_nLeft
#define nRight mccPoreH41_nRight
#define nExit mccPoreH41_nExit
#define wLeft mccPoreH41_wLeft
#define wRight mccPoreH41_wRight
#define wExit mccPoreH41_wExit
#define wall mccPoreH41_wall
#define nTop mccPoreH41_nTop
#define nBottom mccPoreH41_nBottom
#define zexit mccPoreH41_zexit
#define zentry mccPoreH41_zentry
#define intersect_wolterI mccPoreH41_intersect_wolterI
#define reflec_side_table mccPoreH41_reflec_side_table
#define reflec_top_table mccPoreH41_reflec_top_table
#define reflec_bottom_table mccPoreH41_reflec_bottom_table
#define ref_prms mccPoreH41_ref_prms
#define radius_m mccPoreH41_radius_m
#define radius_h mccPoreH41_radius_h
#define Z0 mccPoreH41_Z0
#define xwidth mccPoreH41_xwidth
#define yheight mccPoreH41_yheight
#define chamferwidth mccPoreH41_chamferwidth
#define mirror_reflec mccPoreH41_mirror_reflec
#define bottom_reflec mccPoreH41_bottom_reflec
#define side_reflec mccPoreH41_side_reflec
#define R_d mccPoreH41_R_d
#define absorb_sides mccPoreH41_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 38733 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH42. */
  SIG_MESSAGE("PoreH42 (Init)");
#define mccompcurname  PoreH42
#define mccompcurtype  Pore_h_group
#define mccompcurindex 145
#define nLeft mccPoreH42_nLeft
#define nRight mccPoreH42_nRight
#define nExit mccPoreH42_nExit
#define wLeft mccPoreH42_wLeft
#define wRight mccPoreH42_wRight
#define wExit mccPoreH42_wExit
#define wall mccPoreH42_wall
#define nTop mccPoreH42_nTop
#define nBottom mccPoreH42_nBottom
#define zexit mccPoreH42_zexit
#define zentry mccPoreH42_zentry
#define intersect_wolterI mccPoreH42_intersect_wolterI
#define reflec_side_table mccPoreH42_reflec_side_table
#define reflec_top_table mccPoreH42_reflec_top_table
#define reflec_bottom_table mccPoreH42_reflec_bottom_table
#define ref_prms mccPoreH42_ref_prms
#define radius_m mccPoreH42_radius_m
#define radius_h mccPoreH42_radius_h
#define Z0 mccPoreH42_Z0
#define xwidth mccPoreH42_xwidth
#define yheight mccPoreH42_yheight
#define chamferwidth mccPoreH42_chamferwidth
#define mirror_reflec mccPoreH42_mirror_reflec
#define bottom_reflec mccPoreH42_bottom_reflec
#define side_reflec mccPoreH42_side_reflec
#define R_d mccPoreH42_R_d
#define absorb_sides mccPoreH42_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 38898 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH43. */
  SIG_MESSAGE("PoreH43 (Init)");
#define mccompcurname  PoreH43
#define mccompcurtype  Pore_h_group
#define mccompcurindex 146
#define nLeft mccPoreH43_nLeft
#define nRight mccPoreH43_nRight
#define nExit mccPoreH43_nExit
#define wLeft mccPoreH43_wLeft
#define wRight mccPoreH43_wRight
#define wExit mccPoreH43_wExit
#define wall mccPoreH43_wall
#define nTop mccPoreH43_nTop
#define nBottom mccPoreH43_nBottom
#define zexit mccPoreH43_zexit
#define zentry mccPoreH43_zentry
#define intersect_wolterI mccPoreH43_intersect_wolterI
#define reflec_side_table mccPoreH43_reflec_side_table
#define reflec_top_table mccPoreH43_reflec_top_table
#define reflec_bottom_table mccPoreH43_reflec_bottom_table
#define ref_prms mccPoreH43_ref_prms
#define radius_m mccPoreH43_radius_m
#define radius_h mccPoreH43_radius_h
#define Z0 mccPoreH43_Z0
#define xwidth mccPoreH43_xwidth
#define yheight mccPoreH43_yheight
#define chamferwidth mccPoreH43_chamferwidth
#define mirror_reflec mccPoreH43_mirror_reflec
#define bottom_reflec mccPoreH43_bottom_reflec
#define side_reflec mccPoreH43_side_reflec
#define R_d mccPoreH43_R_d
#define absorb_sides mccPoreH43_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 39063 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH44. */
  SIG_MESSAGE("PoreH44 (Init)");
#define mccompcurname  PoreH44
#define mccompcurtype  Pore_h_group
#define mccompcurindex 147
#define nLeft mccPoreH44_nLeft
#define nRight mccPoreH44_nRight
#define nExit mccPoreH44_nExit
#define wLeft mccPoreH44_wLeft
#define wRight mccPoreH44_wRight
#define wExit mccPoreH44_wExit
#define wall mccPoreH44_wall
#define nTop mccPoreH44_nTop
#define nBottom mccPoreH44_nBottom
#define zexit mccPoreH44_zexit
#define zentry mccPoreH44_zentry
#define intersect_wolterI mccPoreH44_intersect_wolterI
#define reflec_side_table mccPoreH44_reflec_side_table
#define reflec_top_table mccPoreH44_reflec_top_table
#define reflec_bottom_table mccPoreH44_reflec_bottom_table
#define ref_prms mccPoreH44_ref_prms
#define radius_m mccPoreH44_radius_m
#define radius_h mccPoreH44_radius_h
#define Z0 mccPoreH44_Z0
#define xwidth mccPoreH44_xwidth
#define yheight mccPoreH44_yheight
#define chamferwidth mccPoreH44_chamferwidth
#define mirror_reflec mccPoreH44_mirror_reflec
#define bottom_reflec mccPoreH44_bottom_reflec
#define side_reflec mccPoreH44_side_reflec
#define R_d mccPoreH44_R_d
#define absorb_sides mccPoreH44_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 39228 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH45. */
  SIG_MESSAGE("PoreH45 (Init)");
#define mccompcurname  PoreH45
#define mccompcurtype  Pore_h_group
#define mccompcurindex 148
#define nLeft mccPoreH45_nLeft
#define nRight mccPoreH45_nRight
#define nExit mccPoreH45_nExit
#define wLeft mccPoreH45_wLeft
#define wRight mccPoreH45_wRight
#define wExit mccPoreH45_wExit
#define wall mccPoreH45_wall
#define nTop mccPoreH45_nTop
#define nBottom mccPoreH45_nBottom
#define zexit mccPoreH45_zexit
#define zentry mccPoreH45_zentry
#define intersect_wolterI mccPoreH45_intersect_wolterI
#define reflec_side_table mccPoreH45_reflec_side_table
#define reflec_top_table mccPoreH45_reflec_top_table
#define reflec_bottom_table mccPoreH45_reflec_bottom_table
#define ref_prms mccPoreH45_ref_prms
#define radius_m mccPoreH45_radius_m
#define radius_h mccPoreH45_radius_h
#define Z0 mccPoreH45_Z0
#define xwidth mccPoreH45_xwidth
#define yheight mccPoreH45_yheight
#define chamferwidth mccPoreH45_chamferwidth
#define mirror_reflec mccPoreH45_mirror_reflec
#define bottom_reflec mccPoreH45_bottom_reflec
#define side_reflec mccPoreH45_side_reflec
#define R_d mccPoreH45_R_d
#define absorb_sides mccPoreH45_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 39393 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH46. */
  SIG_MESSAGE("PoreH46 (Init)");
#define mccompcurname  PoreH46
#define mccompcurtype  Pore_h_group
#define mccompcurindex 149
#define nLeft mccPoreH46_nLeft
#define nRight mccPoreH46_nRight
#define nExit mccPoreH46_nExit
#define wLeft mccPoreH46_wLeft
#define wRight mccPoreH46_wRight
#define wExit mccPoreH46_wExit
#define wall mccPoreH46_wall
#define nTop mccPoreH46_nTop
#define nBottom mccPoreH46_nBottom
#define zexit mccPoreH46_zexit
#define zentry mccPoreH46_zentry
#define intersect_wolterI mccPoreH46_intersect_wolterI
#define reflec_side_table mccPoreH46_reflec_side_table
#define reflec_top_table mccPoreH46_reflec_top_table
#define reflec_bottom_table mccPoreH46_reflec_bottom_table
#define ref_prms mccPoreH46_ref_prms
#define radius_m mccPoreH46_radius_m
#define radius_h mccPoreH46_radius_h
#define Z0 mccPoreH46_Z0
#define xwidth mccPoreH46_xwidth
#define yheight mccPoreH46_yheight
#define chamferwidth mccPoreH46_chamferwidth
#define mirror_reflec mccPoreH46_mirror_reflec
#define bottom_reflec mccPoreH46_bottom_reflec
#define side_reflec mccPoreH46_side_reflec
#define R_d mccPoreH46_R_d
#define absorb_sides mccPoreH46_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 39558 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH47. */
  SIG_MESSAGE("PoreH47 (Init)");
#define mccompcurname  PoreH47
#define mccompcurtype  Pore_h_group
#define mccompcurindex 150
#define nLeft mccPoreH47_nLeft
#define nRight mccPoreH47_nRight
#define nExit mccPoreH47_nExit
#define wLeft mccPoreH47_wLeft
#define wRight mccPoreH47_wRight
#define wExit mccPoreH47_wExit
#define wall mccPoreH47_wall
#define nTop mccPoreH47_nTop
#define nBottom mccPoreH47_nBottom
#define zexit mccPoreH47_zexit
#define zentry mccPoreH47_zentry
#define intersect_wolterI mccPoreH47_intersect_wolterI
#define reflec_side_table mccPoreH47_reflec_side_table
#define reflec_top_table mccPoreH47_reflec_top_table
#define reflec_bottom_table mccPoreH47_reflec_bottom_table
#define ref_prms mccPoreH47_ref_prms
#define radius_m mccPoreH47_radius_m
#define radius_h mccPoreH47_radius_h
#define Z0 mccPoreH47_Z0
#define xwidth mccPoreH47_xwidth
#define yheight mccPoreH47_yheight
#define chamferwidth mccPoreH47_chamferwidth
#define mirror_reflec mccPoreH47_mirror_reflec
#define bottom_reflec mccPoreH47_bottom_reflec
#define side_reflec mccPoreH47_side_reflec
#define R_d mccPoreH47_R_d
#define absorb_sides mccPoreH47_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 39723 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PoreH48. */
  SIG_MESSAGE("PoreH48 (Init)");
#define mccompcurname  PoreH48
#define mccompcurtype  Pore_h_group
#define mccompcurindex 151
#define nLeft mccPoreH48_nLeft
#define nRight mccPoreH48_nRight
#define nExit mccPoreH48_nExit
#define wLeft mccPoreH48_wLeft
#define wRight mccPoreH48_wRight
#define wExit mccPoreH48_wExit
#define wall mccPoreH48_wall
#define nTop mccPoreH48_nTop
#define nBottom mccPoreH48_nBottom
#define zexit mccPoreH48_zexit
#define zentry mccPoreH48_zentry
#define intersect_wolterI mccPoreH48_intersect_wolterI
#define reflec_side_table mccPoreH48_reflec_side_table
#define reflec_top_table mccPoreH48_reflec_top_table
#define reflec_bottom_table mccPoreH48_reflec_bottom_table
#define ref_prms mccPoreH48_ref_prms
#define radius_m mccPoreH48_radius_m
#define radius_h mccPoreH48_radius_h
#define Z0 mccPoreH48_Z0
#define xwidth mccPoreH48_xwidth
#define yheight mccPoreH48_yheight
#define chamferwidth mccPoreH48_chamferwidth
#define mirror_reflec mccPoreH48_mirror_reflec
#define bottom_reflec mccPoreH48_bottom_reflec
#define side_reflec mccPoreH48_side_reflec
#define R_d mccPoreH48_R_d
#define absorb_sides mccPoreH48_absorb_sides
#line 127 "Pore_h_group.comp"
{
    char *filenames[]={mirror_reflec,bottom_reflec,side_reflec};
    t_Table *ref_tables[]={&reflec_top_table,&reflec_bottom_table,&reflec_side_table};
    int i;

    /*read data from files into tables using read_table-lib*/
    for (i=0;i<3;i++){
        char *reflec=filenames[i];
        t_Table *tp=ref_tables[i];
        if (reflec && strlen(reflec)) {
            char **header_parsed;

            /* read 1st block data from file into tp */
            if (Table_Read(tp, reflec, 1) <= 0)
            {
                exit(fprintf(stderr,"Error: %s: cannot read file %s\n",NAME_CURRENT_COMP, reflec));
            }
            header_parsed = Table_ParseHeader(tp->header,
                    "e_min=","e_max=","e_step=","theta_min=","theta_max=","theta_step=",NULL);
            if (header_parsed[0] && header_parsed[1] && header_parsed[2] &&
                    header_parsed[3] && header_parsed[4] && header_parsed[5])
            {
                ref_prms[i].e_min=strtod(header_parsed[0],NULL);
                ref_prms[i].e_max=strtod(header_parsed[1],NULL);
                ref_prms[i].e_step=strtod(header_parsed[2],NULL);
                ref_prms[i].theta_min=strtod(header_parsed[3],NULL);
                ref_prms[i].theta_max=strtod(header_parsed[4],NULL);
                ref_prms[i].theta_step=strtod(header_parsed[5],NULL);
            } else {
                exit(fprintf(stderr,"Error: %s: wrong/missing header line(s) in file %s\n", NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].e_max-ref_prms[i].e_min) == (int)((tp->rows-1)*ref_prms[i].e_step)))
            {
                exit(fprintf(stderr,"Error: %s: e_step does not match e_min and e_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
            if (!((int)(ref_prms[i].theta_max-ref_prms[i].theta_min) == (int)((tp->columns-1)*ref_prms[i].theta_step)))
            {
                exit(fprintf(stderr,"Error: %s: theta_step does not match theta_min and theta_max in file %s\n",NAME_CURRENT_COMP, reflec));
            }
        }
    }

    /* compute some pore parameters for the parabolic or hyperbolic equations*/
    /* the z coordinate of the entry plane*/
    /*assuming the parameter xi==1*/
    double alpha,thetap,thetah,P,d,e,C0;

    alpha=0.25*atan(radius_m/Z0);
    thetap=alpha;
    thetah=alpha*3;
    P=Z0*tan(4*alpha)*tan(thetap);
    d=Z0*tan(4*alpha)*tan(4*alpha-thetah);
    e=cos(4*alpha)*(1+tan(4*alpha)*tan(thetah));
    C0=4*e*e*P*d/(e*e-1);

    /*now solve to get the z-coordinate of the exit plane, assuming radius_m to be bigger.
      from v. speybroeck and Chase: rh^2 = e^2 (d+Z)^2 - Z^2, where z_{mcxtrace}=Z0-Z, since we assume z=0 at the entry of the pore*/
    double A,B,C;
    A=e*e-1;
    B=2*d*e*e;
    C=e*e*d*d -radius_h*radius_h;
    int status=solve_2nd_order(&zexit,NULL,A,B,C);
    if(zexit<0 || !status){
        fprintf(stderr,"couldn't figure out the length of the hyperbolic_pore\n");
        exit(-1);
    }
    /*go to mcxtrace coordinate*/
    zexit=Z0-zexit;
    // printf("%g %g %g %g\n",A,B,C,zexit);
    //intersect_wolterI=intersect_hyperboloid;

    /*the side, entry, and exit planes*/
    double thetawx = xwidth/2.0/radius_m;
    nLeft[0]=cos(thetawx);
    nLeft[1]=-sin(thetawx);
    nLeft[2]=0;
    wLeft[0]=radius_m*sin(thetawx);
    wLeft[1]=0;//radius_m*cos(thetawx);
    wLeft[2]=0;

    nRight[0]=-cos(thetawx);
    nRight[1]=-sin(thetawx);
    nRight[2]=0;
    wRight[0]=-radius_m*sin(thetawx);
    wRight[1]=0;//radius_m*cos(thetawx);
    wRight[2]=0;


    nEntry[0]=0;
    nEntry[1]=0;
    nEntry[2]=1;
    wEntry[0]=wEntry[1]=wEntry[2]=0;

    nExit[0]=0;
    nExit[1]=0;
    nExit[2]=1;
    wExit[0]=wExit[1]=0;
    wExit[2]=zexit;

}
#line 39888 "instruments/plate49.c"
#undef absorb_sides
#undef R_d
#undef side_reflec
#undef bottom_reflec
#undef mirror_reflec
#undef chamferwidth
#undef yheight
#undef xwidth
#undef Z0
#undef radius_h
#undef radius_m
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component monitorAfter. */
  SIG_MESSAGE("monitorAfter (Init)");
#define mccompcurname  monitorAfter
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 152
#define nx mccmonitorAfter_nx
#define ny mccmonitorAfter_ny
#define nr mccmonitorAfter_nr
#define filename mccmonitorAfter_filename
#define restore_xray mccmonitorAfter_restore_xray
#define PSD_N mccmonitorAfter_PSD_N
#define PSD_p mccmonitorAfter_PSD_p
#define PSD_p2 mccmonitorAfter_PSD_p2
#define posx mccmonitorAfter_posx
#define posy mccmonitorAfter_posy
#define xmin mccmonitorAfter_xmin
#define xmax mccmonitorAfter_xmax
#define ymin mccmonitorAfter_ymin
#define ymax mccmonitorAfter_ymax
#define xwidth mccmonitorAfter_xwidth
#define yheight mccmonitorAfter_yheight
#define radius mccmonitorAfter_radius
#line 69 "PSD_monitor_ext.comp"
{
    int i,j;
    double *p1,*p2,*p3;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ( ((xmin >= xmax) || (ymin >= ymax)) && !radius ) {
            printf("PSD_monitor: %s: Null detection area !\n"
                "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax,radius). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }
    if(!radius){
      p1=calloc(nx*ny,sizeof(double));
      p2=calloc(nx*ny,sizeof(double));
      p3=calloc(nx*ny,sizeof(double));

      PSD_N=calloc(nx,sizeof(double *));
      PSD_p=calloc(nx,sizeof(double *));
      PSD_p2=calloc(nx,sizeof(double *));

      for (i=0; i<nx; i++){
        PSD_N[i]=&(p1[i*ny]);//calloc(ny,sizeof(double));
        PSD_p[i]=&(p2[i*ny]);//calloc(ny,sizeof(double));
        PSD_p2[i]=&(p3[i*ny]);//calloc(ny,sizeof(double));
      }
    }else{
      PSD_N=calloc(1,sizeof(double *));
      PSD_p=calloc(1,sizeof(double *));
      PSD_p2=calloc(1,sizeof(double *));
      *PSD_N=calloc(nr,sizeof(double));
      *PSD_p=calloc(nr,sizeof(double));
      *PSD_p2=calloc(nr,sizeof(double));
    }

}
#line 39980 "instruments/plate49.c"
#undef radius
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component endMonitorWide. */
  SIG_MESSAGE("endMonitorWide (Init)");
#define mccompcurname  endMonitorWide
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 153
#define nx mccendMonitorWide_nx
#define ny mccendMonitorWide_ny
#define nr mccendMonitorWide_nr
#define filename mccendMonitorWide_filename
#define restore_xray mccendMonitorWide_restore_xray
#define PSD_N mccendMonitorWide_PSD_N
#define PSD_p mccendMonitorWide_PSD_p
#define PSD_p2 mccendMonitorWide_PSD_p2
#define posx mccendMonitorWide_posx
#define posy mccendMonitorWide_posy
#define xmin mccendMonitorWide_xmin
#define xmax mccendMonitorWide_xmax
#define ymin mccendMonitorWide_ymin
#define ymax mccendMonitorWide_ymax
#define xwidth mccendMonitorWide_xwidth
#define yheight mccendMonitorWide_yheight
#define radius mccendMonitorWide_radius
#line 69 "PSD_monitor_ext.comp"
{
    int i,j;
    double *p1,*p2,*p3;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ( ((xmin >= xmax) || (ymin >= ymax)) && !radius ) {
            printf("PSD_monitor: %s: Null detection area !\n"
                "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax,radius). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }
    if(!radius){
      p1=calloc(nx*ny,sizeof(double));
      p2=calloc(nx*ny,sizeof(double));
      p3=calloc(nx*ny,sizeof(double));

      PSD_N=calloc(nx,sizeof(double *));
      PSD_p=calloc(nx,sizeof(double *));
      PSD_p2=calloc(nx,sizeof(double *));

      for (i=0; i<nx; i++){
        PSD_N[i]=&(p1[i*ny]);//calloc(ny,sizeof(double));
        PSD_p[i]=&(p2[i*ny]);//calloc(ny,sizeof(double));
        PSD_p2[i]=&(p3[i*ny]);//calloc(ny,sizeof(double));
      }
    }else{
      PSD_N=calloc(1,sizeof(double *));
      PSD_p=calloc(1,sizeof(double *));
      PSD_p2=calloc(1,sizeof(double *));
      *PSD_N=calloc(nr,sizeof(double));
      *PSD_p=calloc(nr,sizeof(double));
      *PSD_p2=calloc(nr,sizeof(double));
    }

}
#line 40062 "instruments/plate49.c"
#undef radius
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if(mcdotrace) mcdisplay();
    mcDEBUG_INSTR_END()
  }

} /* end init */

void mcraytrace(void) {
  /* Copy xray state to local variables. */
  MCNUM mcnlx = mcnx;
  MCNUM mcnly = mcny;
  MCNUM mcnlz = mcnz;
  MCNUM mcnlkx = mcnkx;
  MCNUM mcnlky = mcnky;
  MCNUM mcnlkz = mcnkz;
  MCNUM mcnlphi = mcnphi;
  MCNUM mcnlt = mcnt;
  MCNUM mcnlEx = mcnEx;
  MCNUM mcnlEy = mcnEy;
  MCNUM mcnlEz = mcnEz;
  MCNUM mcnlp = mcnp;

  mcDEBUG_ENTER()
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
/* Set Component group definitions (flags) */
  mcGroupparabolic=0; /* equals index of scattering comp when in group */
  mcGrouphyperbolic=0; /* equals index of scattering comp when in group */
#define mcabsorb mcabsorbAll
  /* TRACE Component origin [1] */
  mccoordschange(mcposrorigin, mcrotrorigin,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component origin (without coords transformations) */
  mcJumpTrace_origin:
  SIG_MESSAGE("origin (Trace)");
  mcDEBUG_COMP("origin")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbComporigin
  STORE_XRAY(1,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[1]++;
  mcPCounter[1] += p;
  mcP2Counter[1] += p*p;
#define mccompcurname  origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define profile mccorigin_profile
#define IntermediateCnts mccorigin_IntermediateCnts
#define StartTime mccorigin_StartTime
#define EndTime mccorigin_EndTime
{   /* Declarations of origin=Progress_bar() SETTING parameters. */
MCNUM percent = mccorigin_percent;
MCNUM flag_save = mccorigin_flag_save;
MCNUM minutes = mccorigin_minutes;
#line 71 "/usr/share/mcxtrace/1.4/misc/Progress_bar.comp"
{
  double ncount;
  ncount = mcget_run_num();
  if (!StartTime) {
    time(&StartTime); /* compute starting time */
    IntermediateCnts = 1e3;
  }
  time_t NowTime;
  time(&NowTime);
  if (!EndTime && ncount >= IntermediateCnts) {
    CurrentTime = NowTime;
    if (difftime(NowTime,StartTime) > 10) { /* wait 10 sec before writing ETA */
      EndTime = StartTime + (time_t)(difftime(NowTime,StartTime)
				     *(double)mcget_ncount()/ncount);
      IntermediateCnts = 0;
      fprintf(stdout, "\nTrace ETA ");
      if (difftime(EndTime,StartTime) < 60.0)
        fprintf(stdout, "%g [s] %% ", difftime(EndTime,StartTime));
      else if (difftime(EndTime,StartTime) > 3600.0)
        fprintf(stdout, "%g [h] %% ", difftime(EndTime,StartTime)/3600.0);
      else
        fprintf(stdout, "%g [min] %% ", difftime(EndTime,StartTime)/60.0);
    } else IntermediateCnts += 1e3;
    fflush(stdout);
  }

  if (EndTime &&
    (    (minutes && difftime(NowTime,CurrentTime) > minutes*60)
      || (percent && !minutes && ncount >= IntermediateCnts))   )
  {
    fprintf(stdout, "%d ", (int)(ncount*100/mcget_ncount())); fflush(stdout);
    CurrentTime = NowTime;
    IntermediateCnts = ncount + percent*mcget_ncount()/100;
    if (IntermediateCnts >= mcget_ncount()) fprintf(stdout, "\n");
    if (flag_save) mcsave(NULL);
  }
}
#line 40232 "instruments/plate49.c"
/* 'origin=Progress_bar()' component instance extend code */
    SIG_MESSAGE("origin (Trace:Extend)");
#line 201 "instruments/plate49.instr"
    photonCount++;
    enteredPore = 0;
    bufferAddNewPhoton();
#line 40239 "instruments/plate49.c"
}   /* End of origin=Progress_bar() SETTING parameter declarations. */
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef profile
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbComporigin:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(1,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component ThetaArm [2] */
  mccoordschange(mcposrThetaArm, mcrotrThetaArm,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component ThetaArm (without coords transformations) */
  mcJumpTrace_ThetaArm:
  SIG_MESSAGE("ThetaArm (Trace)");
  mcDEBUG_COMP("ThetaArm")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompThetaArm
  STORE_XRAY(2,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[2]++;
  mcPCounter[2] += p;
  mcP2Counter[2] += p*p;
#define mccompcurname  ThetaArm
#define mccompcurtype  Arm
#define mccompcurindex 2
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompThetaArm:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(2,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component srcDirectional [3] */
  mccoordschange(mcposrsrcDirectional, mcrotrsrcDirectional,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component srcDirectional (without coords transformations) */
  mcJumpTrace_srcDirectional:
  SIG_MESSAGE("srcDirectional (Trace)");
  mcDEBUG_COMP("srcDirectional")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsrcDirectional
  STORE_XRAY(3,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[3]++;
  mcPCounter[3] += p;
  mcP2Counter[3] += p*p;
#define mccompcurname  srcDirectional
#define mccompcurtype  Source_div
#define mccompcurindex 3
#define spectrum_file mccsrcDirectional_spectrum_file
#define prms mccsrcDirectional_prms
#define p_init mccsrcDirectional_p_init
#define dist mccsrcDirectional_dist
{   /* Declarations of srcDirectional=Source_div() SETTING parameters. */
MCNUM xwidth = mccsrcDirectional_xwidth;
MCNUM yheight = mccsrcDirectional_yheight;
MCNUM focus_aw = mccsrcDirectional_focus_aw;
MCNUM focus_ah = mccsrcDirectional_focus_ah;
MCNUM E0 = mccsrcDirectional_E0;
MCNUM dE = mccsrcDirectional_dE;
MCNUM lambda0 = mccsrcDirectional_lambda0;
MCNUM dlambda = mccsrcDirectional_dlambda;
MCNUM flux = mccsrcDirectional_flux;
MCNUM gauss = mccsrcDirectional_gauss;
MCNUM gauss_a = mccsrcDirectional_gauss_a;
MCNUM randomphase = mccsrcDirectional_randomphase;
MCNUM phase = mccsrcDirectional_phase;
/* 'srcDirectional=Source_div()' component instance has conditional execution */
if (( mcipsource_type == 0 ))

#line 118 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
{
  double kk,theta_x,theta_y,l,e,k;
  p=prms.pmul;
  if (!gauss_a){ 
    theta_x=(rand01()-0.5)*focus_aw;
    theta_y=(rand01()-0.5)*focus_ah;
  }else{
    theta_x=randnorm()*focus_aw;
    theta_y=randnorm()*focus_ah;
  }
  x=prms.xmin+rand01()*xwidth;
  y=prms.ymin+rand01()*yheight;
  z=0;

  if (spectrum_file){
    double pp=0;
    while (pp<=0){ 
      l=prms.T.data[0]+ (prms.T.data[(prms.T.rows-1)*prms.T.columns] -prms.T.data[0])*rand01();
      pp=Table_Value(prms.T,l,1);
    }
    p*=pp;
    /*if E0!=0 the tabled value is assumed to energy in keV*/
    if (E0!=0){
      k=E2K*l;
    }else{
      k=(2*M_PI/l);
    }
  }else if (E0){
    if(!dE){
      e=E0;
    }else if (gauss){
      e=E0+dE*randnorm();
    }else{
      e=randpm1()*dE + E0;
    }
    k=E2K*e;
  }else if (lambda0){
    if (!dlambda){
      l=lambda0;
    }else if (gauss){
      l=lambda0+dlambda*randnorm();
    }else{
      l=randpm1()*dlambda*0.5 + lambda0;
    }
    k=(2*M_PI/l);
  }

  kx=tan(theta_x);
  ky=tan(theta_y);
  kz=1;
  NORM(kx,ky,kz);

  kx*=k;
  ky*=k;
  kz*=k;

  /*set polarization and phase.*/
  Ex=0;Ey=0;Ez=0;
  if (!randomphase){
    phi=phase;
  }else{
    phi=rand01()*M_2_PI;
  }

  /*set polarization vector*/
  Ex=0;Ey=0;Ez=0;

}
#line 40552 "instruments/plate49.c"
}   /* End of srcDirectional=Source_div() SETTING parameter declarations. */
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompsrcDirectional:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(3,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component srcDirectionalWide [4] */
  mccoordschange(mcposrsrcDirectionalWide, mcrotrsrcDirectionalWide,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component srcDirectionalWide (without coords transformations) */
  mcJumpTrace_srcDirectionalWide:
  SIG_MESSAGE("srcDirectionalWide (Trace)");
  mcDEBUG_COMP("srcDirectionalWide")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsrcDirectionalWide
  STORE_XRAY(4,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[4]++;
  mcPCounter[4] += p;
  mcP2Counter[4] += p*p;
#define mccompcurname  srcDirectionalWide
#define mccompcurtype  Source_div
#define mccompcurindex 4
#define spectrum_file mccsrcDirectionalWide_spectrum_file
#define prms mccsrcDirectionalWide_prms
#define p_init mccsrcDirectionalWide_p_init
#define dist mccsrcDirectionalWide_dist
{   /* Declarations of srcDirectionalWide=Source_div() SETTING parameters. */
MCNUM xwidth = mccsrcDirectionalWide_xwidth;
MCNUM yheight = mccsrcDirectionalWide_yheight;
MCNUM focus_aw = mccsrcDirectionalWide_focus_aw;
MCNUM focus_ah = mccsrcDirectionalWide_focus_ah;
MCNUM E0 = mccsrcDirectionalWide_E0;
MCNUM dE = mccsrcDirectionalWide_dE;
MCNUM lambda0 = mccsrcDirectionalWide_lambda0;
MCNUM dlambda = mccsrcDirectionalWide_dlambda;
MCNUM flux = mccsrcDirectionalWide_flux;
MCNUM gauss = mccsrcDirectionalWide_gauss;
MCNUM gauss_a = mccsrcDirectionalWide_gauss_a;
MCNUM randomphase = mccsrcDirectionalWide_randomphase;
MCNUM phase = mccsrcDirectionalWide_phase;
/* 'srcDirectionalWide=Source_div()' component instance has conditional execution */
if (( mcipsource_type == 1 ))

#line 118 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
{
  double kk,theta_x,theta_y,l,e,k;
  p=prms.pmul;
  if (!gauss_a){ 
    theta_x=(rand01()-0.5)*focus_aw;
    theta_y=(rand01()-0.5)*focus_ah;
  }else{
    theta_x=randnorm()*focus_aw;
    theta_y=randnorm()*focus_ah;
  }
  x=prms.xmin+rand01()*xwidth;
  y=prms.ymin+rand01()*yheight;
  z=0;

  if (spectrum_file){
    double pp=0;
    while (pp<=0){ 
      l=prms.T.data[0]+ (prms.T.data[(prms.T.rows-1)*prms.T.columns] -prms.T.data[0])*rand01();
      pp=Table_Value(prms.T,l,1);
    }
    p*=pp;
    /*if E0!=0 the tabled value is assumed to energy in keV*/
    if (E0!=0){
      k=E2K*l;
    }else{
      k=(2*M_PI/l);
    }
  }else if (E0){
    if(!dE){
      e=E0;
    }else if (gauss){
      e=E0+dE*randnorm();
    }else{
      e=randpm1()*dE + E0;
    }
    k=E2K*e;
  }else if (lambda0){
    if (!dlambda){
      l=lambda0;
    }else if (gauss){
      l=lambda0+dlambda*randnorm();
    }else{
      l=randpm1()*dlambda*0.5 + lambda0;
    }
    k=(2*M_PI/l);
  }

  kx=tan(theta_x);
  ky=tan(theta_y);
  kz=1;
  NORM(kx,ky,kz);

  kx*=k;
  ky*=k;
  kz*=k;

  /*set polarization and phase.*/
  Ex=0;Ey=0;Ez=0;
  if (!randomphase){
    phi=phase;
  }else{
    phi=rand01()*M_2_PI;
  }

  /*set polarization vector*/
  Ex=0;Ey=0;Ez=0;

}
#line 40756 "instruments/plate49.c"
}   /* End of srcDirectionalWide=Source_div() SETTING parameter declarations. */
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompsrcDirectionalWide:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(4,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm0 [5] */
  mccoordschange(mcposrPoreArm0, mcrotrPoreArm0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm0 (without coords transformations) */
  mcJumpTrace_PoreArm0:
  SIG_MESSAGE("PoreArm0 (Trace)");
  mcDEBUG_COMP("PoreArm0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm0
  STORE_XRAY(5,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[5]++;
  mcPCounter[5] += p;
  mcP2Counter[5] += p*p;
#define mccompcurname  PoreArm0
#define mccompcurtype  Arm
#define mccompcurindex 5
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm0:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(5,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm1 [6] */
  mccoordschange(mcposrPoreArm1, mcrotrPoreArm1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm1 (without coords transformations) */
  mcJumpTrace_PoreArm1:
  SIG_MESSAGE("PoreArm1 (Trace)");
  mcDEBUG_COMP("PoreArm1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm1
  STORE_XRAY(6,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[6]++;
  mcPCounter[6] += p;
  mcP2Counter[6] += p*p;
#define mccompcurname  PoreArm1
#define mccompcurtype  Arm
#define mccompcurindex 6
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm1:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(6,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm2 [7] */
  mccoordschange(mcposrPoreArm2, mcrotrPoreArm2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm2 (without coords transformations) */
  mcJumpTrace_PoreArm2:
  SIG_MESSAGE("PoreArm2 (Trace)");
  mcDEBUG_COMP("PoreArm2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm2
  STORE_XRAY(7,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[7]++;
  mcPCounter[7] += p;
  mcP2Counter[7] += p*p;
#define mccompcurname  PoreArm2
#define mccompcurtype  Arm
#define mccompcurindex 7
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm2:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(7,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm3 [8] */
  mccoordschange(mcposrPoreArm3, mcrotrPoreArm3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm3 (without coords transformations) */
  mcJumpTrace_PoreArm3:
  SIG_MESSAGE("PoreArm3 (Trace)");
  mcDEBUG_COMP("PoreArm3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm3
  STORE_XRAY(8,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[8]++;
  mcPCounter[8] += p;
  mcP2Counter[8] += p*p;
#define mccompcurname  PoreArm3
#define mccompcurtype  Arm
#define mccompcurindex 8
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm3:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(8,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm4 [9] */
  mccoordschange(mcposrPoreArm4, mcrotrPoreArm4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm4 (without coords transformations) */
  mcJumpTrace_PoreArm4:
  SIG_MESSAGE("PoreArm4 (Trace)");
  mcDEBUG_COMP("PoreArm4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm4
  STORE_XRAY(9,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[9]++;
  mcPCounter[9] += p;
  mcP2Counter[9] += p*p;
#define mccompcurname  PoreArm4
#define mccompcurtype  Arm
#define mccompcurindex 9
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm4:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(9,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm5 [10] */
  mccoordschange(mcposrPoreArm5, mcrotrPoreArm5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm5 (without coords transformations) */
  mcJumpTrace_PoreArm5:
  SIG_MESSAGE("PoreArm5 (Trace)");
  mcDEBUG_COMP("PoreArm5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm5
  STORE_XRAY(10,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[10]++;
  mcPCounter[10] += p;
  mcP2Counter[10] += p*p;
#define mccompcurname  PoreArm5
#define mccompcurtype  Arm
#define mccompcurindex 10
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm5:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(10,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm6 [11] */
  mccoordschange(mcposrPoreArm6, mcrotrPoreArm6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm6 (without coords transformations) */
  mcJumpTrace_PoreArm6:
  SIG_MESSAGE("PoreArm6 (Trace)");
  mcDEBUG_COMP("PoreArm6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm6
  STORE_XRAY(11,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[11]++;
  mcPCounter[11] += p;
  mcP2Counter[11] += p*p;
#define mccompcurname  PoreArm6
#define mccompcurtype  Arm
#define mccompcurindex 11
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm6:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(11,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm7 [12] */
  mccoordschange(mcposrPoreArm7, mcrotrPoreArm7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm7 (without coords transformations) */
  mcJumpTrace_PoreArm7:
  SIG_MESSAGE("PoreArm7 (Trace)");
  mcDEBUG_COMP("PoreArm7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm7
  STORE_XRAY(12,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[12]++;
  mcPCounter[12] += p;
  mcP2Counter[12] += p*p;
#define mccompcurname  PoreArm7
#define mccompcurtype  Arm
#define mccompcurindex 12
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm7:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(12,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm8 [13] */
  mccoordschange(mcposrPoreArm8, mcrotrPoreArm8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm8 (without coords transformations) */
  mcJumpTrace_PoreArm8:
  SIG_MESSAGE("PoreArm8 (Trace)");
  mcDEBUG_COMP("PoreArm8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm8
  STORE_XRAY(13,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[13]++;
  mcPCounter[13] += p;
  mcP2Counter[13] += p*p;
#define mccompcurname  PoreArm8
#define mccompcurtype  Arm
#define mccompcurindex 13
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm8:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(13,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm9 [14] */
  mccoordschange(mcposrPoreArm9, mcrotrPoreArm9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm9 (without coords transformations) */
  mcJumpTrace_PoreArm9:
  SIG_MESSAGE("PoreArm9 (Trace)");
  mcDEBUG_COMP("PoreArm9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm9
  STORE_XRAY(14,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[14]++;
  mcPCounter[14] += p;
  mcP2Counter[14] += p*p;
#define mccompcurname  PoreArm9
#define mccompcurtype  Arm
#define mccompcurindex 14
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm9:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(14,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm10 [15] */
  mccoordschange(mcposrPoreArm10, mcrotrPoreArm10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm10 (without coords transformations) */
  mcJumpTrace_PoreArm10:
  SIG_MESSAGE("PoreArm10 (Trace)");
  mcDEBUG_COMP("PoreArm10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm10
  STORE_XRAY(15,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[15]++;
  mcPCounter[15] += p;
  mcP2Counter[15] += p*p;
#define mccompcurname  PoreArm10
#define mccompcurtype  Arm
#define mccompcurindex 15
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm10:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(15,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm11 [16] */
  mccoordschange(mcposrPoreArm11, mcrotrPoreArm11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm11 (without coords transformations) */
  mcJumpTrace_PoreArm11:
  SIG_MESSAGE("PoreArm11 (Trace)");
  mcDEBUG_COMP("PoreArm11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm11
  STORE_XRAY(16,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[16]++;
  mcPCounter[16] += p;
  mcP2Counter[16] += p*p;
#define mccompcurname  PoreArm11
#define mccompcurtype  Arm
#define mccompcurindex 16
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm11:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(16,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm12 [17] */
  mccoordschange(mcposrPoreArm12, mcrotrPoreArm12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm12 (without coords transformations) */
  mcJumpTrace_PoreArm12:
  SIG_MESSAGE("PoreArm12 (Trace)");
  mcDEBUG_COMP("PoreArm12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm12
  STORE_XRAY(17,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[17]++;
  mcPCounter[17] += p;
  mcP2Counter[17] += p*p;
#define mccompcurname  PoreArm12
#define mccompcurtype  Arm
#define mccompcurindex 17
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm12:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(17,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm13 [18] */
  mccoordschange(mcposrPoreArm13, mcrotrPoreArm13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm13 (without coords transformations) */
  mcJumpTrace_PoreArm13:
  SIG_MESSAGE("PoreArm13 (Trace)");
  mcDEBUG_COMP("PoreArm13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm13
  STORE_XRAY(18,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[18]++;
  mcPCounter[18] += p;
  mcP2Counter[18] += p*p;
#define mccompcurname  PoreArm13
#define mccompcurtype  Arm
#define mccompcurindex 18
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm13:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(18,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm14 [19] */
  mccoordschange(mcposrPoreArm14, mcrotrPoreArm14,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm14 (without coords transformations) */
  mcJumpTrace_PoreArm14:
  SIG_MESSAGE("PoreArm14 (Trace)");
  mcDEBUG_COMP("PoreArm14")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm14
  STORE_XRAY(19,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[19]++;
  mcPCounter[19] += p;
  mcP2Counter[19] += p*p;
#define mccompcurname  PoreArm14
#define mccompcurtype  Arm
#define mccompcurindex 19
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm14:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(19,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm15 [20] */
  mccoordschange(mcposrPoreArm15, mcrotrPoreArm15,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm15 (without coords transformations) */
  mcJumpTrace_PoreArm15:
  SIG_MESSAGE("PoreArm15 (Trace)");
  mcDEBUG_COMP("PoreArm15")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm15
  STORE_XRAY(20,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[20]++;
  mcPCounter[20] += p;
  mcP2Counter[20] += p*p;
#define mccompcurname  PoreArm15
#define mccompcurtype  Arm
#define mccompcurindex 20
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm15:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(20,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm16 [21] */
  mccoordschange(mcposrPoreArm16, mcrotrPoreArm16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm16 (without coords transformations) */
  mcJumpTrace_PoreArm16:
  SIG_MESSAGE("PoreArm16 (Trace)");
  mcDEBUG_COMP("PoreArm16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm16
  STORE_XRAY(21,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[21]++;
  mcPCounter[21] += p;
  mcP2Counter[21] += p*p;
#define mccompcurname  PoreArm16
#define mccompcurtype  Arm
#define mccompcurindex 21
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm16:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(21,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm17 [22] */
  mccoordschange(mcposrPoreArm17, mcrotrPoreArm17,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm17 (without coords transformations) */
  mcJumpTrace_PoreArm17:
  SIG_MESSAGE("PoreArm17 (Trace)");
  mcDEBUG_COMP("PoreArm17")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm17
  STORE_XRAY(22,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[22]++;
  mcPCounter[22] += p;
  mcP2Counter[22] += p*p;
#define mccompcurname  PoreArm17
#define mccompcurtype  Arm
#define mccompcurindex 22
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm17:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(22,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm18 [23] */
  mccoordschange(mcposrPoreArm18, mcrotrPoreArm18,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm18 (without coords transformations) */
  mcJumpTrace_PoreArm18:
  SIG_MESSAGE("PoreArm18 (Trace)");
  mcDEBUG_COMP("PoreArm18")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm18
  STORE_XRAY(23,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[23]++;
  mcPCounter[23] += p;
  mcP2Counter[23] += p*p;
#define mccompcurname  PoreArm18
#define mccompcurtype  Arm
#define mccompcurindex 23
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm18:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(23,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm19 [24] */
  mccoordschange(mcposrPoreArm19, mcrotrPoreArm19,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm19 (without coords transformations) */
  mcJumpTrace_PoreArm19:
  SIG_MESSAGE("PoreArm19 (Trace)");
  mcDEBUG_COMP("PoreArm19")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm19
  STORE_XRAY(24,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[24]++;
  mcPCounter[24] += p;
  mcP2Counter[24] += p*p;
#define mccompcurname  PoreArm19
#define mccompcurtype  Arm
#define mccompcurindex 24
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm19:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(24,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm20 [25] */
  mccoordschange(mcposrPoreArm20, mcrotrPoreArm20,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm20 (without coords transformations) */
  mcJumpTrace_PoreArm20:
  SIG_MESSAGE("PoreArm20 (Trace)");
  mcDEBUG_COMP("PoreArm20")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm20
  STORE_XRAY(25,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[25]++;
  mcPCounter[25] += p;
  mcP2Counter[25] += p*p;
#define mccompcurname  PoreArm20
#define mccompcurtype  Arm
#define mccompcurindex 25
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm20:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(25,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm21 [26] */
  mccoordschange(mcposrPoreArm21, mcrotrPoreArm21,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm21 (without coords transformations) */
  mcJumpTrace_PoreArm21:
  SIG_MESSAGE("PoreArm21 (Trace)");
  mcDEBUG_COMP("PoreArm21")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm21
  STORE_XRAY(26,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[26]++;
  mcPCounter[26] += p;
  mcP2Counter[26] += p*p;
#define mccompcurname  PoreArm21
#define mccompcurtype  Arm
#define mccompcurindex 26
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm21:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(26,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm22 [27] */
  mccoordschange(mcposrPoreArm22, mcrotrPoreArm22,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm22 (without coords transformations) */
  mcJumpTrace_PoreArm22:
  SIG_MESSAGE("PoreArm22 (Trace)");
  mcDEBUG_COMP("PoreArm22")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm22
  STORE_XRAY(27,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[27]++;
  mcPCounter[27] += p;
  mcP2Counter[27] += p*p;
#define mccompcurname  PoreArm22
#define mccompcurtype  Arm
#define mccompcurindex 27
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm22:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(27,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm23 [28] */
  mccoordschange(mcposrPoreArm23, mcrotrPoreArm23,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm23 (without coords transformations) */
  mcJumpTrace_PoreArm23:
  SIG_MESSAGE("PoreArm23 (Trace)");
  mcDEBUG_COMP("PoreArm23")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm23
  STORE_XRAY(28,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[28]++;
  mcPCounter[28] += p;
  mcP2Counter[28] += p*p;
#define mccompcurname  PoreArm23
#define mccompcurtype  Arm
#define mccompcurindex 28
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm23:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(28,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm24 [29] */
  mccoordschange(mcposrPoreArm24, mcrotrPoreArm24,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm24 (without coords transformations) */
  mcJumpTrace_PoreArm24:
  SIG_MESSAGE("PoreArm24 (Trace)");
  mcDEBUG_COMP("PoreArm24")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm24
  STORE_XRAY(29,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[29]++;
  mcPCounter[29] += p;
  mcP2Counter[29] += p*p;
#define mccompcurname  PoreArm24
#define mccompcurtype  Arm
#define mccompcurindex 29
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm24:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(29,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm25 [30] */
  mccoordschange(mcposrPoreArm25, mcrotrPoreArm25,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm25 (without coords transformations) */
  mcJumpTrace_PoreArm25:
  SIG_MESSAGE("PoreArm25 (Trace)");
  mcDEBUG_COMP("PoreArm25")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm25
  STORE_XRAY(30,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[30]++;
  mcPCounter[30] += p;
  mcP2Counter[30] += p*p;
#define mccompcurname  PoreArm25
#define mccompcurtype  Arm
#define mccompcurindex 30
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm25:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(30,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm26 [31] */
  mccoordschange(mcposrPoreArm26, mcrotrPoreArm26,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm26 (without coords transformations) */
  mcJumpTrace_PoreArm26:
  SIG_MESSAGE("PoreArm26 (Trace)");
  mcDEBUG_COMP("PoreArm26")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm26
  STORE_XRAY(31,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[31]++;
  mcPCounter[31] += p;
  mcP2Counter[31] += p*p;
#define mccompcurname  PoreArm26
#define mccompcurtype  Arm
#define mccompcurindex 31
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm26:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(31,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm27 [32] */
  mccoordschange(mcposrPoreArm27, mcrotrPoreArm27,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm27 (without coords transformations) */
  mcJumpTrace_PoreArm27:
  SIG_MESSAGE("PoreArm27 (Trace)");
  mcDEBUG_COMP("PoreArm27")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm27
  STORE_XRAY(32,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[32]++;
  mcPCounter[32] += p;
  mcP2Counter[32] += p*p;
#define mccompcurname  PoreArm27
#define mccompcurtype  Arm
#define mccompcurindex 32
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm27:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(32,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm28 [33] */
  mccoordschange(mcposrPoreArm28, mcrotrPoreArm28,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm28 (without coords transformations) */
  mcJumpTrace_PoreArm28:
  SIG_MESSAGE("PoreArm28 (Trace)");
  mcDEBUG_COMP("PoreArm28")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm28
  STORE_XRAY(33,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[33]++;
  mcPCounter[33] += p;
  mcP2Counter[33] += p*p;
#define mccompcurname  PoreArm28
#define mccompcurtype  Arm
#define mccompcurindex 33
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm28:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(33,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm29 [34] */
  mccoordschange(mcposrPoreArm29, mcrotrPoreArm29,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm29 (without coords transformations) */
  mcJumpTrace_PoreArm29:
  SIG_MESSAGE("PoreArm29 (Trace)");
  mcDEBUG_COMP("PoreArm29")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm29
  STORE_XRAY(34,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[34]++;
  mcPCounter[34] += p;
  mcP2Counter[34] += p*p;
#define mccompcurname  PoreArm29
#define mccompcurtype  Arm
#define mccompcurindex 34
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm29:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(34,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm30 [35] */
  mccoordschange(mcposrPoreArm30, mcrotrPoreArm30,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm30 (without coords transformations) */
  mcJumpTrace_PoreArm30:
  SIG_MESSAGE("PoreArm30 (Trace)");
  mcDEBUG_COMP("PoreArm30")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm30
  STORE_XRAY(35,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[35]++;
  mcPCounter[35] += p;
  mcP2Counter[35] += p*p;
#define mccompcurname  PoreArm30
#define mccompcurtype  Arm
#define mccompcurindex 35
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm30:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(35,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm31 [36] */
  mccoordschange(mcposrPoreArm31, mcrotrPoreArm31,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm31 (without coords transformations) */
  mcJumpTrace_PoreArm31:
  SIG_MESSAGE("PoreArm31 (Trace)");
  mcDEBUG_COMP("PoreArm31")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm31
  STORE_XRAY(36,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[36]++;
  mcPCounter[36] += p;
  mcP2Counter[36] += p*p;
#define mccompcurname  PoreArm31
#define mccompcurtype  Arm
#define mccompcurindex 36
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm31:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(36,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm32 [37] */
  mccoordschange(mcposrPoreArm32, mcrotrPoreArm32,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm32 (without coords transformations) */
  mcJumpTrace_PoreArm32:
  SIG_MESSAGE("PoreArm32 (Trace)");
  mcDEBUG_COMP("PoreArm32")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm32
  STORE_XRAY(37,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[37]++;
  mcPCounter[37] += p;
  mcP2Counter[37] += p*p;
#define mccompcurname  PoreArm32
#define mccompcurtype  Arm
#define mccompcurindex 37
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm32:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(37,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm33 [38] */
  mccoordschange(mcposrPoreArm33, mcrotrPoreArm33,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm33 (without coords transformations) */
  mcJumpTrace_PoreArm33:
  SIG_MESSAGE("PoreArm33 (Trace)");
  mcDEBUG_COMP("PoreArm33")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm33
  STORE_XRAY(38,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[38]++;
  mcPCounter[38] += p;
  mcP2Counter[38] += p*p;
#define mccompcurname  PoreArm33
#define mccompcurtype  Arm
#define mccompcurindex 38
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm33:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(38,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm34 [39] */
  mccoordschange(mcposrPoreArm34, mcrotrPoreArm34,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm34 (without coords transformations) */
  mcJumpTrace_PoreArm34:
  SIG_MESSAGE("PoreArm34 (Trace)");
  mcDEBUG_COMP("PoreArm34")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm34
  STORE_XRAY(39,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[39]++;
  mcPCounter[39] += p;
  mcP2Counter[39] += p*p;
#define mccompcurname  PoreArm34
#define mccompcurtype  Arm
#define mccompcurindex 39
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm34:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(39,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm35 [40] */
  mccoordschange(mcposrPoreArm35, mcrotrPoreArm35,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm35 (without coords transformations) */
  mcJumpTrace_PoreArm35:
  SIG_MESSAGE("PoreArm35 (Trace)");
  mcDEBUG_COMP("PoreArm35")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm35
  STORE_XRAY(40,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[40]++;
  mcPCounter[40] += p;
  mcP2Counter[40] += p*p;
#define mccompcurname  PoreArm35
#define mccompcurtype  Arm
#define mccompcurindex 40
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm35:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(40,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm36 [41] */
  mccoordschange(mcposrPoreArm36, mcrotrPoreArm36,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm36 (without coords transformations) */
  mcJumpTrace_PoreArm36:
  SIG_MESSAGE("PoreArm36 (Trace)");
  mcDEBUG_COMP("PoreArm36")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm36
  STORE_XRAY(41,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[41]++;
  mcPCounter[41] += p;
  mcP2Counter[41] += p*p;
#define mccompcurname  PoreArm36
#define mccompcurtype  Arm
#define mccompcurindex 41
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm36:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(41,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm37 [42] */
  mccoordschange(mcposrPoreArm37, mcrotrPoreArm37,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm37 (without coords transformations) */
  mcJumpTrace_PoreArm37:
  SIG_MESSAGE("PoreArm37 (Trace)");
  mcDEBUG_COMP("PoreArm37")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm37
  STORE_XRAY(42,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[42]++;
  mcPCounter[42] += p;
  mcP2Counter[42] += p*p;
#define mccompcurname  PoreArm37
#define mccompcurtype  Arm
#define mccompcurindex 42
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm37:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(42,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm38 [43] */
  mccoordschange(mcposrPoreArm38, mcrotrPoreArm38,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm38 (without coords transformations) */
  mcJumpTrace_PoreArm38:
  SIG_MESSAGE("PoreArm38 (Trace)");
  mcDEBUG_COMP("PoreArm38")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm38
  STORE_XRAY(43,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[43]++;
  mcPCounter[43] += p;
  mcP2Counter[43] += p*p;
#define mccompcurname  PoreArm38
#define mccompcurtype  Arm
#define mccompcurindex 43
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm38:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(43,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm39 [44] */
  mccoordschange(mcposrPoreArm39, mcrotrPoreArm39,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm39 (without coords transformations) */
  mcJumpTrace_PoreArm39:
  SIG_MESSAGE("PoreArm39 (Trace)");
  mcDEBUG_COMP("PoreArm39")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm39
  STORE_XRAY(44,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[44]++;
  mcPCounter[44] += p;
  mcP2Counter[44] += p*p;
#define mccompcurname  PoreArm39
#define mccompcurtype  Arm
#define mccompcurindex 44
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm39:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(44,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm40 [45] */
  mccoordschange(mcposrPoreArm40, mcrotrPoreArm40,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm40 (without coords transformations) */
  mcJumpTrace_PoreArm40:
  SIG_MESSAGE("PoreArm40 (Trace)");
  mcDEBUG_COMP("PoreArm40")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm40
  STORE_XRAY(45,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[45]++;
  mcPCounter[45] += p;
  mcP2Counter[45] += p*p;
#define mccompcurname  PoreArm40
#define mccompcurtype  Arm
#define mccompcurindex 45
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm40:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(45,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm41 [46] */
  mccoordschange(mcposrPoreArm41, mcrotrPoreArm41,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm41 (without coords transformations) */
  mcJumpTrace_PoreArm41:
  SIG_MESSAGE("PoreArm41 (Trace)");
  mcDEBUG_COMP("PoreArm41")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm41
  STORE_XRAY(46,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[46]++;
  mcPCounter[46] += p;
  mcP2Counter[46] += p*p;
#define mccompcurname  PoreArm41
#define mccompcurtype  Arm
#define mccompcurindex 46
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm41:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(46,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm42 [47] */
  mccoordschange(mcposrPoreArm42, mcrotrPoreArm42,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm42 (without coords transformations) */
  mcJumpTrace_PoreArm42:
  SIG_MESSAGE("PoreArm42 (Trace)");
  mcDEBUG_COMP("PoreArm42")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm42
  STORE_XRAY(47,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[47]++;
  mcPCounter[47] += p;
  mcP2Counter[47] += p*p;
#define mccompcurname  PoreArm42
#define mccompcurtype  Arm
#define mccompcurindex 47
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm42:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(47,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm43 [48] */
  mccoordschange(mcposrPoreArm43, mcrotrPoreArm43,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm43 (without coords transformations) */
  mcJumpTrace_PoreArm43:
  SIG_MESSAGE("PoreArm43 (Trace)");
  mcDEBUG_COMP("PoreArm43")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm43
  STORE_XRAY(48,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[48]++;
  mcPCounter[48] += p;
  mcP2Counter[48] += p*p;
#define mccompcurname  PoreArm43
#define mccompcurtype  Arm
#define mccompcurindex 48
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm43:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(48,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm44 [49] */
  mccoordschange(mcposrPoreArm44, mcrotrPoreArm44,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm44 (without coords transformations) */
  mcJumpTrace_PoreArm44:
  SIG_MESSAGE("PoreArm44 (Trace)");
  mcDEBUG_COMP("PoreArm44")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm44
  STORE_XRAY(49,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[49]++;
  mcPCounter[49] += p;
  mcP2Counter[49] += p*p;
#define mccompcurname  PoreArm44
#define mccompcurtype  Arm
#define mccompcurindex 49
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm44:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(49,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm45 [50] */
  mccoordschange(mcposrPoreArm45, mcrotrPoreArm45,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm45 (without coords transformations) */
  mcJumpTrace_PoreArm45:
  SIG_MESSAGE("PoreArm45 (Trace)");
  mcDEBUG_COMP("PoreArm45")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm45
  STORE_XRAY(50,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[50]++;
  mcPCounter[50] += p;
  mcP2Counter[50] += p*p;
#define mccompcurname  PoreArm45
#define mccompcurtype  Arm
#define mccompcurindex 50
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm45:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(50,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm46 [51] */
  mccoordschange(mcposrPoreArm46, mcrotrPoreArm46,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm46 (without coords transformations) */
  mcJumpTrace_PoreArm46:
  SIG_MESSAGE("PoreArm46 (Trace)");
  mcDEBUG_COMP("PoreArm46")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm46
  STORE_XRAY(51,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[51]++;
  mcPCounter[51] += p;
  mcP2Counter[51] += p*p;
#define mccompcurname  PoreArm46
#define mccompcurtype  Arm
#define mccompcurindex 51
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm46:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(51,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm47 [52] */
  mccoordschange(mcposrPoreArm47, mcrotrPoreArm47,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm47 (without coords transformations) */
  mcJumpTrace_PoreArm47:
  SIG_MESSAGE("PoreArm47 (Trace)");
  mcDEBUG_COMP("PoreArm47")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm47
  STORE_XRAY(52,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[52]++;
  mcPCounter[52] += p;
  mcP2Counter[52] += p*p;
#define mccompcurname  PoreArm47
#define mccompcurtype  Arm
#define mccompcurindex 52
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm47:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(52,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreArm48 [53] */
  mccoordschange(mcposrPoreArm48, mcrotrPoreArm48,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreArm48 (without coords transformations) */
  mcJumpTrace_PoreArm48:
  SIG_MESSAGE("PoreArm48 (Trace)");
  mcDEBUG_COMP("PoreArm48")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreArm48
  STORE_XRAY(53,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[53]++;
  mcPCounter[53] += p;
  mcP2Counter[53] += p*p;
#define mccompcurname  PoreArm48
#define mccompcurtype  Arm
#define mccompcurindex 53
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompPoreArm48:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(53,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP0 [54] */
  mccoordschange(mcposrPoreP0, mcrotrPoreP0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP0 (without coords transformations) */
  mcJumpTrace_PoreP0:
  SIG_MESSAGE("PoreP0 (Trace)");
  mcDEBUG_COMP("PoreP0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP0
  STORE_XRAY(54,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[54]++;
  mcPCounter[54] += p;
  mcP2Counter[54] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP0
#define mccompcurname  PoreP0
#define mccompcurtype  Pore_p_group
#define mccompcurindex 54
#define nLeft mccPoreP0_nLeft
#define nRight mccPoreP0_nRight
#define nExit mccPoreP0_nExit
#define nTop mccPoreP0_nTop
#define nBottom mccPoreP0_nBottom
#define wLeft mccPoreP0_wLeft
#define wRight mccPoreP0_wRight
#define wExit mccPoreP0_wExit
#define wall mccPoreP0_wall
#define zentry mccPoreP0_zentry
#define reflec_top_table mccPoreP0_reflec_top_table
#define reflec_bottom_table mccPoreP0_reflec_bottom_table
#define reflec_side_table mccPoreP0_reflec_side_table
#define ref_prms mccPoreP0_ref_prms
{   /* Declarations of PoreP0=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP0_radius_p;
MCNUM radius_m = mccPoreP0_radius_m;
MCNUM Z0 = mccPoreP0_Z0;
MCNUM xwidth = mccPoreP0_xwidth;
MCNUM yheight = mccPoreP0_yheight;
MCNUM chamferwidth = mccPoreP0_chamferwidth;
char* mirror_reflec = mccPoreP0_mirror_reflec;
char* bottom_reflec = mccPoreP0_bottom_reflec;
char* side_reflec = mccPoreP0_side_reflec;
MCNUM R_d = mccPoreP0_R_d;
MCNUM absorb_sides = mccPoreP0_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 46385 "instruments/plate49.c"
}   /* End of PoreP0=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP0 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=54;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP0:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP1 [55] */
  mccoordschange(mcposrPoreP1, mcrotrPoreP1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP1 (without coords transformations) */
  mcJumpTrace_PoreP1:
  SIG_MESSAGE("PoreP1 (Trace)");
  mcDEBUG_COMP("PoreP1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP1
  STORE_XRAY(55,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[55]++;
  mcPCounter[55] += p;
  mcP2Counter[55] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP1
#define mccompcurname  PoreP1
#define mccompcurtype  Pore_p_group
#define mccompcurindex 55
#define nLeft mccPoreP1_nLeft
#define nRight mccPoreP1_nRight
#define nExit mccPoreP1_nExit
#define nTop mccPoreP1_nTop
#define nBottom mccPoreP1_nBottom
#define wLeft mccPoreP1_wLeft
#define wRight mccPoreP1_wRight
#define wExit mccPoreP1_wExit
#define wall mccPoreP1_wall
#define zentry mccPoreP1_zentry
#define reflec_top_table mccPoreP1_reflec_top_table
#define reflec_bottom_table mccPoreP1_reflec_bottom_table
#define reflec_side_table mccPoreP1_reflec_side_table
#define ref_prms mccPoreP1_ref_prms
{   /* Declarations of PoreP1=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP1_radius_p;
MCNUM radius_m = mccPoreP1_radius_m;
MCNUM Z0 = mccPoreP1_Z0;
MCNUM xwidth = mccPoreP1_xwidth;
MCNUM yheight = mccPoreP1_yheight;
MCNUM chamferwidth = mccPoreP1_chamferwidth;
char* mirror_reflec = mccPoreP1_mirror_reflec;
char* bottom_reflec = mccPoreP1_bottom_reflec;
char* side_reflec = mccPoreP1_side_reflec;
MCNUM R_d = mccPoreP1_R_d;
MCNUM absorb_sides = mccPoreP1_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 46687 "instruments/plate49.c"
}   /* End of PoreP1=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP1 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=55;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP1:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(55,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP2 [56] */
  mccoordschange(mcposrPoreP2, mcrotrPoreP2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP2 (without coords transformations) */
  mcJumpTrace_PoreP2:
  SIG_MESSAGE("PoreP2 (Trace)");
  mcDEBUG_COMP("PoreP2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP2
  STORE_XRAY(56,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[56]++;
  mcPCounter[56] += p;
  mcP2Counter[56] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP2
#define mccompcurname  PoreP2
#define mccompcurtype  Pore_p_group
#define mccompcurindex 56
#define nLeft mccPoreP2_nLeft
#define nRight mccPoreP2_nRight
#define nExit mccPoreP2_nExit
#define nTop mccPoreP2_nTop
#define nBottom mccPoreP2_nBottom
#define wLeft mccPoreP2_wLeft
#define wRight mccPoreP2_wRight
#define wExit mccPoreP2_wExit
#define wall mccPoreP2_wall
#define zentry mccPoreP2_zentry
#define reflec_top_table mccPoreP2_reflec_top_table
#define reflec_bottom_table mccPoreP2_reflec_bottom_table
#define reflec_side_table mccPoreP2_reflec_side_table
#define ref_prms mccPoreP2_ref_prms
{   /* Declarations of PoreP2=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP2_radius_p;
MCNUM radius_m = mccPoreP2_radius_m;
MCNUM Z0 = mccPoreP2_Z0;
MCNUM xwidth = mccPoreP2_xwidth;
MCNUM yheight = mccPoreP2_yheight;
MCNUM chamferwidth = mccPoreP2_chamferwidth;
char* mirror_reflec = mccPoreP2_mirror_reflec;
char* bottom_reflec = mccPoreP2_bottom_reflec;
char* side_reflec = mccPoreP2_side_reflec;
MCNUM R_d = mccPoreP2_R_d;
MCNUM absorb_sides = mccPoreP2_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 46989 "instruments/plate49.c"
}   /* End of PoreP2=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP2 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=56;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP2:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(56,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP3 [57] */
  mccoordschange(mcposrPoreP3, mcrotrPoreP3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP3 (without coords transformations) */
  mcJumpTrace_PoreP3:
  SIG_MESSAGE("PoreP3 (Trace)");
  mcDEBUG_COMP("PoreP3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP3
  STORE_XRAY(57,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[57]++;
  mcPCounter[57] += p;
  mcP2Counter[57] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP3
#define mccompcurname  PoreP3
#define mccompcurtype  Pore_p_group
#define mccompcurindex 57
#define nLeft mccPoreP3_nLeft
#define nRight mccPoreP3_nRight
#define nExit mccPoreP3_nExit
#define nTop mccPoreP3_nTop
#define nBottom mccPoreP3_nBottom
#define wLeft mccPoreP3_wLeft
#define wRight mccPoreP3_wRight
#define wExit mccPoreP3_wExit
#define wall mccPoreP3_wall
#define zentry mccPoreP3_zentry
#define reflec_top_table mccPoreP3_reflec_top_table
#define reflec_bottom_table mccPoreP3_reflec_bottom_table
#define reflec_side_table mccPoreP3_reflec_side_table
#define ref_prms mccPoreP3_ref_prms
{   /* Declarations of PoreP3=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP3_radius_p;
MCNUM radius_m = mccPoreP3_radius_m;
MCNUM Z0 = mccPoreP3_Z0;
MCNUM xwidth = mccPoreP3_xwidth;
MCNUM yheight = mccPoreP3_yheight;
MCNUM chamferwidth = mccPoreP3_chamferwidth;
char* mirror_reflec = mccPoreP3_mirror_reflec;
char* bottom_reflec = mccPoreP3_bottom_reflec;
char* side_reflec = mccPoreP3_side_reflec;
MCNUM R_d = mccPoreP3_R_d;
MCNUM absorb_sides = mccPoreP3_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 47291 "instruments/plate49.c"
}   /* End of PoreP3=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP3 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=57;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP3:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(57,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP4 [58] */
  mccoordschange(mcposrPoreP4, mcrotrPoreP4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP4 (without coords transformations) */
  mcJumpTrace_PoreP4:
  SIG_MESSAGE("PoreP4 (Trace)");
  mcDEBUG_COMP("PoreP4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP4
  STORE_XRAY(58,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[58]++;
  mcPCounter[58] += p;
  mcP2Counter[58] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP4
#define mccompcurname  PoreP4
#define mccompcurtype  Pore_p_group
#define mccompcurindex 58
#define nLeft mccPoreP4_nLeft
#define nRight mccPoreP4_nRight
#define nExit mccPoreP4_nExit
#define nTop mccPoreP4_nTop
#define nBottom mccPoreP4_nBottom
#define wLeft mccPoreP4_wLeft
#define wRight mccPoreP4_wRight
#define wExit mccPoreP4_wExit
#define wall mccPoreP4_wall
#define zentry mccPoreP4_zentry
#define reflec_top_table mccPoreP4_reflec_top_table
#define reflec_bottom_table mccPoreP4_reflec_bottom_table
#define reflec_side_table mccPoreP4_reflec_side_table
#define ref_prms mccPoreP4_ref_prms
{   /* Declarations of PoreP4=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP4_radius_p;
MCNUM radius_m = mccPoreP4_radius_m;
MCNUM Z0 = mccPoreP4_Z0;
MCNUM xwidth = mccPoreP4_xwidth;
MCNUM yheight = mccPoreP4_yheight;
MCNUM chamferwidth = mccPoreP4_chamferwidth;
char* mirror_reflec = mccPoreP4_mirror_reflec;
char* bottom_reflec = mccPoreP4_bottom_reflec;
char* side_reflec = mccPoreP4_side_reflec;
MCNUM R_d = mccPoreP4_R_d;
MCNUM absorb_sides = mccPoreP4_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 47593 "instruments/plate49.c"
}   /* End of PoreP4=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP4 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=58;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP4:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(58,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP5 [59] */
  mccoordschange(mcposrPoreP5, mcrotrPoreP5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP5 (without coords transformations) */
  mcJumpTrace_PoreP5:
  SIG_MESSAGE("PoreP5 (Trace)");
  mcDEBUG_COMP("PoreP5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP5
  STORE_XRAY(59,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[59]++;
  mcPCounter[59] += p;
  mcP2Counter[59] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP5
#define mccompcurname  PoreP5
#define mccompcurtype  Pore_p_group
#define mccompcurindex 59
#define nLeft mccPoreP5_nLeft
#define nRight mccPoreP5_nRight
#define nExit mccPoreP5_nExit
#define nTop mccPoreP5_nTop
#define nBottom mccPoreP5_nBottom
#define wLeft mccPoreP5_wLeft
#define wRight mccPoreP5_wRight
#define wExit mccPoreP5_wExit
#define wall mccPoreP5_wall
#define zentry mccPoreP5_zentry
#define reflec_top_table mccPoreP5_reflec_top_table
#define reflec_bottom_table mccPoreP5_reflec_bottom_table
#define reflec_side_table mccPoreP5_reflec_side_table
#define ref_prms mccPoreP5_ref_prms
{   /* Declarations of PoreP5=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP5_radius_p;
MCNUM radius_m = mccPoreP5_radius_m;
MCNUM Z0 = mccPoreP5_Z0;
MCNUM xwidth = mccPoreP5_xwidth;
MCNUM yheight = mccPoreP5_yheight;
MCNUM chamferwidth = mccPoreP5_chamferwidth;
char* mirror_reflec = mccPoreP5_mirror_reflec;
char* bottom_reflec = mccPoreP5_bottom_reflec;
char* side_reflec = mccPoreP5_side_reflec;
MCNUM R_d = mccPoreP5_R_d;
MCNUM absorb_sides = mccPoreP5_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 47895 "instruments/plate49.c"
}   /* End of PoreP5=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP5 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=59;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP5:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(59,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP6 [60] */
  mccoordschange(mcposrPoreP6, mcrotrPoreP6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP6 (without coords transformations) */
  mcJumpTrace_PoreP6:
  SIG_MESSAGE("PoreP6 (Trace)");
  mcDEBUG_COMP("PoreP6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP6
  STORE_XRAY(60,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[60]++;
  mcPCounter[60] += p;
  mcP2Counter[60] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP6
#define mccompcurname  PoreP6
#define mccompcurtype  Pore_p_group
#define mccompcurindex 60
#define nLeft mccPoreP6_nLeft
#define nRight mccPoreP6_nRight
#define nExit mccPoreP6_nExit
#define nTop mccPoreP6_nTop
#define nBottom mccPoreP6_nBottom
#define wLeft mccPoreP6_wLeft
#define wRight mccPoreP6_wRight
#define wExit mccPoreP6_wExit
#define wall mccPoreP6_wall
#define zentry mccPoreP6_zentry
#define reflec_top_table mccPoreP6_reflec_top_table
#define reflec_bottom_table mccPoreP6_reflec_bottom_table
#define reflec_side_table mccPoreP6_reflec_side_table
#define ref_prms mccPoreP6_ref_prms
{   /* Declarations of PoreP6=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP6_radius_p;
MCNUM radius_m = mccPoreP6_radius_m;
MCNUM Z0 = mccPoreP6_Z0;
MCNUM xwidth = mccPoreP6_xwidth;
MCNUM yheight = mccPoreP6_yheight;
MCNUM chamferwidth = mccPoreP6_chamferwidth;
char* mirror_reflec = mccPoreP6_mirror_reflec;
char* bottom_reflec = mccPoreP6_bottom_reflec;
char* side_reflec = mccPoreP6_side_reflec;
MCNUM R_d = mccPoreP6_R_d;
MCNUM absorb_sides = mccPoreP6_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 48197 "instruments/plate49.c"
}   /* End of PoreP6=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP6 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=60;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP6:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(60,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP7 [61] */
  mccoordschange(mcposrPoreP7, mcrotrPoreP7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP7 (without coords transformations) */
  mcJumpTrace_PoreP7:
  SIG_MESSAGE("PoreP7 (Trace)");
  mcDEBUG_COMP("PoreP7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP7
  STORE_XRAY(61,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[61]++;
  mcPCounter[61] += p;
  mcP2Counter[61] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP7
#define mccompcurname  PoreP7
#define mccompcurtype  Pore_p_group
#define mccompcurindex 61
#define nLeft mccPoreP7_nLeft
#define nRight mccPoreP7_nRight
#define nExit mccPoreP7_nExit
#define nTop mccPoreP7_nTop
#define nBottom mccPoreP7_nBottom
#define wLeft mccPoreP7_wLeft
#define wRight mccPoreP7_wRight
#define wExit mccPoreP7_wExit
#define wall mccPoreP7_wall
#define zentry mccPoreP7_zentry
#define reflec_top_table mccPoreP7_reflec_top_table
#define reflec_bottom_table mccPoreP7_reflec_bottom_table
#define reflec_side_table mccPoreP7_reflec_side_table
#define ref_prms mccPoreP7_ref_prms
{   /* Declarations of PoreP7=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP7_radius_p;
MCNUM radius_m = mccPoreP7_radius_m;
MCNUM Z0 = mccPoreP7_Z0;
MCNUM xwidth = mccPoreP7_xwidth;
MCNUM yheight = mccPoreP7_yheight;
MCNUM chamferwidth = mccPoreP7_chamferwidth;
char* mirror_reflec = mccPoreP7_mirror_reflec;
char* bottom_reflec = mccPoreP7_bottom_reflec;
char* side_reflec = mccPoreP7_side_reflec;
MCNUM R_d = mccPoreP7_R_d;
MCNUM absorb_sides = mccPoreP7_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 48499 "instruments/plate49.c"
}   /* End of PoreP7=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP7 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=61;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP7:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(61,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP8 [62] */
  mccoordschange(mcposrPoreP8, mcrotrPoreP8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP8 (without coords transformations) */
  mcJumpTrace_PoreP8:
  SIG_MESSAGE("PoreP8 (Trace)");
  mcDEBUG_COMP("PoreP8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP8
  STORE_XRAY(62,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[62]++;
  mcPCounter[62] += p;
  mcP2Counter[62] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP8
#define mccompcurname  PoreP8
#define mccompcurtype  Pore_p_group
#define mccompcurindex 62
#define nLeft mccPoreP8_nLeft
#define nRight mccPoreP8_nRight
#define nExit mccPoreP8_nExit
#define nTop mccPoreP8_nTop
#define nBottom mccPoreP8_nBottom
#define wLeft mccPoreP8_wLeft
#define wRight mccPoreP8_wRight
#define wExit mccPoreP8_wExit
#define wall mccPoreP8_wall
#define zentry mccPoreP8_zentry
#define reflec_top_table mccPoreP8_reflec_top_table
#define reflec_bottom_table mccPoreP8_reflec_bottom_table
#define reflec_side_table mccPoreP8_reflec_side_table
#define ref_prms mccPoreP8_ref_prms
{   /* Declarations of PoreP8=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP8_radius_p;
MCNUM radius_m = mccPoreP8_radius_m;
MCNUM Z0 = mccPoreP8_Z0;
MCNUM xwidth = mccPoreP8_xwidth;
MCNUM yheight = mccPoreP8_yheight;
MCNUM chamferwidth = mccPoreP8_chamferwidth;
char* mirror_reflec = mccPoreP8_mirror_reflec;
char* bottom_reflec = mccPoreP8_bottom_reflec;
char* side_reflec = mccPoreP8_side_reflec;
MCNUM R_d = mccPoreP8_R_d;
MCNUM absorb_sides = mccPoreP8_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 48801 "instruments/plate49.c"
}   /* End of PoreP8=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP8 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=62;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP8:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(62,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP9 [63] */
  mccoordschange(mcposrPoreP9, mcrotrPoreP9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP9 (without coords transformations) */
  mcJumpTrace_PoreP9:
  SIG_MESSAGE("PoreP9 (Trace)");
  mcDEBUG_COMP("PoreP9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP9
  STORE_XRAY(63,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[63]++;
  mcPCounter[63] += p;
  mcP2Counter[63] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP9
#define mccompcurname  PoreP9
#define mccompcurtype  Pore_p_group
#define mccompcurindex 63
#define nLeft mccPoreP9_nLeft
#define nRight mccPoreP9_nRight
#define nExit mccPoreP9_nExit
#define nTop mccPoreP9_nTop
#define nBottom mccPoreP9_nBottom
#define wLeft mccPoreP9_wLeft
#define wRight mccPoreP9_wRight
#define wExit mccPoreP9_wExit
#define wall mccPoreP9_wall
#define zentry mccPoreP9_zentry
#define reflec_top_table mccPoreP9_reflec_top_table
#define reflec_bottom_table mccPoreP9_reflec_bottom_table
#define reflec_side_table mccPoreP9_reflec_side_table
#define ref_prms mccPoreP9_ref_prms
{   /* Declarations of PoreP9=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP9_radius_p;
MCNUM radius_m = mccPoreP9_radius_m;
MCNUM Z0 = mccPoreP9_Z0;
MCNUM xwidth = mccPoreP9_xwidth;
MCNUM yheight = mccPoreP9_yheight;
MCNUM chamferwidth = mccPoreP9_chamferwidth;
char* mirror_reflec = mccPoreP9_mirror_reflec;
char* bottom_reflec = mccPoreP9_bottom_reflec;
char* side_reflec = mccPoreP9_side_reflec;
MCNUM R_d = mccPoreP9_R_d;
MCNUM absorb_sides = mccPoreP9_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 49103 "instruments/plate49.c"
}   /* End of PoreP9=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP9 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=63;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP9:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(63,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP10 [64] */
  mccoordschange(mcposrPoreP10, mcrotrPoreP10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP10 (without coords transformations) */
  mcJumpTrace_PoreP10:
  SIG_MESSAGE("PoreP10 (Trace)");
  mcDEBUG_COMP("PoreP10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP10
  STORE_XRAY(64,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[64]++;
  mcPCounter[64] += p;
  mcP2Counter[64] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP10
#define mccompcurname  PoreP10
#define mccompcurtype  Pore_p_group
#define mccompcurindex 64
#define nLeft mccPoreP10_nLeft
#define nRight mccPoreP10_nRight
#define nExit mccPoreP10_nExit
#define nTop mccPoreP10_nTop
#define nBottom mccPoreP10_nBottom
#define wLeft mccPoreP10_wLeft
#define wRight mccPoreP10_wRight
#define wExit mccPoreP10_wExit
#define wall mccPoreP10_wall
#define zentry mccPoreP10_zentry
#define reflec_top_table mccPoreP10_reflec_top_table
#define reflec_bottom_table mccPoreP10_reflec_bottom_table
#define reflec_side_table mccPoreP10_reflec_side_table
#define ref_prms mccPoreP10_ref_prms
{   /* Declarations of PoreP10=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP10_radius_p;
MCNUM radius_m = mccPoreP10_radius_m;
MCNUM Z0 = mccPoreP10_Z0;
MCNUM xwidth = mccPoreP10_xwidth;
MCNUM yheight = mccPoreP10_yheight;
MCNUM chamferwidth = mccPoreP10_chamferwidth;
char* mirror_reflec = mccPoreP10_mirror_reflec;
char* bottom_reflec = mccPoreP10_bottom_reflec;
char* side_reflec = mccPoreP10_side_reflec;
MCNUM R_d = mccPoreP10_R_d;
MCNUM absorb_sides = mccPoreP10_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 49405 "instruments/plate49.c"
}   /* End of PoreP10=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP10 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=64;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP10:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(64,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP11 [65] */
  mccoordschange(mcposrPoreP11, mcrotrPoreP11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP11 (without coords transformations) */
  mcJumpTrace_PoreP11:
  SIG_MESSAGE("PoreP11 (Trace)");
  mcDEBUG_COMP("PoreP11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP11
  STORE_XRAY(65,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[65]++;
  mcPCounter[65] += p;
  mcP2Counter[65] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP11
#define mccompcurname  PoreP11
#define mccompcurtype  Pore_p_group
#define mccompcurindex 65
#define nLeft mccPoreP11_nLeft
#define nRight mccPoreP11_nRight
#define nExit mccPoreP11_nExit
#define nTop mccPoreP11_nTop
#define nBottom mccPoreP11_nBottom
#define wLeft mccPoreP11_wLeft
#define wRight mccPoreP11_wRight
#define wExit mccPoreP11_wExit
#define wall mccPoreP11_wall
#define zentry mccPoreP11_zentry
#define reflec_top_table mccPoreP11_reflec_top_table
#define reflec_bottom_table mccPoreP11_reflec_bottom_table
#define reflec_side_table mccPoreP11_reflec_side_table
#define ref_prms mccPoreP11_ref_prms
{   /* Declarations of PoreP11=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP11_radius_p;
MCNUM radius_m = mccPoreP11_radius_m;
MCNUM Z0 = mccPoreP11_Z0;
MCNUM xwidth = mccPoreP11_xwidth;
MCNUM yheight = mccPoreP11_yheight;
MCNUM chamferwidth = mccPoreP11_chamferwidth;
char* mirror_reflec = mccPoreP11_mirror_reflec;
char* bottom_reflec = mccPoreP11_bottom_reflec;
char* side_reflec = mccPoreP11_side_reflec;
MCNUM R_d = mccPoreP11_R_d;
MCNUM absorb_sides = mccPoreP11_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 49707 "instruments/plate49.c"
}   /* End of PoreP11=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP11 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=65;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP11:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(65,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP12 [66] */
  mccoordschange(mcposrPoreP12, mcrotrPoreP12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP12 (without coords transformations) */
  mcJumpTrace_PoreP12:
  SIG_MESSAGE("PoreP12 (Trace)");
  mcDEBUG_COMP("PoreP12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP12
  STORE_XRAY(66,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[66]++;
  mcPCounter[66] += p;
  mcP2Counter[66] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP12
#define mccompcurname  PoreP12
#define mccompcurtype  Pore_p_group
#define mccompcurindex 66
#define nLeft mccPoreP12_nLeft
#define nRight mccPoreP12_nRight
#define nExit mccPoreP12_nExit
#define nTop mccPoreP12_nTop
#define nBottom mccPoreP12_nBottom
#define wLeft mccPoreP12_wLeft
#define wRight mccPoreP12_wRight
#define wExit mccPoreP12_wExit
#define wall mccPoreP12_wall
#define zentry mccPoreP12_zentry
#define reflec_top_table mccPoreP12_reflec_top_table
#define reflec_bottom_table mccPoreP12_reflec_bottom_table
#define reflec_side_table mccPoreP12_reflec_side_table
#define ref_prms mccPoreP12_ref_prms
{   /* Declarations of PoreP12=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP12_radius_p;
MCNUM radius_m = mccPoreP12_radius_m;
MCNUM Z0 = mccPoreP12_Z0;
MCNUM xwidth = mccPoreP12_xwidth;
MCNUM yheight = mccPoreP12_yheight;
MCNUM chamferwidth = mccPoreP12_chamferwidth;
char* mirror_reflec = mccPoreP12_mirror_reflec;
char* bottom_reflec = mccPoreP12_bottom_reflec;
char* side_reflec = mccPoreP12_side_reflec;
MCNUM R_d = mccPoreP12_R_d;
MCNUM absorb_sides = mccPoreP12_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 50009 "instruments/plate49.c"
}   /* End of PoreP12=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP12 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=66;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP12:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(66,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP13 [67] */
  mccoordschange(mcposrPoreP13, mcrotrPoreP13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP13 (without coords transformations) */
  mcJumpTrace_PoreP13:
  SIG_MESSAGE("PoreP13 (Trace)");
  mcDEBUG_COMP("PoreP13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP13
  STORE_XRAY(67,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[67]++;
  mcPCounter[67] += p;
  mcP2Counter[67] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP13
#define mccompcurname  PoreP13
#define mccompcurtype  Pore_p_group
#define mccompcurindex 67
#define nLeft mccPoreP13_nLeft
#define nRight mccPoreP13_nRight
#define nExit mccPoreP13_nExit
#define nTop mccPoreP13_nTop
#define nBottom mccPoreP13_nBottom
#define wLeft mccPoreP13_wLeft
#define wRight mccPoreP13_wRight
#define wExit mccPoreP13_wExit
#define wall mccPoreP13_wall
#define zentry mccPoreP13_zentry
#define reflec_top_table mccPoreP13_reflec_top_table
#define reflec_bottom_table mccPoreP13_reflec_bottom_table
#define reflec_side_table mccPoreP13_reflec_side_table
#define ref_prms mccPoreP13_ref_prms
{   /* Declarations of PoreP13=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP13_radius_p;
MCNUM radius_m = mccPoreP13_radius_m;
MCNUM Z0 = mccPoreP13_Z0;
MCNUM xwidth = mccPoreP13_xwidth;
MCNUM yheight = mccPoreP13_yheight;
MCNUM chamferwidth = mccPoreP13_chamferwidth;
char* mirror_reflec = mccPoreP13_mirror_reflec;
char* bottom_reflec = mccPoreP13_bottom_reflec;
char* side_reflec = mccPoreP13_side_reflec;
MCNUM R_d = mccPoreP13_R_d;
MCNUM absorb_sides = mccPoreP13_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 50311 "instruments/plate49.c"
}   /* End of PoreP13=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP13 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=67;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP13:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(67,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP14 [68] */
  mccoordschange(mcposrPoreP14, mcrotrPoreP14,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP14 (without coords transformations) */
  mcJumpTrace_PoreP14:
  SIG_MESSAGE("PoreP14 (Trace)");
  mcDEBUG_COMP("PoreP14")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP14
  STORE_XRAY(68,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[68]++;
  mcPCounter[68] += p;
  mcP2Counter[68] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP14
#define mccompcurname  PoreP14
#define mccompcurtype  Pore_p_group
#define mccompcurindex 68
#define nLeft mccPoreP14_nLeft
#define nRight mccPoreP14_nRight
#define nExit mccPoreP14_nExit
#define nTop mccPoreP14_nTop
#define nBottom mccPoreP14_nBottom
#define wLeft mccPoreP14_wLeft
#define wRight mccPoreP14_wRight
#define wExit mccPoreP14_wExit
#define wall mccPoreP14_wall
#define zentry mccPoreP14_zentry
#define reflec_top_table mccPoreP14_reflec_top_table
#define reflec_bottom_table mccPoreP14_reflec_bottom_table
#define reflec_side_table mccPoreP14_reflec_side_table
#define ref_prms mccPoreP14_ref_prms
{   /* Declarations of PoreP14=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP14_radius_p;
MCNUM radius_m = mccPoreP14_radius_m;
MCNUM Z0 = mccPoreP14_Z0;
MCNUM xwidth = mccPoreP14_xwidth;
MCNUM yheight = mccPoreP14_yheight;
MCNUM chamferwidth = mccPoreP14_chamferwidth;
char* mirror_reflec = mccPoreP14_mirror_reflec;
char* bottom_reflec = mccPoreP14_bottom_reflec;
char* side_reflec = mccPoreP14_side_reflec;
MCNUM R_d = mccPoreP14_R_d;
MCNUM absorb_sides = mccPoreP14_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 50613 "instruments/plate49.c"
}   /* End of PoreP14=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP14 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=68;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP14:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(68,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP15 [69] */
  mccoordschange(mcposrPoreP15, mcrotrPoreP15,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP15 (without coords transformations) */
  mcJumpTrace_PoreP15:
  SIG_MESSAGE("PoreP15 (Trace)");
  mcDEBUG_COMP("PoreP15")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP15
  STORE_XRAY(69,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[69]++;
  mcPCounter[69] += p;
  mcP2Counter[69] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP15
#define mccompcurname  PoreP15
#define mccompcurtype  Pore_p_group
#define mccompcurindex 69
#define nLeft mccPoreP15_nLeft
#define nRight mccPoreP15_nRight
#define nExit mccPoreP15_nExit
#define nTop mccPoreP15_nTop
#define nBottom mccPoreP15_nBottom
#define wLeft mccPoreP15_wLeft
#define wRight mccPoreP15_wRight
#define wExit mccPoreP15_wExit
#define wall mccPoreP15_wall
#define zentry mccPoreP15_zentry
#define reflec_top_table mccPoreP15_reflec_top_table
#define reflec_bottom_table mccPoreP15_reflec_bottom_table
#define reflec_side_table mccPoreP15_reflec_side_table
#define ref_prms mccPoreP15_ref_prms
{   /* Declarations of PoreP15=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP15_radius_p;
MCNUM radius_m = mccPoreP15_radius_m;
MCNUM Z0 = mccPoreP15_Z0;
MCNUM xwidth = mccPoreP15_xwidth;
MCNUM yheight = mccPoreP15_yheight;
MCNUM chamferwidth = mccPoreP15_chamferwidth;
char* mirror_reflec = mccPoreP15_mirror_reflec;
char* bottom_reflec = mccPoreP15_bottom_reflec;
char* side_reflec = mccPoreP15_side_reflec;
MCNUM R_d = mccPoreP15_R_d;
MCNUM absorb_sides = mccPoreP15_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 50915 "instruments/plate49.c"
}   /* End of PoreP15=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP15 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=69;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP15:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(69,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP16 [70] */
  mccoordschange(mcposrPoreP16, mcrotrPoreP16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP16 (without coords transformations) */
  mcJumpTrace_PoreP16:
  SIG_MESSAGE("PoreP16 (Trace)");
  mcDEBUG_COMP("PoreP16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP16
  STORE_XRAY(70,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[70]++;
  mcPCounter[70] += p;
  mcP2Counter[70] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP16
#define mccompcurname  PoreP16
#define mccompcurtype  Pore_p_group
#define mccompcurindex 70
#define nLeft mccPoreP16_nLeft
#define nRight mccPoreP16_nRight
#define nExit mccPoreP16_nExit
#define nTop mccPoreP16_nTop
#define nBottom mccPoreP16_nBottom
#define wLeft mccPoreP16_wLeft
#define wRight mccPoreP16_wRight
#define wExit mccPoreP16_wExit
#define wall mccPoreP16_wall
#define zentry mccPoreP16_zentry
#define reflec_top_table mccPoreP16_reflec_top_table
#define reflec_bottom_table mccPoreP16_reflec_bottom_table
#define reflec_side_table mccPoreP16_reflec_side_table
#define ref_prms mccPoreP16_ref_prms
{   /* Declarations of PoreP16=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP16_radius_p;
MCNUM radius_m = mccPoreP16_radius_m;
MCNUM Z0 = mccPoreP16_Z0;
MCNUM xwidth = mccPoreP16_xwidth;
MCNUM yheight = mccPoreP16_yheight;
MCNUM chamferwidth = mccPoreP16_chamferwidth;
char* mirror_reflec = mccPoreP16_mirror_reflec;
char* bottom_reflec = mccPoreP16_bottom_reflec;
char* side_reflec = mccPoreP16_side_reflec;
MCNUM R_d = mccPoreP16_R_d;
MCNUM absorb_sides = mccPoreP16_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 51217 "instruments/plate49.c"
}   /* End of PoreP16=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP16 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=70;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP16:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(70,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP17 [71] */
  mccoordschange(mcposrPoreP17, mcrotrPoreP17,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP17 (without coords transformations) */
  mcJumpTrace_PoreP17:
  SIG_MESSAGE("PoreP17 (Trace)");
  mcDEBUG_COMP("PoreP17")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP17
  STORE_XRAY(71,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[71]++;
  mcPCounter[71] += p;
  mcP2Counter[71] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP17
#define mccompcurname  PoreP17
#define mccompcurtype  Pore_p_group
#define mccompcurindex 71
#define nLeft mccPoreP17_nLeft
#define nRight mccPoreP17_nRight
#define nExit mccPoreP17_nExit
#define nTop mccPoreP17_nTop
#define nBottom mccPoreP17_nBottom
#define wLeft mccPoreP17_wLeft
#define wRight mccPoreP17_wRight
#define wExit mccPoreP17_wExit
#define wall mccPoreP17_wall
#define zentry mccPoreP17_zentry
#define reflec_top_table mccPoreP17_reflec_top_table
#define reflec_bottom_table mccPoreP17_reflec_bottom_table
#define reflec_side_table mccPoreP17_reflec_side_table
#define ref_prms mccPoreP17_ref_prms
{   /* Declarations of PoreP17=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP17_radius_p;
MCNUM radius_m = mccPoreP17_radius_m;
MCNUM Z0 = mccPoreP17_Z0;
MCNUM xwidth = mccPoreP17_xwidth;
MCNUM yheight = mccPoreP17_yheight;
MCNUM chamferwidth = mccPoreP17_chamferwidth;
char* mirror_reflec = mccPoreP17_mirror_reflec;
char* bottom_reflec = mccPoreP17_bottom_reflec;
char* side_reflec = mccPoreP17_side_reflec;
MCNUM R_d = mccPoreP17_R_d;
MCNUM absorb_sides = mccPoreP17_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 51519 "instruments/plate49.c"
}   /* End of PoreP17=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP17 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=71;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP17:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(71,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP18 [72] */
  mccoordschange(mcposrPoreP18, mcrotrPoreP18,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP18 (without coords transformations) */
  mcJumpTrace_PoreP18:
  SIG_MESSAGE("PoreP18 (Trace)");
  mcDEBUG_COMP("PoreP18")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP18
  STORE_XRAY(72,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[72]++;
  mcPCounter[72] += p;
  mcP2Counter[72] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP18
#define mccompcurname  PoreP18
#define mccompcurtype  Pore_p_group
#define mccompcurindex 72
#define nLeft mccPoreP18_nLeft
#define nRight mccPoreP18_nRight
#define nExit mccPoreP18_nExit
#define nTop mccPoreP18_nTop
#define nBottom mccPoreP18_nBottom
#define wLeft mccPoreP18_wLeft
#define wRight mccPoreP18_wRight
#define wExit mccPoreP18_wExit
#define wall mccPoreP18_wall
#define zentry mccPoreP18_zentry
#define reflec_top_table mccPoreP18_reflec_top_table
#define reflec_bottom_table mccPoreP18_reflec_bottom_table
#define reflec_side_table mccPoreP18_reflec_side_table
#define ref_prms mccPoreP18_ref_prms
{   /* Declarations of PoreP18=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP18_radius_p;
MCNUM radius_m = mccPoreP18_radius_m;
MCNUM Z0 = mccPoreP18_Z0;
MCNUM xwidth = mccPoreP18_xwidth;
MCNUM yheight = mccPoreP18_yheight;
MCNUM chamferwidth = mccPoreP18_chamferwidth;
char* mirror_reflec = mccPoreP18_mirror_reflec;
char* bottom_reflec = mccPoreP18_bottom_reflec;
char* side_reflec = mccPoreP18_side_reflec;
MCNUM R_d = mccPoreP18_R_d;
MCNUM absorb_sides = mccPoreP18_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 51821 "instruments/plate49.c"
}   /* End of PoreP18=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP18 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=72;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP18:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(72,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP19 [73] */
  mccoordschange(mcposrPoreP19, mcrotrPoreP19,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP19 (without coords transformations) */
  mcJumpTrace_PoreP19:
  SIG_MESSAGE("PoreP19 (Trace)");
  mcDEBUG_COMP("PoreP19")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP19
  STORE_XRAY(73,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[73]++;
  mcPCounter[73] += p;
  mcP2Counter[73] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP19
#define mccompcurname  PoreP19
#define mccompcurtype  Pore_p_group
#define mccompcurindex 73
#define nLeft mccPoreP19_nLeft
#define nRight mccPoreP19_nRight
#define nExit mccPoreP19_nExit
#define nTop mccPoreP19_nTop
#define nBottom mccPoreP19_nBottom
#define wLeft mccPoreP19_wLeft
#define wRight mccPoreP19_wRight
#define wExit mccPoreP19_wExit
#define wall mccPoreP19_wall
#define zentry mccPoreP19_zentry
#define reflec_top_table mccPoreP19_reflec_top_table
#define reflec_bottom_table mccPoreP19_reflec_bottom_table
#define reflec_side_table mccPoreP19_reflec_side_table
#define ref_prms mccPoreP19_ref_prms
{   /* Declarations of PoreP19=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP19_radius_p;
MCNUM radius_m = mccPoreP19_radius_m;
MCNUM Z0 = mccPoreP19_Z0;
MCNUM xwidth = mccPoreP19_xwidth;
MCNUM yheight = mccPoreP19_yheight;
MCNUM chamferwidth = mccPoreP19_chamferwidth;
char* mirror_reflec = mccPoreP19_mirror_reflec;
char* bottom_reflec = mccPoreP19_bottom_reflec;
char* side_reflec = mccPoreP19_side_reflec;
MCNUM R_d = mccPoreP19_R_d;
MCNUM absorb_sides = mccPoreP19_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 52123 "instruments/plate49.c"
}   /* End of PoreP19=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP19 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=73;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP19:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(73,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP20 [74] */
  mccoordschange(mcposrPoreP20, mcrotrPoreP20,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP20 (without coords transformations) */
  mcJumpTrace_PoreP20:
  SIG_MESSAGE("PoreP20 (Trace)");
  mcDEBUG_COMP("PoreP20")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP20
  STORE_XRAY(74,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[74]++;
  mcPCounter[74] += p;
  mcP2Counter[74] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP20
#define mccompcurname  PoreP20
#define mccompcurtype  Pore_p_group
#define mccompcurindex 74
#define nLeft mccPoreP20_nLeft
#define nRight mccPoreP20_nRight
#define nExit mccPoreP20_nExit
#define nTop mccPoreP20_nTop
#define nBottom mccPoreP20_nBottom
#define wLeft mccPoreP20_wLeft
#define wRight mccPoreP20_wRight
#define wExit mccPoreP20_wExit
#define wall mccPoreP20_wall
#define zentry mccPoreP20_zentry
#define reflec_top_table mccPoreP20_reflec_top_table
#define reflec_bottom_table mccPoreP20_reflec_bottom_table
#define reflec_side_table mccPoreP20_reflec_side_table
#define ref_prms mccPoreP20_ref_prms
{   /* Declarations of PoreP20=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP20_radius_p;
MCNUM radius_m = mccPoreP20_radius_m;
MCNUM Z0 = mccPoreP20_Z0;
MCNUM xwidth = mccPoreP20_xwidth;
MCNUM yheight = mccPoreP20_yheight;
MCNUM chamferwidth = mccPoreP20_chamferwidth;
char* mirror_reflec = mccPoreP20_mirror_reflec;
char* bottom_reflec = mccPoreP20_bottom_reflec;
char* side_reflec = mccPoreP20_side_reflec;
MCNUM R_d = mccPoreP20_R_d;
MCNUM absorb_sides = mccPoreP20_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 52425 "instruments/plate49.c"
}   /* End of PoreP20=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP20 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=74;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP20:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(74,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP21 [75] */
  mccoordschange(mcposrPoreP21, mcrotrPoreP21,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP21 (without coords transformations) */
  mcJumpTrace_PoreP21:
  SIG_MESSAGE("PoreP21 (Trace)");
  mcDEBUG_COMP("PoreP21")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP21
  STORE_XRAY(75,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[75]++;
  mcPCounter[75] += p;
  mcP2Counter[75] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP21
#define mccompcurname  PoreP21
#define mccompcurtype  Pore_p_group
#define mccompcurindex 75
#define nLeft mccPoreP21_nLeft
#define nRight mccPoreP21_nRight
#define nExit mccPoreP21_nExit
#define nTop mccPoreP21_nTop
#define nBottom mccPoreP21_nBottom
#define wLeft mccPoreP21_wLeft
#define wRight mccPoreP21_wRight
#define wExit mccPoreP21_wExit
#define wall mccPoreP21_wall
#define zentry mccPoreP21_zentry
#define reflec_top_table mccPoreP21_reflec_top_table
#define reflec_bottom_table mccPoreP21_reflec_bottom_table
#define reflec_side_table mccPoreP21_reflec_side_table
#define ref_prms mccPoreP21_ref_prms
{   /* Declarations of PoreP21=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP21_radius_p;
MCNUM radius_m = mccPoreP21_radius_m;
MCNUM Z0 = mccPoreP21_Z0;
MCNUM xwidth = mccPoreP21_xwidth;
MCNUM yheight = mccPoreP21_yheight;
MCNUM chamferwidth = mccPoreP21_chamferwidth;
char* mirror_reflec = mccPoreP21_mirror_reflec;
char* bottom_reflec = mccPoreP21_bottom_reflec;
char* side_reflec = mccPoreP21_side_reflec;
MCNUM R_d = mccPoreP21_R_d;
MCNUM absorb_sides = mccPoreP21_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 52727 "instruments/plate49.c"
}   /* End of PoreP21=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP21 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=75;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP21:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP22 [76] */
  mccoordschange(mcposrPoreP22, mcrotrPoreP22,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP22 (without coords transformations) */
  mcJumpTrace_PoreP22:
  SIG_MESSAGE("PoreP22 (Trace)");
  mcDEBUG_COMP("PoreP22")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP22
  STORE_XRAY(76,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[76]++;
  mcPCounter[76] += p;
  mcP2Counter[76] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP22
#define mccompcurname  PoreP22
#define mccompcurtype  Pore_p_group
#define mccompcurindex 76
#define nLeft mccPoreP22_nLeft
#define nRight mccPoreP22_nRight
#define nExit mccPoreP22_nExit
#define nTop mccPoreP22_nTop
#define nBottom mccPoreP22_nBottom
#define wLeft mccPoreP22_wLeft
#define wRight mccPoreP22_wRight
#define wExit mccPoreP22_wExit
#define wall mccPoreP22_wall
#define zentry mccPoreP22_zentry
#define reflec_top_table mccPoreP22_reflec_top_table
#define reflec_bottom_table mccPoreP22_reflec_bottom_table
#define reflec_side_table mccPoreP22_reflec_side_table
#define ref_prms mccPoreP22_ref_prms
{   /* Declarations of PoreP22=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP22_radius_p;
MCNUM radius_m = mccPoreP22_radius_m;
MCNUM Z0 = mccPoreP22_Z0;
MCNUM xwidth = mccPoreP22_xwidth;
MCNUM yheight = mccPoreP22_yheight;
MCNUM chamferwidth = mccPoreP22_chamferwidth;
char* mirror_reflec = mccPoreP22_mirror_reflec;
char* bottom_reflec = mccPoreP22_bottom_reflec;
char* side_reflec = mccPoreP22_side_reflec;
MCNUM R_d = mccPoreP22_R_d;
MCNUM absorb_sides = mccPoreP22_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 53029 "instruments/plate49.c"
}   /* End of PoreP22=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP22 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=76;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP22:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(76,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP23 [77] */
  mccoordschange(mcposrPoreP23, mcrotrPoreP23,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP23 (without coords transformations) */
  mcJumpTrace_PoreP23:
  SIG_MESSAGE("PoreP23 (Trace)");
  mcDEBUG_COMP("PoreP23")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP23
  STORE_XRAY(77,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[77]++;
  mcPCounter[77] += p;
  mcP2Counter[77] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP23
#define mccompcurname  PoreP23
#define mccompcurtype  Pore_p_group
#define mccompcurindex 77
#define nLeft mccPoreP23_nLeft
#define nRight mccPoreP23_nRight
#define nExit mccPoreP23_nExit
#define nTop mccPoreP23_nTop
#define nBottom mccPoreP23_nBottom
#define wLeft mccPoreP23_wLeft
#define wRight mccPoreP23_wRight
#define wExit mccPoreP23_wExit
#define wall mccPoreP23_wall
#define zentry mccPoreP23_zentry
#define reflec_top_table mccPoreP23_reflec_top_table
#define reflec_bottom_table mccPoreP23_reflec_bottom_table
#define reflec_side_table mccPoreP23_reflec_side_table
#define ref_prms mccPoreP23_ref_prms
{   /* Declarations of PoreP23=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP23_radius_p;
MCNUM radius_m = mccPoreP23_radius_m;
MCNUM Z0 = mccPoreP23_Z0;
MCNUM xwidth = mccPoreP23_xwidth;
MCNUM yheight = mccPoreP23_yheight;
MCNUM chamferwidth = mccPoreP23_chamferwidth;
char* mirror_reflec = mccPoreP23_mirror_reflec;
char* bottom_reflec = mccPoreP23_bottom_reflec;
char* side_reflec = mccPoreP23_side_reflec;
MCNUM R_d = mccPoreP23_R_d;
MCNUM absorb_sides = mccPoreP23_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 53331 "instruments/plate49.c"
}   /* End of PoreP23=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP23 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=77;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP23:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(77,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP24 [78] */
  mccoordschange(mcposrPoreP24, mcrotrPoreP24,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP24 (without coords transformations) */
  mcJumpTrace_PoreP24:
  SIG_MESSAGE("PoreP24 (Trace)");
  mcDEBUG_COMP("PoreP24")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP24
  STORE_XRAY(78,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[78]++;
  mcPCounter[78] += p;
  mcP2Counter[78] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP24
#define mccompcurname  PoreP24
#define mccompcurtype  Pore_p_group
#define mccompcurindex 78
#define nLeft mccPoreP24_nLeft
#define nRight mccPoreP24_nRight
#define nExit mccPoreP24_nExit
#define nTop mccPoreP24_nTop
#define nBottom mccPoreP24_nBottom
#define wLeft mccPoreP24_wLeft
#define wRight mccPoreP24_wRight
#define wExit mccPoreP24_wExit
#define wall mccPoreP24_wall
#define zentry mccPoreP24_zentry
#define reflec_top_table mccPoreP24_reflec_top_table
#define reflec_bottom_table mccPoreP24_reflec_bottom_table
#define reflec_side_table mccPoreP24_reflec_side_table
#define ref_prms mccPoreP24_ref_prms
{   /* Declarations of PoreP24=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP24_radius_p;
MCNUM radius_m = mccPoreP24_radius_m;
MCNUM Z0 = mccPoreP24_Z0;
MCNUM xwidth = mccPoreP24_xwidth;
MCNUM yheight = mccPoreP24_yheight;
MCNUM chamferwidth = mccPoreP24_chamferwidth;
char* mirror_reflec = mccPoreP24_mirror_reflec;
char* bottom_reflec = mccPoreP24_bottom_reflec;
char* side_reflec = mccPoreP24_side_reflec;
MCNUM R_d = mccPoreP24_R_d;
MCNUM absorb_sides = mccPoreP24_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 53633 "instruments/plate49.c"
}   /* End of PoreP24=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP24 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=78;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP24:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(78,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP25 [79] */
  mccoordschange(mcposrPoreP25, mcrotrPoreP25,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP25 (without coords transformations) */
  mcJumpTrace_PoreP25:
  SIG_MESSAGE("PoreP25 (Trace)");
  mcDEBUG_COMP("PoreP25")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP25
  STORE_XRAY(79,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[79]++;
  mcPCounter[79] += p;
  mcP2Counter[79] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP25
#define mccompcurname  PoreP25
#define mccompcurtype  Pore_p_group
#define mccompcurindex 79
#define nLeft mccPoreP25_nLeft
#define nRight mccPoreP25_nRight
#define nExit mccPoreP25_nExit
#define nTop mccPoreP25_nTop
#define nBottom mccPoreP25_nBottom
#define wLeft mccPoreP25_wLeft
#define wRight mccPoreP25_wRight
#define wExit mccPoreP25_wExit
#define wall mccPoreP25_wall
#define zentry mccPoreP25_zentry
#define reflec_top_table mccPoreP25_reflec_top_table
#define reflec_bottom_table mccPoreP25_reflec_bottom_table
#define reflec_side_table mccPoreP25_reflec_side_table
#define ref_prms mccPoreP25_ref_prms
{   /* Declarations of PoreP25=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP25_radius_p;
MCNUM radius_m = mccPoreP25_radius_m;
MCNUM Z0 = mccPoreP25_Z0;
MCNUM xwidth = mccPoreP25_xwidth;
MCNUM yheight = mccPoreP25_yheight;
MCNUM chamferwidth = mccPoreP25_chamferwidth;
char* mirror_reflec = mccPoreP25_mirror_reflec;
char* bottom_reflec = mccPoreP25_bottom_reflec;
char* side_reflec = mccPoreP25_side_reflec;
MCNUM R_d = mccPoreP25_R_d;
MCNUM absorb_sides = mccPoreP25_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 53935 "instruments/plate49.c"
}   /* End of PoreP25=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP25 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=79;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP25:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(79,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP26 [80] */
  mccoordschange(mcposrPoreP26, mcrotrPoreP26,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP26 (without coords transformations) */
  mcJumpTrace_PoreP26:
  SIG_MESSAGE("PoreP26 (Trace)");
  mcDEBUG_COMP("PoreP26")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP26
  STORE_XRAY(80,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[80]++;
  mcPCounter[80] += p;
  mcP2Counter[80] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP26
#define mccompcurname  PoreP26
#define mccompcurtype  Pore_p_group
#define mccompcurindex 80
#define nLeft mccPoreP26_nLeft
#define nRight mccPoreP26_nRight
#define nExit mccPoreP26_nExit
#define nTop mccPoreP26_nTop
#define nBottom mccPoreP26_nBottom
#define wLeft mccPoreP26_wLeft
#define wRight mccPoreP26_wRight
#define wExit mccPoreP26_wExit
#define wall mccPoreP26_wall
#define zentry mccPoreP26_zentry
#define reflec_top_table mccPoreP26_reflec_top_table
#define reflec_bottom_table mccPoreP26_reflec_bottom_table
#define reflec_side_table mccPoreP26_reflec_side_table
#define ref_prms mccPoreP26_ref_prms
{   /* Declarations of PoreP26=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP26_radius_p;
MCNUM radius_m = mccPoreP26_radius_m;
MCNUM Z0 = mccPoreP26_Z0;
MCNUM xwidth = mccPoreP26_xwidth;
MCNUM yheight = mccPoreP26_yheight;
MCNUM chamferwidth = mccPoreP26_chamferwidth;
char* mirror_reflec = mccPoreP26_mirror_reflec;
char* bottom_reflec = mccPoreP26_bottom_reflec;
char* side_reflec = mccPoreP26_side_reflec;
MCNUM R_d = mccPoreP26_R_d;
MCNUM absorb_sides = mccPoreP26_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 54237 "instruments/plate49.c"
}   /* End of PoreP26=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP26 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=80;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP26:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(80,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP27 [81] */
  mccoordschange(mcposrPoreP27, mcrotrPoreP27,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP27 (without coords transformations) */
  mcJumpTrace_PoreP27:
  SIG_MESSAGE("PoreP27 (Trace)");
  mcDEBUG_COMP("PoreP27")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP27
  STORE_XRAY(81,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[81]++;
  mcPCounter[81] += p;
  mcP2Counter[81] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP27
#define mccompcurname  PoreP27
#define mccompcurtype  Pore_p_group
#define mccompcurindex 81
#define nLeft mccPoreP27_nLeft
#define nRight mccPoreP27_nRight
#define nExit mccPoreP27_nExit
#define nTop mccPoreP27_nTop
#define nBottom mccPoreP27_nBottom
#define wLeft mccPoreP27_wLeft
#define wRight mccPoreP27_wRight
#define wExit mccPoreP27_wExit
#define wall mccPoreP27_wall
#define zentry mccPoreP27_zentry
#define reflec_top_table mccPoreP27_reflec_top_table
#define reflec_bottom_table mccPoreP27_reflec_bottom_table
#define reflec_side_table mccPoreP27_reflec_side_table
#define ref_prms mccPoreP27_ref_prms
{   /* Declarations of PoreP27=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP27_radius_p;
MCNUM radius_m = mccPoreP27_radius_m;
MCNUM Z0 = mccPoreP27_Z0;
MCNUM xwidth = mccPoreP27_xwidth;
MCNUM yheight = mccPoreP27_yheight;
MCNUM chamferwidth = mccPoreP27_chamferwidth;
char* mirror_reflec = mccPoreP27_mirror_reflec;
char* bottom_reflec = mccPoreP27_bottom_reflec;
char* side_reflec = mccPoreP27_side_reflec;
MCNUM R_d = mccPoreP27_R_d;
MCNUM absorb_sides = mccPoreP27_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 54539 "instruments/plate49.c"
}   /* End of PoreP27=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP27 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=81;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP27:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(81,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP28 [82] */
  mccoordschange(mcposrPoreP28, mcrotrPoreP28,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP28 (without coords transformations) */
  mcJumpTrace_PoreP28:
  SIG_MESSAGE("PoreP28 (Trace)");
  mcDEBUG_COMP("PoreP28")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP28
  STORE_XRAY(82,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[82]++;
  mcPCounter[82] += p;
  mcP2Counter[82] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP28
#define mccompcurname  PoreP28
#define mccompcurtype  Pore_p_group
#define mccompcurindex 82
#define nLeft mccPoreP28_nLeft
#define nRight mccPoreP28_nRight
#define nExit mccPoreP28_nExit
#define nTop mccPoreP28_nTop
#define nBottom mccPoreP28_nBottom
#define wLeft mccPoreP28_wLeft
#define wRight mccPoreP28_wRight
#define wExit mccPoreP28_wExit
#define wall mccPoreP28_wall
#define zentry mccPoreP28_zentry
#define reflec_top_table mccPoreP28_reflec_top_table
#define reflec_bottom_table mccPoreP28_reflec_bottom_table
#define reflec_side_table mccPoreP28_reflec_side_table
#define ref_prms mccPoreP28_ref_prms
{   /* Declarations of PoreP28=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP28_radius_p;
MCNUM radius_m = mccPoreP28_radius_m;
MCNUM Z0 = mccPoreP28_Z0;
MCNUM xwidth = mccPoreP28_xwidth;
MCNUM yheight = mccPoreP28_yheight;
MCNUM chamferwidth = mccPoreP28_chamferwidth;
char* mirror_reflec = mccPoreP28_mirror_reflec;
char* bottom_reflec = mccPoreP28_bottom_reflec;
char* side_reflec = mccPoreP28_side_reflec;
MCNUM R_d = mccPoreP28_R_d;
MCNUM absorb_sides = mccPoreP28_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 54841 "instruments/plate49.c"
}   /* End of PoreP28=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP28 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=82;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP28:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(82,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP29 [83] */
  mccoordschange(mcposrPoreP29, mcrotrPoreP29,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP29 (without coords transformations) */
  mcJumpTrace_PoreP29:
  SIG_MESSAGE("PoreP29 (Trace)");
  mcDEBUG_COMP("PoreP29")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP29
  STORE_XRAY(83,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[83]++;
  mcPCounter[83] += p;
  mcP2Counter[83] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP29
#define mccompcurname  PoreP29
#define mccompcurtype  Pore_p_group
#define mccompcurindex 83
#define nLeft mccPoreP29_nLeft
#define nRight mccPoreP29_nRight
#define nExit mccPoreP29_nExit
#define nTop mccPoreP29_nTop
#define nBottom mccPoreP29_nBottom
#define wLeft mccPoreP29_wLeft
#define wRight mccPoreP29_wRight
#define wExit mccPoreP29_wExit
#define wall mccPoreP29_wall
#define zentry mccPoreP29_zentry
#define reflec_top_table mccPoreP29_reflec_top_table
#define reflec_bottom_table mccPoreP29_reflec_bottom_table
#define reflec_side_table mccPoreP29_reflec_side_table
#define ref_prms mccPoreP29_ref_prms
{   /* Declarations of PoreP29=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP29_radius_p;
MCNUM radius_m = mccPoreP29_radius_m;
MCNUM Z0 = mccPoreP29_Z0;
MCNUM xwidth = mccPoreP29_xwidth;
MCNUM yheight = mccPoreP29_yheight;
MCNUM chamferwidth = mccPoreP29_chamferwidth;
char* mirror_reflec = mccPoreP29_mirror_reflec;
char* bottom_reflec = mccPoreP29_bottom_reflec;
char* side_reflec = mccPoreP29_side_reflec;
MCNUM R_d = mccPoreP29_R_d;
MCNUM absorb_sides = mccPoreP29_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 55143 "instruments/plate49.c"
}   /* End of PoreP29=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP29 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=83;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP29:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(83,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP30 [84] */
  mccoordschange(mcposrPoreP30, mcrotrPoreP30,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP30 (without coords transformations) */
  mcJumpTrace_PoreP30:
  SIG_MESSAGE("PoreP30 (Trace)");
  mcDEBUG_COMP("PoreP30")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP30
  STORE_XRAY(84,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[84]++;
  mcPCounter[84] += p;
  mcP2Counter[84] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP30
#define mccompcurname  PoreP30
#define mccompcurtype  Pore_p_group
#define mccompcurindex 84
#define nLeft mccPoreP30_nLeft
#define nRight mccPoreP30_nRight
#define nExit mccPoreP30_nExit
#define nTop mccPoreP30_nTop
#define nBottom mccPoreP30_nBottom
#define wLeft mccPoreP30_wLeft
#define wRight mccPoreP30_wRight
#define wExit mccPoreP30_wExit
#define wall mccPoreP30_wall
#define zentry mccPoreP30_zentry
#define reflec_top_table mccPoreP30_reflec_top_table
#define reflec_bottom_table mccPoreP30_reflec_bottom_table
#define reflec_side_table mccPoreP30_reflec_side_table
#define ref_prms mccPoreP30_ref_prms
{   /* Declarations of PoreP30=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP30_radius_p;
MCNUM radius_m = mccPoreP30_radius_m;
MCNUM Z0 = mccPoreP30_Z0;
MCNUM xwidth = mccPoreP30_xwidth;
MCNUM yheight = mccPoreP30_yheight;
MCNUM chamferwidth = mccPoreP30_chamferwidth;
char* mirror_reflec = mccPoreP30_mirror_reflec;
char* bottom_reflec = mccPoreP30_bottom_reflec;
char* side_reflec = mccPoreP30_side_reflec;
MCNUM R_d = mccPoreP30_R_d;
MCNUM absorb_sides = mccPoreP30_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 55445 "instruments/plate49.c"
}   /* End of PoreP30=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP30 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=84;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP30:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(84,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP31 [85] */
  mccoordschange(mcposrPoreP31, mcrotrPoreP31,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP31 (without coords transformations) */
  mcJumpTrace_PoreP31:
  SIG_MESSAGE("PoreP31 (Trace)");
  mcDEBUG_COMP("PoreP31")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP31
  STORE_XRAY(85,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[85]++;
  mcPCounter[85] += p;
  mcP2Counter[85] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP31
#define mccompcurname  PoreP31
#define mccompcurtype  Pore_p_group
#define mccompcurindex 85
#define nLeft mccPoreP31_nLeft
#define nRight mccPoreP31_nRight
#define nExit mccPoreP31_nExit
#define nTop mccPoreP31_nTop
#define nBottom mccPoreP31_nBottom
#define wLeft mccPoreP31_wLeft
#define wRight mccPoreP31_wRight
#define wExit mccPoreP31_wExit
#define wall mccPoreP31_wall
#define zentry mccPoreP31_zentry
#define reflec_top_table mccPoreP31_reflec_top_table
#define reflec_bottom_table mccPoreP31_reflec_bottom_table
#define reflec_side_table mccPoreP31_reflec_side_table
#define ref_prms mccPoreP31_ref_prms
{   /* Declarations of PoreP31=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP31_radius_p;
MCNUM radius_m = mccPoreP31_radius_m;
MCNUM Z0 = mccPoreP31_Z0;
MCNUM xwidth = mccPoreP31_xwidth;
MCNUM yheight = mccPoreP31_yheight;
MCNUM chamferwidth = mccPoreP31_chamferwidth;
char* mirror_reflec = mccPoreP31_mirror_reflec;
char* bottom_reflec = mccPoreP31_bottom_reflec;
char* side_reflec = mccPoreP31_side_reflec;
MCNUM R_d = mccPoreP31_R_d;
MCNUM absorb_sides = mccPoreP31_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 55747 "instruments/plate49.c"
}   /* End of PoreP31=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP31 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=85;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP31:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(85,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP32 [86] */
  mccoordschange(mcposrPoreP32, mcrotrPoreP32,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP32 (without coords transformations) */
  mcJumpTrace_PoreP32:
  SIG_MESSAGE("PoreP32 (Trace)");
  mcDEBUG_COMP("PoreP32")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP32
  STORE_XRAY(86,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[86]++;
  mcPCounter[86] += p;
  mcP2Counter[86] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP32
#define mccompcurname  PoreP32
#define mccompcurtype  Pore_p_group
#define mccompcurindex 86
#define nLeft mccPoreP32_nLeft
#define nRight mccPoreP32_nRight
#define nExit mccPoreP32_nExit
#define nTop mccPoreP32_nTop
#define nBottom mccPoreP32_nBottom
#define wLeft mccPoreP32_wLeft
#define wRight mccPoreP32_wRight
#define wExit mccPoreP32_wExit
#define wall mccPoreP32_wall
#define zentry mccPoreP32_zentry
#define reflec_top_table mccPoreP32_reflec_top_table
#define reflec_bottom_table mccPoreP32_reflec_bottom_table
#define reflec_side_table mccPoreP32_reflec_side_table
#define ref_prms mccPoreP32_ref_prms
{   /* Declarations of PoreP32=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP32_radius_p;
MCNUM radius_m = mccPoreP32_radius_m;
MCNUM Z0 = mccPoreP32_Z0;
MCNUM xwidth = mccPoreP32_xwidth;
MCNUM yheight = mccPoreP32_yheight;
MCNUM chamferwidth = mccPoreP32_chamferwidth;
char* mirror_reflec = mccPoreP32_mirror_reflec;
char* bottom_reflec = mccPoreP32_bottom_reflec;
char* side_reflec = mccPoreP32_side_reflec;
MCNUM R_d = mccPoreP32_R_d;
MCNUM absorb_sides = mccPoreP32_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 56049 "instruments/plate49.c"
}   /* End of PoreP32=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP32 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=86;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP32:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(86,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP33 [87] */
  mccoordschange(mcposrPoreP33, mcrotrPoreP33,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP33 (without coords transformations) */
  mcJumpTrace_PoreP33:
  SIG_MESSAGE("PoreP33 (Trace)");
  mcDEBUG_COMP("PoreP33")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP33
  STORE_XRAY(87,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[87]++;
  mcPCounter[87] += p;
  mcP2Counter[87] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP33
#define mccompcurname  PoreP33
#define mccompcurtype  Pore_p_group
#define mccompcurindex 87
#define nLeft mccPoreP33_nLeft
#define nRight mccPoreP33_nRight
#define nExit mccPoreP33_nExit
#define nTop mccPoreP33_nTop
#define nBottom mccPoreP33_nBottom
#define wLeft mccPoreP33_wLeft
#define wRight mccPoreP33_wRight
#define wExit mccPoreP33_wExit
#define wall mccPoreP33_wall
#define zentry mccPoreP33_zentry
#define reflec_top_table mccPoreP33_reflec_top_table
#define reflec_bottom_table mccPoreP33_reflec_bottom_table
#define reflec_side_table mccPoreP33_reflec_side_table
#define ref_prms mccPoreP33_ref_prms
{   /* Declarations of PoreP33=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP33_radius_p;
MCNUM radius_m = mccPoreP33_radius_m;
MCNUM Z0 = mccPoreP33_Z0;
MCNUM xwidth = mccPoreP33_xwidth;
MCNUM yheight = mccPoreP33_yheight;
MCNUM chamferwidth = mccPoreP33_chamferwidth;
char* mirror_reflec = mccPoreP33_mirror_reflec;
char* bottom_reflec = mccPoreP33_bottom_reflec;
char* side_reflec = mccPoreP33_side_reflec;
MCNUM R_d = mccPoreP33_R_d;
MCNUM absorb_sides = mccPoreP33_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 56351 "instruments/plate49.c"
}   /* End of PoreP33=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP33 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=87;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP33:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(87,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP34 [88] */
  mccoordschange(mcposrPoreP34, mcrotrPoreP34,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP34 (without coords transformations) */
  mcJumpTrace_PoreP34:
  SIG_MESSAGE("PoreP34 (Trace)");
  mcDEBUG_COMP("PoreP34")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP34
  STORE_XRAY(88,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[88]++;
  mcPCounter[88] += p;
  mcP2Counter[88] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP34
#define mccompcurname  PoreP34
#define mccompcurtype  Pore_p_group
#define mccompcurindex 88
#define nLeft mccPoreP34_nLeft
#define nRight mccPoreP34_nRight
#define nExit mccPoreP34_nExit
#define nTop mccPoreP34_nTop
#define nBottom mccPoreP34_nBottom
#define wLeft mccPoreP34_wLeft
#define wRight mccPoreP34_wRight
#define wExit mccPoreP34_wExit
#define wall mccPoreP34_wall
#define zentry mccPoreP34_zentry
#define reflec_top_table mccPoreP34_reflec_top_table
#define reflec_bottom_table mccPoreP34_reflec_bottom_table
#define reflec_side_table mccPoreP34_reflec_side_table
#define ref_prms mccPoreP34_ref_prms
{   /* Declarations of PoreP34=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP34_radius_p;
MCNUM radius_m = mccPoreP34_radius_m;
MCNUM Z0 = mccPoreP34_Z0;
MCNUM xwidth = mccPoreP34_xwidth;
MCNUM yheight = mccPoreP34_yheight;
MCNUM chamferwidth = mccPoreP34_chamferwidth;
char* mirror_reflec = mccPoreP34_mirror_reflec;
char* bottom_reflec = mccPoreP34_bottom_reflec;
char* side_reflec = mccPoreP34_side_reflec;
MCNUM R_d = mccPoreP34_R_d;
MCNUM absorb_sides = mccPoreP34_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 56653 "instruments/plate49.c"
}   /* End of PoreP34=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP34 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=88;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP34:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(88,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP35 [89] */
  mccoordschange(mcposrPoreP35, mcrotrPoreP35,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP35 (without coords transformations) */
  mcJumpTrace_PoreP35:
  SIG_MESSAGE("PoreP35 (Trace)");
  mcDEBUG_COMP("PoreP35")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP35
  STORE_XRAY(89,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[89]++;
  mcPCounter[89] += p;
  mcP2Counter[89] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP35
#define mccompcurname  PoreP35
#define mccompcurtype  Pore_p_group
#define mccompcurindex 89
#define nLeft mccPoreP35_nLeft
#define nRight mccPoreP35_nRight
#define nExit mccPoreP35_nExit
#define nTop mccPoreP35_nTop
#define nBottom mccPoreP35_nBottom
#define wLeft mccPoreP35_wLeft
#define wRight mccPoreP35_wRight
#define wExit mccPoreP35_wExit
#define wall mccPoreP35_wall
#define zentry mccPoreP35_zentry
#define reflec_top_table mccPoreP35_reflec_top_table
#define reflec_bottom_table mccPoreP35_reflec_bottom_table
#define reflec_side_table mccPoreP35_reflec_side_table
#define ref_prms mccPoreP35_ref_prms
{   /* Declarations of PoreP35=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP35_radius_p;
MCNUM radius_m = mccPoreP35_radius_m;
MCNUM Z0 = mccPoreP35_Z0;
MCNUM xwidth = mccPoreP35_xwidth;
MCNUM yheight = mccPoreP35_yheight;
MCNUM chamferwidth = mccPoreP35_chamferwidth;
char* mirror_reflec = mccPoreP35_mirror_reflec;
char* bottom_reflec = mccPoreP35_bottom_reflec;
char* side_reflec = mccPoreP35_side_reflec;
MCNUM R_d = mccPoreP35_R_d;
MCNUM absorb_sides = mccPoreP35_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 56955 "instruments/plate49.c"
}   /* End of PoreP35=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP35 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=89;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP35:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(89,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP36 [90] */
  mccoordschange(mcposrPoreP36, mcrotrPoreP36,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP36 (without coords transformations) */
  mcJumpTrace_PoreP36:
  SIG_MESSAGE("PoreP36 (Trace)");
  mcDEBUG_COMP("PoreP36")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP36
  STORE_XRAY(90,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[90]++;
  mcPCounter[90] += p;
  mcP2Counter[90] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP36
#define mccompcurname  PoreP36
#define mccompcurtype  Pore_p_group
#define mccompcurindex 90
#define nLeft mccPoreP36_nLeft
#define nRight mccPoreP36_nRight
#define nExit mccPoreP36_nExit
#define nTop mccPoreP36_nTop
#define nBottom mccPoreP36_nBottom
#define wLeft mccPoreP36_wLeft
#define wRight mccPoreP36_wRight
#define wExit mccPoreP36_wExit
#define wall mccPoreP36_wall
#define zentry mccPoreP36_zentry
#define reflec_top_table mccPoreP36_reflec_top_table
#define reflec_bottom_table mccPoreP36_reflec_bottom_table
#define reflec_side_table mccPoreP36_reflec_side_table
#define ref_prms mccPoreP36_ref_prms
{   /* Declarations of PoreP36=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP36_radius_p;
MCNUM radius_m = mccPoreP36_radius_m;
MCNUM Z0 = mccPoreP36_Z0;
MCNUM xwidth = mccPoreP36_xwidth;
MCNUM yheight = mccPoreP36_yheight;
MCNUM chamferwidth = mccPoreP36_chamferwidth;
char* mirror_reflec = mccPoreP36_mirror_reflec;
char* bottom_reflec = mccPoreP36_bottom_reflec;
char* side_reflec = mccPoreP36_side_reflec;
MCNUM R_d = mccPoreP36_R_d;
MCNUM absorb_sides = mccPoreP36_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 57257 "instruments/plate49.c"
}   /* End of PoreP36=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP36 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=90;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP36:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(90,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP37 [91] */
  mccoordschange(mcposrPoreP37, mcrotrPoreP37,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP37 (without coords transformations) */
  mcJumpTrace_PoreP37:
  SIG_MESSAGE("PoreP37 (Trace)");
  mcDEBUG_COMP("PoreP37")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP37
  STORE_XRAY(91,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[91]++;
  mcPCounter[91] += p;
  mcP2Counter[91] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP37
#define mccompcurname  PoreP37
#define mccompcurtype  Pore_p_group
#define mccompcurindex 91
#define nLeft mccPoreP37_nLeft
#define nRight mccPoreP37_nRight
#define nExit mccPoreP37_nExit
#define nTop mccPoreP37_nTop
#define nBottom mccPoreP37_nBottom
#define wLeft mccPoreP37_wLeft
#define wRight mccPoreP37_wRight
#define wExit mccPoreP37_wExit
#define wall mccPoreP37_wall
#define zentry mccPoreP37_zentry
#define reflec_top_table mccPoreP37_reflec_top_table
#define reflec_bottom_table mccPoreP37_reflec_bottom_table
#define reflec_side_table mccPoreP37_reflec_side_table
#define ref_prms mccPoreP37_ref_prms
{   /* Declarations of PoreP37=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP37_radius_p;
MCNUM radius_m = mccPoreP37_radius_m;
MCNUM Z0 = mccPoreP37_Z0;
MCNUM xwidth = mccPoreP37_xwidth;
MCNUM yheight = mccPoreP37_yheight;
MCNUM chamferwidth = mccPoreP37_chamferwidth;
char* mirror_reflec = mccPoreP37_mirror_reflec;
char* bottom_reflec = mccPoreP37_bottom_reflec;
char* side_reflec = mccPoreP37_side_reflec;
MCNUM R_d = mccPoreP37_R_d;
MCNUM absorb_sides = mccPoreP37_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 57559 "instruments/plate49.c"
}   /* End of PoreP37=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP37 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=91;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP37:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(91,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP38 [92] */
  mccoordschange(mcposrPoreP38, mcrotrPoreP38,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP38 (without coords transformations) */
  mcJumpTrace_PoreP38:
  SIG_MESSAGE("PoreP38 (Trace)");
  mcDEBUG_COMP("PoreP38")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP38
  STORE_XRAY(92,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[92]++;
  mcPCounter[92] += p;
  mcP2Counter[92] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP38
#define mccompcurname  PoreP38
#define mccompcurtype  Pore_p_group
#define mccompcurindex 92
#define nLeft mccPoreP38_nLeft
#define nRight mccPoreP38_nRight
#define nExit mccPoreP38_nExit
#define nTop mccPoreP38_nTop
#define nBottom mccPoreP38_nBottom
#define wLeft mccPoreP38_wLeft
#define wRight mccPoreP38_wRight
#define wExit mccPoreP38_wExit
#define wall mccPoreP38_wall
#define zentry mccPoreP38_zentry
#define reflec_top_table mccPoreP38_reflec_top_table
#define reflec_bottom_table mccPoreP38_reflec_bottom_table
#define reflec_side_table mccPoreP38_reflec_side_table
#define ref_prms mccPoreP38_ref_prms
{   /* Declarations of PoreP38=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP38_radius_p;
MCNUM radius_m = mccPoreP38_radius_m;
MCNUM Z0 = mccPoreP38_Z0;
MCNUM xwidth = mccPoreP38_xwidth;
MCNUM yheight = mccPoreP38_yheight;
MCNUM chamferwidth = mccPoreP38_chamferwidth;
char* mirror_reflec = mccPoreP38_mirror_reflec;
char* bottom_reflec = mccPoreP38_bottom_reflec;
char* side_reflec = mccPoreP38_side_reflec;
MCNUM R_d = mccPoreP38_R_d;
MCNUM absorb_sides = mccPoreP38_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 57861 "instruments/plate49.c"
}   /* End of PoreP38=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP38 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=92;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP38:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(92,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP39 [93] */
  mccoordschange(mcposrPoreP39, mcrotrPoreP39,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP39 (without coords transformations) */
  mcJumpTrace_PoreP39:
  SIG_MESSAGE("PoreP39 (Trace)");
  mcDEBUG_COMP("PoreP39")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP39
  STORE_XRAY(93,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[93]++;
  mcPCounter[93] += p;
  mcP2Counter[93] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP39
#define mccompcurname  PoreP39
#define mccompcurtype  Pore_p_group
#define mccompcurindex 93
#define nLeft mccPoreP39_nLeft
#define nRight mccPoreP39_nRight
#define nExit mccPoreP39_nExit
#define nTop mccPoreP39_nTop
#define nBottom mccPoreP39_nBottom
#define wLeft mccPoreP39_wLeft
#define wRight mccPoreP39_wRight
#define wExit mccPoreP39_wExit
#define wall mccPoreP39_wall
#define zentry mccPoreP39_zentry
#define reflec_top_table mccPoreP39_reflec_top_table
#define reflec_bottom_table mccPoreP39_reflec_bottom_table
#define reflec_side_table mccPoreP39_reflec_side_table
#define ref_prms mccPoreP39_ref_prms
{   /* Declarations of PoreP39=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP39_radius_p;
MCNUM radius_m = mccPoreP39_radius_m;
MCNUM Z0 = mccPoreP39_Z0;
MCNUM xwidth = mccPoreP39_xwidth;
MCNUM yheight = mccPoreP39_yheight;
MCNUM chamferwidth = mccPoreP39_chamferwidth;
char* mirror_reflec = mccPoreP39_mirror_reflec;
char* bottom_reflec = mccPoreP39_bottom_reflec;
char* side_reflec = mccPoreP39_side_reflec;
MCNUM R_d = mccPoreP39_R_d;
MCNUM absorb_sides = mccPoreP39_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 58163 "instruments/plate49.c"
}   /* End of PoreP39=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP39 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=93;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP39:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(93,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP40 [94] */
  mccoordschange(mcposrPoreP40, mcrotrPoreP40,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP40 (without coords transformations) */
  mcJumpTrace_PoreP40:
  SIG_MESSAGE("PoreP40 (Trace)");
  mcDEBUG_COMP("PoreP40")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP40
  STORE_XRAY(94,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[94]++;
  mcPCounter[94] += p;
  mcP2Counter[94] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP40
#define mccompcurname  PoreP40
#define mccompcurtype  Pore_p_group
#define mccompcurindex 94
#define nLeft mccPoreP40_nLeft
#define nRight mccPoreP40_nRight
#define nExit mccPoreP40_nExit
#define nTop mccPoreP40_nTop
#define nBottom mccPoreP40_nBottom
#define wLeft mccPoreP40_wLeft
#define wRight mccPoreP40_wRight
#define wExit mccPoreP40_wExit
#define wall mccPoreP40_wall
#define zentry mccPoreP40_zentry
#define reflec_top_table mccPoreP40_reflec_top_table
#define reflec_bottom_table mccPoreP40_reflec_bottom_table
#define reflec_side_table mccPoreP40_reflec_side_table
#define ref_prms mccPoreP40_ref_prms
{   /* Declarations of PoreP40=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP40_radius_p;
MCNUM radius_m = mccPoreP40_radius_m;
MCNUM Z0 = mccPoreP40_Z0;
MCNUM xwidth = mccPoreP40_xwidth;
MCNUM yheight = mccPoreP40_yheight;
MCNUM chamferwidth = mccPoreP40_chamferwidth;
char* mirror_reflec = mccPoreP40_mirror_reflec;
char* bottom_reflec = mccPoreP40_bottom_reflec;
char* side_reflec = mccPoreP40_side_reflec;
MCNUM R_d = mccPoreP40_R_d;
MCNUM absorb_sides = mccPoreP40_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 58465 "instruments/plate49.c"
}   /* End of PoreP40=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP40 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=94;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP40:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(94,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP41 [95] */
  mccoordschange(mcposrPoreP41, mcrotrPoreP41,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP41 (without coords transformations) */
  mcJumpTrace_PoreP41:
  SIG_MESSAGE("PoreP41 (Trace)");
  mcDEBUG_COMP("PoreP41")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP41
  STORE_XRAY(95,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[95]++;
  mcPCounter[95] += p;
  mcP2Counter[95] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP41
#define mccompcurname  PoreP41
#define mccompcurtype  Pore_p_group
#define mccompcurindex 95
#define nLeft mccPoreP41_nLeft
#define nRight mccPoreP41_nRight
#define nExit mccPoreP41_nExit
#define nTop mccPoreP41_nTop
#define nBottom mccPoreP41_nBottom
#define wLeft mccPoreP41_wLeft
#define wRight mccPoreP41_wRight
#define wExit mccPoreP41_wExit
#define wall mccPoreP41_wall
#define zentry mccPoreP41_zentry
#define reflec_top_table mccPoreP41_reflec_top_table
#define reflec_bottom_table mccPoreP41_reflec_bottom_table
#define reflec_side_table mccPoreP41_reflec_side_table
#define ref_prms mccPoreP41_ref_prms
{   /* Declarations of PoreP41=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP41_radius_p;
MCNUM radius_m = mccPoreP41_radius_m;
MCNUM Z0 = mccPoreP41_Z0;
MCNUM xwidth = mccPoreP41_xwidth;
MCNUM yheight = mccPoreP41_yheight;
MCNUM chamferwidth = mccPoreP41_chamferwidth;
char* mirror_reflec = mccPoreP41_mirror_reflec;
char* bottom_reflec = mccPoreP41_bottom_reflec;
char* side_reflec = mccPoreP41_side_reflec;
MCNUM R_d = mccPoreP41_R_d;
MCNUM absorb_sides = mccPoreP41_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 58767 "instruments/plate49.c"
}   /* End of PoreP41=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP41 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=95;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP41:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(95,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP42 [96] */
  mccoordschange(mcposrPoreP42, mcrotrPoreP42,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP42 (without coords transformations) */
  mcJumpTrace_PoreP42:
  SIG_MESSAGE("PoreP42 (Trace)");
  mcDEBUG_COMP("PoreP42")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP42
  STORE_XRAY(96,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[96]++;
  mcPCounter[96] += p;
  mcP2Counter[96] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP42
#define mccompcurname  PoreP42
#define mccompcurtype  Pore_p_group
#define mccompcurindex 96
#define nLeft mccPoreP42_nLeft
#define nRight mccPoreP42_nRight
#define nExit mccPoreP42_nExit
#define nTop mccPoreP42_nTop
#define nBottom mccPoreP42_nBottom
#define wLeft mccPoreP42_wLeft
#define wRight mccPoreP42_wRight
#define wExit mccPoreP42_wExit
#define wall mccPoreP42_wall
#define zentry mccPoreP42_zentry
#define reflec_top_table mccPoreP42_reflec_top_table
#define reflec_bottom_table mccPoreP42_reflec_bottom_table
#define reflec_side_table mccPoreP42_reflec_side_table
#define ref_prms mccPoreP42_ref_prms
{   /* Declarations of PoreP42=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP42_radius_p;
MCNUM radius_m = mccPoreP42_radius_m;
MCNUM Z0 = mccPoreP42_Z0;
MCNUM xwidth = mccPoreP42_xwidth;
MCNUM yheight = mccPoreP42_yheight;
MCNUM chamferwidth = mccPoreP42_chamferwidth;
char* mirror_reflec = mccPoreP42_mirror_reflec;
char* bottom_reflec = mccPoreP42_bottom_reflec;
char* side_reflec = mccPoreP42_side_reflec;
MCNUM R_d = mccPoreP42_R_d;
MCNUM absorb_sides = mccPoreP42_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 59069 "instruments/plate49.c"
}   /* End of PoreP42=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP42 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=96;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP42:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(96,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP43 [97] */
  mccoordschange(mcposrPoreP43, mcrotrPoreP43,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP43 (without coords transformations) */
  mcJumpTrace_PoreP43:
  SIG_MESSAGE("PoreP43 (Trace)");
  mcDEBUG_COMP("PoreP43")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP43
  STORE_XRAY(97,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[97]++;
  mcPCounter[97] += p;
  mcP2Counter[97] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP43
#define mccompcurname  PoreP43
#define mccompcurtype  Pore_p_group
#define mccompcurindex 97
#define nLeft mccPoreP43_nLeft
#define nRight mccPoreP43_nRight
#define nExit mccPoreP43_nExit
#define nTop mccPoreP43_nTop
#define nBottom mccPoreP43_nBottom
#define wLeft mccPoreP43_wLeft
#define wRight mccPoreP43_wRight
#define wExit mccPoreP43_wExit
#define wall mccPoreP43_wall
#define zentry mccPoreP43_zentry
#define reflec_top_table mccPoreP43_reflec_top_table
#define reflec_bottom_table mccPoreP43_reflec_bottom_table
#define reflec_side_table mccPoreP43_reflec_side_table
#define ref_prms mccPoreP43_ref_prms
{   /* Declarations of PoreP43=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP43_radius_p;
MCNUM radius_m = mccPoreP43_radius_m;
MCNUM Z0 = mccPoreP43_Z0;
MCNUM xwidth = mccPoreP43_xwidth;
MCNUM yheight = mccPoreP43_yheight;
MCNUM chamferwidth = mccPoreP43_chamferwidth;
char* mirror_reflec = mccPoreP43_mirror_reflec;
char* bottom_reflec = mccPoreP43_bottom_reflec;
char* side_reflec = mccPoreP43_side_reflec;
MCNUM R_d = mccPoreP43_R_d;
MCNUM absorb_sides = mccPoreP43_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 59371 "instruments/plate49.c"
}   /* End of PoreP43=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP43 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=97;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP43:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(97,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP44 [98] */
  mccoordschange(mcposrPoreP44, mcrotrPoreP44,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP44 (without coords transformations) */
  mcJumpTrace_PoreP44:
  SIG_MESSAGE("PoreP44 (Trace)");
  mcDEBUG_COMP("PoreP44")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP44
  STORE_XRAY(98,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[98]++;
  mcPCounter[98] += p;
  mcP2Counter[98] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP44
#define mccompcurname  PoreP44
#define mccompcurtype  Pore_p_group
#define mccompcurindex 98
#define nLeft mccPoreP44_nLeft
#define nRight mccPoreP44_nRight
#define nExit mccPoreP44_nExit
#define nTop mccPoreP44_nTop
#define nBottom mccPoreP44_nBottom
#define wLeft mccPoreP44_wLeft
#define wRight mccPoreP44_wRight
#define wExit mccPoreP44_wExit
#define wall mccPoreP44_wall
#define zentry mccPoreP44_zentry
#define reflec_top_table mccPoreP44_reflec_top_table
#define reflec_bottom_table mccPoreP44_reflec_bottom_table
#define reflec_side_table mccPoreP44_reflec_side_table
#define ref_prms mccPoreP44_ref_prms
{   /* Declarations of PoreP44=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP44_radius_p;
MCNUM radius_m = mccPoreP44_radius_m;
MCNUM Z0 = mccPoreP44_Z0;
MCNUM xwidth = mccPoreP44_xwidth;
MCNUM yheight = mccPoreP44_yheight;
MCNUM chamferwidth = mccPoreP44_chamferwidth;
char* mirror_reflec = mccPoreP44_mirror_reflec;
char* bottom_reflec = mccPoreP44_bottom_reflec;
char* side_reflec = mccPoreP44_side_reflec;
MCNUM R_d = mccPoreP44_R_d;
MCNUM absorb_sides = mccPoreP44_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 59673 "instruments/plate49.c"
}   /* End of PoreP44=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP44 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=98;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP44:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(98,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP45 [99] */
  mccoordschange(mcposrPoreP45, mcrotrPoreP45,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP45 (without coords transformations) */
  mcJumpTrace_PoreP45:
  SIG_MESSAGE("PoreP45 (Trace)");
  mcDEBUG_COMP("PoreP45")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP45
  STORE_XRAY(99,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[99]++;
  mcPCounter[99] += p;
  mcP2Counter[99] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP45
#define mccompcurname  PoreP45
#define mccompcurtype  Pore_p_group
#define mccompcurindex 99
#define nLeft mccPoreP45_nLeft
#define nRight mccPoreP45_nRight
#define nExit mccPoreP45_nExit
#define nTop mccPoreP45_nTop
#define nBottom mccPoreP45_nBottom
#define wLeft mccPoreP45_wLeft
#define wRight mccPoreP45_wRight
#define wExit mccPoreP45_wExit
#define wall mccPoreP45_wall
#define zentry mccPoreP45_zentry
#define reflec_top_table mccPoreP45_reflec_top_table
#define reflec_bottom_table mccPoreP45_reflec_bottom_table
#define reflec_side_table mccPoreP45_reflec_side_table
#define ref_prms mccPoreP45_ref_prms
{   /* Declarations of PoreP45=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP45_radius_p;
MCNUM radius_m = mccPoreP45_radius_m;
MCNUM Z0 = mccPoreP45_Z0;
MCNUM xwidth = mccPoreP45_xwidth;
MCNUM yheight = mccPoreP45_yheight;
MCNUM chamferwidth = mccPoreP45_chamferwidth;
char* mirror_reflec = mccPoreP45_mirror_reflec;
char* bottom_reflec = mccPoreP45_bottom_reflec;
char* side_reflec = mccPoreP45_side_reflec;
MCNUM R_d = mccPoreP45_R_d;
MCNUM absorb_sides = mccPoreP45_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 59975 "instruments/plate49.c"
}   /* End of PoreP45=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP45 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=99;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP45:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(99,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP46 [100] */
  mccoordschange(mcposrPoreP46, mcrotrPoreP46,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP46 (without coords transformations) */
  mcJumpTrace_PoreP46:
  SIG_MESSAGE("PoreP46 (Trace)");
  mcDEBUG_COMP("PoreP46")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP46
  STORE_XRAY(100,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[100]++;
  mcPCounter[100] += p;
  mcP2Counter[100] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP46
#define mccompcurname  PoreP46
#define mccompcurtype  Pore_p_group
#define mccompcurindex 100
#define nLeft mccPoreP46_nLeft
#define nRight mccPoreP46_nRight
#define nExit mccPoreP46_nExit
#define nTop mccPoreP46_nTop
#define nBottom mccPoreP46_nBottom
#define wLeft mccPoreP46_wLeft
#define wRight mccPoreP46_wRight
#define wExit mccPoreP46_wExit
#define wall mccPoreP46_wall
#define zentry mccPoreP46_zentry
#define reflec_top_table mccPoreP46_reflec_top_table
#define reflec_bottom_table mccPoreP46_reflec_bottom_table
#define reflec_side_table mccPoreP46_reflec_side_table
#define ref_prms mccPoreP46_ref_prms
{   /* Declarations of PoreP46=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP46_radius_p;
MCNUM radius_m = mccPoreP46_radius_m;
MCNUM Z0 = mccPoreP46_Z0;
MCNUM xwidth = mccPoreP46_xwidth;
MCNUM yheight = mccPoreP46_yheight;
MCNUM chamferwidth = mccPoreP46_chamferwidth;
char* mirror_reflec = mccPoreP46_mirror_reflec;
char* bottom_reflec = mccPoreP46_bottom_reflec;
char* side_reflec = mccPoreP46_side_reflec;
MCNUM R_d = mccPoreP46_R_d;
MCNUM absorb_sides = mccPoreP46_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 60277 "instruments/plate49.c"
}   /* End of PoreP46=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP46 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=100;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP46:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(100,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP47 [101] */
  mccoordschange(mcposrPoreP47, mcrotrPoreP47,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP47 (without coords transformations) */
  mcJumpTrace_PoreP47:
  SIG_MESSAGE("PoreP47 (Trace)");
  mcDEBUG_COMP("PoreP47")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP47
  STORE_XRAY(101,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[101]++;
  mcPCounter[101] += p;
  mcP2Counter[101] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP47
#define mccompcurname  PoreP47
#define mccompcurtype  Pore_p_group
#define mccompcurindex 101
#define nLeft mccPoreP47_nLeft
#define nRight mccPoreP47_nRight
#define nExit mccPoreP47_nExit
#define nTop mccPoreP47_nTop
#define nBottom mccPoreP47_nBottom
#define wLeft mccPoreP47_wLeft
#define wRight mccPoreP47_wRight
#define wExit mccPoreP47_wExit
#define wall mccPoreP47_wall
#define zentry mccPoreP47_zentry
#define reflec_top_table mccPoreP47_reflec_top_table
#define reflec_bottom_table mccPoreP47_reflec_bottom_table
#define reflec_side_table mccPoreP47_reflec_side_table
#define ref_prms mccPoreP47_ref_prms
{   /* Declarations of PoreP47=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP47_radius_p;
MCNUM radius_m = mccPoreP47_radius_m;
MCNUM Z0 = mccPoreP47_Z0;
MCNUM xwidth = mccPoreP47_xwidth;
MCNUM yheight = mccPoreP47_yheight;
MCNUM chamferwidth = mccPoreP47_chamferwidth;
char* mirror_reflec = mccPoreP47_mirror_reflec;
char* bottom_reflec = mccPoreP47_bottom_reflec;
char* side_reflec = mccPoreP47_side_reflec;
MCNUM R_d = mccPoreP47_R_d;
MCNUM absorb_sides = mccPoreP47_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 60579 "instruments/plate49.c"
}   /* End of PoreP47=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP47 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=101;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP47:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(101,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreP48 [102] */
  mccoordschange(mcposrPoreP48, mcrotrPoreP48,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreP48 (without coords transformations) */
  mcJumpTrace_PoreP48:
  SIG_MESSAGE("PoreP48 (Trace)");
  mcDEBUG_COMP("PoreP48")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreP48
  STORE_XRAY(102,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[102]++;
  mcPCounter[102] += p;
  mcP2Counter[102] += p*p;
  if (!mcGroupparabolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreP48
#define mccompcurname  PoreP48
#define mccompcurtype  Pore_p_group
#define mccompcurindex 102
#define nLeft mccPoreP48_nLeft
#define nRight mccPoreP48_nRight
#define nExit mccPoreP48_nExit
#define nTop mccPoreP48_nTop
#define nBottom mccPoreP48_nBottom
#define wLeft mccPoreP48_wLeft
#define wRight mccPoreP48_wRight
#define wExit mccPoreP48_wExit
#define wall mccPoreP48_wall
#define zentry mccPoreP48_zentry
#define reflec_top_table mccPoreP48_reflec_top_table
#define reflec_bottom_table mccPoreP48_reflec_bottom_table
#define reflec_side_table mccPoreP48_reflec_side_table
#define ref_prms mccPoreP48_ref_prms
{   /* Declarations of PoreP48=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP48_radius_p;
MCNUM radius_m = mccPoreP48_radius_m;
MCNUM Z0 = mccPoreP48_Z0;
MCNUM xwidth = mccPoreP48_xwidth;
MCNUM yheight = mccPoreP48_yheight;
MCNUM chamferwidth = mccPoreP48_chamferwidth;
char* mirror_reflec = mccPoreP48_mirror_reflec;
char* bottom_reflec = mccPoreP48_bottom_reflec;
char* side_reflec = mccPoreP48_side_reflec;
MCNUM R_d = mccPoreP48_R_d;
MCNUM absorb_sides = mccPoreP48_absorb_sides;
#line 224 "Pore_p_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/

    /*Moving photon to z=zentry. This odd way of writing this is to handle phase and time automatically.*/
    z-=zentry;
    PROP_Z0;
    z+=zentry;

    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_p*radius_p ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_p-yheight)*(radius_p-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_p)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;
        enteredPore = 1;
        bufferAddPlanePosition(ENTRY, x, y, z);

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz, nLeft[0], nLeft[1], nLeft[2], wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_paraboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_paraboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/
                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }

            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(PT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(PB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(PL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(PR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
                printf("reflec_table is null!\n");
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    } else if (hit_chamfer) {
        // ABSORB;
    } else {
        /*no hit*/
        //ABSORB;
    }
}
#line 60881 "instruments/plate49.c"
/* 'PoreP48=Pore_p_group()' component instance extend code */
    SIG_MESSAGE("PoreP48 (Trace:Extend)");
#line 1121 "instruments/plate49.instr"
if(!enteredPore){
bufferRemoveCurrentPhoton();
ABSORB;}
#line 60888 "instruments/plate49.c"
}   /* End of PoreP48=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreP48 in GROUP parabolic */
  if (SCATTERED) {
    mcGroupparabolic=102;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreP48:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(102,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
/* end of GROUP parabolic */
  if (!mcGroupparabolic) ABSORB; /* absorb xray non scattered in GROUP */
  mcGroupparabolic=0; /* reset group scattered flag */
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH0 [103] */
  mccoordschange(mcposrPoreH0, mcrotrPoreH0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH0 (without coords transformations) */
  mcJumpTrace_PoreH0:
  SIG_MESSAGE("PoreH0 (Trace)");
  mcDEBUG_COMP("PoreH0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH0
  STORE_XRAY(103,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[103]++;
  mcPCounter[103] += p;
  mcP2Counter[103] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH0
#define mccompcurname  PoreH0
#define mccompcurtype  Pore_h_group
#define mccompcurindex 103
#define nLeft mccPoreH0_nLeft
#define nRight mccPoreH0_nRight
#define nExit mccPoreH0_nExit
#define wLeft mccPoreH0_wLeft
#define wRight mccPoreH0_wRight
#define wExit mccPoreH0_wExit
#define wall mccPoreH0_wall
#define nTop mccPoreH0_nTop
#define nBottom mccPoreH0_nBottom
#define zexit mccPoreH0_zexit
#define zentry mccPoreH0_zentry
#define intersect_wolterI mccPoreH0_intersect_wolterI
#define reflec_side_table mccPoreH0_reflec_side_table
#define reflec_top_table mccPoreH0_reflec_top_table
#define reflec_bottom_table mccPoreH0_reflec_bottom_table
#define ref_prms mccPoreH0_ref_prms
{   /* Declarations of PoreH0=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH0_radius_m;
MCNUM radius_h = mccPoreH0_radius_h;
MCNUM Z0 = mccPoreH0_Z0;
MCNUM xwidth = mccPoreH0_xwidth;
MCNUM yheight = mccPoreH0_yheight;
MCNUM chamferwidth = mccPoreH0_chamferwidth;
char* mirror_reflec = mccPoreH0_mirror_reflec;
char* bottom_reflec = mccPoreH0_bottom_reflec;
char* side_reflec = mccPoreH0_side_reflec;
MCNUM R_d = mccPoreH0_R_d;
MCNUM absorb_sides = mccPoreH0_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 61188 "instruments/plate49.c"
}   /* End of PoreH0=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH0 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=103;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH0:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(103,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH1 [104] */
  mccoordschange(mcposrPoreH1, mcrotrPoreH1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH1 (without coords transformations) */
  mcJumpTrace_PoreH1:
  SIG_MESSAGE("PoreH1 (Trace)");
  mcDEBUG_COMP("PoreH1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH1
  STORE_XRAY(104,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[104]++;
  mcPCounter[104] += p;
  mcP2Counter[104] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH1
#define mccompcurname  PoreH1
#define mccompcurtype  Pore_h_group
#define mccompcurindex 104
#define nLeft mccPoreH1_nLeft
#define nRight mccPoreH1_nRight
#define nExit mccPoreH1_nExit
#define wLeft mccPoreH1_wLeft
#define wRight mccPoreH1_wRight
#define wExit mccPoreH1_wExit
#define wall mccPoreH1_wall
#define nTop mccPoreH1_nTop
#define nBottom mccPoreH1_nBottom
#define zexit mccPoreH1_zexit
#define zentry mccPoreH1_zentry
#define intersect_wolterI mccPoreH1_intersect_wolterI
#define reflec_side_table mccPoreH1_reflec_side_table
#define reflec_top_table mccPoreH1_reflec_top_table
#define reflec_bottom_table mccPoreH1_reflec_bottom_table
#define ref_prms mccPoreH1_ref_prms
{   /* Declarations of PoreH1=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH1_radius_m;
MCNUM radius_h = mccPoreH1_radius_h;
MCNUM Z0 = mccPoreH1_Z0;
MCNUM xwidth = mccPoreH1_xwidth;
MCNUM yheight = mccPoreH1_yheight;
MCNUM chamferwidth = mccPoreH1_chamferwidth;
char* mirror_reflec = mccPoreH1_mirror_reflec;
char* bottom_reflec = mccPoreH1_bottom_reflec;
char* side_reflec = mccPoreH1_side_reflec;
MCNUM R_d = mccPoreH1_R_d;
MCNUM absorb_sides = mccPoreH1_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 61487 "instruments/plate49.c"
}   /* End of PoreH1=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH1 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=104;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH1:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(104,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH2 [105] */
  mccoordschange(mcposrPoreH2, mcrotrPoreH2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH2 (without coords transformations) */
  mcJumpTrace_PoreH2:
  SIG_MESSAGE("PoreH2 (Trace)");
  mcDEBUG_COMP("PoreH2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH2
  STORE_XRAY(105,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[105]++;
  mcPCounter[105] += p;
  mcP2Counter[105] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH2
#define mccompcurname  PoreH2
#define mccompcurtype  Pore_h_group
#define mccompcurindex 105
#define nLeft mccPoreH2_nLeft
#define nRight mccPoreH2_nRight
#define nExit mccPoreH2_nExit
#define wLeft mccPoreH2_wLeft
#define wRight mccPoreH2_wRight
#define wExit mccPoreH2_wExit
#define wall mccPoreH2_wall
#define nTop mccPoreH2_nTop
#define nBottom mccPoreH2_nBottom
#define zexit mccPoreH2_zexit
#define zentry mccPoreH2_zentry
#define intersect_wolterI mccPoreH2_intersect_wolterI
#define reflec_side_table mccPoreH2_reflec_side_table
#define reflec_top_table mccPoreH2_reflec_top_table
#define reflec_bottom_table mccPoreH2_reflec_bottom_table
#define ref_prms mccPoreH2_ref_prms
{   /* Declarations of PoreH2=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH2_radius_m;
MCNUM radius_h = mccPoreH2_radius_h;
MCNUM Z0 = mccPoreH2_Z0;
MCNUM xwidth = mccPoreH2_xwidth;
MCNUM yheight = mccPoreH2_yheight;
MCNUM chamferwidth = mccPoreH2_chamferwidth;
char* mirror_reflec = mccPoreH2_mirror_reflec;
char* bottom_reflec = mccPoreH2_bottom_reflec;
char* side_reflec = mccPoreH2_side_reflec;
MCNUM R_d = mccPoreH2_R_d;
MCNUM absorb_sides = mccPoreH2_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 61786 "instruments/plate49.c"
}   /* End of PoreH2=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH2 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=105;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH2:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(105,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH3 [106] */
  mccoordschange(mcposrPoreH3, mcrotrPoreH3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH3 (without coords transformations) */
  mcJumpTrace_PoreH3:
  SIG_MESSAGE("PoreH3 (Trace)");
  mcDEBUG_COMP("PoreH3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH3
  STORE_XRAY(106,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[106]++;
  mcPCounter[106] += p;
  mcP2Counter[106] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH3
#define mccompcurname  PoreH3
#define mccompcurtype  Pore_h_group
#define mccompcurindex 106
#define nLeft mccPoreH3_nLeft
#define nRight mccPoreH3_nRight
#define nExit mccPoreH3_nExit
#define wLeft mccPoreH3_wLeft
#define wRight mccPoreH3_wRight
#define wExit mccPoreH3_wExit
#define wall mccPoreH3_wall
#define nTop mccPoreH3_nTop
#define nBottom mccPoreH3_nBottom
#define zexit mccPoreH3_zexit
#define zentry mccPoreH3_zentry
#define intersect_wolterI mccPoreH3_intersect_wolterI
#define reflec_side_table mccPoreH3_reflec_side_table
#define reflec_top_table mccPoreH3_reflec_top_table
#define reflec_bottom_table mccPoreH3_reflec_bottom_table
#define ref_prms mccPoreH3_ref_prms
{   /* Declarations of PoreH3=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH3_radius_m;
MCNUM radius_h = mccPoreH3_radius_h;
MCNUM Z0 = mccPoreH3_Z0;
MCNUM xwidth = mccPoreH3_xwidth;
MCNUM yheight = mccPoreH3_yheight;
MCNUM chamferwidth = mccPoreH3_chamferwidth;
char* mirror_reflec = mccPoreH3_mirror_reflec;
char* bottom_reflec = mccPoreH3_bottom_reflec;
char* side_reflec = mccPoreH3_side_reflec;
MCNUM R_d = mccPoreH3_R_d;
MCNUM absorb_sides = mccPoreH3_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 62085 "instruments/plate49.c"
}   /* End of PoreH3=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH3 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=106;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH3:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(106,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH4 [107] */
  mccoordschange(mcposrPoreH4, mcrotrPoreH4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH4 (without coords transformations) */
  mcJumpTrace_PoreH4:
  SIG_MESSAGE("PoreH4 (Trace)");
  mcDEBUG_COMP("PoreH4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH4
  STORE_XRAY(107,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[107]++;
  mcPCounter[107] += p;
  mcP2Counter[107] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH4
#define mccompcurname  PoreH4
#define mccompcurtype  Pore_h_group
#define mccompcurindex 107
#define nLeft mccPoreH4_nLeft
#define nRight mccPoreH4_nRight
#define nExit mccPoreH4_nExit
#define wLeft mccPoreH4_wLeft
#define wRight mccPoreH4_wRight
#define wExit mccPoreH4_wExit
#define wall mccPoreH4_wall
#define nTop mccPoreH4_nTop
#define nBottom mccPoreH4_nBottom
#define zexit mccPoreH4_zexit
#define zentry mccPoreH4_zentry
#define intersect_wolterI mccPoreH4_intersect_wolterI
#define reflec_side_table mccPoreH4_reflec_side_table
#define reflec_top_table mccPoreH4_reflec_top_table
#define reflec_bottom_table mccPoreH4_reflec_bottom_table
#define ref_prms mccPoreH4_ref_prms
{   /* Declarations of PoreH4=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH4_radius_m;
MCNUM radius_h = mccPoreH4_radius_h;
MCNUM Z0 = mccPoreH4_Z0;
MCNUM xwidth = mccPoreH4_xwidth;
MCNUM yheight = mccPoreH4_yheight;
MCNUM chamferwidth = mccPoreH4_chamferwidth;
char* mirror_reflec = mccPoreH4_mirror_reflec;
char* bottom_reflec = mccPoreH4_bottom_reflec;
char* side_reflec = mccPoreH4_side_reflec;
MCNUM R_d = mccPoreH4_R_d;
MCNUM absorb_sides = mccPoreH4_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 62384 "instruments/plate49.c"
}   /* End of PoreH4=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH4 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=107;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH4:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(107,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH5 [108] */
  mccoordschange(mcposrPoreH5, mcrotrPoreH5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH5 (without coords transformations) */
  mcJumpTrace_PoreH5:
  SIG_MESSAGE("PoreH5 (Trace)");
  mcDEBUG_COMP("PoreH5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH5
  STORE_XRAY(108,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[108]++;
  mcPCounter[108] += p;
  mcP2Counter[108] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH5
#define mccompcurname  PoreH5
#define mccompcurtype  Pore_h_group
#define mccompcurindex 108
#define nLeft mccPoreH5_nLeft
#define nRight mccPoreH5_nRight
#define nExit mccPoreH5_nExit
#define wLeft mccPoreH5_wLeft
#define wRight mccPoreH5_wRight
#define wExit mccPoreH5_wExit
#define wall mccPoreH5_wall
#define nTop mccPoreH5_nTop
#define nBottom mccPoreH5_nBottom
#define zexit mccPoreH5_zexit
#define zentry mccPoreH5_zentry
#define intersect_wolterI mccPoreH5_intersect_wolterI
#define reflec_side_table mccPoreH5_reflec_side_table
#define reflec_top_table mccPoreH5_reflec_top_table
#define reflec_bottom_table mccPoreH5_reflec_bottom_table
#define ref_prms mccPoreH5_ref_prms
{   /* Declarations of PoreH5=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH5_radius_m;
MCNUM radius_h = mccPoreH5_radius_h;
MCNUM Z0 = mccPoreH5_Z0;
MCNUM xwidth = mccPoreH5_xwidth;
MCNUM yheight = mccPoreH5_yheight;
MCNUM chamferwidth = mccPoreH5_chamferwidth;
char* mirror_reflec = mccPoreH5_mirror_reflec;
char* bottom_reflec = mccPoreH5_bottom_reflec;
char* side_reflec = mccPoreH5_side_reflec;
MCNUM R_d = mccPoreH5_R_d;
MCNUM absorb_sides = mccPoreH5_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 62683 "instruments/plate49.c"
}   /* End of PoreH5=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH5 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=108;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH5:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(108,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH6 [109] */
  mccoordschange(mcposrPoreH6, mcrotrPoreH6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH6 (without coords transformations) */
  mcJumpTrace_PoreH6:
  SIG_MESSAGE("PoreH6 (Trace)");
  mcDEBUG_COMP("PoreH6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH6
  STORE_XRAY(109,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[109]++;
  mcPCounter[109] += p;
  mcP2Counter[109] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH6
#define mccompcurname  PoreH6
#define mccompcurtype  Pore_h_group
#define mccompcurindex 109
#define nLeft mccPoreH6_nLeft
#define nRight mccPoreH6_nRight
#define nExit mccPoreH6_nExit
#define wLeft mccPoreH6_wLeft
#define wRight mccPoreH6_wRight
#define wExit mccPoreH6_wExit
#define wall mccPoreH6_wall
#define nTop mccPoreH6_nTop
#define nBottom mccPoreH6_nBottom
#define zexit mccPoreH6_zexit
#define zentry mccPoreH6_zentry
#define intersect_wolterI mccPoreH6_intersect_wolterI
#define reflec_side_table mccPoreH6_reflec_side_table
#define reflec_top_table mccPoreH6_reflec_top_table
#define reflec_bottom_table mccPoreH6_reflec_bottom_table
#define ref_prms mccPoreH6_ref_prms
{   /* Declarations of PoreH6=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH6_radius_m;
MCNUM radius_h = mccPoreH6_radius_h;
MCNUM Z0 = mccPoreH6_Z0;
MCNUM xwidth = mccPoreH6_xwidth;
MCNUM yheight = mccPoreH6_yheight;
MCNUM chamferwidth = mccPoreH6_chamferwidth;
char* mirror_reflec = mccPoreH6_mirror_reflec;
char* bottom_reflec = mccPoreH6_bottom_reflec;
char* side_reflec = mccPoreH6_side_reflec;
MCNUM R_d = mccPoreH6_R_d;
MCNUM absorb_sides = mccPoreH6_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 62982 "instruments/plate49.c"
}   /* End of PoreH6=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH6 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=109;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH6:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(109,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH7 [110] */
  mccoordschange(mcposrPoreH7, mcrotrPoreH7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH7 (without coords transformations) */
  mcJumpTrace_PoreH7:
  SIG_MESSAGE("PoreH7 (Trace)");
  mcDEBUG_COMP("PoreH7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH7
  STORE_XRAY(110,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[110]++;
  mcPCounter[110] += p;
  mcP2Counter[110] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH7
#define mccompcurname  PoreH7
#define mccompcurtype  Pore_h_group
#define mccompcurindex 110
#define nLeft mccPoreH7_nLeft
#define nRight mccPoreH7_nRight
#define nExit mccPoreH7_nExit
#define wLeft mccPoreH7_wLeft
#define wRight mccPoreH7_wRight
#define wExit mccPoreH7_wExit
#define wall mccPoreH7_wall
#define nTop mccPoreH7_nTop
#define nBottom mccPoreH7_nBottom
#define zexit mccPoreH7_zexit
#define zentry mccPoreH7_zentry
#define intersect_wolterI mccPoreH7_intersect_wolterI
#define reflec_side_table mccPoreH7_reflec_side_table
#define reflec_top_table mccPoreH7_reflec_top_table
#define reflec_bottom_table mccPoreH7_reflec_bottom_table
#define ref_prms mccPoreH7_ref_prms
{   /* Declarations of PoreH7=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH7_radius_m;
MCNUM radius_h = mccPoreH7_radius_h;
MCNUM Z0 = mccPoreH7_Z0;
MCNUM xwidth = mccPoreH7_xwidth;
MCNUM yheight = mccPoreH7_yheight;
MCNUM chamferwidth = mccPoreH7_chamferwidth;
char* mirror_reflec = mccPoreH7_mirror_reflec;
char* bottom_reflec = mccPoreH7_bottom_reflec;
char* side_reflec = mccPoreH7_side_reflec;
MCNUM R_d = mccPoreH7_R_d;
MCNUM absorb_sides = mccPoreH7_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 63281 "instruments/plate49.c"
}   /* End of PoreH7=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH7 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=110;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH7:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(110,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH8 [111] */
  mccoordschange(mcposrPoreH8, mcrotrPoreH8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH8 (without coords transformations) */
  mcJumpTrace_PoreH8:
  SIG_MESSAGE("PoreH8 (Trace)");
  mcDEBUG_COMP("PoreH8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH8
  STORE_XRAY(111,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[111]++;
  mcPCounter[111] += p;
  mcP2Counter[111] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH8
#define mccompcurname  PoreH8
#define mccompcurtype  Pore_h_group
#define mccompcurindex 111
#define nLeft mccPoreH8_nLeft
#define nRight mccPoreH8_nRight
#define nExit mccPoreH8_nExit
#define wLeft mccPoreH8_wLeft
#define wRight mccPoreH8_wRight
#define wExit mccPoreH8_wExit
#define wall mccPoreH8_wall
#define nTop mccPoreH8_nTop
#define nBottom mccPoreH8_nBottom
#define zexit mccPoreH8_zexit
#define zentry mccPoreH8_zentry
#define intersect_wolterI mccPoreH8_intersect_wolterI
#define reflec_side_table mccPoreH8_reflec_side_table
#define reflec_top_table mccPoreH8_reflec_top_table
#define reflec_bottom_table mccPoreH8_reflec_bottom_table
#define ref_prms mccPoreH8_ref_prms
{   /* Declarations of PoreH8=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH8_radius_m;
MCNUM radius_h = mccPoreH8_radius_h;
MCNUM Z0 = mccPoreH8_Z0;
MCNUM xwidth = mccPoreH8_xwidth;
MCNUM yheight = mccPoreH8_yheight;
MCNUM chamferwidth = mccPoreH8_chamferwidth;
char* mirror_reflec = mccPoreH8_mirror_reflec;
char* bottom_reflec = mccPoreH8_bottom_reflec;
char* side_reflec = mccPoreH8_side_reflec;
MCNUM R_d = mccPoreH8_R_d;
MCNUM absorb_sides = mccPoreH8_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 63580 "instruments/plate49.c"
}   /* End of PoreH8=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH8 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=111;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH8:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(111,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH9 [112] */
  mccoordschange(mcposrPoreH9, mcrotrPoreH9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH9 (without coords transformations) */
  mcJumpTrace_PoreH9:
  SIG_MESSAGE("PoreH9 (Trace)");
  mcDEBUG_COMP("PoreH9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH9
  STORE_XRAY(112,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[112]++;
  mcPCounter[112] += p;
  mcP2Counter[112] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH9
#define mccompcurname  PoreH9
#define mccompcurtype  Pore_h_group
#define mccompcurindex 112
#define nLeft mccPoreH9_nLeft
#define nRight mccPoreH9_nRight
#define nExit mccPoreH9_nExit
#define wLeft mccPoreH9_wLeft
#define wRight mccPoreH9_wRight
#define wExit mccPoreH9_wExit
#define wall mccPoreH9_wall
#define nTop mccPoreH9_nTop
#define nBottom mccPoreH9_nBottom
#define zexit mccPoreH9_zexit
#define zentry mccPoreH9_zentry
#define intersect_wolterI mccPoreH9_intersect_wolterI
#define reflec_side_table mccPoreH9_reflec_side_table
#define reflec_top_table mccPoreH9_reflec_top_table
#define reflec_bottom_table mccPoreH9_reflec_bottom_table
#define ref_prms mccPoreH9_ref_prms
{   /* Declarations of PoreH9=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH9_radius_m;
MCNUM radius_h = mccPoreH9_radius_h;
MCNUM Z0 = mccPoreH9_Z0;
MCNUM xwidth = mccPoreH9_xwidth;
MCNUM yheight = mccPoreH9_yheight;
MCNUM chamferwidth = mccPoreH9_chamferwidth;
char* mirror_reflec = mccPoreH9_mirror_reflec;
char* bottom_reflec = mccPoreH9_bottom_reflec;
char* side_reflec = mccPoreH9_side_reflec;
MCNUM R_d = mccPoreH9_R_d;
MCNUM absorb_sides = mccPoreH9_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 63879 "instruments/plate49.c"
}   /* End of PoreH9=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH9 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=112;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH9:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(112,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH10 [113] */
  mccoordschange(mcposrPoreH10, mcrotrPoreH10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH10 (without coords transformations) */
  mcJumpTrace_PoreH10:
  SIG_MESSAGE("PoreH10 (Trace)");
  mcDEBUG_COMP("PoreH10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH10
  STORE_XRAY(113,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[113]++;
  mcPCounter[113] += p;
  mcP2Counter[113] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH10
#define mccompcurname  PoreH10
#define mccompcurtype  Pore_h_group
#define mccompcurindex 113
#define nLeft mccPoreH10_nLeft
#define nRight mccPoreH10_nRight
#define nExit mccPoreH10_nExit
#define wLeft mccPoreH10_wLeft
#define wRight mccPoreH10_wRight
#define wExit mccPoreH10_wExit
#define wall mccPoreH10_wall
#define nTop mccPoreH10_nTop
#define nBottom mccPoreH10_nBottom
#define zexit mccPoreH10_zexit
#define zentry mccPoreH10_zentry
#define intersect_wolterI mccPoreH10_intersect_wolterI
#define reflec_side_table mccPoreH10_reflec_side_table
#define reflec_top_table mccPoreH10_reflec_top_table
#define reflec_bottom_table mccPoreH10_reflec_bottom_table
#define ref_prms mccPoreH10_ref_prms
{   /* Declarations of PoreH10=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH10_radius_m;
MCNUM radius_h = mccPoreH10_radius_h;
MCNUM Z0 = mccPoreH10_Z0;
MCNUM xwidth = mccPoreH10_xwidth;
MCNUM yheight = mccPoreH10_yheight;
MCNUM chamferwidth = mccPoreH10_chamferwidth;
char* mirror_reflec = mccPoreH10_mirror_reflec;
char* bottom_reflec = mccPoreH10_bottom_reflec;
char* side_reflec = mccPoreH10_side_reflec;
MCNUM R_d = mccPoreH10_R_d;
MCNUM absorb_sides = mccPoreH10_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 64178 "instruments/plate49.c"
}   /* End of PoreH10=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH10 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=113;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH10:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(113,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH11 [114] */
  mccoordschange(mcposrPoreH11, mcrotrPoreH11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH11 (without coords transformations) */
  mcJumpTrace_PoreH11:
  SIG_MESSAGE("PoreH11 (Trace)");
  mcDEBUG_COMP("PoreH11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH11
  STORE_XRAY(114,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[114]++;
  mcPCounter[114] += p;
  mcP2Counter[114] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH11
#define mccompcurname  PoreH11
#define mccompcurtype  Pore_h_group
#define mccompcurindex 114
#define nLeft mccPoreH11_nLeft
#define nRight mccPoreH11_nRight
#define nExit mccPoreH11_nExit
#define wLeft mccPoreH11_wLeft
#define wRight mccPoreH11_wRight
#define wExit mccPoreH11_wExit
#define wall mccPoreH11_wall
#define nTop mccPoreH11_nTop
#define nBottom mccPoreH11_nBottom
#define zexit mccPoreH11_zexit
#define zentry mccPoreH11_zentry
#define intersect_wolterI mccPoreH11_intersect_wolterI
#define reflec_side_table mccPoreH11_reflec_side_table
#define reflec_top_table mccPoreH11_reflec_top_table
#define reflec_bottom_table mccPoreH11_reflec_bottom_table
#define ref_prms mccPoreH11_ref_prms
{   /* Declarations of PoreH11=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH11_radius_m;
MCNUM radius_h = mccPoreH11_radius_h;
MCNUM Z0 = mccPoreH11_Z0;
MCNUM xwidth = mccPoreH11_xwidth;
MCNUM yheight = mccPoreH11_yheight;
MCNUM chamferwidth = mccPoreH11_chamferwidth;
char* mirror_reflec = mccPoreH11_mirror_reflec;
char* bottom_reflec = mccPoreH11_bottom_reflec;
char* side_reflec = mccPoreH11_side_reflec;
MCNUM R_d = mccPoreH11_R_d;
MCNUM absorb_sides = mccPoreH11_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 64477 "instruments/plate49.c"
}   /* End of PoreH11=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH11 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=114;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH11:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(114,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH12 [115] */
  mccoordschange(mcposrPoreH12, mcrotrPoreH12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH12 (without coords transformations) */
  mcJumpTrace_PoreH12:
  SIG_MESSAGE("PoreH12 (Trace)");
  mcDEBUG_COMP("PoreH12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH12
  STORE_XRAY(115,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[115]++;
  mcPCounter[115] += p;
  mcP2Counter[115] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH12
#define mccompcurname  PoreH12
#define mccompcurtype  Pore_h_group
#define mccompcurindex 115
#define nLeft mccPoreH12_nLeft
#define nRight mccPoreH12_nRight
#define nExit mccPoreH12_nExit
#define wLeft mccPoreH12_wLeft
#define wRight mccPoreH12_wRight
#define wExit mccPoreH12_wExit
#define wall mccPoreH12_wall
#define nTop mccPoreH12_nTop
#define nBottom mccPoreH12_nBottom
#define zexit mccPoreH12_zexit
#define zentry mccPoreH12_zentry
#define intersect_wolterI mccPoreH12_intersect_wolterI
#define reflec_side_table mccPoreH12_reflec_side_table
#define reflec_top_table mccPoreH12_reflec_top_table
#define reflec_bottom_table mccPoreH12_reflec_bottom_table
#define ref_prms mccPoreH12_ref_prms
{   /* Declarations of PoreH12=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH12_radius_m;
MCNUM radius_h = mccPoreH12_radius_h;
MCNUM Z0 = mccPoreH12_Z0;
MCNUM xwidth = mccPoreH12_xwidth;
MCNUM yheight = mccPoreH12_yheight;
MCNUM chamferwidth = mccPoreH12_chamferwidth;
char* mirror_reflec = mccPoreH12_mirror_reflec;
char* bottom_reflec = mccPoreH12_bottom_reflec;
char* side_reflec = mccPoreH12_side_reflec;
MCNUM R_d = mccPoreH12_R_d;
MCNUM absorb_sides = mccPoreH12_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 64776 "instruments/plate49.c"
}   /* End of PoreH12=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH12 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=115;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH12:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(115,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH13 [116] */
  mccoordschange(mcposrPoreH13, mcrotrPoreH13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH13 (without coords transformations) */
  mcJumpTrace_PoreH13:
  SIG_MESSAGE("PoreH13 (Trace)");
  mcDEBUG_COMP("PoreH13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH13
  STORE_XRAY(116,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[116]++;
  mcPCounter[116] += p;
  mcP2Counter[116] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH13
#define mccompcurname  PoreH13
#define mccompcurtype  Pore_h_group
#define mccompcurindex 116
#define nLeft mccPoreH13_nLeft
#define nRight mccPoreH13_nRight
#define nExit mccPoreH13_nExit
#define wLeft mccPoreH13_wLeft
#define wRight mccPoreH13_wRight
#define wExit mccPoreH13_wExit
#define wall mccPoreH13_wall
#define nTop mccPoreH13_nTop
#define nBottom mccPoreH13_nBottom
#define zexit mccPoreH13_zexit
#define zentry mccPoreH13_zentry
#define intersect_wolterI mccPoreH13_intersect_wolterI
#define reflec_side_table mccPoreH13_reflec_side_table
#define reflec_top_table mccPoreH13_reflec_top_table
#define reflec_bottom_table mccPoreH13_reflec_bottom_table
#define ref_prms mccPoreH13_ref_prms
{   /* Declarations of PoreH13=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH13_radius_m;
MCNUM radius_h = mccPoreH13_radius_h;
MCNUM Z0 = mccPoreH13_Z0;
MCNUM xwidth = mccPoreH13_xwidth;
MCNUM yheight = mccPoreH13_yheight;
MCNUM chamferwidth = mccPoreH13_chamferwidth;
char* mirror_reflec = mccPoreH13_mirror_reflec;
char* bottom_reflec = mccPoreH13_bottom_reflec;
char* side_reflec = mccPoreH13_side_reflec;
MCNUM R_d = mccPoreH13_R_d;
MCNUM absorb_sides = mccPoreH13_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 65075 "instruments/plate49.c"
}   /* End of PoreH13=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH13 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=116;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH13:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(116,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH14 [117] */
  mccoordschange(mcposrPoreH14, mcrotrPoreH14,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH14 (without coords transformations) */
  mcJumpTrace_PoreH14:
  SIG_MESSAGE("PoreH14 (Trace)");
  mcDEBUG_COMP("PoreH14")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH14
  STORE_XRAY(117,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[117]++;
  mcPCounter[117] += p;
  mcP2Counter[117] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH14
#define mccompcurname  PoreH14
#define mccompcurtype  Pore_h_group
#define mccompcurindex 117
#define nLeft mccPoreH14_nLeft
#define nRight mccPoreH14_nRight
#define nExit mccPoreH14_nExit
#define wLeft mccPoreH14_wLeft
#define wRight mccPoreH14_wRight
#define wExit mccPoreH14_wExit
#define wall mccPoreH14_wall
#define nTop mccPoreH14_nTop
#define nBottom mccPoreH14_nBottom
#define zexit mccPoreH14_zexit
#define zentry mccPoreH14_zentry
#define intersect_wolterI mccPoreH14_intersect_wolterI
#define reflec_side_table mccPoreH14_reflec_side_table
#define reflec_top_table mccPoreH14_reflec_top_table
#define reflec_bottom_table mccPoreH14_reflec_bottom_table
#define ref_prms mccPoreH14_ref_prms
{   /* Declarations of PoreH14=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH14_radius_m;
MCNUM radius_h = mccPoreH14_radius_h;
MCNUM Z0 = mccPoreH14_Z0;
MCNUM xwidth = mccPoreH14_xwidth;
MCNUM yheight = mccPoreH14_yheight;
MCNUM chamferwidth = mccPoreH14_chamferwidth;
char* mirror_reflec = mccPoreH14_mirror_reflec;
char* bottom_reflec = mccPoreH14_bottom_reflec;
char* side_reflec = mccPoreH14_side_reflec;
MCNUM R_d = mccPoreH14_R_d;
MCNUM absorb_sides = mccPoreH14_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 65374 "instruments/plate49.c"
}   /* End of PoreH14=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH14 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=117;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH14:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(117,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH15 [118] */
  mccoordschange(mcposrPoreH15, mcrotrPoreH15,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH15 (without coords transformations) */
  mcJumpTrace_PoreH15:
  SIG_MESSAGE("PoreH15 (Trace)");
  mcDEBUG_COMP("PoreH15")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH15
  STORE_XRAY(118,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[118]++;
  mcPCounter[118] += p;
  mcP2Counter[118] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH15
#define mccompcurname  PoreH15
#define mccompcurtype  Pore_h_group
#define mccompcurindex 118
#define nLeft mccPoreH15_nLeft
#define nRight mccPoreH15_nRight
#define nExit mccPoreH15_nExit
#define wLeft mccPoreH15_wLeft
#define wRight mccPoreH15_wRight
#define wExit mccPoreH15_wExit
#define wall mccPoreH15_wall
#define nTop mccPoreH15_nTop
#define nBottom mccPoreH15_nBottom
#define zexit mccPoreH15_zexit
#define zentry mccPoreH15_zentry
#define intersect_wolterI mccPoreH15_intersect_wolterI
#define reflec_side_table mccPoreH15_reflec_side_table
#define reflec_top_table mccPoreH15_reflec_top_table
#define reflec_bottom_table mccPoreH15_reflec_bottom_table
#define ref_prms mccPoreH15_ref_prms
{   /* Declarations of PoreH15=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH15_radius_m;
MCNUM radius_h = mccPoreH15_radius_h;
MCNUM Z0 = mccPoreH15_Z0;
MCNUM xwidth = mccPoreH15_xwidth;
MCNUM yheight = mccPoreH15_yheight;
MCNUM chamferwidth = mccPoreH15_chamferwidth;
char* mirror_reflec = mccPoreH15_mirror_reflec;
char* bottom_reflec = mccPoreH15_bottom_reflec;
char* side_reflec = mccPoreH15_side_reflec;
MCNUM R_d = mccPoreH15_R_d;
MCNUM absorb_sides = mccPoreH15_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 65673 "instruments/plate49.c"
}   /* End of PoreH15=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH15 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=118;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH15:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(118,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH16 [119] */
  mccoordschange(mcposrPoreH16, mcrotrPoreH16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH16 (without coords transformations) */
  mcJumpTrace_PoreH16:
  SIG_MESSAGE("PoreH16 (Trace)");
  mcDEBUG_COMP("PoreH16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH16
  STORE_XRAY(119,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[119]++;
  mcPCounter[119] += p;
  mcP2Counter[119] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH16
#define mccompcurname  PoreH16
#define mccompcurtype  Pore_h_group
#define mccompcurindex 119
#define nLeft mccPoreH16_nLeft
#define nRight mccPoreH16_nRight
#define nExit mccPoreH16_nExit
#define wLeft mccPoreH16_wLeft
#define wRight mccPoreH16_wRight
#define wExit mccPoreH16_wExit
#define wall mccPoreH16_wall
#define nTop mccPoreH16_nTop
#define nBottom mccPoreH16_nBottom
#define zexit mccPoreH16_zexit
#define zentry mccPoreH16_zentry
#define intersect_wolterI mccPoreH16_intersect_wolterI
#define reflec_side_table mccPoreH16_reflec_side_table
#define reflec_top_table mccPoreH16_reflec_top_table
#define reflec_bottom_table mccPoreH16_reflec_bottom_table
#define ref_prms mccPoreH16_ref_prms
{   /* Declarations of PoreH16=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH16_radius_m;
MCNUM radius_h = mccPoreH16_radius_h;
MCNUM Z0 = mccPoreH16_Z0;
MCNUM xwidth = mccPoreH16_xwidth;
MCNUM yheight = mccPoreH16_yheight;
MCNUM chamferwidth = mccPoreH16_chamferwidth;
char* mirror_reflec = mccPoreH16_mirror_reflec;
char* bottom_reflec = mccPoreH16_bottom_reflec;
char* side_reflec = mccPoreH16_side_reflec;
MCNUM R_d = mccPoreH16_R_d;
MCNUM absorb_sides = mccPoreH16_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 65972 "instruments/plate49.c"
}   /* End of PoreH16=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH16 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=119;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH16:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(119,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH17 [120] */
  mccoordschange(mcposrPoreH17, mcrotrPoreH17,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH17 (without coords transformations) */
  mcJumpTrace_PoreH17:
  SIG_MESSAGE("PoreH17 (Trace)");
  mcDEBUG_COMP("PoreH17")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH17
  STORE_XRAY(120,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[120]++;
  mcPCounter[120] += p;
  mcP2Counter[120] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH17
#define mccompcurname  PoreH17
#define mccompcurtype  Pore_h_group
#define mccompcurindex 120
#define nLeft mccPoreH17_nLeft
#define nRight mccPoreH17_nRight
#define nExit mccPoreH17_nExit
#define wLeft mccPoreH17_wLeft
#define wRight mccPoreH17_wRight
#define wExit mccPoreH17_wExit
#define wall mccPoreH17_wall
#define nTop mccPoreH17_nTop
#define nBottom mccPoreH17_nBottom
#define zexit mccPoreH17_zexit
#define zentry mccPoreH17_zentry
#define intersect_wolterI mccPoreH17_intersect_wolterI
#define reflec_side_table mccPoreH17_reflec_side_table
#define reflec_top_table mccPoreH17_reflec_top_table
#define reflec_bottom_table mccPoreH17_reflec_bottom_table
#define ref_prms mccPoreH17_ref_prms
{   /* Declarations of PoreH17=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH17_radius_m;
MCNUM radius_h = mccPoreH17_radius_h;
MCNUM Z0 = mccPoreH17_Z0;
MCNUM xwidth = mccPoreH17_xwidth;
MCNUM yheight = mccPoreH17_yheight;
MCNUM chamferwidth = mccPoreH17_chamferwidth;
char* mirror_reflec = mccPoreH17_mirror_reflec;
char* bottom_reflec = mccPoreH17_bottom_reflec;
char* side_reflec = mccPoreH17_side_reflec;
MCNUM R_d = mccPoreH17_R_d;
MCNUM absorb_sides = mccPoreH17_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 66271 "instruments/plate49.c"
}   /* End of PoreH17=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH17 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=120;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH17:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(120,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH18 [121] */
  mccoordschange(mcposrPoreH18, mcrotrPoreH18,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH18 (without coords transformations) */
  mcJumpTrace_PoreH18:
  SIG_MESSAGE("PoreH18 (Trace)");
  mcDEBUG_COMP("PoreH18")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH18
  STORE_XRAY(121,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[121]++;
  mcPCounter[121] += p;
  mcP2Counter[121] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH18
#define mccompcurname  PoreH18
#define mccompcurtype  Pore_h_group
#define mccompcurindex 121
#define nLeft mccPoreH18_nLeft
#define nRight mccPoreH18_nRight
#define nExit mccPoreH18_nExit
#define wLeft mccPoreH18_wLeft
#define wRight mccPoreH18_wRight
#define wExit mccPoreH18_wExit
#define wall mccPoreH18_wall
#define nTop mccPoreH18_nTop
#define nBottom mccPoreH18_nBottom
#define zexit mccPoreH18_zexit
#define zentry mccPoreH18_zentry
#define intersect_wolterI mccPoreH18_intersect_wolterI
#define reflec_side_table mccPoreH18_reflec_side_table
#define reflec_top_table mccPoreH18_reflec_top_table
#define reflec_bottom_table mccPoreH18_reflec_bottom_table
#define ref_prms mccPoreH18_ref_prms
{   /* Declarations of PoreH18=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH18_radius_m;
MCNUM radius_h = mccPoreH18_radius_h;
MCNUM Z0 = mccPoreH18_Z0;
MCNUM xwidth = mccPoreH18_xwidth;
MCNUM yheight = mccPoreH18_yheight;
MCNUM chamferwidth = mccPoreH18_chamferwidth;
char* mirror_reflec = mccPoreH18_mirror_reflec;
char* bottom_reflec = mccPoreH18_bottom_reflec;
char* side_reflec = mccPoreH18_side_reflec;
MCNUM R_d = mccPoreH18_R_d;
MCNUM absorb_sides = mccPoreH18_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 66570 "instruments/plate49.c"
}   /* End of PoreH18=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH18 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=121;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH18:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(121,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH19 [122] */
  mccoordschange(mcposrPoreH19, mcrotrPoreH19,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH19 (without coords transformations) */
  mcJumpTrace_PoreH19:
  SIG_MESSAGE("PoreH19 (Trace)");
  mcDEBUG_COMP("PoreH19")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH19
  STORE_XRAY(122,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[122]++;
  mcPCounter[122] += p;
  mcP2Counter[122] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH19
#define mccompcurname  PoreH19
#define mccompcurtype  Pore_h_group
#define mccompcurindex 122
#define nLeft mccPoreH19_nLeft
#define nRight mccPoreH19_nRight
#define nExit mccPoreH19_nExit
#define wLeft mccPoreH19_wLeft
#define wRight mccPoreH19_wRight
#define wExit mccPoreH19_wExit
#define wall mccPoreH19_wall
#define nTop mccPoreH19_nTop
#define nBottom mccPoreH19_nBottom
#define zexit mccPoreH19_zexit
#define zentry mccPoreH19_zentry
#define intersect_wolterI mccPoreH19_intersect_wolterI
#define reflec_side_table mccPoreH19_reflec_side_table
#define reflec_top_table mccPoreH19_reflec_top_table
#define reflec_bottom_table mccPoreH19_reflec_bottom_table
#define ref_prms mccPoreH19_ref_prms
{   /* Declarations of PoreH19=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH19_radius_m;
MCNUM radius_h = mccPoreH19_radius_h;
MCNUM Z0 = mccPoreH19_Z0;
MCNUM xwidth = mccPoreH19_xwidth;
MCNUM yheight = mccPoreH19_yheight;
MCNUM chamferwidth = mccPoreH19_chamferwidth;
char* mirror_reflec = mccPoreH19_mirror_reflec;
char* bottom_reflec = mccPoreH19_bottom_reflec;
char* side_reflec = mccPoreH19_side_reflec;
MCNUM R_d = mccPoreH19_R_d;
MCNUM absorb_sides = mccPoreH19_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 66869 "instruments/plate49.c"
}   /* End of PoreH19=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH19 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=122;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH19:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(122,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH20 [123] */
  mccoordschange(mcposrPoreH20, mcrotrPoreH20,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH20 (without coords transformations) */
  mcJumpTrace_PoreH20:
  SIG_MESSAGE("PoreH20 (Trace)");
  mcDEBUG_COMP("PoreH20")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH20
  STORE_XRAY(123,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[123]++;
  mcPCounter[123] += p;
  mcP2Counter[123] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH20
#define mccompcurname  PoreH20
#define mccompcurtype  Pore_h_group
#define mccompcurindex 123
#define nLeft mccPoreH20_nLeft
#define nRight mccPoreH20_nRight
#define nExit mccPoreH20_nExit
#define wLeft mccPoreH20_wLeft
#define wRight mccPoreH20_wRight
#define wExit mccPoreH20_wExit
#define wall mccPoreH20_wall
#define nTop mccPoreH20_nTop
#define nBottom mccPoreH20_nBottom
#define zexit mccPoreH20_zexit
#define zentry mccPoreH20_zentry
#define intersect_wolterI mccPoreH20_intersect_wolterI
#define reflec_side_table mccPoreH20_reflec_side_table
#define reflec_top_table mccPoreH20_reflec_top_table
#define reflec_bottom_table mccPoreH20_reflec_bottom_table
#define ref_prms mccPoreH20_ref_prms
{   /* Declarations of PoreH20=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH20_radius_m;
MCNUM radius_h = mccPoreH20_radius_h;
MCNUM Z0 = mccPoreH20_Z0;
MCNUM xwidth = mccPoreH20_xwidth;
MCNUM yheight = mccPoreH20_yheight;
MCNUM chamferwidth = mccPoreH20_chamferwidth;
char* mirror_reflec = mccPoreH20_mirror_reflec;
char* bottom_reflec = mccPoreH20_bottom_reflec;
char* side_reflec = mccPoreH20_side_reflec;
MCNUM R_d = mccPoreH20_R_d;
MCNUM absorb_sides = mccPoreH20_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 67168 "instruments/plate49.c"
}   /* End of PoreH20=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH20 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=123;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH20:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(123,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH21 [124] */
  mccoordschange(mcposrPoreH21, mcrotrPoreH21,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH21 (without coords transformations) */
  mcJumpTrace_PoreH21:
  SIG_MESSAGE("PoreH21 (Trace)");
  mcDEBUG_COMP("PoreH21")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH21
  STORE_XRAY(124,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[124]++;
  mcPCounter[124] += p;
  mcP2Counter[124] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH21
#define mccompcurname  PoreH21
#define mccompcurtype  Pore_h_group
#define mccompcurindex 124
#define nLeft mccPoreH21_nLeft
#define nRight mccPoreH21_nRight
#define nExit mccPoreH21_nExit
#define wLeft mccPoreH21_wLeft
#define wRight mccPoreH21_wRight
#define wExit mccPoreH21_wExit
#define wall mccPoreH21_wall
#define nTop mccPoreH21_nTop
#define nBottom mccPoreH21_nBottom
#define zexit mccPoreH21_zexit
#define zentry mccPoreH21_zentry
#define intersect_wolterI mccPoreH21_intersect_wolterI
#define reflec_side_table mccPoreH21_reflec_side_table
#define reflec_top_table mccPoreH21_reflec_top_table
#define reflec_bottom_table mccPoreH21_reflec_bottom_table
#define ref_prms mccPoreH21_ref_prms
{   /* Declarations of PoreH21=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH21_radius_m;
MCNUM radius_h = mccPoreH21_radius_h;
MCNUM Z0 = mccPoreH21_Z0;
MCNUM xwidth = mccPoreH21_xwidth;
MCNUM yheight = mccPoreH21_yheight;
MCNUM chamferwidth = mccPoreH21_chamferwidth;
char* mirror_reflec = mccPoreH21_mirror_reflec;
char* bottom_reflec = mccPoreH21_bottom_reflec;
char* side_reflec = mccPoreH21_side_reflec;
MCNUM R_d = mccPoreH21_R_d;
MCNUM absorb_sides = mccPoreH21_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 67467 "instruments/plate49.c"
}   /* End of PoreH21=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH21 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=124;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH21:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(124,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH22 [125] */
  mccoordschange(mcposrPoreH22, mcrotrPoreH22,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH22 (without coords transformations) */
  mcJumpTrace_PoreH22:
  SIG_MESSAGE("PoreH22 (Trace)");
  mcDEBUG_COMP("PoreH22")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH22
  STORE_XRAY(125,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[125]++;
  mcPCounter[125] += p;
  mcP2Counter[125] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH22
#define mccompcurname  PoreH22
#define mccompcurtype  Pore_h_group
#define mccompcurindex 125
#define nLeft mccPoreH22_nLeft
#define nRight mccPoreH22_nRight
#define nExit mccPoreH22_nExit
#define wLeft mccPoreH22_wLeft
#define wRight mccPoreH22_wRight
#define wExit mccPoreH22_wExit
#define wall mccPoreH22_wall
#define nTop mccPoreH22_nTop
#define nBottom mccPoreH22_nBottom
#define zexit mccPoreH22_zexit
#define zentry mccPoreH22_zentry
#define intersect_wolterI mccPoreH22_intersect_wolterI
#define reflec_side_table mccPoreH22_reflec_side_table
#define reflec_top_table mccPoreH22_reflec_top_table
#define reflec_bottom_table mccPoreH22_reflec_bottom_table
#define ref_prms mccPoreH22_ref_prms
{   /* Declarations of PoreH22=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH22_radius_m;
MCNUM radius_h = mccPoreH22_radius_h;
MCNUM Z0 = mccPoreH22_Z0;
MCNUM xwidth = mccPoreH22_xwidth;
MCNUM yheight = mccPoreH22_yheight;
MCNUM chamferwidth = mccPoreH22_chamferwidth;
char* mirror_reflec = mccPoreH22_mirror_reflec;
char* bottom_reflec = mccPoreH22_bottom_reflec;
char* side_reflec = mccPoreH22_side_reflec;
MCNUM R_d = mccPoreH22_R_d;
MCNUM absorb_sides = mccPoreH22_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 67766 "instruments/plate49.c"
}   /* End of PoreH22=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH22 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=125;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH22:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(125,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH23 [126] */
  mccoordschange(mcposrPoreH23, mcrotrPoreH23,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH23 (without coords transformations) */
  mcJumpTrace_PoreH23:
  SIG_MESSAGE("PoreH23 (Trace)");
  mcDEBUG_COMP("PoreH23")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH23
  STORE_XRAY(126,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[126]++;
  mcPCounter[126] += p;
  mcP2Counter[126] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH23
#define mccompcurname  PoreH23
#define mccompcurtype  Pore_h_group
#define mccompcurindex 126
#define nLeft mccPoreH23_nLeft
#define nRight mccPoreH23_nRight
#define nExit mccPoreH23_nExit
#define wLeft mccPoreH23_wLeft
#define wRight mccPoreH23_wRight
#define wExit mccPoreH23_wExit
#define wall mccPoreH23_wall
#define nTop mccPoreH23_nTop
#define nBottom mccPoreH23_nBottom
#define zexit mccPoreH23_zexit
#define zentry mccPoreH23_zentry
#define intersect_wolterI mccPoreH23_intersect_wolterI
#define reflec_side_table mccPoreH23_reflec_side_table
#define reflec_top_table mccPoreH23_reflec_top_table
#define reflec_bottom_table mccPoreH23_reflec_bottom_table
#define ref_prms mccPoreH23_ref_prms
{   /* Declarations of PoreH23=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH23_radius_m;
MCNUM radius_h = mccPoreH23_radius_h;
MCNUM Z0 = mccPoreH23_Z0;
MCNUM xwidth = mccPoreH23_xwidth;
MCNUM yheight = mccPoreH23_yheight;
MCNUM chamferwidth = mccPoreH23_chamferwidth;
char* mirror_reflec = mccPoreH23_mirror_reflec;
char* bottom_reflec = mccPoreH23_bottom_reflec;
char* side_reflec = mccPoreH23_side_reflec;
MCNUM R_d = mccPoreH23_R_d;
MCNUM absorb_sides = mccPoreH23_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 68065 "instruments/plate49.c"
}   /* End of PoreH23=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH23 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=126;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH23:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(126,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH24 [127] */
  mccoordschange(mcposrPoreH24, mcrotrPoreH24,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH24 (without coords transformations) */
  mcJumpTrace_PoreH24:
  SIG_MESSAGE("PoreH24 (Trace)");
  mcDEBUG_COMP("PoreH24")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH24
  STORE_XRAY(127,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[127]++;
  mcPCounter[127] += p;
  mcP2Counter[127] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH24
#define mccompcurname  PoreH24
#define mccompcurtype  Pore_h_group
#define mccompcurindex 127
#define nLeft mccPoreH24_nLeft
#define nRight mccPoreH24_nRight
#define nExit mccPoreH24_nExit
#define wLeft mccPoreH24_wLeft
#define wRight mccPoreH24_wRight
#define wExit mccPoreH24_wExit
#define wall mccPoreH24_wall
#define nTop mccPoreH24_nTop
#define nBottom mccPoreH24_nBottom
#define zexit mccPoreH24_zexit
#define zentry mccPoreH24_zentry
#define intersect_wolterI mccPoreH24_intersect_wolterI
#define reflec_side_table mccPoreH24_reflec_side_table
#define reflec_top_table mccPoreH24_reflec_top_table
#define reflec_bottom_table mccPoreH24_reflec_bottom_table
#define ref_prms mccPoreH24_ref_prms
{   /* Declarations of PoreH24=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH24_radius_m;
MCNUM radius_h = mccPoreH24_radius_h;
MCNUM Z0 = mccPoreH24_Z0;
MCNUM xwidth = mccPoreH24_xwidth;
MCNUM yheight = mccPoreH24_yheight;
MCNUM chamferwidth = mccPoreH24_chamferwidth;
char* mirror_reflec = mccPoreH24_mirror_reflec;
char* bottom_reflec = mccPoreH24_bottom_reflec;
char* side_reflec = mccPoreH24_side_reflec;
MCNUM R_d = mccPoreH24_R_d;
MCNUM absorb_sides = mccPoreH24_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 68364 "instruments/plate49.c"
}   /* End of PoreH24=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH24 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=127;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH24:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(127,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH25 [128] */
  mccoordschange(mcposrPoreH25, mcrotrPoreH25,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH25 (without coords transformations) */
  mcJumpTrace_PoreH25:
  SIG_MESSAGE("PoreH25 (Trace)");
  mcDEBUG_COMP("PoreH25")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH25
  STORE_XRAY(128,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[128]++;
  mcPCounter[128] += p;
  mcP2Counter[128] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH25
#define mccompcurname  PoreH25
#define mccompcurtype  Pore_h_group
#define mccompcurindex 128
#define nLeft mccPoreH25_nLeft
#define nRight mccPoreH25_nRight
#define nExit mccPoreH25_nExit
#define wLeft mccPoreH25_wLeft
#define wRight mccPoreH25_wRight
#define wExit mccPoreH25_wExit
#define wall mccPoreH25_wall
#define nTop mccPoreH25_nTop
#define nBottom mccPoreH25_nBottom
#define zexit mccPoreH25_zexit
#define zentry mccPoreH25_zentry
#define intersect_wolterI mccPoreH25_intersect_wolterI
#define reflec_side_table mccPoreH25_reflec_side_table
#define reflec_top_table mccPoreH25_reflec_top_table
#define reflec_bottom_table mccPoreH25_reflec_bottom_table
#define ref_prms mccPoreH25_ref_prms
{   /* Declarations of PoreH25=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH25_radius_m;
MCNUM radius_h = mccPoreH25_radius_h;
MCNUM Z0 = mccPoreH25_Z0;
MCNUM xwidth = mccPoreH25_xwidth;
MCNUM yheight = mccPoreH25_yheight;
MCNUM chamferwidth = mccPoreH25_chamferwidth;
char* mirror_reflec = mccPoreH25_mirror_reflec;
char* bottom_reflec = mccPoreH25_bottom_reflec;
char* side_reflec = mccPoreH25_side_reflec;
MCNUM R_d = mccPoreH25_R_d;
MCNUM absorb_sides = mccPoreH25_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 68663 "instruments/plate49.c"
}   /* End of PoreH25=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH25 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=128;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH25:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(128,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH26 [129] */
  mccoordschange(mcposrPoreH26, mcrotrPoreH26,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH26 (without coords transformations) */
  mcJumpTrace_PoreH26:
  SIG_MESSAGE("PoreH26 (Trace)");
  mcDEBUG_COMP("PoreH26")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH26
  STORE_XRAY(129,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[129]++;
  mcPCounter[129] += p;
  mcP2Counter[129] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH26
#define mccompcurname  PoreH26
#define mccompcurtype  Pore_h_group
#define mccompcurindex 129
#define nLeft mccPoreH26_nLeft
#define nRight mccPoreH26_nRight
#define nExit mccPoreH26_nExit
#define wLeft mccPoreH26_wLeft
#define wRight mccPoreH26_wRight
#define wExit mccPoreH26_wExit
#define wall mccPoreH26_wall
#define nTop mccPoreH26_nTop
#define nBottom mccPoreH26_nBottom
#define zexit mccPoreH26_zexit
#define zentry mccPoreH26_zentry
#define intersect_wolterI mccPoreH26_intersect_wolterI
#define reflec_side_table mccPoreH26_reflec_side_table
#define reflec_top_table mccPoreH26_reflec_top_table
#define reflec_bottom_table mccPoreH26_reflec_bottom_table
#define ref_prms mccPoreH26_ref_prms
{   /* Declarations of PoreH26=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH26_radius_m;
MCNUM radius_h = mccPoreH26_radius_h;
MCNUM Z0 = mccPoreH26_Z0;
MCNUM xwidth = mccPoreH26_xwidth;
MCNUM yheight = mccPoreH26_yheight;
MCNUM chamferwidth = mccPoreH26_chamferwidth;
char* mirror_reflec = mccPoreH26_mirror_reflec;
char* bottom_reflec = mccPoreH26_bottom_reflec;
char* side_reflec = mccPoreH26_side_reflec;
MCNUM R_d = mccPoreH26_R_d;
MCNUM absorb_sides = mccPoreH26_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 68962 "instruments/plate49.c"
}   /* End of PoreH26=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH26 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=129;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH26:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(129,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH27 [130] */
  mccoordschange(mcposrPoreH27, mcrotrPoreH27,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH27 (without coords transformations) */
  mcJumpTrace_PoreH27:
  SIG_MESSAGE("PoreH27 (Trace)");
  mcDEBUG_COMP("PoreH27")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH27
  STORE_XRAY(130,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[130]++;
  mcPCounter[130] += p;
  mcP2Counter[130] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH27
#define mccompcurname  PoreH27
#define mccompcurtype  Pore_h_group
#define mccompcurindex 130
#define nLeft mccPoreH27_nLeft
#define nRight mccPoreH27_nRight
#define nExit mccPoreH27_nExit
#define wLeft mccPoreH27_wLeft
#define wRight mccPoreH27_wRight
#define wExit mccPoreH27_wExit
#define wall mccPoreH27_wall
#define nTop mccPoreH27_nTop
#define nBottom mccPoreH27_nBottom
#define zexit mccPoreH27_zexit
#define zentry mccPoreH27_zentry
#define intersect_wolterI mccPoreH27_intersect_wolterI
#define reflec_side_table mccPoreH27_reflec_side_table
#define reflec_top_table mccPoreH27_reflec_top_table
#define reflec_bottom_table mccPoreH27_reflec_bottom_table
#define ref_prms mccPoreH27_ref_prms
{   /* Declarations of PoreH27=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH27_radius_m;
MCNUM radius_h = mccPoreH27_radius_h;
MCNUM Z0 = mccPoreH27_Z0;
MCNUM xwidth = mccPoreH27_xwidth;
MCNUM yheight = mccPoreH27_yheight;
MCNUM chamferwidth = mccPoreH27_chamferwidth;
char* mirror_reflec = mccPoreH27_mirror_reflec;
char* bottom_reflec = mccPoreH27_bottom_reflec;
char* side_reflec = mccPoreH27_side_reflec;
MCNUM R_d = mccPoreH27_R_d;
MCNUM absorb_sides = mccPoreH27_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 69261 "instruments/plate49.c"
}   /* End of PoreH27=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH27 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=130;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH27:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(130,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH28 [131] */
  mccoordschange(mcposrPoreH28, mcrotrPoreH28,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH28 (without coords transformations) */
  mcJumpTrace_PoreH28:
  SIG_MESSAGE("PoreH28 (Trace)");
  mcDEBUG_COMP("PoreH28")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH28
  STORE_XRAY(131,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[131]++;
  mcPCounter[131] += p;
  mcP2Counter[131] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH28
#define mccompcurname  PoreH28
#define mccompcurtype  Pore_h_group
#define mccompcurindex 131
#define nLeft mccPoreH28_nLeft
#define nRight mccPoreH28_nRight
#define nExit mccPoreH28_nExit
#define wLeft mccPoreH28_wLeft
#define wRight mccPoreH28_wRight
#define wExit mccPoreH28_wExit
#define wall mccPoreH28_wall
#define nTop mccPoreH28_nTop
#define nBottom mccPoreH28_nBottom
#define zexit mccPoreH28_zexit
#define zentry mccPoreH28_zentry
#define intersect_wolterI mccPoreH28_intersect_wolterI
#define reflec_side_table mccPoreH28_reflec_side_table
#define reflec_top_table mccPoreH28_reflec_top_table
#define reflec_bottom_table mccPoreH28_reflec_bottom_table
#define ref_prms mccPoreH28_ref_prms
{   /* Declarations of PoreH28=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH28_radius_m;
MCNUM radius_h = mccPoreH28_radius_h;
MCNUM Z0 = mccPoreH28_Z0;
MCNUM xwidth = mccPoreH28_xwidth;
MCNUM yheight = mccPoreH28_yheight;
MCNUM chamferwidth = mccPoreH28_chamferwidth;
char* mirror_reflec = mccPoreH28_mirror_reflec;
char* bottom_reflec = mccPoreH28_bottom_reflec;
char* side_reflec = mccPoreH28_side_reflec;
MCNUM R_d = mccPoreH28_R_d;
MCNUM absorb_sides = mccPoreH28_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 69560 "instruments/plate49.c"
}   /* End of PoreH28=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH28 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=131;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH28:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(131,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH29 [132] */
  mccoordschange(mcposrPoreH29, mcrotrPoreH29,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH29 (without coords transformations) */
  mcJumpTrace_PoreH29:
  SIG_MESSAGE("PoreH29 (Trace)");
  mcDEBUG_COMP("PoreH29")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH29
  STORE_XRAY(132,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[132]++;
  mcPCounter[132] += p;
  mcP2Counter[132] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH29
#define mccompcurname  PoreH29
#define mccompcurtype  Pore_h_group
#define mccompcurindex 132
#define nLeft mccPoreH29_nLeft
#define nRight mccPoreH29_nRight
#define nExit mccPoreH29_nExit
#define wLeft mccPoreH29_wLeft
#define wRight mccPoreH29_wRight
#define wExit mccPoreH29_wExit
#define wall mccPoreH29_wall
#define nTop mccPoreH29_nTop
#define nBottom mccPoreH29_nBottom
#define zexit mccPoreH29_zexit
#define zentry mccPoreH29_zentry
#define intersect_wolterI mccPoreH29_intersect_wolterI
#define reflec_side_table mccPoreH29_reflec_side_table
#define reflec_top_table mccPoreH29_reflec_top_table
#define reflec_bottom_table mccPoreH29_reflec_bottom_table
#define ref_prms mccPoreH29_ref_prms
{   /* Declarations of PoreH29=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH29_radius_m;
MCNUM radius_h = mccPoreH29_radius_h;
MCNUM Z0 = mccPoreH29_Z0;
MCNUM xwidth = mccPoreH29_xwidth;
MCNUM yheight = mccPoreH29_yheight;
MCNUM chamferwidth = mccPoreH29_chamferwidth;
char* mirror_reflec = mccPoreH29_mirror_reflec;
char* bottom_reflec = mccPoreH29_bottom_reflec;
char* side_reflec = mccPoreH29_side_reflec;
MCNUM R_d = mccPoreH29_R_d;
MCNUM absorb_sides = mccPoreH29_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 69859 "instruments/plate49.c"
}   /* End of PoreH29=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH29 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=132;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH29:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(132,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH30 [133] */
  mccoordschange(mcposrPoreH30, mcrotrPoreH30,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH30 (without coords transformations) */
  mcJumpTrace_PoreH30:
  SIG_MESSAGE("PoreH30 (Trace)");
  mcDEBUG_COMP("PoreH30")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH30
  STORE_XRAY(133,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[133]++;
  mcPCounter[133] += p;
  mcP2Counter[133] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH30
#define mccompcurname  PoreH30
#define mccompcurtype  Pore_h_group
#define mccompcurindex 133
#define nLeft mccPoreH30_nLeft
#define nRight mccPoreH30_nRight
#define nExit mccPoreH30_nExit
#define wLeft mccPoreH30_wLeft
#define wRight mccPoreH30_wRight
#define wExit mccPoreH30_wExit
#define wall mccPoreH30_wall
#define nTop mccPoreH30_nTop
#define nBottom mccPoreH30_nBottom
#define zexit mccPoreH30_zexit
#define zentry mccPoreH30_zentry
#define intersect_wolterI mccPoreH30_intersect_wolterI
#define reflec_side_table mccPoreH30_reflec_side_table
#define reflec_top_table mccPoreH30_reflec_top_table
#define reflec_bottom_table mccPoreH30_reflec_bottom_table
#define ref_prms mccPoreH30_ref_prms
{   /* Declarations of PoreH30=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH30_radius_m;
MCNUM radius_h = mccPoreH30_radius_h;
MCNUM Z0 = mccPoreH30_Z0;
MCNUM xwidth = mccPoreH30_xwidth;
MCNUM yheight = mccPoreH30_yheight;
MCNUM chamferwidth = mccPoreH30_chamferwidth;
char* mirror_reflec = mccPoreH30_mirror_reflec;
char* bottom_reflec = mccPoreH30_bottom_reflec;
char* side_reflec = mccPoreH30_side_reflec;
MCNUM R_d = mccPoreH30_R_d;
MCNUM absorb_sides = mccPoreH30_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 70158 "instruments/plate49.c"
}   /* End of PoreH30=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH30 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=133;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH30:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(133,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH31 [134] */
  mccoordschange(mcposrPoreH31, mcrotrPoreH31,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH31 (without coords transformations) */
  mcJumpTrace_PoreH31:
  SIG_MESSAGE("PoreH31 (Trace)");
  mcDEBUG_COMP("PoreH31")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH31
  STORE_XRAY(134,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[134]++;
  mcPCounter[134] += p;
  mcP2Counter[134] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH31
#define mccompcurname  PoreH31
#define mccompcurtype  Pore_h_group
#define mccompcurindex 134
#define nLeft mccPoreH31_nLeft
#define nRight mccPoreH31_nRight
#define nExit mccPoreH31_nExit
#define wLeft mccPoreH31_wLeft
#define wRight mccPoreH31_wRight
#define wExit mccPoreH31_wExit
#define wall mccPoreH31_wall
#define nTop mccPoreH31_nTop
#define nBottom mccPoreH31_nBottom
#define zexit mccPoreH31_zexit
#define zentry mccPoreH31_zentry
#define intersect_wolterI mccPoreH31_intersect_wolterI
#define reflec_side_table mccPoreH31_reflec_side_table
#define reflec_top_table mccPoreH31_reflec_top_table
#define reflec_bottom_table mccPoreH31_reflec_bottom_table
#define ref_prms mccPoreH31_ref_prms
{   /* Declarations of PoreH31=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH31_radius_m;
MCNUM radius_h = mccPoreH31_radius_h;
MCNUM Z0 = mccPoreH31_Z0;
MCNUM xwidth = mccPoreH31_xwidth;
MCNUM yheight = mccPoreH31_yheight;
MCNUM chamferwidth = mccPoreH31_chamferwidth;
char* mirror_reflec = mccPoreH31_mirror_reflec;
char* bottom_reflec = mccPoreH31_bottom_reflec;
char* side_reflec = mccPoreH31_side_reflec;
MCNUM R_d = mccPoreH31_R_d;
MCNUM absorb_sides = mccPoreH31_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 70457 "instruments/plate49.c"
}   /* End of PoreH31=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH31 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=134;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH31:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(134,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH32 [135] */
  mccoordschange(mcposrPoreH32, mcrotrPoreH32,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH32 (without coords transformations) */
  mcJumpTrace_PoreH32:
  SIG_MESSAGE("PoreH32 (Trace)");
  mcDEBUG_COMP("PoreH32")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH32
  STORE_XRAY(135,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[135]++;
  mcPCounter[135] += p;
  mcP2Counter[135] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH32
#define mccompcurname  PoreH32
#define mccompcurtype  Pore_h_group
#define mccompcurindex 135
#define nLeft mccPoreH32_nLeft
#define nRight mccPoreH32_nRight
#define nExit mccPoreH32_nExit
#define wLeft mccPoreH32_wLeft
#define wRight mccPoreH32_wRight
#define wExit mccPoreH32_wExit
#define wall mccPoreH32_wall
#define nTop mccPoreH32_nTop
#define nBottom mccPoreH32_nBottom
#define zexit mccPoreH32_zexit
#define zentry mccPoreH32_zentry
#define intersect_wolterI mccPoreH32_intersect_wolterI
#define reflec_side_table mccPoreH32_reflec_side_table
#define reflec_top_table mccPoreH32_reflec_top_table
#define reflec_bottom_table mccPoreH32_reflec_bottom_table
#define ref_prms mccPoreH32_ref_prms
{   /* Declarations of PoreH32=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH32_radius_m;
MCNUM radius_h = mccPoreH32_radius_h;
MCNUM Z0 = mccPoreH32_Z0;
MCNUM xwidth = mccPoreH32_xwidth;
MCNUM yheight = mccPoreH32_yheight;
MCNUM chamferwidth = mccPoreH32_chamferwidth;
char* mirror_reflec = mccPoreH32_mirror_reflec;
char* bottom_reflec = mccPoreH32_bottom_reflec;
char* side_reflec = mccPoreH32_side_reflec;
MCNUM R_d = mccPoreH32_R_d;
MCNUM absorb_sides = mccPoreH32_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 70756 "instruments/plate49.c"
}   /* End of PoreH32=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH32 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=135;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH32:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(135,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH33 [136] */
  mccoordschange(mcposrPoreH33, mcrotrPoreH33,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH33 (without coords transformations) */
  mcJumpTrace_PoreH33:
  SIG_MESSAGE("PoreH33 (Trace)");
  mcDEBUG_COMP("PoreH33")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH33
  STORE_XRAY(136,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[136]++;
  mcPCounter[136] += p;
  mcP2Counter[136] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH33
#define mccompcurname  PoreH33
#define mccompcurtype  Pore_h_group
#define mccompcurindex 136
#define nLeft mccPoreH33_nLeft
#define nRight mccPoreH33_nRight
#define nExit mccPoreH33_nExit
#define wLeft mccPoreH33_wLeft
#define wRight mccPoreH33_wRight
#define wExit mccPoreH33_wExit
#define wall mccPoreH33_wall
#define nTop mccPoreH33_nTop
#define nBottom mccPoreH33_nBottom
#define zexit mccPoreH33_zexit
#define zentry mccPoreH33_zentry
#define intersect_wolterI mccPoreH33_intersect_wolterI
#define reflec_side_table mccPoreH33_reflec_side_table
#define reflec_top_table mccPoreH33_reflec_top_table
#define reflec_bottom_table mccPoreH33_reflec_bottom_table
#define ref_prms mccPoreH33_ref_prms
{   /* Declarations of PoreH33=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH33_radius_m;
MCNUM radius_h = mccPoreH33_radius_h;
MCNUM Z0 = mccPoreH33_Z0;
MCNUM xwidth = mccPoreH33_xwidth;
MCNUM yheight = mccPoreH33_yheight;
MCNUM chamferwidth = mccPoreH33_chamferwidth;
char* mirror_reflec = mccPoreH33_mirror_reflec;
char* bottom_reflec = mccPoreH33_bottom_reflec;
char* side_reflec = mccPoreH33_side_reflec;
MCNUM R_d = mccPoreH33_R_d;
MCNUM absorb_sides = mccPoreH33_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 71055 "instruments/plate49.c"
}   /* End of PoreH33=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH33 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=136;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH33:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(136,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH34 [137] */
  mccoordschange(mcposrPoreH34, mcrotrPoreH34,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH34 (without coords transformations) */
  mcJumpTrace_PoreH34:
  SIG_MESSAGE("PoreH34 (Trace)");
  mcDEBUG_COMP("PoreH34")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH34
  STORE_XRAY(137,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[137]++;
  mcPCounter[137] += p;
  mcP2Counter[137] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH34
#define mccompcurname  PoreH34
#define mccompcurtype  Pore_h_group
#define mccompcurindex 137
#define nLeft mccPoreH34_nLeft
#define nRight mccPoreH34_nRight
#define nExit mccPoreH34_nExit
#define wLeft mccPoreH34_wLeft
#define wRight mccPoreH34_wRight
#define wExit mccPoreH34_wExit
#define wall mccPoreH34_wall
#define nTop mccPoreH34_nTop
#define nBottom mccPoreH34_nBottom
#define zexit mccPoreH34_zexit
#define zentry mccPoreH34_zentry
#define intersect_wolterI mccPoreH34_intersect_wolterI
#define reflec_side_table mccPoreH34_reflec_side_table
#define reflec_top_table mccPoreH34_reflec_top_table
#define reflec_bottom_table mccPoreH34_reflec_bottom_table
#define ref_prms mccPoreH34_ref_prms
{   /* Declarations of PoreH34=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH34_radius_m;
MCNUM radius_h = mccPoreH34_radius_h;
MCNUM Z0 = mccPoreH34_Z0;
MCNUM xwidth = mccPoreH34_xwidth;
MCNUM yheight = mccPoreH34_yheight;
MCNUM chamferwidth = mccPoreH34_chamferwidth;
char* mirror_reflec = mccPoreH34_mirror_reflec;
char* bottom_reflec = mccPoreH34_bottom_reflec;
char* side_reflec = mccPoreH34_side_reflec;
MCNUM R_d = mccPoreH34_R_d;
MCNUM absorb_sides = mccPoreH34_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 71354 "instruments/plate49.c"
}   /* End of PoreH34=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH34 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=137;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH34:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(137,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH35 [138] */
  mccoordschange(mcposrPoreH35, mcrotrPoreH35,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH35 (without coords transformations) */
  mcJumpTrace_PoreH35:
  SIG_MESSAGE("PoreH35 (Trace)");
  mcDEBUG_COMP("PoreH35")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH35
  STORE_XRAY(138,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[138]++;
  mcPCounter[138] += p;
  mcP2Counter[138] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH35
#define mccompcurname  PoreH35
#define mccompcurtype  Pore_h_group
#define mccompcurindex 138
#define nLeft mccPoreH35_nLeft
#define nRight mccPoreH35_nRight
#define nExit mccPoreH35_nExit
#define wLeft mccPoreH35_wLeft
#define wRight mccPoreH35_wRight
#define wExit mccPoreH35_wExit
#define wall mccPoreH35_wall
#define nTop mccPoreH35_nTop
#define nBottom mccPoreH35_nBottom
#define zexit mccPoreH35_zexit
#define zentry mccPoreH35_zentry
#define intersect_wolterI mccPoreH35_intersect_wolterI
#define reflec_side_table mccPoreH35_reflec_side_table
#define reflec_top_table mccPoreH35_reflec_top_table
#define reflec_bottom_table mccPoreH35_reflec_bottom_table
#define ref_prms mccPoreH35_ref_prms
{   /* Declarations of PoreH35=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH35_radius_m;
MCNUM radius_h = mccPoreH35_radius_h;
MCNUM Z0 = mccPoreH35_Z0;
MCNUM xwidth = mccPoreH35_xwidth;
MCNUM yheight = mccPoreH35_yheight;
MCNUM chamferwidth = mccPoreH35_chamferwidth;
char* mirror_reflec = mccPoreH35_mirror_reflec;
char* bottom_reflec = mccPoreH35_bottom_reflec;
char* side_reflec = mccPoreH35_side_reflec;
MCNUM R_d = mccPoreH35_R_d;
MCNUM absorb_sides = mccPoreH35_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 71653 "instruments/plate49.c"
}   /* End of PoreH35=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH35 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=138;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH35:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(138,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH36 [139] */
  mccoordschange(mcposrPoreH36, mcrotrPoreH36,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH36 (without coords transformations) */
  mcJumpTrace_PoreH36:
  SIG_MESSAGE("PoreH36 (Trace)");
  mcDEBUG_COMP("PoreH36")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH36
  STORE_XRAY(139,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[139]++;
  mcPCounter[139] += p;
  mcP2Counter[139] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH36
#define mccompcurname  PoreH36
#define mccompcurtype  Pore_h_group
#define mccompcurindex 139
#define nLeft mccPoreH36_nLeft
#define nRight mccPoreH36_nRight
#define nExit mccPoreH36_nExit
#define wLeft mccPoreH36_wLeft
#define wRight mccPoreH36_wRight
#define wExit mccPoreH36_wExit
#define wall mccPoreH36_wall
#define nTop mccPoreH36_nTop
#define nBottom mccPoreH36_nBottom
#define zexit mccPoreH36_zexit
#define zentry mccPoreH36_zentry
#define intersect_wolterI mccPoreH36_intersect_wolterI
#define reflec_side_table mccPoreH36_reflec_side_table
#define reflec_top_table mccPoreH36_reflec_top_table
#define reflec_bottom_table mccPoreH36_reflec_bottom_table
#define ref_prms mccPoreH36_ref_prms
{   /* Declarations of PoreH36=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH36_radius_m;
MCNUM radius_h = mccPoreH36_radius_h;
MCNUM Z0 = mccPoreH36_Z0;
MCNUM xwidth = mccPoreH36_xwidth;
MCNUM yheight = mccPoreH36_yheight;
MCNUM chamferwidth = mccPoreH36_chamferwidth;
char* mirror_reflec = mccPoreH36_mirror_reflec;
char* bottom_reflec = mccPoreH36_bottom_reflec;
char* side_reflec = mccPoreH36_side_reflec;
MCNUM R_d = mccPoreH36_R_d;
MCNUM absorb_sides = mccPoreH36_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 71952 "instruments/plate49.c"
}   /* End of PoreH36=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH36 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=139;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH36:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(139,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH37 [140] */
  mccoordschange(mcposrPoreH37, mcrotrPoreH37,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH37 (without coords transformations) */
  mcJumpTrace_PoreH37:
  SIG_MESSAGE("PoreH37 (Trace)");
  mcDEBUG_COMP("PoreH37")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH37
  STORE_XRAY(140,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[140]++;
  mcPCounter[140] += p;
  mcP2Counter[140] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH37
#define mccompcurname  PoreH37
#define mccompcurtype  Pore_h_group
#define mccompcurindex 140
#define nLeft mccPoreH37_nLeft
#define nRight mccPoreH37_nRight
#define nExit mccPoreH37_nExit
#define wLeft mccPoreH37_wLeft
#define wRight mccPoreH37_wRight
#define wExit mccPoreH37_wExit
#define wall mccPoreH37_wall
#define nTop mccPoreH37_nTop
#define nBottom mccPoreH37_nBottom
#define zexit mccPoreH37_zexit
#define zentry mccPoreH37_zentry
#define intersect_wolterI mccPoreH37_intersect_wolterI
#define reflec_side_table mccPoreH37_reflec_side_table
#define reflec_top_table mccPoreH37_reflec_top_table
#define reflec_bottom_table mccPoreH37_reflec_bottom_table
#define ref_prms mccPoreH37_ref_prms
{   /* Declarations of PoreH37=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH37_radius_m;
MCNUM radius_h = mccPoreH37_radius_h;
MCNUM Z0 = mccPoreH37_Z0;
MCNUM xwidth = mccPoreH37_xwidth;
MCNUM yheight = mccPoreH37_yheight;
MCNUM chamferwidth = mccPoreH37_chamferwidth;
char* mirror_reflec = mccPoreH37_mirror_reflec;
char* bottom_reflec = mccPoreH37_bottom_reflec;
char* side_reflec = mccPoreH37_side_reflec;
MCNUM R_d = mccPoreH37_R_d;
MCNUM absorb_sides = mccPoreH37_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 72251 "instruments/plate49.c"
}   /* End of PoreH37=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH37 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=140;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH37:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(140,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH38 [141] */
  mccoordschange(mcposrPoreH38, mcrotrPoreH38,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH38 (without coords transformations) */
  mcJumpTrace_PoreH38:
  SIG_MESSAGE("PoreH38 (Trace)");
  mcDEBUG_COMP("PoreH38")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH38
  STORE_XRAY(141,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[141]++;
  mcPCounter[141] += p;
  mcP2Counter[141] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH38
#define mccompcurname  PoreH38
#define mccompcurtype  Pore_h_group
#define mccompcurindex 141
#define nLeft mccPoreH38_nLeft
#define nRight mccPoreH38_nRight
#define nExit mccPoreH38_nExit
#define wLeft mccPoreH38_wLeft
#define wRight mccPoreH38_wRight
#define wExit mccPoreH38_wExit
#define wall mccPoreH38_wall
#define nTop mccPoreH38_nTop
#define nBottom mccPoreH38_nBottom
#define zexit mccPoreH38_zexit
#define zentry mccPoreH38_zentry
#define intersect_wolterI mccPoreH38_intersect_wolterI
#define reflec_side_table mccPoreH38_reflec_side_table
#define reflec_top_table mccPoreH38_reflec_top_table
#define reflec_bottom_table mccPoreH38_reflec_bottom_table
#define ref_prms mccPoreH38_ref_prms
{   /* Declarations of PoreH38=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH38_radius_m;
MCNUM radius_h = mccPoreH38_radius_h;
MCNUM Z0 = mccPoreH38_Z0;
MCNUM xwidth = mccPoreH38_xwidth;
MCNUM yheight = mccPoreH38_yheight;
MCNUM chamferwidth = mccPoreH38_chamferwidth;
char* mirror_reflec = mccPoreH38_mirror_reflec;
char* bottom_reflec = mccPoreH38_bottom_reflec;
char* side_reflec = mccPoreH38_side_reflec;
MCNUM R_d = mccPoreH38_R_d;
MCNUM absorb_sides = mccPoreH38_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 72550 "instruments/plate49.c"
}   /* End of PoreH38=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH38 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=141;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH38:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(141,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH39 [142] */
  mccoordschange(mcposrPoreH39, mcrotrPoreH39,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH39 (without coords transformations) */
  mcJumpTrace_PoreH39:
  SIG_MESSAGE("PoreH39 (Trace)");
  mcDEBUG_COMP("PoreH39")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH39
  STORE_XRAY(142,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[142]++;
  mcPCounter[142] += p;
  mcP2Counter[142] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH39
#define mccompcurname  PoreH39
#define mccompcurtype  Pore_h_group
#define mccompcurindex 142
#define nLeft mccPoreH39_nLeft
#define nRight mccPoreH39_nRight
#define nExit mccPoreH39_nExit
#define wLeft mccPoreH39_wLeft
#define wRight mccPoreH39_wRight
#define wExit mccPoreH39_wExit
#define wall mccPoreH39_wall
#define nTop mccPoreH39_nTop
#define nBottom mccPoreH39_nBottom
#define zexit mccPoreH39_zexit
#define zentry mccPoreH39_zentry
#define intersect_wolterI mccPoreH39_intersect_wolterI
#define reflec_side_table mccPoreH39_reflec_side_table
#define reflec_top_table mccPoreH39_reflec_top_table
#define reflec_bottom_table mccPoreH39_reflec_bottom_table
#define ref_prms mccPoreH39_ref_prms
{   /* Declarations of PoreH39=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH39_radius_m;
MCNUM radius_h = mccPoreH39_radius_h;
MCNUM Z0 = mccPoreH39_Z0;
MCNUM xwidth = mccPoreH39_xwidth;
MCNUM yheight = mccPoreH39_yheight;
MCNUM chamferwidth = mccPoreH39_chamferwidth;
char* mirror_reflec = mccPoreH39_mirror_reflec;
char* bottom_reflec = mccPoreH39_bottom_reflec;
char* side_reflec = mccPoreH39_side_reflec;
MCNUM R_d = mccPoreH39_R_d;
MCNUM absorb_sides = mccPoreH39_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 72849 "instruments/plate49.c"
}   /* End of PoreH39=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH39 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=142;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH39:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(142,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH40 [143] */
  mccoordschange(mcposrPoreH40, mcrotrPoreH40,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH40 (without coords transformations) */
  mcJumpTrace_PoreH40:
  SIG_MESSAGE("PoreH40 (Trace)");
  mcDEBUG_COMP("PoreH40")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH40
  STORE_XRAY(143,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[143]++;
  mcPCounter[143] += p;
  mcP2Counter[143] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH40
#define mccompcurname  PoreH40
#define mccompcurtype  Pore_h_group
#define mccompcurindex 143
#define nLeft mccPoreH40_nLeft
#define nRight mccPoreH40_nRight
#define nExit mccPoreH40_nExit
#define wLeft mccPoreH40_wLeft
#define wRight mccPoreH40_wRight
#define wExit mccPoreH40_wExit
#define wall mccPoreH40_wall
#define nTop mccPoreH40_nTop
#define nBottom mccPoreH40_nBottom
#define zexit mccPoreH40_zexit
#define zentry mccPoreH40_zentry
#define intersect_wolterI mccPoreH40_intersect_wolterI
#define reflec_side_table mccPoreH40_reflec_side_table
#define reflec_top_table mccPoreH40_reflec_top_table
#define reflec_bottom_table mccPoreH40_reflec_bottom_table
#define ref_prms mccPoreH40_ref_prms
{   /* Declarations of PoreH40=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH40_radius_m;
MCNUM radius_h = mccPoreH40_radius_h;
MCNUM Z0 = mccPoreH40_Z0;
MCNUM xwidth = mccPoreH40_xwidth;
MCNUM yheight = mccPoreH40_yheight;
MCNUM chamferwidth = mccPoreH40_chamferwidth;
char* mirror_reflec = mccPoreH40_mirror_reflec;
char* bottom_reflec = mccPoreH40_bottom_reflec;
char* side_reflec = mccPoreH40_side_reflec;
MCNUM R_d = mccPoreH40_R_d;
MCNUM absorb_sides = mccPoreH40_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 73148 "instruments/plate49.c"
}   /* End of PoreH40=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH40 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=143;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH40:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(143,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH41 [144] */
  mccoordschange(mcposrPoreH41, mcrotrPoreH41,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH41 (without coords transformations) */
  mcJumpTrace_PoreH41:
  SIG_MESSAGE("PoreH41 (Trace)");
  mcDEBUG_COMP("PoreH41")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH41
  STORE_XRAY(144,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[144]++;
  mcPCounter[144] += p;
  mcP2Counter[144] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH41
#define mccompcurname  PoreH41
#define mccompcurtype  Pore_h_group
#define mccompcurindex 144
#define nLeft mccPoreH41_nLeft
#define nRight mccPoreH41_nRight
#define nExit mccPoreH41_nExit
#define wLeft mccPoreH41_wLeft
#define wRight mccPoreH41_wRight
#define wExit mccPoreH41_wExit
#define wall mccPoreH41_wall
#define nTop mccPoreH41_nTop
#define nBottom mccPoreH41_nBottom
#define zexit mccPoreH41_zexit
#define zentry mccPoreH41_zentry
#define intersect_wolterI mccPoreH41_intersect_wolterI
#define reflec_side_table mccPoreH41_reflec_side_table
#define reflec_top_table mccPoreH41_reflec_top_table
#define reflec_bottom_table mccPoreH41_reflec_bottom_table
#define ref_prms mccPoreH41_ref_prms
{   /* Declarations of PoreH41=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH41_radius_m;
MCNUM radius_h = mccPoreH41_radius_h;
MCNUM Z0 = mccPoreH41_Z0;
MCNUM xwidth = mccPoreH41_xwidth;
MCNUM yheight = mccPoreH41_yheight;
MCNUM chamferwidth = mccPoreH41_chamferwidth;
char* mirror_reflec = mccPoreH41_mirror_reflec;
char* bottom_reflec = mccPoreH41_bottom_reflec;
char* side_reflec = mccPoreH41_side_reflec;
MCNUM R_d = mccPoreH41_R_d;
MCNUM absorb_sides = mccPoreH41_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 73447 "instruments/plate49.c"
}   /* End of PoreH41=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH41 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=144;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH41:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(144,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH42 [145] */
  mccoordschange(mcposrPoreH42, mcrotrPoreH42,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH42 (without coords transformations) */
  mcJumpTrace_PoreH42:
  SIG_MESSAGE("PoreH42 (Trace)");
  mcDEBUG_COMP("PoreH42")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH42
  STORE_XRAY(145,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[145]++;
  mcPCounter[145] += p;
  mcP2Counter[145] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH42
#define mccompcurname  PoreH42
#define mccompcurtype  Pore_h_group
#define mccompcurindex 145
#define nLeft mccPoreH42_nLeft
#define nRight mccPoreH42_nRight
#define nExit mccPoreH42_nExit
#define wLeft mccPoreH42_wLeft
#define wRight mccPoreH42_wRight
#define wExit mccPoreH42_wExit
#define wall mccPoreH42_wall
#define nTop mccPoreH42_nTop
#define nBottom mccPoreH42_nBottom
#define zexit mccPoreH42_zexit
#define zentry mccPoreH42_zentry
#define intersect_wolterI mccPoreH42_intersect_wolterI
#define reflec_side_table mccPoreH42_reflec_side_table
#define reflec_top_table mccPoreH42_reflec_top_table
#define reflec_bottom_table mccPoreH42_reflec_bottom_table
#define ref_prms mccPoreH42_ref_prms
{   /* Declarations of PoreH42=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH42_radius_m;
MCNUM radius_h = mccPoreH42_radius_h;
MCNUM Z0 = mccPoreH42_Z0;
MCNUM xwidth = mccPoreH42_xwidth;
MCNUM yheight = mccPoreH42_yheight;
MCNUM chamferwidth = mccPoreH42_chamferwidth;
char* mirror_reflec = mccPoreH42_mirror_reflec;
char* bottom_reflec = mccPoreH42_bottom_reflec;
char* side_reflec = mccPoreH42_side_reflec;
MCNUM R_d = mccPoreH42_R_d;
MCNUM absorb_sides = mccPoreH42_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 73746 "instruments/plate49.c"
}   /* End of PoreH42=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH42 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=145;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH42:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(145,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH43 [146] */
  mccoordschange(mcposrPoreH43, mcrotrPoreH43,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH43 (without coords transformations) */
  mcJumpTrace_PoreH43:
  SIG_MESSAGE("PoreH43 (Trace)");
  mcDEBUG_COMP("PoreH43")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH43
  STORE_XRAY(146,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[146]++;
  mcPCounter[146] += p;
  mcP2Counter[146] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH43
#define mccompcurname  PoreH43
#define mccompcurtype  Pore_h_group
#define mccompcurindex 146
#define nLeft mccPoreH43_nLeft
#define nRight mccPoreH43_nRight
#define nExit mccPoreH43_nExit
#define wLeft mccPoreH43_wLeft
#define wRight mccPoreH43_wRight
#define wExit mccPoreH43_wExit
#define wall mccPoreH43_wall
#define nTop mccPoreH43_nTop
#define nBottom mccPoreH43_nBottom
#define zexit mccPoreH43_zexit
#define zentry mccPoreH43_zentry
#define intersect_wolterI mccPoreH43_intersect_wolterI
#define reflec_side_table mccPoreH43_reflec_side_table
#define reflec_top_table mccPoreH43_reflec_top_table
#define reflec_bottom_table mccPoreH43_reflec_bottom_table
#define ref_prms mccPoreH43_ref_prms
{   /* Declarations of PoreH43=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH43_radius_m;
MCNUM radius_h = mccPoreH43_radius_h;
MCNUM Z0 = mccPoreH43_Z0;
MCNUM xwidth = mccPoreH43_xwidth;
MCNUM yheight = mccPoreH43_yheight;
MCNUM chamferwidth = mccPoreH43_chamferwidth;
char* mirror_reflec = mccPoreH43_mirror_reflec;
char* bottom_reflec = mccPoreH43_bottom_reflec;
char* side_reflec = mccPoreH43_side_reflec;
MCNUM R_d = mccPoreH43_R_d;
MCNUM absorb_sides = mccPoreH43_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 74045 "instruments/plate49.c"
}   /* End of PoreH43=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH43 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=146;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH43:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(146,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH44 [147] */
  mccoordschange(mcposrPoreH44, mcrotrPoreH44,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH44 (without coords transformations) */
  mcJumpTrace_PoreH44:
  SIG_MESSAGE("PoreH44 (Trace)");
  mcDEBUG_COMP("PoreH44")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH44
  STORE_XRAY(147,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[147]++;
  mcPCounter[147] += p;
  mcP2Counter[147] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH44
#define mccompcurname  PoreH44
#define mccompcurtype  Pore_h_group
#define mccompcurindex 147
#define nLeft mccPoreH44_nLeft
#define nRight mccPoreH44_nRight
#define nExit mccPoreH44_nExit
#define wLeft mccPoreH44_wLeft
#define wRight mccPoreH44_wRight
#define wExit mccPoreH44_wExit
#define wall mccPoreH44_wall
#define nTop mccPoreH44_nTop
#define nBottom mccPoreH44_nBottom
#define zexit mccPoreH44_zexit
#define zentry mccPoreH44_zentry
#define intersect_wolterI mccPoreH44_intersect_wolterI
#define reflec_side_table mccPoreH44_reflec_side_table
#define reflec_top_table mccPoreH44_reflec_top_table
#define reflec_bottom_table mccPoreH44_reflec_bottom_table
#define ref_prms mccPoreH44_ref_prms
{   /* Declarations of PoreH44=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH44_radius_m;
MCNUM radius_h = mccPoreH44_radius_h;
MCNUM Z0 = mccPoreH44_Z0;
MCNUM xwidth = mccPoreH44_xwidth;
MCNUM yheight = mccPoreH44_yheight;
MCNUM chamferwidth = mccPoreH44_chamferwidth;
char* mirror_reflec = mccPoreH44_mirror_reflec;
char* bottom_reflec = mccPoreH44_bottom_reflec;
char* side_reflec = mccPoreH44_side_reflec;
MCNUM R_d = mccPoreH44_R_d;
MCNUM absorb_sides = mccPoreH44_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 74344 "instruments/plate49.c"
}   /* End of PoreH44=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH44 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=147;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH44:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(147,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH45 [148] */
  mccoordschange(mcposrPoreH45, mcrotrPoreH45,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH45 (without coords transformations) */
  mcJumpTrace_PoreH45:
  SIG_MESSAGE("PoreH45 (Trace)");
  mcDEBUG_COMP("PoreH45")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH45
  STORE_XRAY(148,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[148]++;
  mcPCounter[148] += p;
  mcP2Counter[148] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH45
#define mccompcurname  PoreH45
#define mccompcurtype  Pore_h_group
#define mccompcurindex 148
#define nLeft mccPoreH45_nLeft
#define nRight mccPoreH45_nRight
#define nExit mccPoreH45_nExit
#define wLeft mccPoreH45_wLeft
#define wRight mccPoreH45_wRight
#define wExit mccPoreH45_wExit
#define wall mccPoreH45_wall
#define nTop mccPoreH45_nTop
#define nBottom mccPoreH45_nBottom
#define zexit mccPoreH45_zexit
#define zentry mccPoreH45_zentry
#define intersect_wolterI mccPoreH45_intersect_wolterI
#define reflec_side_table mccPoreH45_reflec_side_table
#define reflec_top_table mccPoreH45_reflec_top_table
#define reflec_bottom_table mccPoreH45_reflec_bottom_table
#define ref_prms mccPoreH45_ref_prms
{   /* Declarations of PoreH45=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH45_radius_m;
MCNUM radius_h = mccPoreH45_radius_h;
MCNUM Z0 = mccPoreH45_Z0;
MCNUM xwidth = mccPoreH45_xwidth;
MCNUM yheight = mccPoreH45_yheight;
MCNUM chamferwidth = mccPoreH45_chamferwidth;
char* mirror_reflec = mccPoreH45_mirror_reflec;
char* bottom_reflec = mccPoreH45_bottom_reflec;
char* side_reflec = mccPoreH45_side_reflec;
MCNUM R_d = mccPoreH45_R_d;
MCNUM absorb_sides = mccPoreH45_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 74643 "instruments/plate49.c"
}   /* End of PoreH45=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH45 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=148;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH45:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(148,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH46 [149] */
  mccoordschange(mcposrPoreH46, mcrotrPoreH46,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH46 (without coords transformations) */
  mcJumpTrace_PoreH46:
  SIG_MESSAGE("PoreH46 (Trace)");
  mcDEBUG_COMP("PoreH46")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH46
  STORE_XRAY(149,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[149]++;
  mcPCounter[149] += p;
  mcP2Counter[149] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH46
#define mccompcurname  PoreH46
#define mccompcurtype  Pore_h_group
#define mccompcurindex 149
#define nLeft mccPoreH46_nLeft
#define nRight mccPoreH46_nRight
#define nExit mccPoreH46_nExit
#define wLeft mccPoreH46_wLeft
#define wRight mccPoreH46_wRight
#define wExit mccPoreH46_wExit
#define wall mccPoreH46_wall
#define nTop mccPoreH46_nTop
#define nBottom mccPoreH46_nBottom
#define zexit mccPoreH46_zexit
#define zentry mccPoreH46_zentry
#define intersect_wolterI mccPoreH46_intersect_wolterI
#define reflec_side_table mccPoreH46_reflec_side_table
#define reflec_top_table mccPoreH46_reflec_top_table
#define reflec_bottom_table mccPoreH46_reflec_bottom_table
#define ref_prms mccPoreH46_ref_prms
{   /* Declarations of PoreH46=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH46_radius_m;
MCNUM radius_h = mccPoreH46_radius_h;
MCNUM Z0 = mccPoreH46_Z0;
MCNUM xwidth = mccPoreH46_xwidth;
MCNUM yheight = mccPoreH46_yheight;
MCNUM chamferwidth = mccPoreH46_chamferwidth;
char* mirror_reflec = mccPoreH46_mirror_reflec;
char* bottom_reflec = mccPoreH46_bottom_reflec;
char* side_reflec = mccPoreH46_side_reflec;
MCNUM R_d = mccPoreH46_R_d;
MCNUM absorb_sides = mccPoreH46_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 74942 "instruments/plate49.c"
}   /* End of PoreH46=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH46 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=149;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH46:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(149,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH47 [150] */
  mccoordschange(mcposrPoreH47, mcrotrPoreH47,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH47 (without coords transformations) */
  mcJumpTrace_PoreH47:
  SIG_MESSAGE("PoreH47 (Trace)");
  mcDEBUG_COMP("PoreH47")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH47
  STORE_XRAY(150,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[150]++;
  mcPCounter[150] += p;
  mcP2Counter[150] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH47
#define mccompcurname  PoreH47
#define mccompcurtype  Pore_h_group
#define mccompcurindex 150
#define nLeft mccPoreH47_nLeft
#define nRight mccPoreH47_nRight
#define nExit mccPoreH47_nExit
#define wLeft mccPoreH47_wLeft
#define wRight mccPoreH47_wRight
#define wExit mccPoreH47_wExit
#define wall mccPoreH47_wall
#define nTop mccPoreH47_nTop
#define nBottom mccPoreH47_nBottom
#define zexit mccPoreH47_zexit
#define zentry mccPoreH47_zentry
#define intersect_wolterI mccPoreH47_intersect_wolterI
#define reflec_side_table mccPoreH47_reflec_side_table
#define reflec_top_table mccPoreH47_reflec_top_table
#define reflec_bottom_table mccPoreH47_reflec_bottom_table
#define ref_prms mccPoreH47_ref_prms
{   /* Declarations of PoreH47=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH47_radius_m;
MCNUM radius_h = mccPoreH47_radius_h;
MCNUM Z0 = mccPoreH47_Z0;
MCNUM xwidth = mccPoreH47_xwidth;
MCNUM yheight = mccPoreH47_yheight;
MCNUM chamferwidth = mccPoreH47_chamferwidth;
char* mirror_reflec = mccPoreH47_mirror_reflec;
char* bottom_reflec = mccPoreH47_bottom_reflec;
char* side_reflec = mccPoreH47_side_reflec;
MCNUM R_d = mccPoreH47_R_d;
MCNUM absorb_sides = mccPoreH47_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 75241 "instruments/plate49.c"
}   /* End of PoreH47=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH47 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=150;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH47:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(150,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component PoreH48 [151] */
  mccoordschange(mcposrPoreH48, mcrotrPoreH48,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component PoreH48 (without coords transformations) */
  mcJumpTrace_PoreH48:
  SIG_MESSAGE("PoreH48 (Trace)");
  mcDEBUG_COMP("PoreH48")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPoreH48
  STORE_XRAY(151,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[151]++;
  mcPCounter[151] += p;
  mcP2Counter[151] += p*p;
  if (!mcGrouphyperbolic) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
#define mcabsorb mcabsorbCompPoreH48
#define mccompcurname  PoreH48
#define mccompcurtype  Pore_h_group
#define mccompcurindex 151
#define nLeft mccPoreH48_nLeft
#define nRight mccPoreH48_nRight
#define nExit mccPoreH48_nExit
#define wLeft mccPoreH48_wLeft
#define wRight mccPoreH48_wRight
#define wExit mccPoreH48_wExit
#define wall mccPoreH48_wall
#define nTop mccPoreH48_nTop
#define nBottom mccPoreH48_nBottom
#define zexit mccPoreH48_zexit
#define zentry mccPoreH48_zentry
#define intersect_wolterI mccPoreH48_intersect_wolterI
#define reflec_side_table mccPoreH48_reflec_side_table
#define reflec_top_table mccPoreH48_reflec_top_table
#define reflec_bottom_table mccPoreH48_reflec_bottom_table
#define ref_prms mccPoreH48_ref_prms
{   /* Declarations of PoreH48=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH48_radius_m;
MCNUM radius_h = mccPoreH48_radius_h;
MCNUM Z0 = mccPoreH48_Z0;
MCNUM xwidth = mccPoreH48_xwidth;
MCNUM yheight = mccPoreH48_yheight;
MCNUM chamferwidth = mccPoreH48_chamferwidth;
char* mirror_reflec = mccPoreH48_mirror_reflec;
char* bottom_reflec = mccPoreH48_bottom_reflec;
char* side_reflec = mccPoreH48_side_reflec;
MCNUM R_d = mccPoreH48_R_d;
MCNUM absorb_sides = mccPoreH48_absorb_sides;
#line 229 "Pore_h_group.comp"
{
    enum {LEFT, RIGHT, TOP, BOTTOM, EXIT, NONE} wall;
    t_Table *reflec_table=NULL;
    int hit_pore, hit_chamfer;
    double R;
    int paramsIndex;

    /*To allow photons to enter through the sidewalls, we'd need some more sophisticated logic here.*/
    PROP_Z0;
    hit_pore= ( ( x*x + (y+radius_m)*(y+radius_m) < radius_m*radius_m ) && ( x*x + (y+radius_m)*(y+radius_m) >(radius_m-yheight)*(radius_m-yheight) ) && (atan(fabs(x)/fabs(y+radius_m))< xwidth/2.0/radius_m)) ;
    hit_chamfer=0;

    if(hit_pore){
        SCATTER;

        int exit=0;
        int intersections[5];
        int i_small;
        double l[5];
        double l_small;

        double nx,ny,nz;

        while (!exit){
            l_small=DBL_MAX;
            wall=NONE;
            double nx,ny,nz;
            double wx,wy,wz;

            //left wall
            intersections[LEFT]=plane_intersect(l+LEFT,x,y,z,kx,ky,kz,nLeft[0],nLeft[1],nLeft[2],wLeft[0],wLeft[1],wLeft[2]);
            if (intersections[LEFT] && l[LEFT]>DBL_EPSILON && l[LEFT]<l_small) {l_small=l[LEFT];i_small=intersections[LEFT];wall=LEFT;}
            //right wall
            intersections[RIGHT]=plane_intersect(l+RIGHT,x,y,z,kx,ky,kz,nRight[0],nRight[1],nRight[2],wRight[0],wRight[1],wRight[2]);
            if (intersections[RIGHT] && l[RIGHT]>DBL_EPSILON && l[RIGHT]<l_small) {l_small=l[RIGHT];i_small=intersections[RIGHT];wall=RIGHT;}
            /*exit plane*/
            intersections[EXIT]=plane_intersect(l+EXIT,x,y,z,kx,ky,kz,nExit[0],nExit[1],nExit[2],wExit[0],wExit[1],wExit[2]);
            if (intersections[EXIT] && l[EXIT]>DBL_EPSILON && l[EXIT]<l_small) {l_small=l[EXIT];i_small=intersections[EXIT];wall=EXIT;}
            /*top surface - the real reflecting surface*/
            intersections[TOP]=intersect_hyperboloid((l+TOP),x,y+radius_m,z,kx,ky,kz,Z0,radius_m,&(nTop[0]),&(nTop[1]),&(nTop[2]));
            if (intersections[TOP] && l[TOP]>DBL_EPSILON && l[TOP]<l_small) {l_small=l[TOP];i_small=intersections[TOP];wall=TOP;}
            /*bottom surface*/
            intersections[BOTTOM]=intersect_hyperboloid((l+BOTTOM),x,y+radius_m,z,kx,ky,kz,Z0,radius_m-yheight,&(nBottom[0]),&(nBottom[1]),&(nBottom[2]));
            if (intersections[BOTTOM] && l[BOTTOM]>DBL_EPSILON && l[BOTTOM]<l_small) {l_small=l[BOTTOM];i_small=intersections[BOTTOM];wall=BOTTOM;}

            /*sort intersections ot find the smallest positive one*/
            switch (wall){
                case LEFT:
                    /*handle left wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nLeft[0];ny=nLeft[1];nz=nLeft[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case RIGHT:
                    /*handle right wall "reflection"*/
                    reflec_table=&reflec_side_table;
                    paramsIndex = 2;
                    nx=nRight[0];ny=nRight[1];nz=nRight[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case TOP:
                    /*handle top wall reflection*/

                    reflec_table=&reflec_top_table;
                    paramsIndex = 0;
                    nx=nTop[0];ny=nTop[1];nz=nTop[2];
                    break;
                case BOTTOM:
                    /*handle bottom wall "reflection"*/
                    reflec_table=&reflec_bottom_table;
                    paramsIndex = 1;
                    nx=nBottom[0];ny=nBottom[1];nz=nBottom[2];
                    if(absorb_sides){
                      ABSORB;
                    } else {

                    }
                    break;
                case EXIT:
                    /*photon will exit pore*/
                    exit=1;
                    break;
            }
            if(exit){
                continue;
            }
            PROP_DL(l_small);
            if(wall == TOP){
                bufferAddReflection(HT, x, y, z);
            } else if(wall == BOTTOM){
                bufferAddReflection(HB, x, y, z);
            } else if(wall == LEFT){
                bufferAddReflection(HL, x, y, z);
            } else if(wall == RIGHT){
                bufferAddReflection(HR, x, y, z);
            }

            double kix=kx,kiy=ky,kiz=kz;

            double s=scalar_prod(kx,ky,kz,nx,ny,nz);
            /*reflect the photon through the surface normal*/
            if(s!=0){
                kx-=2*s*nx;
                ky-=2*s*ny;
                kz-=2*s*nz;
            }
            SCATTER;

            double k=sqrt(kx*kx+ ky*ky + kz*kz);
            double theta=RAD2DEG*0.5*acos(scalar_prod(kx,ky,kz,kix,kiy,kiz)/k/k);
            double e=K2E*k;

            if(reflec_table==NULL){
                R=R_d;
            }else{
                R=Table_Value2d(*reflec_table,(e-ref_prms[paramsIndex].e_min)/ref_prms[paramsIndex].e_step, (theta-ref_prms[paramsIndex].theta_min)/ref_prms[paramsIndex].theta_step);
            }
            p*=R;
        }
    }else if (hit_chamfer){
        //ABSORB;
    }else{
        /*no hit*/
        //ABSORB;
    }
}
#line 75540 "instruments/plate49.c"
}   /* End of PoreH48=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp PoreH48 in GROUP hyperbolic */
  if (SCATTERED) {
    mcGrouphyperbolic=151;
  } else {
    RESTORE=1;
  }
  /* Label for restoring  xray */
  mcabsorbCompPoreH48:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(151,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
/* end of GROUP hyperbolic */
  if (!mcGrouphyperbolic) ABSORB; /* absorb xray non scattered in GROUP */
  mcGrouphyperbolic=0; /* reset group scattered flag */
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component monitorAfter [152] */
  mccoordschange(mcposrmonitorAfter, mcrotrmonitorAfter,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component monitorAfter (without coords transformations) */
  mcJumpTrace_monitorAfter:
  SIG_MESSAGE("monitorAfter (Trace)");
  mcDEBUG_COMP("monitorAfter")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonitorAfter
  STORE_XRAY(152,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[152]++;
  mcPCounter[152] += p;
  mcP2Counter[152] += p*p;
#define mccompcurname  monitorAfter
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 152
#define nx mccmonitorAfter_nx
#define ny mccmonitorAfter_ny
#define nr mccmonitorAfter_nr
#define filename mccmonitorAfter_filename
#define restore_xray mccmonitorAfter_restore_xray
#define PSD_N mccmonitorAfter_PSD_N
#define PSD_p mccmonitorAfter_PSD_p
#define PSD_p2 mccmonitorAfter_PSD_p2
#define posx mccmonitorAfter_posx
#define posy mccmonitorAfter_posy
{   /* Declarations of monitorAfter=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccmonitorAfter_xmin;
MCNUM xmax = mccmonitorAfter_xmax;
MCNUM ymin = mccmonitorAfter_ymin;
MCNUM ymax = mccmonitorAfter_ymax;
MCNUM xwidth = mccmonitorAfter_xwidth;
MCNUM yheight = mccmonitorAfter_yheight;
MCNUM radius = mccmonitorAfter_radius;
#line 107 "PSD_monitor_ext.comp"
{
    posx = 0;
    posy = 0;
    int ix,jy;

    PROP_Z0;
    if (!radius){
      if (x>xmin && x<xmax && y>ymin && y<ymax)
      {
        ix = floor((x - xmin)*nx/(xmax - xmin));
        jy = floor((y - ymin)*ny/(ymax - ymin));
        PSD_N[ix][jy]++;
        PSD_p[ix][jy] += p;
        PSD_p2[ix][jy] += p*p;
        posx = x;
        posy = y;
        SCATTER;
      }
    }else{
      double r=sqrt(x*x+y*y);
      if (r<radius){
        ix = floor(r*nr/radius);
        PSD_N[0][ix]++;
        PSD_p[0][ix] += p;
        PSD_p2[0][ix] += p*p;
        SCATTER;
      }
    }
    if (restore_xray) {
      RESTORE_XRAY(INDEX_CURRENT_COMP, x, y, z, kx, ky, kz, phi, t, Ex, Ey, Ez, p);
    }
}
#line 75725 "instruments/plate49.c"
/* 'monitorAfter=PSD_monitor_ext()' component instance extend code */
    SIG_MESSAGE("monitorAfter (Trace:Extend)");
#line 1823 "instruments/plate49.instr"
        photonPassedThrough++;
        photonPassedThroughWeighted += p;
        bufferAddPlanePosition(EXITP, posx, posy, 0.15);
        bufferAddPhotonInfo(p);
#line 75733 "instruments/plate49.c"
}   /* End of monitorAfter=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompmonitorAfter:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(152,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  /* TRACE Component endMonitorWide [153] */
  mccoordschange(mcposrendMonitorWide, mcrotrendMonitorWide,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlkx,
    &mcnlky,
    &mcnlkz,
    &mcnlEx,
    &mcnlEy,
    &mcnlEz);
  /* define label inside component endMonitorWide (without coords transformations) */
  mcJumpTrace_endMonitorWide:
  SIG_MESSAGE("endMonitorWide (Trace)");
  mcDEBUG_COMP("endMonitorWide")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define kx mcnlkx
#define ky mcnlky
#define kz mcnlkz
#define phi mcnlphi
#define t mcnlt
#define Ex mcnlEx
#define Ey mcnlEy
#define Ez mcnlEz
#define p mcnlp

#define mcabsorbComp mcabsorbCompendMonitorWide
  STORE_XRAY(153,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlkx,
    mcnlky,
    mcnlkz,
    mcnlphi,
    mcnlt,
    mcnlEx,
    mcnlEy,
    mcnlEz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[153]++;
  mcPCounter[153] += p;
  mcP2Counter[153] += p*p;
#define mccompcurname  endMonitorWide
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 153
#define nx mccendMonitorWide_nx
#define ny mccendMonitorWide_ny
#define nr mccendMonitorWide_nr
#define filename mccendMonitorWide_filename
#define restore_xray mccendMonitorWide_restore_xray
#define PSD_N mccendMonitorWide_PSD_N
#define PSD_p mccendMonitorWide_PSD_p
#define PSD_p2 mccendMonitorWide_PSD_p2
#define posx mccendMonitorWide_posx
#define posy mccendMonitorWide_posy
{   /* Declarations of endMonitorWide=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccendMonitorWide_xmin;
MCNUM xmax = mccendMonitorWide_xmax;
MCNUM ymin = mccendMonitorWide_ymin;
MCNUM ymax = mccendMonitorWide_ymax;
MCNUM xwidth = mccendMonitorWide_xwidth;
MCNUM yheight = mccendMonitorWide_yheight;
MCNUM radius = mccendMonitorWide_radius;
#line 107 "PSD_monitor_ext.comp"
{
    posx = 0;
    posy = 0;
    int ix,jy;

    PROP_Z0;
    if (!radius){
      if (x>xmin && x<xmax && y>ymin && y<ymax)
      {
        ix = floor((x - xmin)*nx/(xmax - xmin));
        jy = floor((y - ymin)*ny/(ymax - ymin));
        PSD_N[ix][jy]++;
        PSD_p[ix][jy] += p;
        PSD_p2[ix][jy] += p*p;
        posx = x;
        posy = y;
        SCATTER;
      }
    }else{
      double r=sqrt(x*x+y*y);
      if (r<radius){
        ix = floor(r*nr/radius);
        PSD_N[0][ix]++;
        PSD_p[0][ix] += p;
        PSD_p2[0][ix] += p*p;
        SCATTER;
      }
    }
    if (restore_xray) {
      RESTORE_XRAY(INDEX_CURRENT_COMP, x, y, z, kx, ky, kz, phi, t, Ex, Ey, Ez, p);
    }
}
#line 75905 "instruments/plate49.c"
/* 'endMonitorWide=PSD_monitor_ext()' component instance extend code */
    SIG_MESSAGE("endMonitorWide (Trace:Extend)");
#line 1850 "instruments/plate49.instr"
        bufferAddAbsorb(FOCALPLANE, posx, posy, focalLength);
#line 75910 "instruments/plate49.c"
}   /* End of endMonitorWide=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  xray */
  mcabsorbCompendMonitorWide:
  if (RESTORE) /* restore if needed */
  { RESTORE_XRAY(153,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlkx,
      mcnlky,
      mcnlkz,
      mcnlphi,
      mcnlt,
      mcnlEx,
      mcnlEy,
      mcnlEz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef Ez
#undef Ey
#undef Ex
#undef t
#undef phi
#undef kz
#undef ky
#undef kx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)

  mcabsorbAll:
  mcDEBUG_LEAVE()
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlkx,
mcnlky,
mcnlkz,
mcnlphi,
mcnlt,
mcnlEx,
mcnlEy,
mcnlEz,
mcnlp)
  /* Copy xray state to global variables. */
  mcnx = mcnlx;
  mcny = mcnly;
  mcnz = mcnlz;
  mcnkx = mcnlkx;
  mcnky = mcnlky;
  mcnkz = mcnlkz;
  mcnphi = mcnlphi;
  mcnt = mcnlt;
  mcnEx = mcnlEx;
  mcnEy = mcnlEy;
  mcnEz = mcnlEz;
  mcnp = mcnlp;

} /* end trace */

void mcsave(FILE *handle) {
  if (!handle) mcsiminfo_init(NULL);
  /* User component SAVE code. */

  /* User SAVE code for component 'origin'. */
  SIG_MESSAGE("origin (Save)");
#define mccompcurname  origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define profile mccorigin_profile
#define IntermediateCnts mccorigin_IntermediateCnts
#define StartTime mccorigin_StartTime
#define EndTime mccorigin_EndTime
{   /* Declarations of origin=Progress_bar() SETTING parameters. */
MCNUM percent = mccorigin_percent;
MCNUM flag_save = mccorigin_flag_save;
MCNUM minutes = mccorigin_minutes;
#line 110 "/usr/share/mcxtrace/1.4/misc/Progress_bar.comp"
{
  MPI_MASTER(fprintf(stdout, "\nSave [%s]\n", mcinstrument_name););
  if (profile && strlen(profile)) {
    char filename[256];
    if (!strlen(profile)) strcpy(filename, mcinstrument_name);
    else strcpy(filename, profile);
    DETECTOR_OUT_1D(
        "Intensity profiler",
        "Component index [1]",
        "Intensity",
        "prof", 1, mcNUMCOMP, mcNUMCOMP-1,
        &mcNCounter[1],&mcPCounter[1],&mcP2Counter[1],
        filename);

  }
}
#line 76033 "instruments/plate49.c"
}   /* End of origin=Progress_bar() SETTING parameter declarations. */
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef profile
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'monitorAfter'. */
  SIG_MESSAGE("monitorAfter (Save)");
#define mccompcurname  monitorAfter
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 152
#define nx mccmonitorAfter_nx
#define ny mccmonitorAfter_ny
#define nr mccmonitorAfter_nr
#define filename mccmonitorAfter_filename
#define restore_xray mccmonitorAfter_restore_xray
#define PSD_N mccmonitorAfter_PSD_N
#define PSD_p mccmonitorAfter_PSD_p
#define PSD_p2 mccmonitorAfter_PSD_p2
#define posx mccmonitorAfter_posx
#define posy mccmonitorAfter_posy
{   /* Declarations of monitorAfter=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccmonitorAfter_xmin;
MCNUM xmax = mccmonitorAfter_xmax;
MCNUM ymin = mccmonitorAfter_ymin;
MCNUM ymax = mccmonitorAfter_ymax;
MCNUM xwidth = mccmonitorAfter_xwidth;
MCNUM yheight = mccmonitorAfter_yheight;
MCNUM radius = mccmonitorAfter_radius;
#line 140 "PSD_monitor_ext.comp"
{
    if(!radius){
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [m]",
          "Y position [m]",
          xmin, xmax, ymin, ymax,
          nx, ny,
          *PSD_N,*PSD_p,*PSD_p2,
          filename);
    }else{
      DETECTOR_OUT_1D(
          "PSD_monitor","Radial Position[m]", "Intensity", "R",
          0,radius,nr,&PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],filename);
    }

}
#line 76084 "instruments/plate49.c"
}   /* End of monitorAfter=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'endMonitorWide'. */
  SIG_MESSAGE("endMonitorWide (Save)");
#define mccompcurname  endMonitorWide
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 153
#define nx mccendMonitorWide_nx
#define ny mccendMonitorWide_ny
#define nr mccendMonitorWide_nr
#define filename mccendMonitorWide_filename
#define restore_xray mccendMonitorWide_restore_xray
#define PSD_N mccendMonitorWide_PSD_N
#define PSD_p mccendMonitorWide_PSD_p
#define PSD_p2 mccendMonitorWide_PSD_p2
#define posx mccendMonitorWide_posx
#define posy mccendMonitorWide_posy
{   /* Declarations of endMonitorWide=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccendMonitorWide_xmin;
MCNUM xmax = mccendMonitorWide_xmax;
MCNUM ymin = mccendMonitorWide_ymin;
MCNUM ymax = mccendMonitorWide_ymax;
MCNUM xwidth = mccendMonitorWide_xwidth;
MCNUM yheight = mccendMonitorWide_yheight;
MCNUM radius = mccendMonitorWide_radius;
#line 140 "PSD_monitor_ext.comp"
{
    if(!radius){
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [m]",
          "Y position [m]",
          xmin, xmax, ymin, ymax,
          nx, ny,
          *PSD_N,*PSD_p,*PSD_p2,
          filename);
    }else{
      DETECTOR_OUT_1D(
          "PSD_monitor","Radial Position[m]", "Intensity", "R",
          0,radius,nr,&PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],filename);
    }

}
#line 76141 "instruments/plate49.c"
}   /* End of endMonitorWide=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  if (!handle) mcsiminfo_close(); 
} /* end save */
void mcfinally(void) {
  /* User component FINALLY code. */
  mcsiminfo_init(NULL);
  mcsave(mcsiminfo_file); /* save data when simulation ends */

  /* User FINALLY code for component 'origin'. */
  SIG_MESSAGE("origin (Finally)");
#define mccompcurname  origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define profile mccorigin_profile
#define IntermediateCnts mccorigin_IntermediateCnts
#define StartTime mccorigin_StartTime
#define EndTime mccorigin_EndTime
{   /* Declarations of origin=Progress_bar() SETTING parameters. */
MCNUM percent = mccorigin_percent;
MCNUM flag_save = mccorigin_flag_save;
MCNUM minutes = mccorigin_minutes;
#line 128 "/usr/share/mcxtrace/1.4/misc/Progress_bar.comp"
{
  time_t NowTime;
  time(&NowTime);
  fprintf(stdout, "\nFinally [%s: %s]. Time: ", mcinstrument_name, mcdirname ? mcdirname : ".");
  if (difftime(NowTime,StartTime) < 60.0)
    fprintf(stdout, "%g [s] ", difftime(NowTime,StartTime));
  else if (difftime(NowTime,StartTime) > 3600.0)
    fprintf(stdout, "%g [h] ", difftime(NowTime,StartTime)/3660.0);
  else
    fprintf(stdout, "%g [min] ", difftime(NowTime,StartTime)/60.0);
  fprintf(stdout, "\n");
}
#line 76190 "instruments/plate49.c"
}   /* End of origin=Progress_bar() SETTING parameter declarations. */
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef profile
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[1]) fprintf(stderr, "Warning: No xray could reach Component[1] origin\n");
    if (mcAbsorbProp[1]) fprintf(stderr, "Warning: %g events were removed in Component[1] origin=Progress_bar()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[1]);
    if (!mcNCounter[2]) fprintf(stderr, "Warning: No xray could reach Component[2] ThetaArm\n");
    if (mcAbsorbProp[2]) fprintf(stderr, "Warning: %g events were removed in Component[2] ThetaArm=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[2]);
    if (!mcNCounter[3]) fprintf(stderr, "Warning: No xray could reach Component[3] srcDirectional\n");
    if (mcAbsorbProp[3]) fprintf(stderr, "Warning: %g events were removed in Component[3] srcDirectional=Source_div()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[3]);
    if (!mcNCounter[4]) fprintf(stderr, "Warning: No xray could reach Component[4] srcDirectionalWide\n");
    if (mcAbsorbProp[4]) fprintf(stderr, "Warning: %g events were removed in Component[4] srcDirectionalWide=Source_div()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[4]);
    if (!mcNCounter[5]) fprintf(stderr, "Warning: No xray could reach Component[5] PoreArm0\n");
    if (mcAbsorbProp[5]) fprintf(stderr, "Warning: %g events were removed in Component[5] PoreArm0=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[5]);
    if (!mcNCounter[6]) fprintf(stderr, "Warning: No xray could reach Component[6] PoreArm1\n");
    if (mcAbsorbProp[6]) fprintf(stderr, "Warning: %g events were removed in Component[6] PoreArm1=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[6]);
    if (!mcNCounter[7]) fprintf(stderr, "Warning: No xray could reach Component[7] PoreArm2\n");
    if (mcAbsorbProp[7]) fprintf(stderr, "Warning: %g events were removed in Component[7] PoreArm2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[7]);
    if (!mcNCounter[8]) fprintf(stderr, "Warning: No xray could reach Component[8] PoreArm3\n");
    if (mcAbsorbProp[8]) fprintf(stderr, "Warning: %g events were removed in Component[8] PoreArm3=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[8]);
    if (!mcNCounter[9]) fprintf(stderr, "Warning: No xray could reach Component[9] PoreArm4\n");
    if (mcAbsorbProp[9]) fprintf(stderr, "Warning: %g events were removed in Component[9] PoreArm4=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[9]);
    if (!mcNCounter[10]) fprintf(stderr, "Warning: No xray could reach Component[10] PoreArm5\n");
    if (mcAbsorbProp[10]) fprintf(stderr, "Warning: %g events were removed in Component[10] PoreArm5=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[10]);
    if (!mcNCounter[11]) fprintf(stderr, "Warning: No xray could reach Component[11] PoreArm6\n");
    if (mcAbsorbProp[11]) fprintf(stderr, "Warning: %g events were removed in Component[11] PoreArm6=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[11]);
    if (!mcNCounter[12]) fprintf(stderr, "Warning: No xray could reach Component[12] PoreArm7\n");
    if (mcAbsorbProp[12]) fprintf(stderr, "Warning: %g events were removed in Component[12] PoreArm7=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[12]);
    if (!mcNCounter[13]) fprintf(stderr, "Warning: No xray could reach Component[13] PoreArm8\n");
    if (mcAbsorbProp[13]) fprintf(stderr, "Warning: %g events were removed in Component[13] PoreArm8=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[13]);
    if (!mcNCounter[14]) fprintf(stderr, "Warning: No xray could reach Component[14] PoreArm9\n");
    if (mcAbsorbProp[14]) fprintf(stderr, "Warning: %g events were removed in Component[14] PoreArm9=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[14]);
    if (!mcNCounter[15]) fprintf(stderr, "Warning: No xray could reach Component[15] PoreArm10\n");
    if (mcAbsorbProp[15]) fprintf(stderr, "Warning: %g events were removed in Component[15] PoreArm10=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[15]);
    if (!mcNCounter[16]) fprintf(stderr, "Warning: No xray could reach Component[16] PoreArm11\n");
    if (mcAbsorbProp[16]) fprintf(stderr, "Warning: %g events were removed in Component[16] PoreArm11=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[16]);
    if (!mcNCounter[17]) fprintf(stderr, "Warning: No xray could reach Component[17] PoreArm12\n");
    if (mcAbsorbProp[17]) fprintf(stderr, "Warning: %g events were removed in Component[17] PoreArm12=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[17]);
    if (!mcNCounter[18]) fprintf(stderr, "Warning: No xray could reach Component[18] PoreArm13\n");
    if (mcAbsorbProp[18]) fprintf(stderr, "Warning: %g events were removed in Component[18] PoreArm13=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[18]);
    if (!mcNCounter[19]) fprintf(stderr, "Warning: No xray could reach Component[19] PoreArm14\n");
    if (mcAbsorbProp[19]) fprintf(stderr, "Warning: %g events were removed in Component[19] PoreArm14=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[19]);
    if (!mcNCounter[20]) fprintf(stderr, "Warning: No xray could reach Component[20] PoreArm15\n");
    if (mcAbsorbProp[20]) fprintf(stderr, "Warning: %g events were removed in Component[20] PoreArm15=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[20]);
    if (!mcNCounter[21]) fprintf(stderr, "Warning: No xray could reach Component[21] PoreArm16\n");
    if (mcAbsorbProp[21]) fprintf(stderr, "Warning: %g events were removed in Component[21] PoreArm16=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[21]);
    if (!mcNCounter[22]) fprintf(stderr, "Warning: No xray could reach Component[22] PoreArm17\n");
    if (mcAbsorbProp[22]) fprintf(stderr, "Warning: %g events were removed in Component[22] PoreArm17=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[22]);
    if (!mcNCounter[23]) fprintf(stderr, "Warning: No xray could reach Component[23] PoreArm18\n");
    if (mcAbsorbProp[23]) fprintf(stderr, "Warning: %g events were removed in Component[23] PoreArm18=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[23]);
    if (!mcNCounter[24]) fprintf(stderr, "Warning: No xray could reach Component[24] PoreArm19\n");
    if (mcAbsorbProp[24]) fprintf(stderr, "Warning: %g events were removed in Component[24] PoreArm19=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[24]);
    if (!mcNCounter[25]) fprintf(stderr, "Warning: No xray could reach Component[25] PoreArm20\n");
    if (mcAbsorbProp[25]) fprintf(stderr, "Warning: %g events were removed in Component[25] PoreArm20=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[25]);
    if (!mcNCounter[26]) fprintf(stderr, "Warning: No xray could reach Component[26] PoreArm21\n");
    if (mcAbsorbProp[26]) fprintf(stderr, "Warning: %g events were removed in Component[26] PoreArm21=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[26]);
    if (!mcNCounter[27]) fprintf(stderr, "Warning: No xray could reach Component[27] PoreArm22\n");
    if (mcAbsorbProp[27]) fprintf(stderr, "Warning: %g events were removed in Component[27] PoreArm22=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[27]);
    if (!mcNCounter[28]) fprintf(stderr, "Warning: No xray could reach Component[28] PoreArm23\n");
    if (mcAbsorbProp[28]) fprintf(stderr, "Warning: %g events were removed in Component[28] PoreArm23=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[28]);
    if (!mcNCounter[29]) fprintf(stderr, "Warning: No xray could reach Component[29] PoreArm24\n");
    if (mcAbsorbProp[29]) fprintf(stderr, "Warning: %g events were removed in Component[29] PoreArm24=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[29]);
    if (!mcNCounter[30]) fprintf(stderr, "Warning: No xray could reach Component[30] PoreArm25\n");
    if (mcAbsorbProp[30]) fprintf(stderr, "Warning: %g events were removed in Component[30] PoreArm25=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[30]);
    if (!mcNCounter[31]) fprintf(stderr, "Warning: No xray could reach Component[31] PoreArm26\n");
    if (mcAbsorbProp[31]) fprintf(stderr, "Warning: %g events were removed in Component[31] PoreArm26=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[31]);
    if (!mcNCounter[32]) fprintf(stderr, "Warning: No xray could reach Component[32] PoreArm27\n");
    if (mcAbsorbProp[32]) fprintf(stderr, "Warning: %g events were removed in Component[32] PoreArm27=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[32]);
    if (!mcNCounter[33]) fprintf(stderr, "Warning: No xray could reach Component[33] PoreArm28\n");
    if (mcAbsorbProp[33]) fprintf(stderr, "Warning: %g events were removed in Component[33] PoreArm28=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[33]);
    if (!mcNCounter[34]) fprintf(stderr, "Warning: No xray could reach Component[34] PoreArm29\n");
    if (mcAbsorbProp[34]) fprintf(stderr, "Warning: %g events were removed in Component[34] PoreArm29=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[34]);
    if (!mcNCounter[35]) fprintf(stderr, "Warning: No xray could reach Component[35] PoreArm30\n");
    if (mcAbsorbProp[35]) fprintf(stderr, "Warning: %g events were removed in Component[35] PoreArm30=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[35]);
    if (!mcNCounter[36]) fprintf(stderr, "Warning: No xray could reach Component[36] PoreArm31\n");
    if (mcAbsorbProp[36]) fprintf(stderr, "Warning: %g events were removed in Component[36] PoreArm31=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[36]);
    if (!mcNCounter[37]) fprintf(stderr, "Warning: No xray could reach Component[37] PoreArm32\n");
    if (mcAbsorbProp[37]) fprintf(stderr, "Warning: %g events were removed in Component[37] PoreArm32=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[37]);
    if (!mcNCounter[38]) fprintf(stderr, "Warning: No xray could reach Component[38] PoreArm33\n");
    if (mcAbsorbProp[38]) fprintf(stderr, "Warning: %g events were removed in Component[38] PoreArm33=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[38]);
    if (!mcNCounter[39]) fprintf(stderr, "Warning: No xray could reach Component[39] PoreArm34\n");
    if (mcAbsorbProp[39]) fprintf(stderr, "Warning: %g events were removed in Component[39] PoreArm34=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[39]);
    if (!mcNCounter[40]) fprintf(stderr, "Warning: No xray could reach Component[40] PoreArm35\n");
    if (mcAbsorbProp[40]) fprintf(stderr, "Warning: %g events were removed in Component[40] PoreArm35=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[40]);
    if (!mcNCounter[41]) fprintf(stderr, "Warning: No xray could reach Component[41] PoreArm36\n");
    if (mcAbsorbProp[41]) fprintf(stderr, "Warning: %g events were removed in Component[41] PoreArm36=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[41]);
    if (!mcNCounter[42]) fprintf(stderr, "Warning: No xray could reach Component[42] PoreArm37\n");
    if (mcAbsorbProp[42]) fprintf(stderr, "Warning: %g events were removed in Component[42] PoreArm37=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[42]);
    if (!mcNCounter[43]) fprintf(stderr, "Warning: No xray could reach Component[43] PoreArm38\n");
    if (mcAbsorbProp[43]) fprintf(stderr, "Warning: %g events were removed in Component[43] PoreArm38=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[43]);
    if (!mcNCounter[44]) fprintf(stderr, "Warning: No xray could reach Component[44] PoreArm39\n");
    if (mcAbsorbProp[44]) fprintf(stderr, "Warning: %g events were removed in Component[44] PoreArm39=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[44]);
    if (!mcNCounter[45]) fprintf(stderr, "Warning: No xray could reach Component[45] PoreArm40\n");
    if (mcAbsorbProp[45]) fprintf(stderr, "Warning: %g events were removed in Component[45] PoreArm40=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[45]);
    if (!mcNCounter[46]) fprintf(stderr, "Warning: No xray could reach Component[46] PoreArm41\n");
    if (mcAbsorbProp[46]) fprintf(stderr, "Warning: %g events were removed in Component[46] PoreArm41=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[46]);
    if (!mcNCounter[47]) fprintf(stderr, "Warning: No xray could reach Component[47] PoreArm42\n");
    if (mcAbsorbProp[47]) fprintf(stderr, "Warning: %g events were removed in Component[47] PoreArm42=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[47]);
    if (!mcNCounter[48]) fprintf(stderr, "Warning: No xray could reach Component[48] PoreArm43\n");
    if (mcAbsorbProp[48]) fprintf(stderr, "Warning: %g events were removed in Component[48] PoreArm43=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[48]);
    if (!mcNCounter[49]) fprintf(stderr, "Warning: No xray could reach Component[49] PoreArm44\n");
    if (mcAbsorbProp[49]) fprintf(stderr, "Warning: %g events were removed in Component[49] PoreArm44=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[49]);
    if (!mcNCounter[50]) fprintf(stderr, "Warning: No xray could reach Component[50] PoreArm45\n");
    if (mcAbsorbProp[50]) fprintf(stderr, "Warning: %g events were removed in Component[50] PoreArm45=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[50]);
    if (!mcNCounter[51]) fprintf(stderr, "Warning: No xray could reach Component[51] PoreArm46\n");
    if (mcAbsorbProp[51]) fprintf(stderr, "Warning: %g events were removed in Component[51] PoreArm46=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[51]);
    if (!mcNCounter[52]) fprintf(stderr, "Warning: No xray could reach Component[52] PoreArm47\n");
    if (mcAbsorbProp[52]) fprintf(stderr, "Warning: %g events were removed in Component[52] PoreArm47=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[52]);
    if (!mcNCounter[53]) fprintf(stderr, "Warning: No xray could reach Component[53] PoreArm48\n");
    if (mcAbsorbProp[53]) fprintf(stderr, "Warning: %g events were removed in Component[53] PoreArm48=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[53]);
    if (!mcNCounter[54]) fprintf(stderr, "Warning: No xray could reach Component[54] PoreP0\n");
    if (mcAbsorbProp[54]) fprintf(stderr, "Warning: %g events were removed in Component[54] PoreP0=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[54]);
    if (!mcNCounter[55]) fprintf(stderr, "Warning: No xray could reach Component[55] PoreP1\n");
    if (mcAbsorbProp[55]) fprintf(stderr, "Warning: %g events were removed in Component[55] PoreP1=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[55]);
    if (!mcNCounter[56]) fprintf(stderr, "Warning: No xray could reach Component[56] PoreP2\n");
    if (mcAbsorbProp[56]) fprintf(stderr, "Warning: %g events were removed in Component[56] PoreP2=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[56]);
    if (!mcNCounter[57]) fprintf(stderr, "Warning: No xray could reach Component[57] PoreP3\n");
    if (mcAbsorbProp[57]) fprintf(stderr, "Warning: %g events were removed in Component[57] PoreP3=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[57]);
    if (!mcNCounter[58]) fprintf(stderr, "Warning: No xray could reach Component[58] PoreP4\n");
    if (mcAbsorbProp[58]) fprintf(stderr, "Warning: %g events were removed in Component[58] PoreP4=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[58]);
    if (!mcNCounter[59]) fprintf(stderr, "Warning: No xray could reach Component[59] PoreP5\n");
    if (mcAbsorbProp[59]) fprintf(stderr, "Warning: %g events were removed in Component[59] PoreP5=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[59]);
    if (!mcNCounter[60]) fprintf(stderr, "Warning: No xray could reach Component[60] PoreP6\n");
    if (mcAbsorbProp[60]) fprintf(stderr, "Warning: %g events were removed in Component[60] PoreP6=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[60]);
    if (!mcNCounter[61]) fprintf(stderr, "Warning: No xray could reach Component[61] PoreP7\n");
    if (mcAbsorbProp[61]) fprintf(stderr, "Warning: %g events were removed in Component[61] PoreP7=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[61]);
    if (!mcNCounter[62]) fprintf(stderr, "Warning: No xray could reach Component[62] PoreP8\n");
    if (mcAbsorbProp[62]) fprintf(stderr, "Warning: %g events were removed in Component[62] PoreP8=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[62]);
    if (!mcNCounter[63]) fprintf(stderr, "Warning: No xray could reach Component[63] PoreP9\n");
    if (mcAbsorbProp[63]) fprintf(stderr, "Warning: %g events were removed in Component[63] PoreP9=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[63]);
    if (!mcNCounter[64]) fprintf(stderr, "Warning: No xray could reach Component[64] PoreP10\n");
    if (mcAbsorbProp[64]) fprintf(stderr, "Warning: %g events were removed in Component[64] PoreP10=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[64]);
    if (!mcNCounter[65]) fprintf(stderr, "Warning: No xray could reach Component[65] PoreP11\n");
    if (mcAbsorbProp[65]) fprintf(stderr, "Warning: %g events were removed in Component[65] PoreP11=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[65]);
    if (!mcNCounter[66]) fprintf(stderr, "Warning: No xray could reach Component[66] PoreP12\n");
    if (mcAbsorbProp[66]) fprintf(stderr, "Warning: %g events were removed in Component[66] PoreP12=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[66]);
    if (!mcNCounter[67]) fprintf(stderr, "Warning: No xray could reach Component[67] PoreP13\n");
    if (mcAbsorbProp[67]) fprintf(stderr, "Warning: %g events were removed in Component[67] PoreP13=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[67]);
    if (!mcNCounter[68]) fprintf(stderr, "Warning: No xray could reach Component[68] PoreP14\n");
    if (mcAbsorbProp[68]) fprintf(stderr, "Warning: %g events were removed in Component[68] PoreP14=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[68]);
    if (!mcNCounter[69]) fprintf(stderr, "Warning: No xray could reach Component[69] PoreP15\n");
    if (mcAbsorbProp[69]) fprintf(stderr, "Warning: %g events were removed in Component[69] PoreP15=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[69]);
    if (!mcNCounter[70]) fprintf(stderr, "Warning: No xray could reach Component[70] PoreP16\n");
    if (mcAbsorbProp[70]) fprintf(stderr, "Warning: %g events were removed in Component[70] PoreP16=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[70]);
    if (!mcNCounter[71]) fprintf(stderr, "Warning: No xray could reach Component[71] PoreP17\n");
    if (mcAbsorbProp[71]) fprintf(stderr, "Warning: %g events were removed in Component[71] PoreP17=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[71]);
    if (!mcNCounter[72]) fprintf(stderr, "Warning: No xray could reach Component[72] PoreP18\n");
    if (mcAbsorbProp[72]) fprintf(stderr, "Warning: %g events were removed in Component[72] PoreP18=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[72]);
    if (!mcNCounter[73]) fprintf(stderr, "Warning: No xray could reach Component[73] PoreP19\n");
    if (mcAbsorbProp[73]) fprintf(stderr, "Warning: %g events were removed in Component[73] PoreP19=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[73]);
    if (!mcNCounter[74]) fprintf(stderr, "Warning: No xray could reach Component[74] PoreP20\n");
    if (mcAbsorbProp[74]) fprintf(stderr, "Warning: %g events were removed in Component[74] PoreP20=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[74]);
    if (!mcNCounter[75]) fprintf(stderr, "Warning: No xray could reach Component[75] PoreP21\n");
    if (mcAbsorbProp[75]) fprintf(stderr, "Warning: %g events were removed in Component[75] PoreP21=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[75]);
    if (!mcNCounter[76]) fprintf(stderr, "Warning: No xray could reach Component[76] PoreP22\n");
    if (mcAbsorbProp[76]) fprintf(stderr, "Warning: %g events were removed in Component[76] PoreP22=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[76]);
    if (!mcNCounter[77]) fprintf(stderr, "Warning: No xray could reach Component[77] PoreP23\n");
    if (mcAbsorbProp[77]) fprintf(stderr, "Warning: %g events were removed in Component[77] PoreP23=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[77]);
    if (!mcNCounter[78]) fprintf(stderr, "Warning: No xray could reach Component[78] PoreP24\n");
    if (mcAbsorbProp[78]) fprintf(stderr, "Warning: %g events were removed in Component[78] PoreP24=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[78]);
    if (!mcNCounter[79]) fprintf(stderr, "Warning: No xray could reach Component[79] PoreP25\n");
    if (mcAbsorbProp[79]) fprintf(stderr, "Warning: %g events were removed in Component[79] PoreP25=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[79]);
    if (!mcNCounter[80]) fprintf(stderr, "Warning: No xray could reach Component[80] PoreP26\n");
    if (mcAbsorbProp[80]) fprintf(stderr, "Warning: %g events were removed in Component[80] PoreP26=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[80]);
    if (!mcNCounter[81]) fprintf(stderr, "Warning: No xray could reach Component[81] PoreP27\n");
    if (mcAbsorbProp[81]) fprintf(stderr, "Warning: %g events were removed in Component[81] PoreP27=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[81]);
    if (!mcNCounter[82]) fprintf(stderr, "Warning: No xray could reach Component[82] PoreP28\n");
    if (mcAbsorbProp[82]) fprintf(stderr, "Warning: %g events were removed in Component[82] PoreP28=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[82]);
    if (!mcNCounter[83]) fprintf(stderr, "Warning: No xray could reach Component[83] PoreP29\n");
    if (mcAbsorbProp[83]) fprintf(stderr, "Warning: %g events were removed in Component[83] PoreP29=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[83]);
    if (!mcNCounter[84]) fprintf(stderr, "Warning: No xray could reach Component[84] PoreP30\n");
    if (mcAbsorbProp[84]) fprintf(stderr, "Warning: %g events were removed in Component[84] PoreP30=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[84]);
    if (!mcNCounter[85]) fprintf(stderr, "Warning: No xray could reach Component[85] PoreP31\n");
    if (mcAbsorbProp[85]) fprintf(stderr, "Warning: %g events were removed in Component[85] PoreP31=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[85]);
    if (!mcNCounter[86]) fprintf(stderr, "Warning: No xray could reach Component[86] PoreP32\n");
    if (mcAbsorbProp[86]) fprintf(stderr, "Warning: %g events were removed in Component[86] PoreP32=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[86]);
    if (!mcNCounter[87]) fprintf(stderr, "Warning: No xray could reach Component[87] PoreP33\n");
    if (mcAbsorbProp[87]) fprintf(stderr, "Warning: %g events were removed in Component[87] PoreP33=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[87]);
    if (!mcNCounter[88]) fprintf(stderr, "Warning: No xray could reach Component[88] PoreP34\n");
    if (mcAbsorbProp[88]) fprintf(stderr, "Warning: %g events were removed in Component[88] PoreP34=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[88]);
    if (!mcNCounter[89]) fprintf(stderr, "Warning: No xray could reach Component[89] PoreP35\n");
    if (mcAbsorbProp[89]) fprintf(stderr, "Warning: %g events were removed in Component[89] PoreP35=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[89]);
    if (!mcNCounter[90]) fprintf(stderr, "Warning: No xray could reach Component[90] PoreP36\n");
    if (mcAbsorbProp[90]) fprintf(stderr, "Warning: %g events were removed in Component[90] PoreP36=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[90]);
    if (!mcNCounter[91]) fprintf(stderr, "Warning: No xray could reach Component[91] PoreP37\n");
    if (mcAbsorbProp[91]) fprintf(stderr, "Warning: %g events were removed in Component[91] PoreP37=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[91]);
    if (!mcNCounter[92]) fprintf(stderr, "Warning: No xray could reach Component[92] PoreP38\n");
    if (mcAbsorbProp[92]) fprintf(stderr, "Warning: %g events were removed in Component[92] PoreP38=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[92]);
    if (!mcNCounter[93]) fprintf(stderr, "Warning: No xray could reach Component[93] PoreP39\n");
    if (mcAbsorbProp[93]) fprintf(stderr, "Warning: %g events were removed in Component[93] PoreP39=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[93]);
    if (!mcNCounter[94]) fprintf(stderr, "Warning: No xray could reach Component[94] PoreP40\n");
    if (mcAbsorbProp[94]) fprintf(stderr, "Warning: %g events were removed in Component[94] PoreP40=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[94]);
    if (!mcNCounter[95]) fprintf(stderr, "Warning: No xray could reach Component[95] PoreP41\n");
    if (mcAbsorbProp[95]) fprintf(stderr, "Warning: %g events were removed in Component[95] PoreP41=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[95]);
    if (!mcNCounter[96]) fprintf(stderr, "Warning: No xray could reach Component[96] PoreP42\n");
    if (mcAbsorbProp[96]) fprintf(stderr, "Warning: %g events were removed in Component[96] PoreP42=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[96]);
    if (!mcNCounter[97]) fprintf(stderr, "Warning: No xray could reach Component[97] PoreP43\n");
    if (mcAbsorbProp[97]) fprintf(stderr, "Warning: %g events were removed in Component[97] PoreP43=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[97]);
    if (!mcNCounter[98]) fprintf(stderr, "Warning: No xray could reach Component[98] PoreP44\n");
    if (mcAbsorbProp[98]) fprintf(stderr, "Warning: %g events were removed in Component[98] PoreP44=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[98]);
    if (!mcNCounter[99]) fprintf(stderr, "Warning: No xray could reach Component[99] PoreP45\n");
    if (mcAbsorbProp[99]) fprintf(stderr, "Warning: %g events were removed in Component[99] PoreP45=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[99]);
    if (!mcNCounter[100]) fprintf(stderr, "Warning: No xray could reach Component[100] PoreP46\n");
    if (mcAbsorbProp[100]) fprintf(stderr, "Warning: %g events were removed in Component[100] PoreP46=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[100]);
    if (!mcNCounter[101]) fprintf(stderr, "Warning: No xray could reach Component[101] PoreP47\n");
    if (mcAbsorbProp[101]) fprintf(stderr, "Warning: %g events were removed in Component[101] PoreP47=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[101]);
    if (!mcNCounter[102]) fprintf(stderr, "Warning: No xray could reach Component[102] PoreP48\n");
    if (mcAbsorbProp[102]) fprintf(stderr, "Warning: %g events were removed in Component[102] PoreP48=Pore_p_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[102]);
    if (!mcNCounter[103]) fprintf(stderr, "Warning: No xray could reach Component[103] PoreH0\n");
    if (mcAbsorbProp[103]) fprintf(stderr, "Warning: %g events were removed in Component[103] PoreH0=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[103]);
    if (!mcNCounter[104]) fprintf(stderr, "Warning: No xray could reach Component[104] PoreH1\n");
    if (mcAbsorbProp[104]) fprintf(stderr, "Warning: %g events were removed in Component[104] PoreH1=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[104]);
    if (!mcNCounter[105]) fprintf(stderr, "Warning: No xray could reach Component[105] PoreH2\n");
    if (mcAbsorbProp[105]) fprintf(stderr, "Warning: %g events were removed in Component[105] PoreH2=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[105]);
    if (!mcNCounter[106]) fprintf(stderr, "Warning: No xray could reach Component[106] PoreH3\n");
    if (mcAbsorbProp[106]) fprintf(stderr, "Warning: %g events were removed in Component[106] PoreH3=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[106]);
    if (!mcNCounter[107]) fprintf(stderr, "Warning: No xray could reach Component[107] PoreH4\n");
    if (mcAbsorbProp[107]) fprintf(stderr, "Warning: %g events were removed in Component[107] PoreH4=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[107]);
    if (!mcNCounter[108]) fprintf(stderr, "Warning: No xray could reach Component[108] PoreH5\n");
    if (mcAbsorbProp[108]) fprintf(stderr, "Warning: %g events were removed in Component[108] PoreH5=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[108]);
    if (!mcNCounter[109]) fprintf(stderr, "Warning: No xray could reach Component[109] PoreH6\n");
    if (mcAbsorbProp[109]) fprintf(stderr, "Warning: %g events were removed in Component[109] PoreH6=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[109]);
    if (!mcNCounter[110]) fprintf(stderr, "Warning: No xray could reach Component[110] PoreH7\n");
    if (mcAbsorbProp[110]) fprintf(stderr, "Warning: %g events were removed in Component[110] PoreH7=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[110]);
    if (!mcNCounter[111]) fprintf(stderr, "Warning: No xray could reach Component[111] PoreH8\n");
    if (mcAbsorbProp[111]) fprintf(stderr, "Warning: %g events were removed in Component[111] PoreH8=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[111]);
    if (!mcNCounter[112]) fprintf(stderr, "Warning: No xray could reach Component[112] PoreH9\n");
    if (mcAbsorbProp[112]) fprintf(stderr, "Warning: %g events were removed in Component[112] PoreH9=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[112]);
    if (!mcNCounter[113]) fprintf(stderr, "Warning: No xray could reach Component[113] PoreH10\n");
    if (mcAbsorbProp[113]) fprintf(stderr, "Warning: %g events were removed in Component[113] PoreH10=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[113]);
    if (!mcNCounter[114]) fprintf(stderr, "Warning: No xray could reach Component[114] PoreH11\n");
    if (mcAbsorbProp[114]) fprintf(stderr, "Warning: %g events were removed in Component[114] PoreH11=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[114]);
    if (!mcNCounter[115]) fprintf(stderr, "Warning: No xray could reach Component[115] PoreH12\n");
    if (mcAbsorbProp[115]) fprintf(stderr, "Warning: %g events were removed in Component[115] PoreH12=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[115]);
    if (!mcNCounter[116]) fprintf(stderr, "Warning: No xray could reach Component[116] PoreH13\n");
    if (mcAbsorbProp[116]) fprintf(stderr, "Warning: %g events were removed in Component[116] PoreH13=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[116]);
    if (!mcNCounter[117]) fprintf(stderr, "Warning: No xray could reach Component[117] PoreH14\n");
    if (mcAbsorbProp[117]) fprintf(stderr, "Warning: %g events were removed in Component[117] PoreH14=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[117]);
    if (!mcNCounter[118]) fprintf(stderr, "Warning: No xray could reach Component[118] PoreH15\n");
    if (mcAbsorbProp[118]) fprintf(stderr, "Warning: %g events were removed in Component[118] PoreH15=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[118]);
    if (!mcNCounter[119]) fprintf(stderr, "Warning: No xray could reach Component[119] PoreH16\n");
    if (mcAbsorbProp[119]) fprintf(stderr, "Warning: %g events were removed in Component[119] PoreH16=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[119]);
    if (!mcNCounter[120]) fprintf(stderr, "Warning: No xray could reach Component[120] PoreH17\n");
    if (mcAbsorbProp[120]) fprintf(stderr, "Warning: %g events were removed in Component[120] PoreH17=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[120]);
    if (!mcNCounter[121]) fprintf(stderr, "Warning: No xray could reach Component[121] PoreH18\n");
    if (mcAbsorbProp[121]) fprintf(stderr, "Warning: %g events were removed in Component[121] PoreH18=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[121]);
    if (!mcNCounter[122]) fprintf(stderr, "Warning: No xray could reach Component[122] PoreH19\n");
    if (mcAbsorbProp[122]) fprintf(stderr, "Warning: %g events were removed in Component[122] PoreH19=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[122]);
    if (!mcNCounter[123]) fprintf(stderr, "Warning: No xray could reach Component[123] PoreH20\n");
    if (mcAbsorbProp[123]) fprintf(stderr, "Warning: %g events were removed in Component[123] PoreH20=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[123]);
    if (!mcNCounter[124]) fprintf(stderr, "Warning: No xray could reach Component[124] PoreH21\n");
    if (mcAbsorbProp[124]) fprintf(stderr, "Warning: %g events were removed in Component[124] PoreH21=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[124]);
    if (!mcNCounter[125]) fprintf(stderr, "Warning: No xray could reach Component[125] PoreH22\n");
    if (mcAbsorbProp[125]) fprintf(stderr, "Warning: %g events were removed in Component[125] PoreH22=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[125]);
    if (!mcNCounter[126]) fprintf(stderr, "Warning: No xray could reach Component[126] PoreH23\n");
    if (mcAbsorbProp[126]) fprintf(stderr, "Warning: %g events were removed in Component[126] PoreH23=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[126]);
    if (!mcNCounter[127]) fprintf(stderr, "Warning: No xray could reach Component[127] PoreH24\n");
    if (mcAbsorbProp[127]) fprintf(stderr, "Warning: %g events were removed in Component[127] PoreH24=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[127]);
    if (!mcNCounter[128]) fprintf(stderr, "Warning: No xray could reach Component[128] PoreH25\n");
    if (mcAbsorbProp[128]) fprintf(stderr, "Warning: %g events were removed in Component[128] PoreH25=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[128]);
    if (!mcNCounter[129]) fprintf(stderr, "Warning: No xray could reach Component[129] PoreH26\n");
    if (mcAbsorbProp[129]) fprintf(stderr, "Warning: %g events were removed in Component[129] PoreH26=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[129]);
    if (!mcNCounter[130]) fprintf(stderr, "Warning: No xray could reach Component[130] PoreH27\n");
    if (mcAbsorbProp[130]) fprintf(stderr, "Warning: %g events were removed in Component[130] PoreH27=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[130]);
    if (!mcNCounter[131]) fprintf(stderr, "Warning: No xray could reach Component[131] PoreH28\n");
    if (mcAbsorbProp[131]) fprintf(stderr, "Warning: %g events were removed in Component[131] PoreH28=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[131]);
    if (!mcNCounter[132]) fprintf(stderr, "Warning: No xray could reach Component[132] PoreH29\n");
    if (mcAbsorbProp[132]) fprintf(stderr, "Warning: %g events were removed in Component[132] PoreH29=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[132]);
    if (!mcNCounter[133]) fprintf(stderr, "Warning: No xray could reach Component[133] PoreH30\n");
    if (mcAbsorbProp[133]) fprintf(stderr, "Warning: %g events were removed in Component[133] PoreH30=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[133]);
    if (!mcNCounter[134]) fprintf(stderr, "Warning: No xray could reach Component[134] PoreH31\n");
    if (mcAbsorbProp[134]) fprintf(stderr, "Warning: %g events were removed in Component[134] PoreH31=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[134]);
    if (!mcNCounter[135]) fprintf(stderr, "Warning: No xray could reach Component[135] PoreH32\n");
    if (mcAbsorbProp[135]) fprintf(stderr, "Warning: %g events were removed in Component[135] PoreH32=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[135]);
    if (!mcNCounter[136]) fprintf(stderr, "Warning: No xray could reach Component[136] PoreH33\n");
    if (mcAbsorbProp[136]) fprintf(stderr, "Warning: %g events were removed in Component[136] PoreH33=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[136]);
    if (!mcNCounter[137]) fprintf(stderr, "Warning: No xray could reach Component[137] PoreH34\n");
    if (mcAbsorbProp[137]) fprintf(stderr, "Warning: %g events were removed in Component[137] PoreH34=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[137]);
    if (!mcNCounter[138]) fprintf(stderr, "Warning: No xray could reach Component[138] PoreH35\n");
    if (mcAbsorbProp[138]) fprintf(stderr, "Warning: %g events were removed in Component[138] PoreH35=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[138]);
    if (!mcNCounter[139]) fprintf(stderr, "Warning: No xray could reach Component[139] PoreH36\n");
    if (mcAbsorbProp[139]) fprintf(stderr, "Warning: %g events were removed in Component[139] PoreH36=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[139]);
    if (!mcNCounter[140]) fprintf(stderr, "Warning: No xray could reach Component[140] PoreH37\n");
    if (mcAbsorbProp[140]) fprintf(stderr, "Warning: %g events were removed in Component[140] PoreH37=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[140]);
    if (!mcNCounter[141]) fprintf(stderr, "Warning: No xray could reach Component[141] PoreH38\n");
    if (mcAbsorbProp[141]) fprintf(stderr, "Warning: %g events were removed in Component[141] PoreH38=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[141]);
    if (!mcNCounter[142]) fprintf(stderr, "Warning: No xray could reach Component[142] PoreH39\n");
    if (mcAbsorbProp[142]) fprintf(stderr, "Warning: %g events were removed in Component[142] PoreH39=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[142]);
    if (!mcNCounter[143]) fprintf(stderr, "Warning: No xray could reach Component[143] PoreH40\n");
    if (mcAbsorbProp[143]) fprintf(stderr, "Warning: %g events were removed in Component[143] PoreH40=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[143]);
    if (!mcNCounter[144]) fprintf(stderr, "Warning: No xray could reach Component[144] PoreH41\n");
    if (mcAbsorbProp[144]) fprintf(stderr, "Warning: %g events were removed in Component[144] PoreH41=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[144]);
    if (!mcNCounter[145]) fprintf(stderr, "Warning: No xray could reach Component[145] PoreH42\n");
    if (mcAbsorbProp[145]) fprintf(stderr, "Warning: %g events were removed in Component[145] PoreH42=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[145]);
    if (!mcNCounter[146]) fprintf(stderr, "Warning: No xray could reach Component[146] PoreH43\n");
    if (mcAbsorbProp[146]) fprintf(stderr, "Warning: %g events were removed in Component[146] PoreH43=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[146]);
    if (!mcNCounter[147]) fprintf(stderr, "Warning: No xray could reach Component[147] PoreH44\n");
    if (mcAbsorbProp[147]) fprintf(stderr, "Warning: %g events were removed in Component[147] PoreH44=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[147]);
    if (!mcNCounter[148]) fprintf(stderr, "Warning: No xray could reach Component[148] PoreH45\n");
    if (mcAbsorbProp[148]) fprintf(stderr, "Warning: %g events were removed in Component[148] PoreH45=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[148]);
    if (!mcNCounter[149]) fprintf(stderr, "Warning: No xray could reach Component[149] PoreH46\n");
    if (mcAbsorbProp[149]) fprintf(stderr, "Warning: %g events were removed in Component[149] PoreH46=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[149]);
    if (!mcNCounter[150]) fprintf(stderr, "Warning: No xray could reach Component[150] PoreH47\n");
    if (mcAbsorbProp[150]) fprintf(stderr, "Warning: %g events were removed in Component[150] PoreH47=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[150]);
    if (!mcNCounter[151]) fprintf(stderr, "Warning: No xray could reach Component[151] PoreH48\n");
    if (mcAbsorbProp[151]) fprintf(stderr, "Warning: %g events were removed in Component[151] PoreH48=Pore_h_group()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[151]);
  /* User FINALLY code for component 'monitorAfter'. */
  SIG_MESSAGE("monitorAfter (Finally)");
#define mccompcurname  monitorAfter
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 152
#define nx mccmonitorAfter_nx
#define ny mccmonitorAfter_ny
#define nr mccmonitorAfter_nr
#define filename mccmonitorAfter_filename
#define restore_xray mccmonitorAfter_restore_xray
#define PSD_N mccmonitorAfter_PSD_N
#define PSD_p mccmonitorAfter_PSD_p
#define PSD_p2 mccmonitorAfter_PSD_p2
#define posx mccmonitorAfter_posx
#define posy mccmonitorAfter_posy
{   /* Declarations of monitorAfter=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccmonitorAfter_xmin;
MCNUM xmax = mccmonitorAfter_xmax;
MCNUM ymin = mccmonitorAfter_ymin;
MCNUM ymax = mccmonitorAfter_ymax;
MCNUM xwidth = mccmonitorAfter_xwidth;
MCNUM yheight = mccmonitorAfter_yheight;
MCNUM radius = mccmonitorAfter_radius;
#line 159 "PSD_monitor_ext.comp"
{
   free(PSD_N[0]);
   free(PSD_N);
   free(PSD_p[0]);
   free(PSD_p);
   free(PSD_p2[0]);
   free(PSD_p2);
}
#line 76534 "instruments/plate49.c"
}   /* End of monitorAfter=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[152]) fprintf(stderr, "Warning: No xray could reach Component[152] monitorAfter\n");
    if (mcAbsorbProp[152]) fprintf(stderr, "Warning: %g events were removed in Component[152] monitorAfter=PSD_monitor_ext()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[152]);
  /* User FINALLY code for component 'endMonitorWide'. */
  SIG_MESSAGE("endMonitorWide (Finally)");
#define mccompcurname  endMonitorWide
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 153
#define nx mccendMonitorWide_nx
#define ny mccendMonitorWide_ny
#define nr mccendMonitorWide_nr
#define filename mccendMonitorWide_filename
#define restore_xray mccendMonitorWide_restore_xray
#define PSD_N mccendMonitorWide_PSD_N
#define PSD_p mccendMonitorWide_PSD_p
#define PSD_p2 mccendMonitorWide_PSD_p2
#define posx mccendMonitorWide_posx
#define posy mccendMonitorWide_posy
{   /* Declarations of endMonitorWide=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccendMonitorWide_xmin;
MCNUM xmax = mccendMonitorWide_xmax;
MCNUM ymin = mccendMonitorWide_ymin;
MCNUM ymax = mccendMonitorWide_ymax;
MCNUM xwidth = mccendMonitorWide_xwidth;
MCNUM yheight = mccendMonitorWide_yheight;
MCNUM radius = mccendMonitorWide_radius;
#line 159 "PSD_monitor_ext.comp"
{
   free(PSD_N[0]);
   free(PSD_N);
   free(PSD_p[0]);
   free(PSD_p);
   free(PSD_p2[0]);
   free(PSD_p2);
}
#line 76584 "instruments/plate49.c"
}   /* End of endMonitorWide=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[153]) fprintf(stderr, "Warning: No xray could reach Component[153] endMonitorWide\n");
    if (mcAbsorbProp[153]) fprintf(stderr, "Warning: %g events were removed in Component[153] endMonitorWide=PSD_monitor_ext()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[153]);
  /* User FINALLY code from instrument definition. */
  SIG_MESSAGE("AthenaModule (Finally)");
#define mccompcurname  AthenaModule
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaAthenaModule coords_set(0,0,0)
#define module_nr mcipmodule_nr
#define plate_nr mcipplate_nr
#define energy mcipenergy
#define source_type mcipsource_type
#define source_th mcipsource_th
#define source_dx mcipsource_dx
#define source_dy mcipsource_dy
#define absorb_sides mcipabsorb_sides
#define absorb_bottom mcipabsorb_bottom
#define output_filename mcipoutput_filename
#line 1856 "instruments/plate49.instr"
{
    photonCount++;

    double sourceFlux = photonCount/srcW/srcH;

    bufferAddRunInfo(photonCount, photonPassedThrough, photonPassedThroughWeighted, sourceFlux, radiusM);
    bufferEndOfRun();

    char fn[256];
    sprintf(fn, "%s.dat", output_filename);

    FILE *fp = fopen(fn, "a");
    // showBufferHead();
    bufferWriteAndReset(fp);
    fflush(fp);
    fclose(fp);
}
#line 76636 "instruments/plate49.c"
#undef output_filename
#undef absorb_bottom
#undef absorb_sides
#undef source_dy
#undef source_dx
#undef source_th
#undef source_type
#undef energy
#undef plate_nr
#undef module_nr
#undef mcposaAthenaModule
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname

  mcsiminfo_close(); 
} /* end finally */
#define magnify mcdis_magnify
#define line mcdis_line
#define dashed_line mcdis_dashed_line
#define multiline mcdis_multiline
#define rectangle mcdis_rectangle
#define box mcdis_box
#define circle mcdis_circle
void mcdisplay(void) {
  printf("MCDISPLAY: start\n");
  /* Components MCDISPLAY code. */

  /* MCDISPLAY code for component 'ThetaArm'. */
  SIG_MESSAGE("ThetaArm (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ThetaArm");
#define mccompcurname  ThetaArm
#define mccompcurtype  Arm
#define mccompcurindex 2
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76679 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'srcDirectional'. */
  SIG_MESSAGE("srcDirectional (McDisplay)");
  printf("MCDISPLAY: component %s\n", "srcDirectional");
#define mccompcurname  srcDirectional
#define mccompcurtype  Source_div
#define mccompcurindex 3
#define spectrum_file mccsrcDirectional_spectrum_file
#define prms mccsrcDirectional_prms
#define p_init mccsrcDirectional_p_init
#define dist mccsrcDirectional_dist
{   /* Declarations of srcDirectional=Source_div() SETTING parameters. */
MCNUM xwidth = mccsrcDirectional_xwidth;
MCNUM yheight = mccsrcDirectional_yheight;
MCNUM focus_aw = mccsrcDirectional_focus_aw;
MCNUM focus_ah = mccsrcDirectional_focus_ah;
MCNUM E0 = mccsrcDirectional_E0;
MCNUM dE = mccsrcDirectional_dE;
MCNUM lambda0 = mccsrcDirectional_lambda0;
MCNUM dlambda = mccsrcDirectional_dlambda;
MCNUM flux = mccsrcDirectional_flux;
MCNUM gauss = mccsrcDirectional_gauss;
MCNUM gauss_a = mccsrcDirectional_gauss_a;
MCNUM randomphase = mccsrcDirectional_randomphase;
MCNUM phase = mccsrcDirectional_phase;
#line 188 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
{
  magnify("xy");
  double dist=1;
  multiline(5, -xwidth/2.0, -yheight/2.0, 0.0,
                xwidth/2.0, -yheight/2.0, 0.0,
                xwidth/2.0,  yheight/2.0, 0.0,
               -xwidth/2.0,  yheight/2.0, 0.0,
               -xwidth/2.0, -yheight/2.0, 0.0);
  if (focus_aw){
    dashed_line(0,0,0, tan(focus_aw/2.0)*dist,0,dist,4);
    dashed_line(0,0,0,-tan(focus_aw/2.0)*dist,0,dist,4);
  }
  if (focus_ah){
    dashed_line(0,0,0,0, tan(focus_ah/2.0)*dist,dist,4);
    dashed_line(0,0,0,0,-tan(focus_ah/2.0)*dist,dist,4);
  }
}
#line 76726 "instruments/plate49.c"
}   /* End of srcDirectional=Source_div() SETTING parameter declarations. */
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'srcDirectionalWide'. */
  SIG_MESSAGE("srcDirectionalWide (McDisplay)");
  printf("MCDISPLAY: component %s\n", "srcDirectionalWide");
#define mccompcurname  srcDirectionalWide
#define mccompcurtype  Source_div
#define mccompcurindex 4
#define spectrum_file mccsrcDirectionalWide_spectrum_file
#define prms mccsrcDirectionalWide_prms
#define p_init mccsrcDirectionalWide_p_init
#define dist mccsrcDirectionalWide_dist
{   /* Declarations of srcDirectionalWide=Source_div() SETTING parameters. */
MCNUM xwidth = mccsrcDirectionalWide_xwidth;
MCNUM yheight = mccsrcDirectionalWide_yheight;
MCNUM focus_aw = mccsrcDirectionalWide_focus_aw;
MCNUM focus_ah = mccsrcDirectionalWide_focus_ah;
MCNUM E0 = mccsrcDirectionalWide_E0;
MCNUM dE = mccsrcDirectionalWide_dE;
MCNUM lambda0 = mccsrcDirectionalWide_lambda0;
MCNUM dlambda = mccsrcDirectionalWide_dlambda;
MCNUM flux = mccsrcDirectionalWide_flux;
MCNUM gauss = mccsrcDirectionalWide_gauss;
MCNUM gauss_a = mccsrcDirectionalWide_gauss_a;
MCNUM randomphase = mccsrcDirectionalWide_randomphase;
MCNUM phase = mccsrcDirectionalWide_phase;
#line 188 "/usr/share/mcxtrace/1.4/sources/Source_div.comp"
{
  magnify("xy");
  double dist=1;
  multiline(5, -xwidth/2.0, -yheight/2.0, 0.0,
                xwidth/2.0, -yheight/2.0, 0.0,
                xwidth/2.0,  yheight/2.0, 0.0,
               -xwidth/2.0,  yheight/2.0, 0.0,
               -xwidth/2.0, -yheight/2.0, 0.0);
  if (focus_aw){
    dashed_line(0,0,0, tan(focus_aw/2.0)*dist,0,dist,4);
    dashed_line(0,0,0,-tan(focus_aw/2.0)*dist,0,dist,4);
  }
  if (focus_ah){
    dashed_line(0,0,0,0, tan(focus_ah/2.0)*dist,dist,4);
    dashed_line(0,0,0,0,-tan(focus_ah/2.0)*dist,dist,4);
  }
}
#line 76778 "instruments/plate49.c"
}   /* End of srcDirectionalWide=Source_div() SETTING parameter declarations. */
#undef dist
#undef p_init
#undef prms
#undef spectrum_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm0'. */
  SIG_MESSAGE("PoreArm0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm0");
#define mccompcurname  PoreArm0
#define mccompcurtype  Arm
#define mccompcurindex 5
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76802 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm1'. */
  SIG_MESSAGE("PoreArm1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm1");
#define mccompcurname  PoreArm1
#define mccompcurtype  Arm
#define mccompcurindex 6
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76821 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm2'. */
  SIG_MESSAGE("PoreArm2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm2");
#define mccompcurname  PoreArm2
#define mccompcurtype  Arm
#define mccompcurindex 7
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76840 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm3'. */
  SIG_MESSAGE("PoreArm3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm3");
#define mccompcurname  PoreArm3
#define mccompcurtype  Arm
#define mccompcurindex 8
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76859 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm4'. */
  SIG_MESSAGE("PoreArm4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm4");
#define mccompcurname  PoreArm4
#define mccompcurtype  Arm
#define mccompcurindex 9
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76878 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm5'. */
  SIG_MESSAGE("PoreArm5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm5");
#define mccompcurname  PoreArm5
#define mccompcurtype  Arm
#define mccompcurindex 10
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76897 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm6'. */
  SIG_MESSAGE("PoreArm6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm6");
#define mccompcurname  PoreArm6
#define mccompcurtype  Arm
#define mccompcurindex 11
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76916 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm7'. */
  SIG_MESSAGE("PoreArm7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm7");
#define mccompcurname  PoreArm7
#define mccompcurtype  Arm
#define mccompcurindex 12
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76935 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm8'. */
  SIG_MESSAGE("PoreArm8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm8");
#define mccompcurname  PoreArm8
#define mccompcurtype  Arm
#define mccompcurindex 13
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76954 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm9'. */
  SIG_MESSAGE("PoreArm9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm9");
#define mccompcurname  PoreArm9
#define mccompcurtype  Arm
#define mccompcurindex 14
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76973 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm10'. */
  SIG_MESSAGE("PoreArm10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm10");
#define mccompcurname  PoreArm10
#define mccompcurtype  Arm
#define mccompcurindex 15
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 76992 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm11'. */
  SIG_MESSAGE("PoreArm11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm11");
#define mccompcurname  PoreArm11
#define mccompcurtype  Arm
#define mccompcurindex 16
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77011 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm12'. */
  SIG_MESSAGE("PoreArm12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm12");
#define mccompcurname  PoreArm12
#define mccompcurtype  Arm
#define mccompcurindex 17
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77030 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm13'. */
  SIG_MESSAGE("PoreArm13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm13");
#define mccompcurname  PoreArm13
#define mccompcurtype  Arm
#define mccompcurindex 18
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77049 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm14'. */
  SIG_MESSAGE("PoreArm14 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm14");
#define mccompcurname  PoreArm14
#define mccompcurtype  Arm
#define mccompcurindex 19
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77068 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm15'. */
  SIG_MESSAGE("PoreArm15 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm15");
#define mccompcurname  PoreArm15
#define mccompcurtype  Arm
#define mccompcurindex 20
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77087 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm16'. */
  SIG_MESSAGE("PoreArm16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm16");
#define mccompcurname  PoreArm16
#define mccompcurtype  Arm
#define mccompcurindex 21
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77106 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm17'. */
  SIG_MESSAGE("PoreArm17 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm17");
#define mccompcurname  PoreArm17
#define mccompcurtype  Arm
#define mccompcurindex 22
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77125 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm18'. */
  SIG_MESSAGE("PoreArm18 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm18");
#define mccompcurname  PoreArm18
#define mccompcurtype  Arm
#define mccompcurindex 23
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77144 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm19'. */
  SIG_MESSAGE("PoreArm19 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm19");
#define mccompcurname  PoreArm19
#define mccompcurtype  Arm
#define mccompcurindex 24
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77163 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm20'. */
  SIG_MESSAGE("PoreArm20 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm20");
#define mccompcurname  PoreArm20
#define mccompcurtype  Arm
#define mccompcurindex 25
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77182 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm21'. */
  SIG_MESSAGE("PoreArm21 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm21");
#define mccompcurname  PoreArm21
#define mccompcurtype  Arm
#define mccompcurindex 26
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77201 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm22'. */
  SIG_MESSAGE("PoreArm22 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm22");
#define mccompcurname  PoreArm22
#define mccompcurtype  Arm
#define mccompcurindex 27
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77220 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm23'. */
  SIG_MESSAGE("PoreArm23 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm23");
#define mccompcurname  PoreArm23
#define mccompcurtype  Arm
#define mccompcurindex 28
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77239 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm24'. */
  SIG_MESSAGE("PoreArm24 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm24");
#define mccompcurname  PoreArm24
#define mccompcurtype  Arm
#define mccompcurindex 29
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77258 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm25'. */
  SIG_MESSAGE("PoreArm25 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm25");
#define mccompcurname  PoreArm25
#define mccompcurtype  Arm
#define mccompcurindex 30
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77277 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm26'. */
  SIG_MESSAGE("PoreArm26 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm26");
#define mccompcurname  PoreArm26
#define mccompcurtype  Arm
#define mccompcurindex 31
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77296 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm27'. */
  SIG_MESSAGE("PoreArm27 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm27");
#define mccompcurname  PoreArm27
#define mccompcurtype  Arm
#define mccompcurindex 32
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77315 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm28'. */
  SIG_MESSAGE("PoreArm28 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm28");
#define mccompcurname  PoreArm28
#define mccompcurtype  Arm
#define mccompcurindex 33
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77334 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm29'. */
  SIG_MESSAGE("PoreArm29 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm29");
#define mccompcurname  PoreArm29
#define mccompcurtype  Arm
#define mccompcurindex 34
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77353 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm30'. */
  SIG_MESSAGE("PoreArm30 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm30");
#define mccompcurname  PoreArm30
#define mccompcurtype  Arm
#define mccompcurindex 35
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77372 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm31'. */
  SIG_MESSAGE("PoreArm31 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm31");
#define mccompcurname  PoreArm31
#define mccompcurtype  Arm
#define mccompcurindex 36
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77391 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm32'. */
  SIG_MESSAGE("PoreArm32 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm32");
#define mccompcurname  PoreArm32
#define mccompcurtype  Arm
#define mccompcurindex 37
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77410 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm33'. */
  SIG_MESSAGE("PoreArm33 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm33");
#define mccompcurname  PoreArm33
#define mccompcurtype  Arm
#define mccompcurindex 38
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77429 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm34'. */
  SIG_MESSAGE("PoreArm34 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm34");
#define mccompcurname  PoreArm34
#define mccompcurtype  Arm
#define mccompcurindex 39
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77448 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm35'. */
  SIG_MESSAGE("PoreArm35 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm35");
#define mccompcurname  PoreArm35
#define mccompcurtype  Arm
#define mccompcurindex 40
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77467 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm36'. */
  SIG_MESSAGE("PoreArm36 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm36");
#define mccompcurname  PoreArm36
#define mccompcurtype  Arm
#define mccompcurindex 41
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77486 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm37'. */
  SIG_MESSAGE("PoreArm37 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm37");
#define mccompcurname  PoreArm37
#define mccompcurtype  Arm
#define mccompcurindex 42
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77505 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm38'. */
  SIG_MESSAGE("PoreArm38 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm38");
#define mccompcurname  PoreArm38
#define mccompcurtype  Arm
#define mccompcurindex 43
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77524 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm39'. */
  SIG_MESSAGE("PoreArm39 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm39");
#define mccompcurname  PoreArm39
#define mccompcurtype  Arm
#define mccompcurindex 44
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77543 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm40'. */
  SIG_MESSAGE("PoreArm40 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm40");
#define mccompcurname  PoreArm40
#define mccompcurtype  Arm
#define mccompcurindex 45
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77562 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm41'. */
  SIG_MESSAGE("PoreArm41 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm41");
#define mccompcurname  PoreArm41
#define mccompcurtype  Arm
#define mccompcurindex 46
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77581 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm42'. */
  SIG_MESSAGE("PoreArm42 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm42");
#define mccompcurname  PoreArm42
#define mccompcurtype  Arm
#define mccompcurindex 47
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77600 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm43'. */
  SIG_MESSAGE("PoreArm43 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm43");
#define mccompcurname  PoreArm43
#define mccompcurtype  Arm
#define mccompcurindex 48
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77619 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm44'. */
  SIG_MESSAGE("PoreArm44 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm44");
#define mccompcurname  PoreArm44
#define mccompcurtype  Arm
#define mccompcurindex 49
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77638 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm45'. */
  SIG_MESSAGE("PoreArm45 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm45");
#define mccompcurname  PoreArm45
#define mccompcurtype  Arm
#define mccompcurindex 50
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77657 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm46'. */
  SIG_MESSAGE("PoreArm46 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm46");
#define mccompcurname  PoreArm46
#define mccompcurtype  Arm
#define mccompcurindex 51
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77676 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm47'. */
  SIG_MESSAGE("PoreArm47 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm47");
#define mccompcurname  PoreArm47
#define mccompcurtype  Arm
#define mccompcurindex 52
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77695 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreArm48'. */
  SIG_MESSAGE("PoreArm48 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreArm48");
#define mccompcurname  PoreArm48
#define mccompcurtype  Arm
#define mccompcurindex 53
#line 45 "/usr/share/mcxtrace/1.4/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77714 "instruments/plate49.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP0'. */
  SIG_MESSAGE("PoreP0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP0");
#define mccompcurname  PoreP0
#define mccompcurtype  Pore_p_group
#define mccompcurindex 54
#define nLeft mccPoreP0_nLeft
#define nRight mccPoreP0_nRight
#define nExit mccPoreP0_nExit
#define nTop mccPoreP0_nTop
#define nBottom mccPoreP0_nBottom
#define wLeft mccPoreP0_wLeft
#define wRight mccPoreP0_wRight
#define wExit mccPoreP0_wExit
#define wall mccPoreP0_wall
#define zentry mccPoreP0_zentry
#define reflec_top_table mccPoreP0_reflec_top_table
#define reflec_bottom_table mccPoreP0_reflec_bottom_table
#define reflec_side_table mccPoreP0_reflec_side_table
#define ref_prms mccPoreP0_ref_prms
{   /* Declarations of PoreP0=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP0_radius_p;
MCNUM radius_m = mccPoreP0_radius_m;
MCNUM Z0 = mccPoreP0_Z0;
MCNUM xwidth = mccPoreP0_xwidth;
MCNUM yheight = mccPoreP0_yheight;
MCNUM chamferwidth = mccPoreP0_chamferwidth;
char* mirror_reflec = mccPoreP0_mirror_reflec;
char* bottom_reflec = mccPoreP0_bottom_reflec;
char* side_reflec = mccPoreP0_side_reflec;
MCNUM R_d = mccPoreP0_R_d;
MCNUM absorb_sides = mccPoreP0_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 77787 "instruments/plate49.c"
}   /* End of PoreP0=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP1'. */
  SIG_MESSAGE("PoreP1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP1");
#define mccompcurname  PoreP1
#define mccompcurtype  Pore_p_group
#define mccompcurindex 55
#define nLeft mccPoreP1_nLeft
#define nRight mccPoreP1_nRight
#define nExit mccPoreP1_nExit
#define nTop mccPoreP1_nTop
#define nBottom mccPoreP1_nBottom
#define wLeft mccPoreP1_wLeft
#define wRight mccPoreP1_wRight
#define wExit mccPoreP1_wExit
#define wall mccPoreP1_wall
#define zentry mccPoreP1_zentry
#define reflec_top_table mccPoreP1_reflec_top_table
#define reflec_bottom_table mccPoreP1_reflec_bottom_table
#define reflec_side_table mccPoreP1_reflec_side_table
#define ref_prms mccPoreP1_ref_prms
{   /* Declarations of PoreP1=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP1_radius_p;
MCNUM radius_m = mccPoreP1_radius_m;
MCNUM Z0 = mccPoreP1_Z0;
MCNUM xwidth = mccPoreP1_xwidth;
MCNUM yheight = mccPoreP1_yheight;
MCNUM chamferwidth = mccPoreP1_chamferwidth;
char* mirror_reflec = mccPoreP1_mirror_reflec;
char* bottom_reflec = mccPoreP1_bottom_reflec;
char* side_reflec = mccPoreP1_side_reflec;
MCNUM R_d = mccPoreP1_R_d;
MCNUM absorb_sides = mccPoreP1_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 77875 "instruments/plate49.c"
}   /* End of PoreP1=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP2'. */
  SIG_MESSAGE("PoreP2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP2");
#define mccompcurname  PoreP2
#define mccompcurtype  Pore_p_group
#define mccompcurindex 56
#define nLeft mccPoreP2_nLeft
#define nRight mccPoreP2_nRight
#define nExit mccPoreP2_nExit
#define nTop mccPoreP2_nTop
#define nBottom mccPoreP2_nBottom
#define wLeft mccPoreP2_wLeft
#define wRight mccPoreP2_wRight
#define wExit mccPoreP2_wExit
#define wall mccPoreP2_wall
#define zentry mccPoreP2_zentry
#define reflec_top_table mccPoreP2_reflec_top_table
#define reflec_bottom_table mccPoreP2_reflec_bottom_table
#define reflec_side_table mccPoreP2_reflec_side_table
#define ref_prms mccPoreP2_ref_prms
{   /* Declarations of PoreP2=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP2_radius_p;
MCNUM radius_m = mccPoreP2_radius_m;
MCNUM Z0 = mccPoreP2_Z0;
MCNUM xwidth = mccPoreP2_xwidth;
MCNUM yheight = mccPoreP2_yheight;
MCNUM chamferwidth = mccPoreP2_chamferwidth;
char* mirror_reflec = mccPoreP2_mirror_reflec;
char* bottom_reflec = mccPoreP2_bottom_reflec;
char* side_reflec = mccPoreP2_side_reflec;
MCNUM R_d = mccPoreP2_R_d;
MCNUM absorb_sides = mccPoreP2_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 77963 "instruments/plate49.c"
}   /* End of PoreP2=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP3'. */
  SIG_MESSAGE("PoreP3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP3");
#define mccompcurname  PoreP3
#define mccompcurtype  Pore_p_group
#define mccompcurindex 57
#define nLeft mccPoreP3_nLeft
#define nRight mccPoreP3_nRight
#define nExit mccPoreP3_nExit
#define nTop mccPoreP3_nTop
#define nBottom mccPoreP3_nBottom
#define wLeft mccPoreP3_wLeft
#define wRight mccPoreP3_wRight
#define wExit mccPoreP3_wExit
#define wall mccPoreP3_wall
#define zentry mccPoreP3_zentry
#define reflec_top_table mccPoreP3_reflec_top_table
#define reflec_bottom_table mccPoreP3_reflec_bottom_table
#define reflec_side_table mccPoreP3_reflec_side_table
#define ref_prms mccPoreP3_ref_prms
{   /* Declarations of PoreP3=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP3_radius_p;
MCNUM radius_m = mccPoreP3_radius_m;
MCNUM Z0 = mccPoreP3_Z0;
MCNUM xwidth = mccPoreP3_xwidth;
MCNUM yheight = mccPoreP3_yheight;
MCNUM chamferwidth = mccPoreP3_chamferwidth;
char* mirror_reflec = mccPoreP3_mirror_reflec;
char* bottom_reflec = mccPoreP3_bottom_reflec;
char* side_reflec = mccPoreP3_side_reflec;
MCNUM R_d = mccPoreP3_R_d;
MCNUM absorb_sides = mccPoreP3_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78051 "instruments/plate49.c"
}   /* End of PoreP3=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP4'. */
  SIG_MESSAGE("PoreP4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP4");
#define mccompcurname  PoreP4
#define mccompcurtype  Pore_p_group
#define mccompcurindex 58
#define nLeft mccPoreP4_nLeft
#define nRight mccPoreP4_nRight
#define nExit mccPoreP4_nExit
#define nTop mccPoreP4_nTop
#define nBottom mccPoreP4_nBottom
#define wLeft mccPoreP4_wLeft
#define wRight mccPoreP4_wRight
#define wExit mccPoreP4_wExit
#define wall mccPoreP4_wall
#define zentry mccPoreP4_zentry
#define reflec_top_table mccPoreP4_reflec_top_table
#define reflec_bottom_table mccPoreP4_reflec_bottom_table
#define reflec_side_table mccPoreP4_reflec_side_table
#define ref_prms mccPoreP4_ref_prms
{   /* Declarations of PoreP4=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP4_radius_p;
MCNUM radius_m = mccPoreP4_radius_m;
MCNUM Z0 = mccPoreP4_Z0;
MCNUM xwidth = mccPoreP4_xwidth;
MCNUM yheight = mccPoreP4_yheight;
MCNUM chamferwidth = mccPoreP4_chamferwidth;
char* mirror_reflec = mccPoreP4_mirror_reflec;
char* bottom_reflec = mccPoreP4_bottom_reflec;
char* side_reflec = mccPoreP4_side_reflec;
MCNUM R_d = mccPoreP4_R_d;
MCNUM absorb_sides = mccPoreP4_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78139 "instruments/plate49.c"
}   /* End of PoreP4=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP5'. */
  SIG_MESSAGE("PoreP5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP5");
#define mccompcurname  PoreP5
#define mccompcurtype  Pore_p_group
#define mccompcurindex 59
#define nLeft mccPoreP5_nLeft
#define nRight mccPoreP5_nRight
#define nExit mccPoreP5_nExit
#define nTop mccPoreP5_nTop
#define nBottom mccPoreP5_nBottom
#define wLeft mccPoreP5_wLeft
#define wRight mccPoreP5_wRight
#define wExit mccPoreP5_wExit
#define wall mccPoreP5_wall
#define zentry mccPoreP5_zentry
#define reflec_top_table mccPoreP5_reflec_top_table
#define reflec_bottom_table mccPoreP5_reflec_bottom_table
#define reflec_side_table mccPoreP5_reflec_side_table
#define ref_prms mccPoreP5_ref_prms
{   /* Declarations of PoreP5=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP5_radius_p;
MCNUM radius_m = mccPoreP5_radius_m;
MCNUM Z0 = mccPoreP5_Z0;
MCNUM xwidth = mccPoreP5_xwidth;
MCNUM yheight = mccPoreP5_yheight;
MCNUM chamferwidth = mccPoreP5_chamferwidth;
char* mirror_reflec = mccPoreP5_mirror_reflec;
char* bottom_reflec = mccPoreP5_bottom_reflec;
char* side_reflec = mccPoreP5_side_reflec;
MCNUM R_d = mccPoreP5_R_d;
MCNUM absorb_sides = mccPoreP5_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78227 "instruments/plate49.c"
}   /* End of PoreP5=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP6'. */
  SIG_MESSAGE("PoreP6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP6");
#define mccompcurname  PoreP6
#define mccompcurtype  Pore_p_group
#define mccompcurindex 60
#define nLeft mccPoreP6_nLeft
#define nRight mccPoreP6_nRight
#define nExit mccPoreP6_nExit
#define nTop mccPoreP6_nTop
#define nBottom mccPoreP6_nBottom
#define wLeft mccPoreP6_wLeft
#define wRight mccPoreP6_wRight
#define wExit mccPoreP6_wExit
#define wall mccPoreP6_wall
#define zentry mccPoreP6_zentry
#define reflec_top_table mccPoreP6_reflec_top_table
#define reflec_bottom_table mccPoreP6_reflec_bottom_table
#define reflec_side_table mccPoreP6_reflec_side_table
#define ref_prms mccPoreP6_ref_prms
{   /* Declarations of PoreP6=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP6_radius_p;
MCNUM radius_m = mccPoreP6_radius_m;
MCNUM Z0 = mccPoreP6_Z0;
MCNUM xwidth = mccPoreP6_xwidth;
MCNUM yheight = mccPoreP6_yheight;
MCNUM chamferwidth = mccPoreP6_chamferwidth;
char* mirror_reflec = mccPoreP6_mirror_reflec;
char* bottom_reflec = mccPoreP6_bottom_reflec;
char* side_reflec = mccPoreP6_side_reflec;
MCNUM R_d = mccPoreP6_R_d;
MCNUM absorb_sides = mccPoreP6_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78315 "instruments/plate49.c"
}   /* End of PoreP6=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP7'. */
  SIG_MESSAGE("PoreP7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP7");
#define mccompcurname  PoreP7
#define mccompcurtype  Pore_p_group
#define mccompcurindex 61
#define nLeft mccPoreP7_nLeft
#define nRight mccPoreP7_nRight
#define nExit mccPoreP7_nExit
#define nTop mccPoreP7_nTop
#define nBottom mccPoreP7_nBottom
#define wLeft mccPoreP7_wLeft
#define wRight mccPoreP7_wRight
#define wExit mccPoreP7_wExit
#define wall mccPoreP7_wall
#define zentry mccPoreP7_zentry
#define reflec_top_table mccPoreP7_reflec_top_table
#define reflec_bottom_table mccPoreP7_reflec_bottom_table
#define reflec_side_table mccPoreP7_reflec_side_table
#define ref_prms mccPoreP7_ref_prms
{   /* Declarations of PoreP7=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP7_radius_p;
MCNUM radius_m = mccPoreP7_radius_m;
MCNUM Z0 = mccPoreP7_Z0;
MCNUM xwidth = mccPoreP7_xwidth;
MCNUM yheight = mccPoreP7_yheight;
MCNUM chamferwidth = mccPoreP7_chamferwidth;
char* mirror_reflec = mccPoreP7_mirror_reflec;
char* bottom_reflec = mccPoreP7_bottom_reflec;
char* side_reflec = mccPoreP7_side_reflec;
MCNUM R_d = mccPoreP7_R_d;
MCNUM absorb_sides = mccPoreP7_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78403 "instruments/plate49.c"
}   /* End of PoreP7=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP8'. */
  SIG_MESSAGE("PoreP8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP8");
#define mccompcurname  PoreP8
#define mccompcurtype  Pore_p_group
#define mccompcurindex 62
#define nLeft mccPoreP8_nLeft
#define nRight mccPoreP8_nRight
#define nExit mccPoreP8_nExit
#define nTop mccPoreP8_nTop
#define nBottom mccPoreP8_nBottom
#define wLeft mccPoreP8_wLeft
#define wRight mccPoreP8_wRight
#define wExit mccPoreP8_wExit
#define wall mccPoreP8_wall
#define zentry mccPoreP8_zentry
#define reflec_top_table mccPoreP8_reflec_top_table
#define reflec_bottom_table mccPoreP8_reflec_bottom_table
#define reflec_side_table mccPoreP8_reflec_side_table
#define ref_prms mccPoreP8_ref_prms
{   /* Declarations of PoreP8=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP8_radius_p;
MCNUM radius_m = mccPoreP8_radius_m;
MCNUM Z0 = mccPoreP8_Z0;
MCNUM xwidth = mccPoreP8_xwidth;
MCNUM yheight = mccPoreP8_yheight;
MCNUM chamferwidth = mccPoreP8_chamferwidth;
char* mirror_reflec = mccPoreP8_mirror_reflec;
char* bottom_reflec = mccPoreP8_bottom_reflec;
char* side_reflec = mccPoreP8_side_reflec;
MCNUM R_d = mccPoreP8_R_d;
MCNUM absorb_sides = mccPoreP8_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78491 "instruments/plate49.c"
}   /* End of PoreP8=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP9'. */
  SIG_MESSAGE("PoreP9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP9");
#define mccompcurname  PoreP9
#define mccompcurtype  Pore_p_group
#define mccompcurindex 63
#define nLeft mccPoreP9_nLeft
#define nRight mccPoreP9_nRight
#define nExit mccPoreP9_nExit
#define nTop mccPoreP9_nTop
#define nBottom mccPoreP9_nBottom
#define wLeft mccPoreP9_wLeft
#define wRight mccPoreP9_wRight
#define wExit mccPoreP9_wExit
#define wall mccPoreP9_wall
#define zentry mccPoreP9_zentry
#define reflec_top_table mccPoreP9_reflec_top_table
#define reflec_bottom_table mccPoreP9_reflec_bottom_table
#define reflec_side_table mccPoreP9_reflec_side_table
#define ref_prms mccPoreP9_ref_prms
{   /* Declarations of PoreP9=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP9_radius_p;
MCNUM radius_m = mccPoreP9_radius_m;
MCNUM Z0 = mccPoreP9_Z0;
MCNUM xwidth = mccPoreP9_xwidth;
MCNUM yheight = mccPoreP9_yheight;
MCNUM chamferwidth = mccPoreP9_chamferwidth;
char* mirror_reflec = mccPoreP9_mirror_reflec;
char* bottom_reflec = mccPoreP9_bottom_reflec;
char* side_reflec = mccPoreP9_side_reflec;
MCNUM R_d = mccPoreP9_R_d;
MCNUM absorb_sides = mccPoreP9_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78579 "instruments/plate49.c"
}   /* End of PoreP9=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP10'. */
  SIG_MESSAGE("PoreP10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP10");
#define mccompcurname  PoreP10
#define mccompcurtype  Pore_p_group
#define mccompcurindex 64
#define nLeft mccPoreP10_nLeft
#define nRight mccPoreP10_nRight
#define nExit mccPoreP10_nExit
#define nTop mccPoreP10_nTop
#define nBottom mccPoreP10_nBottom
#define wLeft mccPoreP10_wLeft
#define wRight mccPoreP10_wRight
#define wExit mccPoreP10_wExit
#define wall mccPoreP10_wall
#define zentry mccPoreP10_zentry
#define reflec_top_table mccPoreP10_reflec_top_table
#define reflec_bottom_table mccPoreP10_reflec_bottom_table
#define reflec_side_table mccPoreP10_reflec_side_table
#define ref_prms mccPoreP10_ref_prms
{   /* Declarations of PoreP10=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP10_radius_p;
MCNUM radius_m = mccPoreP10_radius_m;
MCNUM Z0 = mccPoreP10_Z0;
MCNUM xwidth = mccPoreP10_xwidth;
MCNUM yheight = mccPoreP10_yheight;
MCNUM chamferwidth = mccPoreP10_chamferwidth;
char* mirror_reflec = mccPoreP10_mirror_reflec;
char* bottom_reflec = mccPoreP10_bottom_reflec;
char* side_reflec = mccPoreP10_side_reflec;
MCNUM R_d = mccPoreP10_R_d;
MCNUM absorb_sides = mccPoreP10_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78667 "instruments/plate49.c"
}   /* End of PoreP10=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP11'. */
  SIG_MESSAGE("PoreP11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP11");
#define mccompcurname  PoreP11
#define mccompcurtype  Pore_p_group
#define mccompcurindex 65
#define nLeft mccPoreP11_nLeft
#define nRight mccPoreP11_nRight
#define nExit mccPoreP11_nExit
#define nTop mccPoreP11_nTop
#define nBottom mccPoreP11_nBottom
#define wLeft mccPoreP11_wLeft
#define wRight mccPoreP11_wRight
#define wExit mccPoreP11_wExit
#define wall mccPoreP11_wall
#define zentry mccPoreP11_zentry
#define reflec_top_table mccPoreP11_reflec_top_table
#define reflec_bottom_table mccPoreP11_reflec_bottom_table
#define reflec_side_table mccPoreP11_reflec_side_table
#define ref_prms mccPoreP11_ref_prms
{   /* Declarations of PoreP11=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP11_radius_p;
MCNUM radius_m = mccPoreP11_radius_m;
MCNUM Z0 = mccPoreP11_Z0;
MCNUM xwidth = mccPoreP11_xwidth;
MCNUM yheight = mccPoreP11_yheight;
MCNUM chamferwidth = mccPoreP11_chamferwidth;
char* mirror_reflec = mccPoreP11_mirror_reflec;
char* bottom_reflec = mccPoreP11_bottom_reflec;
char* side_reflec = mccPoreP11_side_reflec;
MCNUM R_d = mccPoreP11_R_d;
MCNUM absorb_sides = mccPoreP11_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78755 "instruments/plate49.c"
}   /* End of PoreP11=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP12'. */
  SIG_MESSAGE("PoreP12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP12");
#define mccompcurname  PoreP12
#define mccompcurtype  Pore_p_group
#define mccompcurindex 66
#define nLeft mccPoreP12_nLeft
#define nRight mccPoreP12_nRight
#define nExit mccPoreP12_nExit
#define nTop mccPoreP12_nTop
#define nBottom mccPoreP12_nBottom
#define wLeft mccPoreP12_wLeft
#define wRight mccPoreP12_wRight
#define wExit mccPoreP12_wExit
#define wall mccPoreP12_wall
#define zentry mccPoreP12_zentry
#define reflec_top_table mccPoreP12_reflec_top_table
#define reflec_bottom_table mccPoreP12_reflec_bottom_table
#define reflec_side_table mccPoreP12_reflec_side_table
#define ref_prms mccPoreP12_ref_prms
{   /* Declarations of PoreP12=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP12_radius_p;
MCNUM radius_m = mccPoreP12_radius_m;
MCNUM Z0 = mccPoreP12_Z0;
MCNUM xwidth = mccPoreP12_xwidth;
MCNUM yheight = mccPoreP12_yheight;
MCNUM chamferwidth = mccPoreP12_chamferwidth;
char* mirror_reflec = mccPoreP12_mirror_reflec;
char* bottom_reflec = mccPoreP12_bottom_reflec;
char* side_reflec = mccPoreP12_side_reflec;
MCNUM R_d = mccPoreP12_R_d;
MCNUM absorb_sides = mccPoreP12_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78843 "instruments/plate49.c"
}   /* End of PoreP12=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP13'. */
  SIG_MESSAGE("PoreP13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP13");
#define mccompcurname  PoreP13
#define mccompcurtype  Pore_p_group
#define mccompcurindex 67
#define nLeft mccPoreP13_nLeft
#define nRight mccPoreP13_nRight
#define nExit mccPoreP13_nExit
#define nTop mccPoreP13_nTop
#define nBottom mccPoreP13_nBottom
#define wLeft mccPoreP13_wLeft
#define wRight mccPoreP13_wRight
#define wExit mccPoreP13_wExit
#define wall mccPoreP13_wall
#define zentry mccPoreP13_zentry
#define reflec_top_table mccPoreP13_reflec_top_table
#define reflec_bottom_table mccPoreP13_reflec_bottom_table
#define reflec_side_table mccPoreP13_reflec_side_table
#define ref_prms mccPoreP13_ref_prms
{   /* Declarations of PoreP13=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP13_radius_p;
MCNUM radius_m = mccPoreP13_radius_m;
MCNUM Z0 = mccPoreP13_Z0;
MCNUM xwidth = mccPoreP13_xwidth;
MCNUM yheight = mccPoreP13_yheight;
MCNUM chamferwidth = mccPoreP13_chamferwidth;
char* mirror_reflec = mccPoreP13_mirror_reflec;
char* bottom_reflec = mccPoreP13_bottom_reflec;
char* side_reflec = mccPoreP13_side_reflec;
MCNUM R_d = mccPoreP13_R_d;
MCNUM absorb_sides = mccPoreP13_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 78931 "instruments/plate49.c"
}   /* End of PoreP13=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP14'. */
  SIG_MESSAGE("PoreP14 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP14");
#define mccompcurname  PoreP14
#define mccompcurtype  Pore_p_group
#define mccompcurindex 68
#define nLeft mccPoreP14_nLeft
#define nRight mccPoreP14_nRight
#define nExit mccPoreP14_nExit
#define nTop mccPoreP14_nTop
#define nBottom mccPoreP14_nBottom
#define wLeft mccPoreP14_wLeft
#define wRight mccPoreP14_wRight
#define wExit mccPoreP14_wExit
#define wall mccPoreP14_wall
#define zentry mccPoreP14_zentry
#define reflec_top_table mccPoreP14_reflec_top_table
#define reflec_bottom_table mccPoreP14_reflec_bottom_table
#define reflec_side_table mccPoreP14_reflec_side_table
#define ref_prms mccPoreP14_ref_prms
{   /* Declarations of PoreP14=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP14_radius_p;
MCNUM radius_m = mccPoreP14_radius_m;
MCNUM Z0 = mccPoreP14_Z0;
MCNUM xwidth = mccPoreP14_xwidth;
MCNUM yheight = mccPoreP14_yheight;
MCNUM chamferwidth = mccPoreP14_chamferwidth;
char* mirror_reflec = mccPoreP14_mirror_reflec;
char* bottom_reflec = mccPoreP14_bottom_reflec;
char* side_reflec = mccPoreP14_side_reflec;
MCNUM R_d = mccPoreP14_R_d;
MCNUM absorb_sides = mccPoreP14_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79019 "instruments/plate49.c"
}   /* End of PoreP14=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP15'. */
  SIG_MESSAGE("PoreP15 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP15");
#define mccompcurname  PoreP15
#define mccompcurtype  Pore_p_group
#define mccompcurindex 69
#define nLeft mccPoreP15_nLeft
#define nRight mccPoreP15_nRight
#define nExit mccPoreP15_nExit
#define nTop mccPoreP15_nTop
#define nBottom mccPoreP15_nBottom
#define wLeft mccPoreP15_wLeft
#define wRight mccPoreP15_wRight
#define wExit mccPoreP15_wExit
#define wall mccPoreP15_wall
#define zentry mccPoreP15_zentry
#define reflec_top_table mccPoreP15_reflec_top_table
#define reflec_bottom_table mccPoreP15_reflec_bottom_table
#define reflec_side_table mccPoreP15_reflec_side_table
#define ref_prms mccPoreP15_ref_prms
{   /* Declarations of PoreP15=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP15_radius_p;
MCNUM radius_m = mccPoreP15_radius_m;
MCNUM Z0 = mccPoreP15_Z0;
MCNUM xwidth = mccPoreP15_xwidth;
MCNUM yheight = mccPoreP15_yheight;
MCNUM chamferwidth = mccPoreP15_chamferwidth;
char* mirror_reflec = mccPoreP15_mirror_reflec;
char* bottom_reflec = mccPoreP15_bottom_reflec;
char* side_reflec = mccPoreP15_side_reflec;
MCNUM R_d = mccPoreP15_R_d;
MCNUM absorb_sides = mccPoreP15_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79107 "instruments/plate49.c"
}   /* End of PoreP15=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP16'. */
  SIG_MESSAGE("PoreP16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP16");
#define mccompcurname  PoreP16
#define mccompcurtype  Pore_p_group
#define mccompcurindex 70
#define nLeft mccPoreP16_nLeft
#define nRight mccPoreP16_nRight
#define nExit mccPoreP16_nExit
#define nTop mccPoreP16_nTop
#define nBottom mccPoreP16_nBottom
#define wLeft mccPoreP16_wLeft
#define wRight mccPoreP16_wRight
#define wExit mccPoreP16_wExit
#define wall mccPoreP16_wall
#define zentry mccPoreP16_zentry
#define reflec_top_table mccPoreP16_reflec_top_table
#define reflec_bottom_table mccPoreP16_reflec_bottom_table
#define reflec_side_table mccPoreP16_reflec_side_table
#define ref_prms mccPoreP16_ref_prms
{   /* Declarations of PoreP16=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP16_radius_p;
MCNUM radius_m = mccPoreP16_radius_m;
MCNUM Z0 = mccPoreP16_Z0;
MCNUM xwidth = mccPoreP16_xwidth;
MCNUM yheight = mccPoreP16_yheight;
MCNUM chamferwidth = mccPoreP16_chamferwidth;
char* mirror_reflec = mccPoreP16_mirror_reflec;
char* bottom_reflec = mccPoreP16_bottom_reflec;
char* side_reflec = mccPoreP16_side_reflec;
MCNUM R_d = mccPoreP16_R_d;
MCNUM absorb_sides = mccPoreP16_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79195 "instruments/plate49.c"
}   /* End of PoreP16=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP17'. */
  SIG_MESSAGE("PoreP17 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP17");
#define mccompcurname  PoreP17
#define mccompcurtype  Pore_p_group
#define mccompcurindex 71
#define nLeft mccPoreP17_nLeft
#define nRight mccPoreP17_nRight
#define nExit mccPoreP17_nExit
#define nTop mccPoreP17_nTop
#define nBottom mccPoreP17_nBottom
#define wLeft mccPoreP17_wLeft
#define wRight mccPoreP17_wRight
#define wExit mccPoreP17_wExit
#define wall mccPoreP17_wall
#define zentry mccPoreP17_zentry
#define reflec_top_table mccPoreP17_reflec_top_table
#define reflec_bottom_table mccPoreP17_reflec_bottom_table
#define reflec_side_table mccPoreP17_reflec_side_table
#define ref_prms mccPoreP17_ref_prms
{   /* Declarations of PoreP17=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP17_radius_p;
MCNUM radius_m = mccPoreP17_radius_m;
MCNUM Z0 = mccPoreP17_Z0;
MCNUM xwidth = mccPoreP17_xwidth;
MCNUM yheight = mccPoreP17_yheight;
MCNUM chamferwidth = mccPoreP17_chamferwidth;
char* mirror_reflec = mccPoreP17_mirror_reflec;
char* bottom_reflec = mccPoreP17_bottom_reflec;
char* side_reflec = mccPoreP17_side_reflec;
MCNUM R_d = mccPoreP17_R_d;
MCNUM absorb_sides = mccPoreP17_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79283 "instruments/plate49.c"
}   /* End of PoreP17=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP18'. */
  SIG_MESSAGE("PoreP18 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP18");
#define mccompcurname  PoreP18
#define mccompcurtype  Pore_p_group
#define mccompcurindex 72
#define nLeft mccPoreP18_nLeft
#define nRight mccPoreP18_nRight
#define nExit mccPoreP18_nExit
#define nTop mccPoreP18_nTop
#define nBottom mccPoreP18_nBottom
#define wLeft mccPoreP18_wLeft
#define wRight mccPoreP18_wRight
#define wExit mccPoreP18_wExit
#define wall mccPoreP18_wall
#define zentry mccPoreP18_zentry
#define reflec_top_table mccPoreP18_reflec_top_table
#define reflec_bottom_table mccPoreP18_reflec_bottom_table
#define reflec_side_table mccPoreP18_reflec_side_table
#define ref_prms mccPoreP18_ref_prms
{   /* Declarations of PoreP18=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP18_radius_p;
MCNUM radius_m = mccPoreP18_radius_m;
MCNUM Z0 = mccPoreP18_Z0;
MCNUM xwidth = mccPoreP18_xwidth;
MCNUM yheight = mccPoreP18_yheight;
MCNUM chamferwidth = mccPoreP18_chamferwidth;
char* mirror_reflec = mccPoreP18_mirror_reflec;
char* bottom_reflec = mccPoreP18_bottom_reflec;
char* side_reflec = mccPoreP18_side_reflec;
MCNUM R_d = mccPoreP18_R_d;
MCNUM absorb_sides = mccPoreP18_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79371 "instruments/plate49.c"
}   /* End of PoreP18=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP19'. */
  SIG_MESSAGE("PoreP19 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP19");
#define mccompcurname  PoreP19
#define mccompcurtype  Pore_p_group
#define mccompcurindex 73
#define nLeft mccPoreP19_nLeft
#define nRight mccPoreP19_nRight
#define nExit mccPoreP19_nExit
#define nTop mccPoreP19_nTop
#define nBottom mccPoreP19_nBottom
#define wLeft mccPoreP19_wLeft
#define wRight mccPoreP19_wRight
#define wExit mccPoreP19_wExit
#define wall mccPoreP19_wall
#define zentry mccPoreP19_zentry
#define reflec_top_table mccPoreP19_reflec_top_table
#define reflec_bottom_table mccPoreP19_reflec_bottom_table
#define reflec_side_table mccPoreP19_reflec_side_table
#define ref_prms mccPoreP19_ref_prms
{   /* Declarations of PoreP19=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP19_radius_p;
MCNUM radius_m = mccPoreP19_radius_m;
MCNUM Z0 = mccPoreP19_Z0;
MCNUM xwidth = mccPoreP19_xwidth;
MCNUM yheight = mccPoreP19_yheight;
MCNUM chamferwidth = mccPoreP19_chamferwidth;
char* mirror_reflec = mccPoreP19_mirror_reflec;
char* bottom_reflec = mccPoreP19_bottom_reflec;
char* side_reflec = mccPoreP19_side_reflec;
MCNUM R_d = mccPoreP19_R_d;
MCNUM absorb_sides = mccPoreP19_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79459 "instruments/plate49.c"
}   /* End of PoreP19=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP20'. */
  SIG_MESSAGE("PoreP20 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP20");
#define mccompcurname  PoreP20
#define mccompcurtype  Pore_p_group
#define mccompcurindex 74
#define nLeft mccPoreP20_nLeft
#define nRight mccPoreP20_nRight
#define nExit mccPoreP20_nExit
#define nTop mccPoreP20_nTop
#define nBottom mccPoreP20_nBottom
#define wLeft mccPoreP20_wLeft
#define wRight mccPoreP20_wRight
#define wExit mccPoreP20_wExit
#define wall mccPoreP20_wall
#define zentry mccPoreP20_zentry
#define reflec_top_table mccPoreP20_reflec_top_table
#define reflec_bottom_table mccPoreP20_reflec_bottom_table
#define reflec_side_table mccPoreP20_reflec_side_table
#define ref_prms mccPoreP20_ref_prms
{   /* Declarations of PoreP20=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP20_radius_p;
MCNUM radius_m = mccPoreP20_radius_m;
MCNUM Z0 = mccPoreP20_Z0;
MCNUM xwidth = mccPoreP20_xwidth;
MCNUM yheight = mccPoreP20_yheight;
MCNUM chamferwidth = mccPoreP20_chamferwidth;
char* mirror_reflec = mccPoreP20_mirror_reflec;
char* bottom_reflec = mccPoreP20_bottom_reflec;
char* side_reflec = mccPoreP20_side_reflec;
MCNUM R_d = mccPoreP20_R_d;
MCNUM absorb_sides = mccPoreP20_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79547 "instruments/plate49.c"
}   /* End of PoreP20=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP21'. */
  SIG_MESSAGE("PoreP21 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP21");
#define mccompcurname  PoreP21
#define mccompcurtype  Pore_p_group
#define mccompcurindex 75
#define nLeft mccPoreP21_nLeft
#define nRight mccPoreP21_nRight
#define nExit mccPoreP21_nExit
#define nTop mccPoreP21_nTop
#define nBottom mccPoreP21_nBottom
#define wLeft mccPoreP21_wLeft
#define wRight mccPoreP21_wRight
#define wExit mccPoreP21_wExit
#define wall mccPoreP21_wall
#define zentry mccPoreP21_zentry
#define reflec_top_table mccPoreP21_reflec_top_table
#define reflec_bottom_table mccPoreP21_reflec_bottom_table
#define reflec_side_table mccPoreP21_reflec_side_table
#define ref_prms mccPoreP21_ref_prms
{   /* Declarations of PoreP21=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP21_radius_p;
MCNUM radius_m = mccPoreP21_radius_m;
MCNUM Z0 = mccPoreP21_Z0;
MCNUM xwidth = mccPoreP21_xwidth;
MCNUM yheight = mccPoreP21_yheight;
MCNUM chamferwidth = mccPoreP21_chamferwidth;
char* mirror_reflec = mccPoreP21_mirror_reflec;
char* bottom_reflec = mccPoreP21_bottom_reflec;
char* side_reflec = mccPoreP21_side_reflec;
MCNUM R_d = mccPoreP21_R_d;
MCNUM absorb_sides = mccPoreP21_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79635 "instruments/plate49.c"
}   /* End of PoreP21=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP22'. */
  SIG_MESSAGE("PoreP22 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP22");
#define mccompcurname  PoreP22
#define mccompcurtype  Pore_p_group
#define mccompcurindex 76
#define nLeft mccPoreP22_nLeft
#define nRight mccPoreP22_nRight
#define nExit mccPoreP22_nExit
#define nTop mccPoreP22_nTop
#define nBottom mccPoreP22_nBottom
#define wLeft mccPoreP22_wLeft
#define wRight mccPoreP22_wRight
#define wExit mccPoreP22_wExit
#define wall mccPoreP22_wall
#define zentry mccPoreP22_zentry
#define reflec_top_table mccPoreP22_reflec_top_table
#define reflec_bottom_table mccPoreP22_reflec_bottom_table
#define reflec_side_table mccPoreP22_reflec_side_table
#define ref_prms mccPoreP22_ref_prms
{   /* Declarations of PoreP22=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP22_radius_p;
MCNUM radius_m = mccPoreP22_radius_m;
MCNUM Z0 = mccPoreP22_Z0;
MCNUM xwidth = mccPoreP22_xwidth;
MCNUM yheight = mccPoreP22_yheight;
MCNUM chamferwidth = mccPoreP22_chamferwidth;
char* mirror_reflec = mccPoreP22_mirror_reflec;
char* bottom_reflec = mccPoreP22_bottom_reflec;
char* side_reflec = mccPoreP22_side_reflec;
MCNUM R_d = mccPoreP22_R_d;
MCNUM absorb_sides = mccPoreP22_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79723 "instruments/plate49.c"
}   /* End of PoreP22=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP23'. */
  SIG_MESSAGE("PoreP23 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP23");
#define mccompcurname  PoreP23
#define mccompcurtype  Pore_p_group
#define mccompcurindex 77
#define nLeft mccPoreP23_nLeft
#define nRight mccPoreP23_nRight
#define nExit mccPoreP23_nExit
#define nTop mccPoreP23_nTop
#define nBottom mccPoreP23_nBottom
#define wLeft mccPoreP23_wLeft
#define wRight mccPoreP23_wRight
#define wExit mccPoreP23_wExit
#define wall mccPoreP23_wall
#define zentry mccPoreP23_zentry
#define reflec_top_table mccPoreP23_reflec_top_table
#define reflec_bottom_table mccPoreP23_reflec_bottom_table
#define reflec_side_table mccPoreP23_reflec_side_table
#define ref_prms mccPoreP23_ref_prms
{   /* Declarations of PoreP23=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP23_radius_p;
MCNUM radius_m = mccPoreP23_radius_m;
MCNUM Z0 = mccPoreP23_Z0;
MCNUM xwidth = mccPoreP23_xwidth;
MCNUM yheight = mccPoreP23_yheight;
MCNUM chamferwidth = mccPoreP23_chamferwidth;
char* mirror_reflec = mccPoreP23_mirror_reflec;
char* bottom_reflec = mccPoreP23_bottom_reflec;
char* side_reflec = mccPoreP23_side_reflec;
MCNUM R_d = mccPoreP23_R_d;
MCNUM absorb_sides = mccPoreP23_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79811 "instruments/plate49.c"
}   /* End of PoreP23=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP24'. */
  SIG_MESSAGE("PoreP24 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP24");
#define mccompcurname  PoreP24
#define mccompcurtype  Pore_p_group
#define mccompcurindex 78
#define nLeft mccPoreP24_nLeft
#define nRight mccPoreP24_nRight
#define nExit mccPoreP24_nExit
#define nTop mccPoreP24_nTop
#define nBottom mccPoreP24_nBottom
#define wLeft mccPoreP24_wLeft
#define wRight mccPoreP24_wRight
#define wExit mccPoreP24_wExit
#define wall mccPoreP24_wall
#define zentry mccPoreP24_zentry
#define reflec_top_table mccPoreP24_reflec_top_table
#define reflec_bottom_table mccPoreP24_reflec_bottom_table
#define reflec_side_table mccPoreP24_reflec_side_table
#define ref_prms mccPoreP24_ref_prms
{   /* Declarations of PoreP24=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP24_radius_p;
MCNUM radius_m = mccPoreP24_radius_m;
MCNUM Z0 = mccPoreP24_Z0;
MCNUM xwidth = mccPoreP24_xwidth;
MCNUM yheight = mccPoreP24_yheight;
MCNUM chamferwidth = mccPoreP24_chamferwidth;
char* mirror_reflec = mccPoreP24_mirror_reflec;
char* bottom_reflec = mccPoreP24_bottom_reflec;
char* side_reflec = mccPoreP24_side_reflec;
MCNUM R_d = mccPoreP24_R_d;
MCNUM absorb_sides = mccPoreP24_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79899 "instruments/plate49.c"
}   /* End of PoreP24=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP25'. */
  SIG_MESSAGE("PoreP25 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP25");
#define mccompcurname  PoreP25
#define mccompcurtype  Pore_p_group
#define mccompcurindex 79
#define nLeft mccPoreP25_nLeft
#define nRight mccPoreP25_nRight
#define nExit mccPoreP25_nExit
#define nTop mccPoreP25_nTop
#define nBottom mccPoreP25_nBottom
#define wLeft mccPoreP25_wLeft
#define wRight mccPoreP25_wRight
#define wExit mccPoreP25_wExit
#define wall mccPoreP25_wall
#define zentry mccPoreP25_zentry
#define reflec_top_table mccPoreP25_reflec_top_table
#define reflec_bottom_table mccPoreP25_reflec_bottom_table
#define reflec_side_table mccPoreP25_reflec_side_table
#define ref_prms mccPoreP25_ref_prms
{   /* Declarations of PoreP25=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP25_radius_p;
MCNUM radius_m = mccPoreP25_radius_m;
MCNUM Z0 = mccPoreP25_Z0;
MCNUM xwidth = mccPoreP25_xwidth;
MCNUM yheight = mccPoreP25_yheight;
MCNUM chamferwidth = mccPoreP25_chamferwidth;
char* mirror_reflec = mccPoreP25_mirror_reflec;
char* bottom_reflec = mccPoreP25_bottom_reflec;
char* side_reflec = mccPoreP25_side_reflec;
MCNUM R_d = mccPoreP25_R_d;
MCNUM absorb_sides = mccPoreP25_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 79987 "instruments/plate49.c"
}   /* End of PoreP25=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP26'. */
  SIG_MESSAGE("PoreP26 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP26");
#define mccompcurname  PoreP26
#define mccompcurtype  Pore_p_group
#define mccompcurindex 80
#define nLeft mccPoreP26_nLeft
#define nRight mccPoreP26_nRight
#define nExit mccPoreP26_nExit
#define nTop mccPoreP26_nTop
#define nBottom mccPoreP26_nBottom
#define wLeft mccPoreP26_wLeft
#define wRight mccPoreP26_wRight
#define wExit mccPoreP26_wExit
#define wall mccPoreP26_wall
#define zentry mccPoreP26_zentry
#define reflec_top_table mccPoreP26_reflec_top_table
#define reflec_bottom_table mccPoreP26_reflec_bottom_table
#define reflec_side_table mccPoreP26_reflec_side_table
#define ref_prms mccPoreP26_ref_prms
{   /* Declarations of PoreP26=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP26_radius_p;
MCNUM radius_m = mccPoreP26_radius_m;
MCNUM Z0 = mccPoreP26_Z0;
MCNUM xwidth = mccPoreP26_xwidth;
MCNUM yheight = mccPoreP26_yheight;
MCNUM chamferwidth = mccPoreP26_chamferwidth;
char* mirror_reflec = mccPoreP26_mirror_reflec;
char* bottom_reflec = mccPoreP26_bottom_reflec;
char* side_reflec = mccPoreP26_side_reflec;
MCNUM R_d = mccPoreP26_R_d;
MCNUM absorb_sides = mccPoreP26_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80075 "instruments/plate49.c"
}   /* End of PoreP26=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP27'. */
  SIG_MESSAGE("PoreP27 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP27");
#define mccompcurname  PoreP27
#define mccompcurtype  Pore_p_group
#define mccompcurindex 81
#define nLeft mccPoreP27_nLeft
#define nRight mccPoreP27_nRight
#define nExit mccPoreP27_nExit
#define nTop mccPoreP27_nTop
#define nBottom mccPoreP27_nBottom
#define wLeft mccPoreP27_wLeft
#define wRight mccPoreP27_wRight
#define wExit mccPoreP27_wExit
#define wall mccPoreP27_wall
#define zentry mccPoreP27_zentry
#define reflec_top_table mccPoreP27_reflec_top_table
#define reflec_bottom_table mccPoreP27_reflec_bottom_table
#define reflec_side_table mccPoreP27_reflec_side_table
#define ref_prms mccPoreP27_ref_prms
{   /* Declarations of PoreP27=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP27_radius_p;
MCNUM radius_m = mccPoreP27_radius_m;
MCNUM Z0 = mccPoreP27_Z0;
MCNUM xwidth = mccPoreP27_xwidth;
MCNUM yheight = mccPoreP27_yheight;
MCNUM chamferwidth = mccPoreP27_chamferwidth;
char* mirror_reflec = mccPoreP27_mirror_reflec;
char* bottom_reflec = mccPoreP27_bottom_reflec;
char* side_reflec = mccPoreP27_side_reflec;
MCNUM R_d = mccPoreP27_R_d;
MCNUM absorb_sides = mccPoreP27_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80163 "instruments/plate49.c"
}   /* End of PoreP27=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP28'. */
  SIG_MESSAGE("PoreP28 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP28");
#define mccompcurname  PoreP28
#define mccompcurtype  Pore_p_group
#define mccompcurindex 82
#define nLeft mccPoreP28_nLeft
#define nRight mccPoreP28_nRight
#define nExit mccPoreP28_nExit
#define nTop mccPoreP28_nTop
#define nBottom mccPoreP28_nBottom
#define wLeft mccPoreP28_wLeft
#define wRight mccPoreP28_wRight
#define wExit mccPoreP28_wExit
#define wall mccPoreP28_wall
#define zentry mccPoreP28_zentry
#define reflec_top_table mccPoreP28_reflec_top_table
#define reflec_bottom_table mccPoreP28_reflec_bottom_table
#define reflec_side_table mccPoreP28_reflec_side_table
#define ref_prms mccPoreP28_ref_prms
{   /* Declarations of PoreP28=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP28_radius_p;
MCNUM radius_m = mccPoreP28_radius_m;
MCNUM Z0 = mccPoreP28_Z0;
MCNUM xwidth = mccPoreP28_xwidth;
MCNUM yheight = mccPoreP28_yheight;
MCNUM chamferwidth = mccPoreP28_chamferwidth;
char* mirror_reflec = mccPoreP28_mirror_reflec;
char* bottom_reflec = mccPoreP28_bottom_reflec;
char* side_reflec = mccPoreP28_side_reflec;
MCNUM R_d = mccPoreP28_R_d;
MCNUM absorb_sides = mccPoreP28_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80251 "instruments/plate49.c"
}   /* End of PoreP28=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP29'. */
  SIG_MESSAGE("PoreP29 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP29");
#define mccompcurname  PoreP29
#define mccompcurtype  Pore_p_group
#define mccompcurindex 83
#define nLeft mccPoreP29_nLeft
#define nRight mccPoreP29_nRight
#define nExit mccPoreP29_nExit
#define nTop mccPoreP29_nTop
#define nBottom mccPoreP29_nBottom
#define wLeft mccPoreP29_wLeft
#define wRight mccPoreP29_wRight
#define wExit mccPoreP29_wExit
#define wall mccPoreP29_wall
#define zentry mccPoreP29_zentry
#define reflec_top_table mccPoreP29_reflec_top_table
#define reflec_bottom_table mccPoreP29_reflec_bottom_table
#define reflec_side_table mccPoreP29_reflec_side_table
#define ref_prms mccPoreP29_ref_prms
{   /* Declarations of PoreP29=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP29_radius_p;
MCNUM radius_m = mccPoreP29_radius_m;
MCNUM Z0 = mccPoreP29_Z0;
MCNUM xwidth = mccPoreP29_xwidth;
MCNUM yheight = mccPoreP29_yheight;
MCNUM chamferwidth = mccPoreP29_chamferwidth;
char* mirror_reflec = mccPoreP29_mirror_reflec;
char* bottom_reflec = mccPoreP29_bottom_reflec;
char* side_reflec = mccPoreP29_side_reflec;
MCNUM R_d = mccPoreP29_R_d;
MCNUM absorb_sides = mccPoreP29_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80339 "instruments/plate49.c"
}   /* End of PoreP29=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP30'. */
  SIG_MESSAGE("PoreP30 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP30");
#define mccompcurname  PoreP30
#define mccompcurtype  Pore_p_group
#define mccompcurindex 84
#define nLeft mccPoreP30_nLeft
#define nRight mccPoreP30_nRight
#define nExit mccPoreP30_nExit
#define nTop mccPoreP30_nTop
#define nBottom mccPoreP30_nBottom
#define wLeft mccPoreP30_wLeft
#define wRight mccPoreP30_wRight
#define wExit mccPoreP30_wExit
#define wall mccPoreP30_wall
#define zentry mccPoreP30_zentry
#define reflec_top_table mccPoreP30_reflec_top_table
#define reflec_bottom_table mccPoreP30_reflec_bottom_table
#define reflec_side_table mccPoreP30_reflec_side_table
#define ref_prms mccPoreP30_ref_prms
{   /* Declarations of PoreP30=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP30_radius_p;
MCNUM radius_m = mccPoreP30_radius_m;
MCNUM Z0 = mccPoreP30_Z0;
MCNUM xwidth = mccPoreP30_xwidth;
MCNUM yheight = mccPoreP30_yheight;
MCNUM chamferwidth = mccPoreP30_chamferwidth;
char* mirror_reflec = mccPoreP30_mirror_reflec;
char* bottom_reflec = mccPoreP30_bottom_reflec;
char* side_reflec = mccPoreP30_side_reflec;
MCNUM R_d = mccPoreP30_R_d;
MCNUM absorb_sides = mccPoreP30_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80427 "instruments/plate49.c"
}   /* End of PoreP30=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP31'. */
  SIG_MESSAGE("PoreP31 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP31");
#define mccompcurname  PoreP31
#define mccompcurtype  Pore_p_group
#define mccompcurindex 85
#define nLeft mccPoreP31_nLeft
#define nRight mccPoreP31_nRight
#define nExit mccPoreP31_nExit
#define nTop mccPoreP31_nTop
#define nBottom mccPoreP31_nBottom
#define wLeft mccPoreP31_wLeft
#define wRight mccPoreP31_wRight
#define wExit mccPoreP31_wExit
#define wall mccPoreP31_wall
#define zentry mccPoreP31_zentry
#define reflec_top_table mccPoreP31_reflec_top_table
#define reflec_bottom_table mccPoreP31_reflec_bottom_table
#define reflec_side_table mccPoreP31_reflec_side_table
#define ref_prms mccPoreP31_ref_prms
{   /* Declarations of PoreP31=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP31_radius_p;
MCNUM radius_m = mccPoreP31_radius_m;
MCNUM Z0 = mccPoreP31_Z0;
MCNUM xwidth = mccPoreP31_xwidth;
MCNUM yheight = mccPoreP31_yheight;
MCNUM chamferwidth = mccPoreP31_chamferwidth;
char* mirror_reflec = mccPoreP31_mirror_reflec;
char* bottom_reflec = mccPoreP31_bottom_reflec;
char* side_reflec = mccPoreP31_side_reflec;
MCNUM R_d = mccPoreP31_R_d;
MCNUM absorb_sides = mccPoreP31_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80515 "instruments/plate49.c"
}   /* End of PoreP31=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP32'. */
  SIG_MESSAGE("PoreP32 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP32");
#define mccompcurname  PoreP32
#define mccompcurtype  Pore_p_group
#define mccompcurindex 86
#define nLeft mccPoreP32_nLeft
#define nRight mccPoreP32_nRight
#define nExit mccPoreP32_nExit
#define nTop mccPoreP32_nTop
#define nBottom mccPoreP32_nBottom
#define wLeft mccPoreP32_wLeft
#define wRight mccPoreP32_wRight
#define wExit mccPoreP32_wExit
#define wall mccPoreP32_wall
#define zentry mccPoreP32_zentry
#define reflec_top_table mccPoreP32_reflec_top_table
#define reflec_bottom_table mccPoreP32_reflec_bottom_table
#define reflec_side_table mccPoreP32_reflec_side_table
#define ref_prms mccPoreP32_ref_prms
{   /* Declarations of PoreP32=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP32_radius_p;
MCNUM radius_m = mccPoreP32_radius_m;
MCNUM Z0 = mccPoreP32_Z0;
MCNUM xwidth = mccPoreP32_xwidth;
MCNUM yheight = mccPoreP32_yheight;
MCNUM chamferwidth = mccPoreP32_chamferwidth;
char* mirror_reflec = mccPoreP32_mirror_reflec;
char* bottom_reflec = mccPoreP32_bottom_reflec;
char* side_reflec = mccPoreP32_side_reflec;
MCNUM R_d = mccPoreP32_R_d;
MCNUM absorb_sides = mccPoreP32_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80603 "instruments/plate49.c"
}   /* End of PoreP32=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP33'. */
  SIG_MESSAGE("PoreP33 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP33");
#define mccompcurname  PoreP33
#define mccompcurtype  Pore_p_group
#define mccompcurindex 87
#define nLeft mccPoreP33_nLeft
#define nRight mccPoreP33_nRight
#define nExit mccPoreP33_nExit
#define nTop mccPoreP33_nTop
#define nBottom mccPoreP33_nBottom
#define wLeft mccPoreP33_wLeft
#define wRight mccPoreP33_wRight
#define wExit mccPoreP33_wExit
#define wall mccPoreP33_wall
#define zentry mccPoreP33_zentry
#define reflec_top_table mccPoreP33_reflec_top_table
#define reflec_bottom_table mccPoreP33_reflec_bottom_table
#define reflec_side_table mccPoreP33_reflec_side_table
#define ref_prms mccPoreP33_ref_prms
{   /* Declarations of PoreP33=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP33_radius_p;
MCNUM radius_m = mccPoreP33_radius_m;
MCNUM Z0 = mccPoreP33_Z0;
MCNUM xwidth = mccPoreP33_xwidth;
MCNUM yheight = mccPoreP33_yheight;
MCNUM chamferwidth = mccPoreP33_chamferwidth;
char* mirror_reflec = mccPoreP33_mirror_reflec;
char* bottom_reflec = mccPoreP33_bottom_reflec;
char* side_reflec = mccPoreP33_side_reflec;
MCNUM R_d = mccPoreP33_R_d;
MCNUM absorb_sides = mccPoreP33_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80691 "instruments/plate49.c"
}   /* End of PoreP33=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP34'. */
  SIG_MESSAGE("PoreP34 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP34");
#define mccompcurname  PoreP34
#define mccompcurtype  Pore_p_group
#define mccompcurindex 88
#define nLeft mccPoreP34_nLeft
#define nRight mccPoreP34_nRight
#define nExit mccPoreP34_nExit
#define nTop mccPoreP34_nTop
#define nBottom mccPoreP34_nBottom
#define wLeft mccPoreP34_wLeft
#define wRight mccPoreP34_wRight
#define wExit mccPoreP34_wExit
#define wall mccPoreP34_wall
#define zentry mccPoreP34_zentry
#define reflec_top_table mccPoreP34_reflec_top_table
#define reflec_bottom_table mccPoreP34_reflec_bottom_table
#define reflec_side_table mccPoreP34_reflec_side_table
#define ref_prms mccPoreP34_ref_prms
{   /* Declarations of PoreP34=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP34_radius_p;
MCNUM radius_m = mccPoreP34_radius_m;
MCNUM Z0 = mccPoreP34_Z0;
MCNUM xwidth = mccPoreP34_xwidth;
MCNUM yheight = mccPoreP34_yheight;
MCNUM chamferwidth = mccPoreP34_chamferwidth;
char* mirror_reflec = mccPoreP34_mirror_reflec;
char* bottom_reflec = mccPoreP34_bottom_reflec;
char* side_reflec = mccPoreP34_side_reflec;
MCNUM R_d = mccPoreP34_R_d;
MCNUM absorb_sides = mccPoreP34_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80779 "instruments/plate49.c"
}   /* End of PoreP34=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP35'. */
  SIG_MESSAGE("PoreP35 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP35");
#define mccompcurname  PoreP35
#define mccompcurtype  Pore_p_group
#define mccompcurindex 89
#define nLeft mccPoreP35_nLeft
#define nRight mccPoreP35_nRight
#define nExit mccPoreP35_nExit
#define nTop mccPoreP35_nTop
#define nBottom mccPoreP35_nBottom
#define wLeft mccPoreP35_wLeft
#define wRight mccPoreP35_wRight
#define wExit mccPoreP35_wExit
#define wall mccPoreP35_wall
#define zentry mccPoreP35_zentry
#define reflec_top_table mccPoreP35_reflec_top_table
#define reflec_bottom_table mccPoreP35_reflec_bottom_table
#define reflec_side_table mccPoreP35_reflec_side_table
#define ref_prms mccPoreP35_ref_prms
{   /* Declarations of PoreP35=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP35_radius_p;
MCNUM radius_m = mccPoreP35_radius_m;
MCNUM Z0 = mccPoreP35_Z0;
MCNUM xwidth = mccPoreP35_xwidth;
MCNUM yheight = mccPoreP35_yheight;
MCNUM chamferwidth = mccPoreP35_chamferwidth;
char* mirror_reflec = mccPoreP35_mirror_reflec;
char* bottom_reflec = mccPoreP35_bottom_reflec;
char* side_reflec = mccPoreP35_side_reflec;
MCNUM R_d = mccPoreP35_R_d;
MCNUM absorb_sides = mccPoreP35_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80867 "instruments/plate49.c"
}   /* End of PoreP35=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP36'. */
  SIG_MESSAGE("PoreP36 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP36");
#define mccompcurname  PoreP36
#define mccompcurtype  Pore_p_group
#define mccompcurindex 90
#define nLeft mccPoreP36_nLeft
#define nRight mccPoreP36_nRight
#define nExit mccPoreP36_nExit
#define nTop mccPoreP36_nTop
#define nBottom mccPoreP36_nBottom
#define wLeft mccPoreP36_wLeft
#define wRight mccPoreP36_wRight
#define wExit mccPoreP36_wExit
#define wall mccPoreP36_wall
#define zentry mccPoreP36_zentry
#define reflec_top_table mccPoreP36_reflec_top_table
#define reflec_bottom_table mccPoreP36_reflec_bottom_table
#define reflec_side_table mccPoreP36_reflec_side_table
#define ref_prms mccPoreP36_ref_prms
{   /* Declarations of PoreP36=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP36_radius_p;
MCNUM radius_m = mccPoreP36_radius_m;
MCNUM Z0 = mccPoreP36_Z0;
MCNUM xwidth = mccPoreP36_xwidth;
MCNUM yheight = mccPoreP36_yheight;
MCNUM chamferwidth = mccPoreP36_chamferwidth;
char* mirror_reflec = mccPoreP36_mirror_reflec;
char* bottom_reflec = mccPoreP36_bottom_reflec;
char* side_reflec = mccPoreP36_side_reflec;
MCNUM R_d = mccPoreP36_R_d;
MCNUM absorb_sides = mccPoreP36_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 80955 "instruments/plate49.c"
}   /* End of PoreP36=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP37'. */
  SIG_MESSAGE("PoreP37 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP37");
#define mccompcurname  PoreP37
#define mccompcurtype  Pore_p_group
#define mccompcurindex 91
#define nLeft mccPoreP37_nLeft
#define nRight mccPoreP37_nRight
#define nExit mccPoreP37_nExit
#define nTop mccPoreP37_nTop
#define nBottom mccPoreP37_nBottom
#define wLeft mccPoreP37_wLeft
#define wRight mccPoreP37_wRight
#define wExit mccPoreP37_wExit
#define wall mccPoreP37_wall
#define zentry mccPoreP37_zentry
#define reflec_top_table mccPoreP37_reflec_top_table
#define reflec_bottom_table mccPoreP37_reflec_bottom_table
#define reflec_side_table mccPoreP37_reflec_side_table
#define ref_prms mccPoreP37_ref_prms
{   /* Declarations of PoreP37=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP37_radius_p;
MCNUM radius_m = mccPoreP37_radius_m;
MCNUM Z0 = mccPoreP37_Z0;
MCNUM xwidth = mccPoreP37_xwidth;
MCNUM yheight = mccPoreP37_yheight;
MCNUM chamferwidth = mccPoreP37_chamferwidth;
char* mirror_reflec = mccPoreP37_mirror_reflec;
char* bottom_reflec = mccPoreP37_bottom_reflec;
char* side_reflec = mccPoreP37_side_reflec;
MCNUM R_d = mccPoreP37_R_d;
MCNUM absorb_sides = mccPoreP37_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81043 "instruments/plate49.c"
}   /* End of PoreP37=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP38'. */
  SIG_MESSAGE("PoreP38 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP38");
#define mccompcurname  PoreP38
#define mccompcurtype  Pore_p_group
#define mccompcurindex 92
#define nLeft mccPoreP38_nLeft
#define nRight mccPoreP38_nRight
#define nExit mccPoreP38_nExit
#define nTop mccPoreP38_nTop
#define nBottom mccPoreP38_nBottom
#define wLeft mccPoreP38_wLeft
#define wRight mccPoreP38_wRight
#define wExit mccPoreP38_wExit
#define wall mccPoreP38_wall
#define zentry mccPoreP38_zentry
#define reflec_top_table mccPoreP38_reflec_top_table
#define reflec_bottom_table mccPoreP38_reflec_bottom_table
#define reflec_side_table mccPoreP38_reflec_side_table
#define ref_prms mccPoreP38_ref_prms
{   /* Declarations of PoreP38=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP38_radius_p;
MCNUM radius_m = mccPoreP38_radius_m;
MCNUM Z0 = mccPoreP38_Z0;
MCNUM xwidth = mccPoreP38_xwidth;
MCNUM yheight = mccPoreP38_yheight;
MCNUM chamferwidth = mccPoreP38_chamferwidth;
char* mirror_reflec = mccPoreP38_mirror_reflec;
char* bottom_reflec = mccPoreP38_bottom_reflec;
char* side_reflec = mccPoreP38_side_reflec;
MCNUM R_d = mccPoreP38_R_d;
MCNUM absorb_sides = mccPoreP38_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81131 "instruments/plate49.c"
}   /* End of PoreP38=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP39'. */
  SIG_MESSAGE("PoreP39 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP39");
#define mccompcurname  PoreP39
#define mccompcurtype  Pore_p_group
#define mccompcurindex 93
#define nLeft mccPoreP39_nLeft
#define nRight mccPoreP39_nRight
#define nExit mccPoreP39_nExit
#define nTop mccPoreP39_nTop
#define nBottom mccPoreP39_nBottom
#define wLeft mccPoreP39_wLeft
#define wRight mccPoreP39_wRight
#define wExit mccPoreP39_wExit
#define wall mccPoreP39_wall
#define zentry mccPoreP39_zentry
#define reflec_top_table mccPoreP39_reflec_top_table
#define reflec_bottom_table mccPoreP39_reflec_bottom_table
#define reflec_side_table mccPoreP39_reflec_side_table
#define ref_prms mccPoreP39_ref_prms
{   /* Declarations of PoreP39=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP39_radius_p;
MCNUM radius_m = mccPoreP39_radius_m;
MCNUM Z0 = mccPoreP39_Z0;
MCNUM xwidth = mccPoreP39_xwidth;
MCNUM yheight = mccPoreP39_yheight;
MCNUM chamferwidth = mccPoreP39_chamferwidth;
char* mirror_reflec = mccPoreP39_mirror_reflec;
char* bottom_reflec = mccPoreP39_bottom_reflec;
char* side_reflec = mccPoreP39_side_reflec;
MCNUM R_d = mccPoreP39_R_d;
MCNUM absorb_sides = mccPoreP39_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81219 "instruments/plate49.c"
}   /* End of PoreP39=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP40'. */
  SIG_MESSAGE("PoreP40 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP40");
#define mccompcurname  PoreP40
#define mccompcurtype  Pore_p_group
#define mccompcurindex 94
#define nLeft mccPoreP40_nLeft
#define nRight mccPoreP40_nRight
#define nExit mccPoreP40_nExit
#define nTop mccPoreP40_nTop
#define nBottom mccPoreP40_nBottom
#define wLeft mccPoreP40_wLeft
#define wRight mccPoreP40_wRight
#define wExit mccPoreP40_wExit
#define wall mccPoreP40_wall
#define zentry mccPoreP40_zentry
#define reflec_top_table mccPoreP40_reflec_top_table
#define reflec_bottom_table mccPoreP40_reflec_bottom_table
#define reflec_side_table mccPoreP40_reflec_side_table
#define ref_prms mccPoreP40_ref_prms
{   /* Declarations of PoreP40=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP40_radius_p;
MCNUM radius_m = mccPoreP40_radius_m;
MCNUM Z0 = mccPoreP40_Z0;
MCNUM xwidth = mccPoreP40_xwidth;
MCNUM yheight = mccPoreP40_yheight;
MCNUM chamferwidth = mccPoreP40_chamferwidth;
char* mirror_reflec = mccPoreP40_mirror_reflec;
char* bottom_reflec = mccPoreP40_bottom_reflec;
char* side_reflec = mccPoreP40_side_reflec;
MCNUM R_d = mccPoreP40_R_d;
MCNUM absorb_sides = mccPoreP40_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81307 "instruments/plate49.c"
}   /* End of PoreP40=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP41'. */
  SIG_MESSAGE("PoreP41 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP41");
#define mccompcurname  PoreP41
#define mccompcurtype  Pore_p_group
#define mccompcurindex 95
#define nLeft mccPoreP41_nLeft
#define nRight mccPoreP41_nRight
#define nExit mccPoreP41_nExit
#define nTop mccPoreP41_nTop
#define nBottom mccPoreP41_nBottom
#define wLeft mccPoreP41_wLeft
#define wRight mccPoreP41_wRight
#define wExit mccPoreP41_wExit
#define wall mccPoreP41_wall
#define zentry mccPoreP41_zentry
#define reflec_top_table mccPoreP41_reflec_top_table
#define reflec_bottom_table mccPoreP41_reflec_bottom_table
#define reflec_side_table mccPoreP41_reflec_side_table
#define ref_prms mccPoreP41_ref_prms
{   /* Declarations of PoreP41=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP41_radius_p;
MCNUM radius_m = mccPoreP41_radius_m;
MCNUM Z0 = mccPoreP41_Z0;
MCNUM xwidth = mccPoreP41_xwidth;
MCNUM yheight = mccPoreP41_yheight;
MCNUM chamferwidth = mccPoreP41_chamferwidth;
char* mirror_reflec = mccPoreP41_mirror_reflec;
char* bottom_reflec = mccPoreP41_bottom_reflec;
char* side_reflec = mccPoreP41_side_reflec;
MCNUM R_d = mccPoreP41_R_d;
MCNUM absorb_sides = mccPoreP41_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81395 "instruments/plate49.c"
}   /* End of PoreP41=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP42'. */
  SIG_MESSAGE("PoreP42 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP42");
#define mccompcurname  PoreP42
#define mccompcurtype  Pore_p_group
#define mccompcurindex 96
#define nLeft mccPoreP42_nLeft
#define nRight mccPoreP42_nRight
#define nExit mccPoreP42_nExit
#define nTop mccPoreP42_nTop
#define nBottom mccPoreP42_nBottom
#define wLeft mccPoreP42_wLeft
#define wRight mccPoreP42_wRight
#define wExit mccPoreP42_wExit
#define wall mccPoreP42_wall
#define zentry mccPoreP42_zentry
#define reflec_top_table mccPoreP42_reflec_top_table
#define reflec_bottom_table mccPoreP42_reflec_bottom_table
#define reflec_side_table mccPoreP42_reflec_side_table
#define ref_prms mccPoreP42_ref_prms
{   /* Declarations of PoreP42=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP42_radius_p;
MCNUM radius_m = mccPoreP42_radius_m;
MCNUM Z0 = mccPoreP42_Z0;
MCNUM xwidth = mccPoreP42_xwidth;
MCNUM yheight = mccPoreP42_yheight;
MCNUM chamferwidth = mccPoreP42_chamferwidth;
char* mirror_reflec = mccPoreP42_mirror_reflec;
char* bottom_reflec = mccPoreP42_bottom_reflec;
char* side_reflec = mccPoreP42_side_reflec;
MCNUM R_d = mccPoreP42_R_d;
MCNUM absorb_sides = mccPoreP42_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81483 "instruments/plate49.c"
}   /* End of PoreP42=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP43'. */
  SIG_MESSAGE("PoreP43 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP43");
#define mccompcurname  PoreP43
#define mccompcurtype  Pore_p_group
#define mccompcurindex 97
#define nLeft mccPoreP43_nLeft
#define nRight mccPoreP43_nRight
#define nExit mccPoreP43_nExit
#define nTop mccPoreP43_nTop
#define nBottom mccPoreP43_nBottom
#define wLeft mccPoreP43_wLeft
#define wRight mccPoreP43_wRight
#define wExit mccPoreP43_wExit
#define wall mccPoreP43_wall
#define zentry mccPoreP43_zentry
#define reflec_top_table mccPoreP43_reflec_top_table
#define reflec_bottom_table mccPoreP43_reflec_bottom_table
#define reflec_side_table mccPoreP43_reflec_side_table
#define ref_prms mccPoreP43_ref_prms
{   /* Declarations of PoreP43=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP43_radius_p;
MCNUM radius_m = mccPoreP43_radius_m;
MCNUM Z0 = mccPoreP43_Z0;
MCNUM xwidth = mccPoreP43_xwidth;
MCNUM yheight = mccPoreP43_yheight;
MCNUM chamferwidth = mccPoreP43_chamferwidth;
char* mirror_reflec = mccPoreP43_mirror_reflec;
char* bottom_reflec = mccPoreP43_bottom_reflec;
char* side_reflec = mccPoreP43_side_reflec;
MCNUM R_d = mccPoreP43_R_d;
MCNUM absorb_sides = mccPoreP43_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81571 "instruments/plate49.c"
}   /* End of PoreP43=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP44'. */
  SIG_MESSAGE("PoreP44 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP44");
#define mccompcurname  PoreP44
#define mccompcurtype  Pore_p_group
#define mccompcurindex 98
#define nLeft mccPoreP44_nLeft
#define nRight mccPoreP44_nRight
#define nExit mccPoreP44_nExit
#define nTop mccPoreP44_nTop
#define nBottom mccPoreP44_nBottom
#define wLeft mccPoreP44_wLeft
#define wRight mccPoreP44_wRight
#define wExit mccPoreP44_wExit
#define wall mccPoreP44_wall
#define zentry mccPoreP44_zentry
#define reflec_top_table mccPoreP44_reflec_top_table
#define reflec_bottom_table mccPoreP44_reflec_bottom_table
#define reflec_side_table mccPoreP44_reflec_side_table
#define ref_prms mccPoreP44_ref_prms
{   /* Declarations of PoreP44=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP44_radius_p;
MCNUM radius_m = mccPoreP44_radius_m;
MCNUM Z0 = mccPoreP44_Z0;
MCNUM xwidth = mccPoreP44_xwidth;
MCNUM yheight = mccPoreP44_yheight;
MCNUM chamferwidth = mccPoreP44_chamferwidth;
char* mirror_reflec = mccPoreP44_mirror_reflec;
char* bottom_reflec = mccPoreP44_bottom_reflec;
char* side_reflec = mccPoreP44_side_reflec;
MCNUM R_d = mccPoreP44_R_d;
MCNUM absorb_sides = mccPoreP44_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81659 "instruments/plate49.c"
}   /* End of PoreP44=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP45'. */
  SIG_MESSAGE("PoreP45 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP45");
#define mccompcurname  PoreP45
#define mccompcurtype  Pore_p_group
#define mccompcurindex 99
#define nLeft mccPoreP45_nLeft
#define nRight mccPoreP45_nRight
#define nExit mccPoreP45_nExit
#define nTop mccPoreP45_nTop
#define nBottom mccPoreP45_nBottom
#define wLeft mccPoreP45_wLeft
#define wRight mccPoreP45_wRight
#define wExit mccPoreP45_wExit
#define wall mccPoreP45_wall
#define zentry mccPoreP45_zentry
#define reflec_top_table mccPoreP45_reflec_top_table
#define reflec_bottom_table mccPoreP45_reflec_bottom_table
#define reflec_side_table mccPoreP45_reflec_side_table
#define ref_prms mccPoreP45_ref_prms
{   /* Declarations of PoreP45=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP45_radius_p;
MCNUM radius_m = mccPoreP45_radius_m;
MCNUM Z0 = mccPoreP45_Z0;
MCNUM xwidth = mccPoreP45_xwidth;
MCNUM yheight = mccPoreP45_yheight;
MCNUM chamferwidth = mccPoreP45_chamferwidth;
char* mirror_reflec = mccPoreP45_mirror_reflec;
char* bottom_reflec = mccPoreP45_bottom_reflec;
char* side_reflec = mccPoreP45_side_reflec;
MCNUM R_d = mccPoreP45_R_d;
MCNUM absorb_sides = mccPoreP45_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81747 "instruments/plate49.c"
}   /* End of PoreP45=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP46'. */
  SIG_MESSAGE("PoreP46 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP46");
#define mccompcurname  PoreP46
#define mccompcurtype  Pore_p_group
#define mccompcurindex 100
#define nLeft mccPoreP46_nLeft
#define nRight mccPoreP46_nRight
#define nExit mccPoreP46_nExit
#define nTop mccPoreP46_nTop
#define nBottom mccPoreP46_nBottom
#define wLeft mccPoreP46_wLeft
#define wRight mccPoreP46_wRight
#define wExit mccPoreP46_wExit
#define wall mccPoreP46_wall
#define zentry mccPoreP46_zentry
#define reflec_top_table mccPoreP46_reflec_top_table
#define reflec_bottom_table mccPoreP46_reflec_bottom_table
#define reflec_side_table mccPoreP46_reflec_side_table
#define ref_prms mccPoreP46_ref_prms
{   /* Declarations of PoreP46=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP46_radius_p;
MCNUM radius_m = mccPoreP46_radius_m;
MCNUM Z0 = mccPoreP46_Z0;
MCNUM xwidth = mccPoreP46_xwidth;
MCNUM yheight = mccPoreP46_yheight;
MCNUM chamferwidth = mccPoreP46_chamferwidth;
char* mirror_reflec = mccPoreP46_mirror_reflec;
char* bottom_reflec = mccPoreP46_bottom_reflec;
char* side_reflec = mccPoreP46_side_reflec;
MCNUM R_d = mccPoreP46_R_d;
MCNUM absorb_sides = mccPoreP46_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81835 "instruments/plate49.c"
}   /* End of PoreP46=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP47'. */
  SIG_MESSAGE("PoreP47 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP47");
#define mccompcurname  PoreP47
#define mccompcurtype  Pore_p_group
#define mccompcurindex 101
#define nLeft mccPoreP47_nLeft
#define nRight mccPoreP47_nRight
#define nExit mccPoreP47_nExit
#define nTop mccPoreP47_nTop
#define nBottom mccPoreP47_nBottom
#define wLeft mccPoreP47_wLeft
#define wRight mccPoreP47_wRight
#define wExit mccPoreP47_wExit
#define wall mccPoreP47_wall
#define zentry mccPoreP47_zentry
#define reflec_top_table mccPoreP47_reflec_top_table
#define reflec_bottom_table mccPoreP47_reflec_bottom_table
#define reflec_side_table mccPoreP47_reflec_side_table
#define ref_prms mccPoreP47_ref_prms
{   /* Declarations of PoreP47=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP47_radius_p;
MCNUM radius_m = mccPoreP47_radius_m;
MCNUM Z0 = mccPoreP47_Z0;
MCNUM xwidth = mccPoreP47_xwidth;
MCNUM yheight = mccPoreP47_yheight;
MCNUM chamferwidth = mccPoreP47_chamferwidth;
char* mirror_reflec = mccPoreP47_mirror_reflec;
char* bottom_reflec = mccPoreP47_bottom_reflec;
char* side_reflec = mccPoreP47_side_reflec;
MCNUM R_d = mccPoreP47_R_d;
MCNUM absorb_sides = mccPoreP47_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 81923 "instruments/plate49.c"
}   /* End of PoreP47=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreP48'. */
  SIG_MESSAGE("PoreP48 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreP48");
#define mccompcurname  PoreP48
#define mccompcurtype  Pore_p_group
#define mccompcurindex 102
#define nLeft mccPoreP48_nLeft
#define nRight mccPoreP48_nRight
#define nExit mccPoreP48_nExit
#define nTop mccPoreP48_nTop
#define nBottom mccPoreP48_nBottom
#define wLeft mccPoreP48_wLeft
#define wRight mccPoreP48_wRight
#define wExit mccPoreP48_wExit
#define wall mccPoreP48_wall
#define zentry mccPoreP48_zentry
#define reflec_top_table mccPoreP48_reflec_top_table
#define reflec_bottom_table mccPoreP48_reflec_bottom_table
#define reflec_side_table mccPoreP48_reflec_side_table
#define ref_prms mccPoreP48_ref_prms
{   /* Declarations of PoreP48=Pore_p_group() SETTING parameters. */
MCNUM radius_p = mccPoreP48_radius_p;
MCNUM radius_m = mccPoreP48_radius_m;
MCNUM Z0 = mccPoreP48_Z0;
MCNUM xwidth = mccPoreP48_xwidth;
MCNUM yheight = mccPoreP48_yheight;
MCNUM chamferwidth = mccPoreP48_chamferwidth;
char* mirror_reflec = mccPoreP48_mirror_reflec;
char* bottom_reflec = mccPoreP48_bottom_reflec;
char* side_reflec = mccPoreP48_side_reflec;
MCNUM R_d = mccPoreP48_R_d;
MCNUM absorb_sides = mccPoreP48_absorb_sides;
#line 368 "Pore_p_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_m,inner_p;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_p=radius_p-yheight;

    magnify("");
    line(0,0,0, 0,radius_p-radius_m,zentry); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry,  sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);
    line(-sin(theta)*radius_p, cos(theta)*radius_p-radius_m, zentry, -sin(theta)*inner_p, cos(theta)*inner_p-radius_m, zentry);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_p, cos(t0)*radius_p-radius_m, zentry, sin(t1)*radius_p, cos(t1)*radius_p-radius_m, zentry);
        line( sin(t0)*inner_p, cos(t0)*inner_p-radius_m, zentry, sin(t1)*inner_p, cos(t1)*inner_p-radius_m, zentry);
    }


}
#line 82011 "instruments/plate49.c"
}   /* End of PoreP48=Pore_p_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_side_table
#undef reflec_bottom_table
#undef reflec_top_table
#undef zentry
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nBottom
#undef nTop
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH0'. */
  SIG_MESSAGE("PoreH0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH0");
#define mccompcurname  PoreH0
#define mccompcurtype  Pore_h_group
#define mccompcurindex 103
#define nLeft mccPoreH0_nLeft
#define nRight mccPoreH0_nRight
#define nExit mccPoreH0_nExit
#define wLeft mccPoreH0_wLeft
#define wRight mccPoreH0_wRight
#define wExit mccPoreH0_wExit
#define wall mccPoreH0_wall
#define nTop mccPoreH0_nTop
#define nBottom mccPoreH0_nBottom
#define zexit mccPoreH0_zexit
#define zentry mccPoreH0_zentry
#define intersect_wolterI mccPoreH0_intersect_wolterI
#define reflec_side_table mccPoreH0_reflec_side_table
#define reflec_top_table mccPoreH0_reflec_top_table
#define reflec_bottom_table mccPoreH0_reflec_bottom_table
#define ref_prms mccPoreH0_ref_prms
{   /* Declarations of PoreH0=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH0_radius_m;
MCNUM radius_h = mccPoreH0_radius_h;
MCNUM Z0 = mccPoreH0_Z0;
MCNUM xwidth = mccPoreH0_xwidth;
MCNUM yheight = mccPoreH0_yheight;
MCNUM chamferwidth = mccPoreH0_chamferwidth;
char* mirror_reflec = mccPoreH0_mirror_reflec;
char* bottom_reflec = mccPoreH0_bottom_reflec;
char* side_reflec = mccPoreH0_side_reflec;
MCNUM R_d = mccPoreH0_R_d;
MCNUM absorb_sides = mccPoreH0_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82100 "instruments/plate49.c"
}   /* End of PoreH0=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH1'. */
  SIG_MESSAGE("PoreH1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH1");
#define mccompcurname  PoreH1
#define mccompcurtype  Pore_h_group
#define mccompcurindex 104
#define nLeft mccPoreH1_nLeft
#define nRight mccPoreH1_nRight
#define nExit mccPoreH1_nExit
#define wLeft mccPoreH1_wLeft
#define wRight mccPoreH1_wRight
#define wExit mccPoreH1_wExit
#define wall mccPoreH1_wall
#define nTop mccPoreH1_nTop
#define nBottom mccPoreH1_nBottom
#define zexit mccPoreH1_zexit
#define zentry mccPoreH1_zentry
#define intersect_wolterI mccPoreH1_intersect_wolterI
#define reflec_side_table mccPoreH1_reflec_side_table
#define reflec_top_table mccPoreH1_reflec_top_table
#define reflec_bottom_table mccPoreH1_reflec_bottom_table
#define ref_prms mccPoreH1_ref_prms
{   /* Declarations of PoreH1=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH1_radius_m;
MCNUM radius_h = mccPoreH1_radius_h;
MCNUM Z0 = mccPoreH1_Z0;
MCNUM xwidth = mccPoreH1_xwidth;
MCNUM yheight = mccPoreH1_yheight;
MCNUM chamferwidth = mccPoreH1_chamferwidth;
char* mirror_reflec = mccPoreH1_mirror_reflec;
char* bottom_reflec = mccPoreH1_bottom_reflec;
char* side_reflec = mccPoreH1_side_reflec;
MCNUM R_d = mccPoreH1_R_d;
MCNUM absorb_sides = mccPoreH1_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82191 "instruments/plate49.c"
}   /* End of PoreH1=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH2'. */
  SIG_MESSAGE("PoreH2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH2");
#define mccompcurname  PoreH2
#define mccompcurtype  Pore_h_group
#define mccompcurindex 105
#define nLeft mccPoreH2_nLeft
#define nRight mccPoreH2_nRight
#define nExit mccPoreH2_nExit
#define wLeft mccPoreH2_wLeft
#define wRight mccPoreH2_wRight
#define wExit mccPoreH2_wExit
#define wall mccPoreH2_wall
#define nTop mccPoreH2_nTop
#define nBottom mccPoreH2_nBottom
#define zexit mccPoreH2_zexit
#define zentry mccPoreH2_zentry
#define intersect_wolterI mccPoreH2_intersect_wolterI
#define reflec_side_table mccPoreH2_reflec_side_table
#define reflec_top_table mccPoreH2_reflec_top_table
#define reflec_bottom_table mccPoreH2_reflec_bottom_table
#define ref_prms mccPoreH2_ref_prms
{   /* Declarations of PoreH2=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH2_radius_m;
MCNUM radius_h = mccPoreH2_radius_h;
MCNUM Z0 = mccPoreH2_Z0;
MCNUM xwidth = mccPoreH2_xwidth;
MCNUM yheight = mccPoreH2_yheight;
MCNUM chamferwidth = mccPoreH2_chamferwidth;
char* mirror_reflec = mccPoreH2_mirror_reflec;
char* bottom_reflec = mccPoreH2_bottom_reflec;
char* side_reflec = mccPoreH2_side_reflec;
MCNUM R_d = mccPoreH2_R_d;
MCNUM absorb_sides = mccPoreH2_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82282 "instruments/plate49.c"
}   /* End of PoreH2=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH3'. */
  SIG_MESSAGE("PoreH3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH3");
#define mccompcurname  PoreH3
#define mccompcurtype  Pore_h_group
#define mccompcurindex 106
#define nLeft mccPoreH3_nLeft
#define nRight mccPoreH3_nRight
#define nExit mccPoreH3_nExit
#define wLeft mccPoreH3_wLeft
#define wRight mccPoreH3_wRight
#define wExit mccPoreH3_wExit
#define wall mccPoreH3_wall
#define nTop mccPoreH3_nTop
#define nBottom mccPoreH3_nBottom
#define zexit mccPoreH3_zexit
#define zentry mccPoreH3_zentry
#define intersect_wolterI mccPoreH3_intersect_wolterI
#define reflec_side_table mccPoreH3_reflec_side_table
#define reflec_top_table mccPoreH3_reflec_top_table
#define reflec_bottom_table mccPoreH3_reflec_bottom_table
#define ref_prms mccPoreH3_ref_prms
{   /* Declarations of PoreH3=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH3_radius_m;
MCNUM radius_h = mccPoreH3_radius_h;
MCNUM Z0 = mccPoreH3_Z0;
MCNUM xwidth = mccPoreH3_xwidth;
MCNUM yheight = mccPoreH3_yheight;
MCNUM chamferwidth = mccPoreH3_chamferwidth;
char* mirror_reflec = mccPoreH3_mirror_reflec;
char* bottom_reflec = mccPoreH3_bottom_reflec;
char* side_reflec = mccPoreH3_side_reflec;
MCNUM R_d = mccPoreH3_R_d;
MCNUM absorb_sides = mccPoreH3_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82373 "instruments/plate49.c"
}   /* End of PoreH3=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH4'. */
  SIG_MESSAGE("PoreH4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH4");
#define mccompcurname  PoreH4
#define mccompcurtype  Pore_h_group
#define mccompcurindex 107
#define nLeft mccPoreH4_nLeft
#define nRight mccPoreH4_nRight
#define nExit mccPoreH4_nExit
#define wLeft mccPoreH4_wLeft
#define wRight mccPoreH4_wRight
#define wExit mccPoreH4_wExit
#define wall mccPoreH4_wall
#define nTop mccPoreH4_nTop
#define nBottom mccPoreH4_nBottom
#define zexit mccPoreH4_zexit
#define zentry mccPoreH4_zentry
#define intersect_wolterI mccPoreH4_intersect_wolterI
#define reflec_side_table mccPoreH4_reflec_side_table
#define reflec_top_table mccPoreH4_reflec_top_table
#define reflec_bottom_table mccPoreH4_reflec_bottom_table
#define ref_prms mccPoreH4_ref_prms
{   /* Declarations of PoreH4=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH4_radius_m;
MCNUM radius_h = mccPoreH4_radius_h;
MCNUM Z0 = mccPoreH4_Z0;
MCNUM xwidth = mccPoreH4_xwidth;
MCNUM yheight = mccPoreH4_yheight;
MCNUM chamferwidth = mccPoreH4_chamferwidth;
char* mirror_reflec = mccPoreH4_mirror_reflec;
char* bottom_reflec = mccPoreH4_bottom_reflec;
char* side_reflec = mccPoreH4_side_reflec;
MCNUM R_d = mccPoreH4_R_d;
MCNUM absorb_sides = mccPoreH4_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82464 "instruments/plate49.c"
}   /* End of PoreH4=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH5'. */
  SIG_MESSAGE("PoreH5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH5");
#define mccompcurname  PoreH5
#define mccompcurtype  Pore_h_group
#define mccompcurindex 108
#define nLeft mccPoreH5_nLeft
#define nRight mccPoreH5_nRight
#define nExit mccPoreH5_nExit
#define wLeft mccPoreH5_wLeft
#define wRight mccPoreH5_wRight
#define wExit mccPoreH5_wExit
#define wall mccPoreH5_wall
#define nTop mccPoreH5_nTop
#define nBottom mccPoreH5_nBottom
#define zexit mccPoreH5_zexit
#define zentry mccPoreH5_zentry
#define intersect_wolterI mccPoreH5_intersect_wolterI
#define reflec_side_table mccPoreH5_reflec_side_table
#define reflec_top_table mccPoreH5_reflec_top_table
#define reflec_bottom_table mccPoreH5_reflec_bottom_table
#define ref_prms mccPoreH5_ref_prms
{   /* Declarations of PoreH5=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH5_radius_m;
MCNUM radius_h = mccPoreH5_radius_h;
MCNUM Z0 = mccPoreH5_Z0;
MCNUM xwidth = mccPoreH5_xwidth;
MCNUM yheight = mccPoreH5_yheight;
MCNUM chamferwidth = mccPoreH5_chamferwidth;
char* mirror_reflec = mccPoreH5_mirror_reflec;
char* bottom_reflec = mccPoreH5_bottom_reflec;
char* side_reflec = mccPoreH5_side_reflec;
MCNUM R_d = mccPoreH5_R_d;
MCNUM absorb_sides = mccPoreH5_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82555 "instruments/plate49.c"
}   /* End of PoreH5=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH6'. */
  SIG_MESSAGE("PoreH6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH6");
#define mccompcurname  PoreH6
#define mccompcurtype  Pore_h_group
#define mccompcurindex 109
#define nLeft mccPoreH6_nLeft
#define nRight mccPoreH6_nRight
#define nExit mccPoreH6_nExit
#define wLeft mccPoreH6_wLeft
#define wRight mccPoreH6_wRight
#define wExit mccPoreH6_wExit
#define wall mccPoreH6_wall
#define nTop mccPoreH6_nTop
#define nBottom mccPoreH6_nBottom
#define zexit mccPoreH6_zexit
#define zentry mccPoreH6_zentry
#define intersect_wolterI mccPoreH6_intersect_wolterI
#define reflec_side_table mccPoreH6_reflec_side_table
#define reflec_top_table mccPoreH6_reflec_top_table
#define reflec_bottom_table mccPoreH6_reflec_bottom_table
#define ref_prms mccPoreH6_ref_prms
{   /* Declarations of PoreH6=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH6_radius_m;
MCNUM radius_h = mccPoreH6_radius_h;
MCNUM Z0 = mccPoreH6_Z0;
MCNUM xwidth = mccPoreH6_xwidth;
MCNUM yheight = mccPoreH6_yheight;
MCNUM chamferwidth = mccPoreH6_chamferwidth;
char* mirror_reflec = mccPoreH6_mirror_reflec;
char* bottom_reflec = mccPoreH6_bottom_reflec;
char* side_reflec = mccPoreH6_side_reflec;
MCNUM R_d = mccPoreH6_R_d;
MCNUM absorb_sides = mccPoreH6_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82646 "instruments/plate49.c"
}   /* End of PoreH6=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH7'. */
  SIG_MESSAGE("PoreH7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH7");
#define mccompcurname  PoreH7
#define mccompcurtype  Pore_h_group
#define mccompcurindex 110
#define nLeft mccPoreH7_nLeft
#define nRight mccPoreH7_nRight
#define nExit mccPoreH7_nExit
#define wLeft mccPoreH7_wLeft
#define wRight mccPoreH7_wRight
#define wExit mccPoreH7_wExit
#define wall mccPoreH7_wall
#define nTop mccPoreH7_nTop
#define nBottom mccPoreH7_nBottom
#define zexit mccPoreH7_zexit
#define zentry mccPoreH7_zentry
#define intersect_wolterI mccPoreH7_intersect_wolterI
#define reflec_side_table mccPoreH7_reflec_side_table
#define reflec_top_table mccPoreH7_reflec_top_table
#define reflec_bottom_table mccPoreH7_reflec_bottom_table
#define ref_prms mccPoreH7_ref_prms
{   /* Declarations of PoreH7=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH7_radius_m;
MCNUM radius_h = mccPoreH7_radius_h;
MCNUM Z0 = mccPoreH7_Z0;
MCNUM xwidth = mccPoreH7_xwidth;
MCNUM yheight = mccPoreH7_yheight;
MCNUM chamferwidth = mccPoreH7_chamferwidth;
char* mirror_reflec = mccPoreH7_mirror_reflec;
char* bottom_reflec = mccPoreH7_bottom_reflec;
char* side_reflec = mccPoreH7_side_reflec;
MCNUM R_d = mccPoreH7_R_d;
MCNUM absorb_sides = mccPoreH7_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82737 "instruments/plate49.c"
}   /* End of PoreH7=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH8'. */
  SIG_MESSAGE("PoreH8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH8");
#define mccompcurname  PoreH8
#define mccompcurtype  Pore_h_group
#define mccompcurindex 111
#define nLeft mccPoreH8_nLeft
#define nRight mccPoreH8_nRight
#define nExit mccPoreH8_nExit
#define wLeft mccPoreH8_wLeft
#define wRight mccPoreH8_wRight
#define wExit mccPoreH8_wExit
#define wall mccPoreH8_wall
#define nTop mccPoreH8_nTop
#define nBottom mccPoreH8_nBottom
#define zexit mccPoreH8_zexit
#define zentry mccPoreH8_zentry
#define intersect_wolterI mccPoreH8_intersect_wolterI
#define reflec_side_table mccPoreH8_reflec_side_table
#define reflec_top_table mccPoreH8_reflec_top_table
#define reflec_bottom_table mccPoreH8_reflec_bottom_table
#define ref_prms mccPoreH8_ref_prms
{   /* Declarations of PoreH8=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH8_radius_m;
MCNUM radius_h = mccPoreH8_radius_h;
MCNUM Z0 = mccPoreH8_Z0;
MCNUM xwidth = mccPoreH8_xwidth;
MCNUM yheight = mccPoreH8_yheight;
MCNUM chamferwidth = mccPoreH8_chamferwidth;
char* mirror_reflec = mccPoreH8_mirror_reflec;
char* bottom_reflec = mccPoreH8_bottom_reflec;
char* side_reflec = mccPoreH8_side_reflec;
MCNUM R_d = mccPoreH8_R_d;
MCNUM absorb_sides = mccPoreH8_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82828 "instruments/plate49.c"
}   /* End of PoreH8=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH9'. */
  SIG_MESSAGE("PoreH9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH9");
#define mccompcurname  PoreH9
#define mccompcurtype  Pore_h_group
#define mccompcurindex 112
#define nLeft mccPoreH9_nLeft
#define nRight mccPoreH9_nRight
#define nExit mccPoreH9_nExit
#define wLeft mccPoreH9_wLeft
#define wRight mccPoreH9_wRight
#define wExit mccPoreH9_wExit
#define wall mccPoreH9_wall
#define nTop mccPoreH9_nTop
#define nBottom mccPoreH9_nBottom
#define zexit mccPoreH9_zexit
#define zentry mccPoreH9_zentry
#define intersect_wolterI mccPoreH9_intersect_wolterI
#define reflec_side_table mccPoreH9_reflec_side_table
#define reflec_top_table mccPoreH9_reflec_top_table
#define reflec_bottom_table mccPoreH9_reflec_bottom_table
#define ref_prms mccPoreH9_ref_prms
{   /* Declarations of PoreH9=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH9_radius_m;
MCNUM radius_h = mccPoreH9_radius_h;
MCNUM Z0 = mccPoreH9_Z0;
MCNUM xwidth = mccPoreH9_xwidth;
MCNUM yheight = mccPoreH9_yheight;
MCNUM chamferwidth = mccPoreH9_chamferwidth;
char* mirror_reflec = mccPoreH9_mirror_reflec;
char* bottom_reflec = mccPoreH9_bottom_reflec;
char* side_reflec = mccPoreH9_side_reflec;
MCNUM R_d = mccPoreH9_R_d;
MCNUM absorb_sides = mccPoreH9_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 82919 "instruments/plate49.c"
}   /* End of PoreH9=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH10'. */
  SIG_MESSAGE("PoreH10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH10");
#define mccompcurname  PoreH10
#define mccompcurtype  Pore_h_group
#define mccompcurindex 113
#define nLeft mccPoreH10_nLeft
#define nRight mccPoreH10_nRight
#define nExit mccPoreH10_nExit
#define wLeft mccPoreH10_wLeft
#define wRight mccPoreH10_wRight
#define wExit mccPoreH10_wExit
#define wall mccPoreH10_wall
#define nTop mccPoreH10_nTop
#define nBottom mccPoreH10_nBottom
#define zexit mccPoreH10_zexit
#define zentry mccPoreH10_zentry
#define intersect_wolterI mccPoreH10_intersect_wolterI
#define reflec_side_table mccPoreH10_reflec_side_table
#define reflec_top_table mccPoreH10_reflec_top_table
#define reflec_bottom_table mccPoreH10_reflec_bottom_table
#define ref_prms mccPoreH10_ref_prms
{   /* Declarations of PoreH10=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH10_radius_m;
MCNUM radius_h = mccPoreH10_radius_h;
MCNUM Z0 = mccPoreH10_Z0;
MCNUM xwidth = mccPoreH10_xwidth;
MCNUM yheight = mccPoreH10_yheight;
MCNUM chamferwidth = mccPoreH10_chamferwidth;
char* mirror_reflec = mccPoreH10_mirror_reflec;
char* bottom_reflec = mccPoreH10_bottom_reflec;
char* side_reflec = mccPoreH10_side_reflec;
MCNUM R_d = mccPoreH10_R_d;
MCNUM absorb_sides = mccPoreH10_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83010 "instruments/plate49.c"
}   /* End of PoreH10=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH11'. */
  SIG_MESSAGE("PoreH11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH11");
#define mccompcurname  PoreH11
#define mccompcurtype  Pore_h_group
#define mccompcurindex 114
#define nLeft mccPoreH11_nLeft
#define nRight mccPoreH11_nRight
#define nExit mccPoreH11_nExit
#define wLeft mccPoreH11_wLeft
#define wRight mccPoreH11_wRight
#define wExit mccPoreH11_wExit
#define wall mccPoreH11_wall
#define nTop mccPoreH11_nTop
#define nBottom mccPoreH11_nBottom
#define zexit mccPoreH11_zexit
#define zentry mccPoreH11_zentry
#define intersect_wolterI mccPoreH11_intersect_wolterI
#define reflec_side_table mccPoreH11_reflec_side_table
#define reflec_top_table mccPoreH11_reflec_top_table
#define reflec_bottom_table mccPoreH11_reflec_bottom_table
#define ref_prms mccPoreH11_ref_prms
{   /* Declarations of PoreH11=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH11_radius_m;
MCNUM radius_h = mccPoreH11_radius_h;
MCNUM Z0 = mccPoreH11_Z0;
MCNUM xwidth = mccPoreH11_xwidth;
MCNUM yheight = mccPoreH11_yheight;
MCNUM chamferwidth = mccPoreH11_chamferwidth;
char* mirror_reflec = mccPoreH11_mirror_reflec;
char* bottom_reflec = mccPoreH11_bottom_reflec;
char* side_reflec = mccPoreH11_side_reflec;
MCNUM R_d = mccPoreH11_R_d;
MCNUM absorb_sides = mccPoreH11_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83101 "instruments/plate49.c"
}   /* End of PoreH11=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH12'. */
  SIG_MESSAGE("PoreH12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH12");
#define mccompcurname  PoreH12
#define mccompcurtype  Pore_h_group
#define mccompcurindex 115
#define nLeft mccPoreH12_nLeft
#define nRight mccPoreH12_nRight
#define nExit mccPoreH12_nExit
#define wLeft mccPoreH12_wLeft
#define wRight mccPoreH12_wRight
#define wExit mccPoreH12_wExit
#define wall mccPoreH12_wall
#define nTop mccPoreH12_nTop
#define nBottom mccPoreH12_nBottom
#define zexit mccPoreH12_zexit
#define zentry mccPoreH12_zentry
#define intersect_wolterI mccPoreH12_intersect_wolterI
#define reflec_side_table mccPoreH12_reflec_side_table
#define reflec_top_table mccPoreH12_reflec_top_table
#define reflec_bottom_table mccPoreH12_reflec_bottom_table
#define ref_prms mccPoreH12_ref_prms
{   /* Declarations of PoreH12=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH12_radius_m;
MCNUM radius_h = mccPoreH12_radius_h;
MCNUM Z0 = mccPoreH12_Z0;
MCNUM xwidth = mccPoreH12_xwidth;
MCNUM yheight = mccPoreH12_yheight;
MCNUM chamferwidth = mccPoreH12_chamferwidth;
char* mirror_reflec = mccPoreH12_mirror_reflec;
char* bottom_reflec = mccPoreH12_bottom_reflec;
char* side_reflec = mccPoreH12_side_reflec;
MCNUM R_d = mccPoreH12_R_d;
MCNUM absorb_sides = mccPoreH12_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83192 "instruments/plate49.c"
}   /* End of PoreH12=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH13'. */
  SIG_MESSAGE("PoreH13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH13");
#define mccompcurname  PoreH13
#define mccompcurtype  Pore_h_group
#define mccompcurindex 116
#define nLeft mccPoreH13_nLeft
#define nRight mccPoreH13_nRight
#define nExit mccPoreH13_nExit
#define wLeft mccPoreH13_wLeft
#define wRight mccPoreH13_wRight
#define wExit mccPoreH13_wExit
#define wall mccPoreH13_wall
#define nTop mccPoreH13_nTop
#define nBottom mccPoreH13_nBottom
#define zexit mccPoreH13_zexit
#define zentry mccPoreH13_zentry
#define intersect_wolterI mccPoreH13_intersect_wolterI
#define reflec_side_table mccPoreH13_reflec_side_table
#define reflec_top_table mccPoreH13_reflec_top_table
#define reflec_bottom_table mccPoreH13_reflec_bottom_table
#define ref_prms mccPoreH13_ref_prms
{   /* Declarations of PoreH13=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH13_radius_m;
MCNUM radius_h = mccPoreH13_radius_h;
MCNUM Z0 = mccPoreH13_Z0;
MCNUM xwidth = mccPoreH13_xwidth;
MCNUM yheight = mccPoreH13_yheight;
MCNUM chamferwidth = mccPoreH13_chamferwidth;
char* mirror_reflec = mccPoreH13_mirror_reflec;
char* bottom_reflec = mccPoreH13_bottom_reflec;
char* side_reflec = mccPoreH13_side_reflec;
MCNUM R_d = mccPoreH13_R_d;
MCNUM absorb_sides = mccPoreH13_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83283 "instruments/plate49.c"
}   /* End of PoreH13=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH14'. */
  SIG_MESSAGE("PoreH14 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH14");
#define mccompcurname  PoreH14
#define mccompcurtype  Pore_h_group
#define mccompcurindex 117
#define nLeft mccPoreH14_nLeft
#define nRight mccPoreH14_nRight
#define nExit mccPoreH14_nExit
#define wLeft mccPoreH14_wLeft
#define wRight mccPoreH14_wRight
#define wExit mccPoreH14_wExit
#define wall mccPoreH14_wall
#define nTop mccPoreH14_nTop
#define nBottom mccPoreH14_nBottom
#define zexit mccPoreH14_zexit
#define zentry mccPoreH14_zentry
#define intersect_wolterI mccPoreH14_intersect_wolterI
#define reflec_side_table mccPoreH14_reflec_side_table
#define reflec_top_table mccPoreH14_reflec_top_table
#define reflec_bottom_table mccPoreH14_reflec_bottom_table
#define ref_prms mccPoreH14_ref_prms
{   /* Declarations of PoreH14=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH14_radius_m;
MCNUM radius_h = mccPoreH14_radius_h;
MCNUM Z0 = mccPoreH14_Z0;
MCNUM xwidth = mccPoreH14_xwidth;
MCNUM yheight = mccPoreH14_yheight;
MCNUM chamferwidth = mccPoreH14_chamferwidth;
char* mirror_reflec = mccPoreH14_mirror_reflec;
char* bottom_reflec = mccPoreH14_bottom_reflec;
char* side_reflec = mccPoreH14_side_reflec;
MCNUM R_d = mccPoreH14_R_d;
MCNUM absorb_sides = mccPoreH14_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83374 "instruments/plate49.c"
}   /* End of PoreH14=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH15'. */
  SIG_MESSAGE("PoreH15 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH15");
#define mccompcurname  PoreH15
#define mccompcurtype  Pore_h_group
#define mccompcurindex 118
#define nLeft mccPoreH15_nLeft
#define nRight mccPoreH15_nRight
#define nExit mccPoreH15_nExit
#define wLeft mccPoreH15_wLeft
#define wRight mccPoreH15_wRight
#define wExit mccPoreH15_wExit
#define wall mccPoreH15_wall
#define nTop mccPoreH15_nTop
#define nBottom mccPoreH15_nBottom
#define zexit mccPoreH15_zexit
#define zentry mccPoreH15_zentry
#define intersect_wolterI mccPoreH15_intersect_wolterI
#define reflec_side_table mccPoreH15_reflec_side_table
#define reflec_top_table mccPoreH15_reflec_top_table
#define reflec_bottom_table mccPoreH15_reflec_bottom_table
#define ref_prms mccPoreH15_ref_prms
{   /* Declarations of PoreH15=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH15_radius_m;
MCNUM radius_h = mccPoreH15_radius_h;
MCNUM Z0 = mccPoreH15_Z0;
MCNUM xwidth = mccPoreH15_xwidth;
MCNUM yheight = mccPoreH15_yheight;
MCNUM chamferwidth = mccPoreH15_chamferwidth;
char* mirror_reflec = mccPoreH15_mirror_reflec;
char* bottom_reflec = mccPoreH15_bottom_reflec;
char* side_reflec = mccPoreH15_side_reflec;
MCNUM R_d = mccPoreH15_R_d;
MCNUM absorb_sides = mccPoreH15_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83465 "instruments/plate49.c"
}   /* End of PoreH15=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH16'. */
  SIG_MESSAGE("PoreH16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH16");
#define mccompcurname  PoreH16
#define mccompcurtype  Pore_h_group
#define mccompcurindex 119
#define nLeft mccPoreH16_nLeft
#define nRight mccPoreH16_nRight
#define nExit mccPoreH16_nExit
#define wLeft mccPoreH16_wLeft
#define wRight mccPoreH16_wRight
#define wExit mccPoreH16_wExit
#define wall mccPoreH16_wall
#define nTop mccPoreH16_nTop
#define nBottom mccPoreH16_nBottom
#define zexit mccPoreH16_zexit
#define zentry mccPoreH16_zentry
#define intersect_wolterI mccPoreH16_intersect_wolterI
#define reflec_side_table mccPoreH16_reflec_side_table
#define reflec_top_table mccPoreH16_reflec_top_table
#define reflec_bottom_table mccPoreH16_reflec_bottom_table
#define ref_prms mccPoreH16_ref_prms
{   /* Declarations of PoreH16=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH16_radius_m;
MCNUM radius_h = mccPoreH16_radius_h;
MCNUM Z0 = mccPoreH16_Z0;
MCNUM xwidth = mccPoreH16_xwidth;
MCNUM yheight = mccPoreH16_yheight;
MCNUM chamferwidth = mccPoreH16_chamferwidth;
char* mirror_reflec = mccPoreH16_mirror_reflec;
char* bottom_reflec = mccPoreH16_bottom_reflec;
char* side_reflec = mccPoreH16_side_reflec;
MCNUM R_d = mccPoreH16_R_d;
MCNUM absorb_sides = mccPoreH16_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83556 "instruments/plate49.c"
}   /* End of PoreH16=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH17'. */
  SIG_MESSAGE("PoreH17 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH17");
#define mccompcurname  PoreH17
#define mccompcurtype  Pore_h_group
#define mccompcurindex 120
#define nLeft mccPoreH17_nLeft
#define nRight mccPoreH17_nRight
#define nExit mccPoreH17_nExit
#define wLeft mccPoreH17_wLeft
#define wRight mccPoreH17_wRight
#define wExit mccPoreH17_wExit
#define wall mccPoreH17_wall
#define nTop mccPoreH17_nTop
#define nBottom mccPoreH17_nBottom
#define zexit mccPoreH17_zexit
#define zentry mccPoreH17_zentry
#define intersect_wolterI mccPoreH17_intersect_wolterI
#define reflec_side_table mccPoreH17_reflec_side_table
#define reflec_top_table mccPoreH17_reflec_top_table
#define reflec_bottom_table mccPoreH17_reflec_bottom_table
#define ref_prms mccPoreH17_ref_prms
{   /* Declarations of PoreH17=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH17_radius_m;
MCNUM radius_h = mccPoreH17_radius_h;
MCNUM Z0 = mccPoreH17_Z0;
MCNUM xwidth = mccPoreH17_xwidth;
MCNUM yheight = mccPoreH17_yheight;
MCNUM chamferwidth = mccPoreH17_chamferwidth;
char* mirror_reflec = mccPoreH17_mirror_reflec;
char* bottom_reflec = mccPoreH17_bottom_reflec;
char* side_reflec = mccPoreH17_side_reflec;
MCNUM R_d = mccPoreH17_R_d;
MCNUM absorb_sides = mccPoreH17_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83647 "instruments/plate49.c"
}   /* End of PoreH17=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH18'. */
  SIG_MESSAGE("PoreH18 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH18");
#define mccompcurname  PoreH18
#define mccompcurtype  Pore_h_group
#define mccompcurindex 121
#define nLeft mccPoreH18_nLeft
#define nRight mccPoreH18_nRight
#define nExit mccPoreH18_nExit
#define wLeft mccPoreH18_wLeft
#define wRight mccPoreH18_wRight
#define wExit mccPoreH18_wExit
#define wall mccPoreH18_wall
#define nTop mccPoreH18_nTop
#define nBottom mccPoreH18_nBottom
#define zexit mccPoreH18_zexit
#define zentry mccPoreH18_zentry
#define intersect_wolterI mccPoreH18_intersect_wolterI
#define reflec_side_table mccPoreH18_reflec_side_table
#define reflec_top_table mccPoreH18_reflec_top_table
#define reflec_bottom_table mccPoreH18_reflec_bottom_table
#define ref_prms mccPoreH18_ref_prms
{   /* Declarations of PoreH18=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH18_radius_m;
MCNUM radius_h = mccPoreH18_radius_h;
MCNUM Z0 = mccPoreH18_Z0;
MCNUM xwidth = mccPoreH18_xwidth;
MCNUM yheight = mccPoreH18_yheight;
MCNUM chamferwidth = mccPoreH18_chamferwidth;
char* mirror_reflec = mccPoreH18_mirror_reflec;
char* bottom_reflec = mccPoreH18_bottom_reflec;
char* side_reflec = mccPoreH18_side_reflec;
MCNUM R_d = mccPoreH18_R_d;
MCNUM absorb_sides = mccPoreH18_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83738 "instruments/plate49.c"
}   /* End of PoreH18=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH19'. */
  SIG_MESSAGE("PoreH19 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH19");
#define mccompcurname  PoreH19
#define mccompcurtype  Pore_h_group
#define mccompcurindex 122
#define nLeft mccPoreH19_nLeft
#define nRight mccPoreH19_nRight
#define nExit mccPoreH19_nExit
#define wLeft mccPoreH19_wLeft
#define wRight mccPoreH19_wRight
#define wExit mccPoreH19_wExit
#define wall mccPoreH19_wall
#define nTop mccPoreH19_nTop
#define nBottom mccPoreH19_nBottom
#define zexit mccPoreH19_zexit
#define zentry mccPoreH19_zentry
#define intersect_wolterI mccPoreH19_intersect_wolterI
#define reflec_side_table mccPoreH19_reflec_side_table
#define reflec_top_table mccPoreH19_reflec_top_table
#define reflec_bottom_table mccPoreH19_reflec_bottom_table
#define ref_prms mccPoreH19_ref_prms
{   /* Declarations of PoreH19=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH19_radius_m;
MCNUM radius_h = mccPoreH19_radius_h;
MCNUM Z0 = mccPoreH19_Z0;
MCNUM xwidth = mccPoreH19_xwidth;
MCNUM yheight = mccPoreH19_yheight;
MCNUM chamferwidth = mccPoreH19_chamferwidth;
char* mirror_reflec = mccPoreH19_mirror_reflec;
char* bottom_reflec = mccPoreH19_bottom_reflec;
char* side_reflec = mccPoreH19_side_reflec;
MCNUM R_d = mccPoreH19_R_d;
MCNUM absorb_sides = mccPoreH19_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83829 "instruments/plate49.c"
}   /* End of PoreH19=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH20'. */
  SIG_MESSAGE("PoreH20 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH20");
#define mccompcurname  PoreH20
#define mccompcurtype  Pore_h_group
#define mccompcurindex 123
#define nLeft mccPoreH20_nLeft
#define nRight mccPoreH20_nRight
#define nExit mccPoreH20_nExit
#define wLeft mccPoreH20_wLeft
#define wRight mccPoreH20_wRight
#define wExit mccPoreH20_wExit
#define wall mccPoreH20_wall
#define nTop mccPoreH20_nTop
#define nBottom mccPoreH20_nBottom
#define zexit mccPoreH20_zexit
#define zentry mccPoreH20_zentry
#define intersect_wolterI mccPoreH20_intersect_wolterI
#define reflec_side_table mccPoreH20_reflec_side_table
#define reflec_top_table mccPoreH20_reflec_top_table
#define reflec_bottom_table mccPoreH20_reflec_bottom_table
#define ref_prms mccPoreH20_ref_prms
{   /* Declarations of PoreH20=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH20_radius_m;
MCNUM radius_h = mccPoreH20_radius_h;
MCNUM Z0 = mccPoreH20_Z0;
MCNUM xwidth = mccPoreH20_xwidth;
MCNUM yheight = mccPoreH20_yheight;
MCNUM chamferwidth = mccPoreH20_chamferwidth;
char* mirror_reflec = mccPoreH20_mirror_reflec;
char* bottom_reflec = mccPoreH20_bottom_reflec;
char* side_reflec = mccPoreH20_side_reflec;
MCNUM R_d = mccPoreH20_R_d;
MCNUM absorb_sides = mccPoreH20_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 83920 "instruments/plate49.c"
}   /* End of PoreH20=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH21'. */
  SIG_MESSAGE("PoreH21 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH21");
#define mccompcurname  PoreH21
#define mccompcurtype  Pore_h_group
#define mccompcurindex 124
#define nLeft mccPoreH21_nLeft
#define nRight mccPoreH21_nRight
#define nExit mccPoreH21_nExit
#define wLeft mccPoreH21_wLeft
#define wRight mccPoreH21_wRight
#define wExit mccPoreH21_wExit
#define wall mccPoreH21_wall
#define nTop mccPoreH21_nTop
#define nBottom mccPoreH21_nBottom
#define zexit mccPoreH21_zexit
#define zentry mccPoreH21_zentry
#define intersect_wolterI mccPoreH21_intersect_wolterI
#define reflec_side_table mccPoreH21_reflec_side_table
#define reflec_top_table mccPoreH21_reflec_top_table
#define reflec_bottom_table mccPoreH21_reflec_bottom_table
#define ref_prms mccPoreH21_ref_prms
{   /* Declarations of PoreH21=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH21_radius_m;
MCNUM radius_h = mccPoreH21_radius_h;
MCNUM Z0 = mccPoreH21_Z0;
MCNUM xwidth = mccPoreH21_xwidth;
MCNUM yheight = mccPoreH21_yheight;
MCNUM chamferwidth = mccPoreH21_chamferwidth;
char* mirror_reflec = mccPoreH21_mirror_reflec;
char* bottom_reflec = mccPoreH21_bottom_reflec;
char* side_reflec = mccPoreH21_side_reflec;
MCNUM R_d = mccPoreH21_R_d;
MCNUM absorb_sides = mccPoreH21_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84011 "instruments/plate49.c"
}   /* End of PoreH21=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH22'. */
  SIG_MESSAGE("PoreH22 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH22");
#define mccompcurname  PoreH22
#define mccompcurtype  Pore_h_group
#define mccompcurindex 125
#define nLeft mccPoreH22_nLeft
#define nRight mccPoreH22_nRight
#define nExit mccPoreH22_nExit
#define wLeft mccPoreH22_wLeft
#define wRight mccPoreH22_wRight
#define wExit mccPoreH22_wExit
#define wall mccPoreH22_wall
#define nTop mccPoreH22_nTop
#define nBottom mccPoreH22_nBottom
#define zexit mccPoreH22_zexit
#define zentry mccPoreH22_zentry
#define intersect_wolterI mccPoreH22_intersect_wolterI
#define reflec_side_table mccPoreH22_reflec_side_table
#define reflec_top_table mccPoreH22_reflec_top_table
#define reflec_bottom_table mccPoreH22_reflec_bottom_table
#define ref_prms mccPoreH22_ref_prms
{   /* Declarations of PoreH22=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH22_radius_m;
MCNUM radius_h = mccPoreH22_radius_h;
MCNUM Z0 = mccPoreH22_Z0;
MCNUM xwidth = mccPoreH22_xwidth;
MCNUM yheight = mccPoreH22_yheight;
MCNUM chamferwidth = mccPoreH22_chamferwidth;
char* mirror_reflec = mccPoreH22_mirror_reflec;
char* bottom_reflec = mccPoreH22_bottom_reflec;
char* side_reflec = mccPoreH22_side_reflec;
MCNUM R_d = mccPoreH22_R_d;
MCNUM absorb_sides = mccPoreH22_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84102 "instruments/plate49.c"
}   /* End of PoreH22=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH23'. */
  SIG_MESSAGE("PoreH23 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH23");
#define mccompcurname  PoreH23
#define mccompcurtype  Pore_h_group
#define mccompcurindex 126
#define nLeft mccPoreH23_nLeft
#define nRight mccPoreH23_nRight
#define nExit mccPoreH23_nExit
#define wLeft mccPoreH23_wLeft
#define wRight mccPoreH23_wRight
#define wExit mccPoreH23_wExit
#define wall mccPoreH23_wall
#define nTop mccPoreH23_nTop
#define nBottom mccPoreH23_nBottom
#define zexit mccPoreH23_zexit
#define zentry mccPoreH23_zentry
#define intersect_wolterI mccPoreH23_intersect_wolterI
#define reflec_side_table mccPoreH23_reflec_side_table
#define reflec_top_table mccPoreH23_reflec_top_table
#define reflec_bottom_table mccPoreH23_reflec_bottom_table
#define ref_prms mccPoreH23_ref_prms
{   /* Declarations of PoreH23=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH23_radius_m;
MCNUM radius_h = mccPoreH23_radius_h;
MCNUM Z0 = mccPoreH23_Z0;
MCNUM xwidth = mccPoreH23_xwidth;
MCNUM yheight = mccPoreH23_yheight;
MCNUM chamferwidth = mccPoreH23_chamferwidth;
char* mirror_reflec = mccPoreH23_mirror_reflec;
char* bottom_reflec = mccPoreH23_bottom_reflec;
char* side_reflec = mccPoreH23_side_reflec;
MCNUM R_d = mccPoreH23_R_d;
MCNUM absorb_sides = mccPoreH23_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84193 "instruments/plate49.c"
}   /* End of PoreH23=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH24'. */
  SIG_MESSAGE("PoreH24 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH24");
#define mccompcurname  PoreH24
#define mccompcurtype  Pore_h_group
#define mccompcurindex 127
#define nLeft mccPoreH24_nLeft
#define nRight mccPoreH24_nRight
#define nExit mccPoreH24_nExit
#define wLeft mccPoreH24_wLeft
#define wRight mccPoreH24_wRight
#define wExit mccPoreH24_wExit
#define wall mccPoreH24_wall
#define nTop mccPoreH24_nTop
#define nBottom mccPoreH24_nBottom
#define zexit mccPoreH24_zexit
#define zentry mccPoreH24_zentry
#define intersect_wolterI mccPoreH24_intersect_wolterI
#define reflec_side_table mccPoreH24_reflec_side_table
#define reflec_top_table mccPoreH24_reflec_top_table
#define reflec_bottom_table mccPoreH24_reflec_bottom_table
#define ref_prms mccPoreH24_ref_prms
{   /* Declarations of PoreH24=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH24_radius_m;
MCNUM radius_h = mccPoreH24_radius_h;
MCNUM Z0 = mccPoreH24_Z0;
MCNUM xwidth = mccPoreH24_xwidth;
MCNUM yheight = mccPoreH24_yheight;
MCNUM chamferwidth = mccPoreH24_chamferwidth;
char* mirror_reflec = mccPoreH24_mirror_reflec;
char* bottom_reflec = mccPoreH24_bottom_reflec;
char* side_reflec = mccPoreH24_side_reflec;
MCNUM R_d = mccPoreH24_R_d;
MCNUM absorb_sides = mccPoreH24_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84284 "instruments/plate49.c"
}   /* End of PoreH24=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH25'. */
  SIG_MESSAGE("PoreH25 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH25");
#define mccompcurname  PoreH25
#define mccompcurtype  Pore_h_group
#define mccompcurindex 128
#define nLeft mccPoreH25_nLeft
#define nRight mccPoreH25_nRight
#define nExit mccPoreH25_nExit
#define wLeft mccPoreH25_wLeft
#define wRight mccPoreH25_wRight
#define wExit mccPoreH25_wExit
#define wall mccPoreH25_wall
#define nTop mccPoreH25_nTop
#define nBottom mccPoreH25_nBottom
#define zexit mccPoreH25_zexit
#define zentry mccPoreH25_zentry
#define intersect_wolterI mccPoreH25_intersect_wolterI
#define reflec_side_table mccPoreH25_reflec_side_table
#define reflec_top_table mccPoreH25_reflec_top_table
#define reflec_bottom_table mccPoreH25_reflec_bottom_table
#define ref_prms mccPoreH25_ref_prms
{   /* Declarations of PoreH25=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH25_radius_m;
MCNUM radius_h = mccPoreH25_radius_h;
MCNUM Z0 = mccPoreH25_Z0;
MCNUM xwidth = mccPoreH25_xwidth;
MCNUM yheight = mccPoreH25_yheight;
MCNUM chamferwidth = mccPoreH25_chamferwidth;
char* mirror_reflec = mccPoreH25_mirror_reflec;
char* bottom_reflec = mccPoreH25_bottom_reflec;
char* side_reflec = mccPoreH25_side_reflec;
MCNUM R_d = mccPoreH25_R_d;
MCNUM absorb_sides = mccPoreH25_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84375 "instruments/plate49.c"
}   /* End of PoreH25=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH26'. */
  SIG_MESSAGE("PoreH26 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH26");
#define mccompcurname  PoreH26
#define mccompcurtype  Pore_h_group
#define mccompcurindex 129
#define nLeft mccPoreH26_nLeft
#define nRight mccPoreH26_nRight
#define nExit mccPoreH26_nExit
#define wLeft mccPoreH26_wLeft
#define wRight mccPoreH26_wRight
#define wExit mccPoreH26_wExit
#define wall mccPoreH26_wall
#define nTop mccPoreH26_nTop
#define nBottom mccPoreH26_nBottom
#define zexit mccPoreH26_zexit
#define zentry mccPoreH26_zentry
#define intersect_wolterI mccPoreH26_intersect_wolterI
#define reflec_side_table mccPoreH26_reflec_side_table
#define reflec_top_table mccPoreH26_reflec_top_table
#define reflec_bottom_table mccPoreH26_reflec_bottom_table
#define ref_prms mccPoreH26_ref_prms
{   /* Declarations of PoreH26=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH26_radius_m;
MCNUM radius_h = mccPoreH26_radius_h;
MCNUM Z0 = mccPoreH26_Z0;
MCNUM xwidth = mccPoreH26_xwidth;
MCNUM yheight = mccPoreH26_yheight;
MCNUM chamferwidth = mccPoreH26_chamferwidth;
char* mirror_reflec = mccPoreH26_mirror_reflec;
char* bottom_reflec = mccPoreH26_bottom_reflec;
char* side_reflec = mccPoreH26_side_reflec;
MCNUM R_d = mccPoreH26_R_d;
MCNUM absorb_sides = mccPoreH26_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84466 "instruments/plate49.c"
}   /* End of PoreH26=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH27'. */
  SIG_MESSAGE("PoreH27 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH27");
#define mccompcurname  PoreH27
#define mccompcurtype  Pore_h_group
#define mccompcurindex 130
#define nLeft mccPoreH27_nLeft
#define nRight mccPoreH27_nRight
#define nExit mccPoreH27_nExit
#define wLeft mccPoreH27_wLeft
#define wRight mccPoreH27_wRight
#define wExit mccPoreH27_wExit
#define wall mccPoreH27_wall
#define nTop mccPoreH27_nTop
#define nBottom mccPoreH27_nBottom
#define zexit mccPoreH27_zexit
#define zentry mccPoreH27_zentry
#define intersect_wolterI mccPoreH27_intersect_wolterI
#define reflec_side_table mccPoreH27_reflec_side_table
#define reflec_top_table mccPoreH27_reflec_top_table
#define reflec_bottom_table mccPoreH27_reflec_bottom_table
#define ref_prms mccPoreH27_ref_prms
{   /* Declarations of PoreH27=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH27_radius_m;
MCNUM radius_h = mccPoreH27_radius_h;
MCNUM Z0 = mccPoreH27_Z0;
MCNUM xwidth = mccPoreH27_xwidth;
MCNUM yheight = mccPoreH27_yheight;
MCNUM chamferwidth = mccPoreH27_chamferwidth;
char* mirror_reflec = mccPoreH27_mirror_reflec;
char* bottom_reflec = mccPoreH27_bottom_reflec;
char* side_reflec = mccPoreH27_side_reflec;
MCNUM R_d = mccPoreH27_R_d;
MCNUM absorb_sides = mccPoreH27_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84557 "instruments/plate49.c"
}   /* End of PoreH27=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH28'. */
  SIG_MESSAGE("PoreH28 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH28");
#define mccompcurname  PoreH28
#define mccompcurtype  Pore_h_group
#define mccompcurindex 131
#define nLeft mccPoreH28_nLeft
#define nRight mccPoreH28_nRight
#define nExit mccPoreH28_nExit
#define wLeft mccPoreH28_wLeft
#define wRight mccPoreH28_wRight
#define wExit mccPoreH28_wExit
#define wall mccPoreH28_wall
#define nTop mccPoreH28_nTop
#define nBottom mccPoreH28_nBottom
#define zexit mccPoreH28_zexit
#define zentry mccPoreH28_zentry
#define intersect_wolterI mccPoreH28_intersect_wolterI
#define reflec_side_table mccPoreH28_reflec_side_table
#define reflec_top_table mccPoreH28_reflec_top_table
#define reflec_bottom_table mccPoreH28_reflec_bottom_table
#define ref_prms mccPoreH28_ref_prms
{   /* Declarations of PoreH28=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH28_radius_m;
MCNUM radius_h = mccPoreH28_radius_h;
MCNUM Z0 = mccPoreH28_Z0;
MCNUM xwidth = mccPoreH28_xwidth;
MCNUM yheight = mccPoreH28_yheight;
MCNUM chamferwidth = mccPoreH28_chamferwidth;
char* mirror_reflec = mccPoreH28_mirror_reflec;
char* bottom_reflec = mccPoreH28_bottom_reflec;
char* side_reflec = mccPoreH28_side_reflec;
MCNUM R_d = mccPoreH28_R_d;
MCNUM absorb_sides = mccPoreH28_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84648 "instruments/plate49.c"
}   /* End of PoreH28=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH29'. */
  SIG_MESSAGE("PoreH29 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH29");
#define mccompcurname  PoreH29
#define mccompcurtype  Pore_h_group
#define mccompcurindex 132
#define nLeft mccPoreH29_nLeft
#define nRight mccPoreH29_nRight
#define nExit mccPoreH29_nExit
#define wLeft mccPoreH29_wLeft
#define wRight mccPoreH29_wRight
#define wExit mccPoreH29_wExit
#define wall mccPoreH29_wall
#define nTop mccPoreH29_nTop
#define nBottom mccPoreH29_nBottom
#define zexit mccPoreH29_zexit
#define zentry mccPoreH29_zentry
#define intersect_wolterI mccPoreH29_intersect_wolterI
#define reflec_side_table mccPoreH29_reflec_side_table
#define reflec_top_table mccPoreH29_reflec_top_table
#define reflec_bottom_table mccPoreH29_reflec_bottom_table
#define ref_prms mccPoreH29_ref_prms
{   /* Declarations of PoreH29=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH29_radius_m;
MCNUM radius_h = mccPoreH29_radius_h;
MCNUM Z0 = mccPoreH29_Z0;
MCNUM xwidth = mccPoreH29_xwidth;
MCNUM yheight = mccPoreH29_yheight;
MCNUM chamferwidth = mccPoreH29_chamferwidth;
char* mirror_reflec = mccPoreH29_mirror_reflec;
char* bottom_reflec = mccPoreH29_bottom_reflec;
char* side_reflec = mccPoreH29_side_reflec;
MCNUM R_d = mccPoreH29_R_d;
MCNUM absorb_sides = mccPoreH29_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84739 "instruments/plate49.c"
}   /* End of PoreH29=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH30'. */
  SIG_MESSAGE("PoreH30 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH30");
#define mccompcurname  PoreH30
#define mccompcurtype  Pore_h_group
#define mccompcurindex 133
#define nLeft mccPoreH30_nLeft
#define nRight mccPoreH30_nRight
#define nExit mccPoreH30_nExit
#define wLeft mccPoreH30_wLeft
#define wRight mccPoreH30_wRight
#define wExit mccPoreH30_wExit
#define wall mccPoreH30_wall
#define nTop mccPoreH30_nTop
#define nBottom mccPoreH30_nBottom
#define zexit mccPoreH30_zexit
#define zentry mccPoreH30_zentry
#define intersect_wolterI mccPoreH30_intersect_wolterI
#define reflec_side_table mccPoreH30_reflec_side_table
#define reflec_top_table mccPoreH30_reflec_top_table
#define reflec_bottom_table mccPoreH30_reflec_bottom_table
#define ref_prms mccPoreH30_ref_prms
{   /* Declarations of PoreH30=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH30_radius_m;
MCNUM radius_h = mccPoreH30_radius_h;
MCNUM Z0 = mccPoreH30_Z0;
MCNUM xwidth = mccPoreH30_xwidth;
MCNUM yheight = mccPoreH30_yheight;
MCNUM chamferwidth = mccPoreH30_chamferwidth;
char* mirror_reflec = mccPoreH30_mirror_reflec;
char* bottom_reflec = mccPoreH30_bottom_reflec;
char* side_reflec = mccPoreH30_side_reflec;
MCNUM R_d = mccPoreH30_R_d;
MCNUM absorb_sides = mccPoreH30_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84830 "instruments/plate49.c"
}   /* End of PoreH30=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH31'. */
  SIG_MESSAGE("PoreH31 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH31");
#define mccompcurname  PoreH31
#define mccompcurtype  Pore_h_group
#define mccompcurindex 134
#define nLeft mccPoreH31_nLeft
#define nRight mccPoreH31_nRight
#define nExit mccPoreH31_nExit
#define wLeft mccPoreH31_wLeft
#define wRight mccPoreH31_wRight
#define wExit mccPoreH31_wExit
#define wall mccPoreH31_wall
#define nTop mccPoreH31_nTop
#define nBottom mccPoreH31_nBottom
#define zexit mccPoreH31_zexit
#define zentry mccPoreH31_zentry
#define intersect_wolterI mccPoreH31_intersect_wolterI
#define reflec_side_table mccPoreH31_reflec_side_table
#define reflec_top_table mccPoreH31_reflec_top_table
#define reflec_bottom_table mccPoreH31_reflec_bottom_table
#define ref_prms mccPoreH31_ref_prms
{   /* Declarations of PoreH31=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH31_radius_m;
MCNUM radius_h = mccPoreH31_radius_h;
MCNUM Z0 = mccPoreH31_Z0;
MCNUM xwidth = mccPoreH31_xwidth;
MCNUM yheight = mccPoreH31_yheight;
MCNUM chamferwidth = mccPoreH31_chamferwidth;
char* mirror_reflec = mccPoreH31_mirror_reflec;
char* bottom_reflec = mccPoreH31_bottom_reflec;
char* side_reflec = mccPoreH31_side_reflec;
MCNUM R_d = mccPoreH31_R_d;
MCNUM absorb_sides = mccPoreH31_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 84921 "instruments/plate49.c"
}   /* End of PoreH31=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH32'. */
  SIG_MESSAGE("PoreH32 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH32");
#define mccompcurname  PoreH32
#define mccompcurtype  Pore_h_group
#define mccompcurindex 135
#define nLeft mccPoreH32_nLeft
#define nRight mccPoreH32_nRight
#define nExit mccPoreH32_nExit
#define wLeft mccPoreH32_wLeft
#define wRight mccPoreH32_wRight
#define wExit mccPoreH32_wExit
#define wall mccPoreH32_wall
#define nTop mccPoreH32_nTop
#define nBottom mccPoreH32_nBottom
#define zexit mccPoreH32_zexit
#define zentry mccPoreH32_zentry
#define intersect_wolterI mccPoreH32_intersect_wolterI
#define reflec_side_table mccPoreH32_reflec_side_table
#define reflec_top_table mccPoreH32_reflec_top_table
#define reflec_bottom_table mccPoreH32_reflec_bottom_table
#define ref_prms mccPoreH32_ref_prms
{   /* Declarations of PoreH32=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH32_radius_m;
MCNUM radius_h = mccPoreH32_radius_h;
MCNUM Z0 = mccPoreH32_Z0;
MCNUM xwidth = mccPoreH32_xwidth;
MCNUM yheight = mccPoreH32_yheight;
MCNUM chamferwidth = mccPoreH32_chamferwidth;
char* mirror_reflec = mccPoreH32_mirror_reflec;
char* bottom_reflec = mccPoreH32_bottom_reflec;
char* side_reflec = mccPoreH32_side_reflec;
MCNUM R_d = mccPoreH32_R_d;
MCNUM absorb_sides = mccPoreH32_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85012 "instruments/plate49.c"
}   /* End of PoreH32=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH33'. */
  SIG_MESSAGE("PoreH33 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH33");
#define mccompcurname  PoreH33
#define mccompcurtype  Pore_h_group
#define mccompcurindex 136
#define nLeft mccPoreH33_nLeft
#define nRight mccPoreH33_nRight
#define nExit mccPoreH33_nExit
#define wLeft mccPoreH33_wLeft
#define wRight mccPoreH33_wRight
#define wExit mccPoreH33_wExit
#define wall mccPoreH33_wall
#define nTop mccPoreH33_nTop
#define nBottom mccPoreH33_nBottom
#define zexit mccPoreH33_zexit
#define zentry mccPoreH33_zentry
#define intersect_wolterI mccPoreH33_intersect_wolterI
#define reflec_side_table mccPoreH33_reflec_side_table
#define reflec_top_table mccPoreH33_reflec_top_table
#define reflec_bottom_table mccPoreH33_reflec_bottom_table
#define ref_prms mccPoreH33_ref_prms
{   /* Declarations of PoreH33=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH33_radius_m;
MCNUM radius_h = mccPoreH33_radius_h;
MCNUM Z0 = mccPoreH33_Z0;
MCNUM xwidth = mccPoreH33_xwidth;
MCNUM yheight = mccPoreH33_yheight;
MCNUM chamferwidth = mccPoreH33_chamferwidth;
char* mirror_reflec = mccPoreH33_mirror_reflec;
char* bottom_reflec = mccPoreH33_bottom_reflec;
char* side_reflec = mccPoreH33_side_reflec;
MCNUM R_d = mccPoreH33_R_d;
MCNUM absorb_sides = mccPoreH33_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85103 "instruments/plate49.c"
}   /* End of PoreH33=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH34'. */
  SIG_MESSAGE("PoreH34 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH34");
#define mccompcurname  PoreH34
#define mccompcurtype  Pore_h_group
#define mccompcurindex 137
#define nLeft mccPoreH34_nLeft
#define nRight mccPoreH34_nRight
#define nExit mccPoreH34_nExit
#define wLeft mccPoreH34_wLeft
#define wRight mccPoreH34_wRight
#define wExit mccPoreH34_wExit
#define wall mccPoreH34_wall
#define nTop mccPoreH34_nTop
#define nBottom mccPoreH34_nBottom
#define zexit mccPoreH34_zexit
#define zentry mccPoreH34_zentry
#define intersect_wolterI mccPoreH34_intersect_wolterI
#define reflec_side_table mccPoreH34_reflec_side_table
#define reflec_top_table mccPoreH34_reflec_top_table
#define reflec_bottom_table mccPoreH34_reflec_bottom_table
#define ref_prms mccPoreH34_ref_prms
{   /* Declarations of PoreH34=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH34_radius_m;
MCNUM radius_h = mccPoreH34_radius_h;
MCNUM Z0 = mccPoreH34_Z0;
MCNUM xwidth = mccPoreH34_xwidth;
MCNUM yheight = mccPoreH34_yheight;
MCNUM chamferwidth = mccPoreH34_chamferwidth;
char* mirror_reflec = mccPoreH34_mirror_reflec;
char* bottom_reflec = mccPoreH34_bottom_reflec;
char* side_reflec = mccPoreH34_side_reflec;
MCNUM R_d = mccPoreH34_R_d;
MCNUM absorb_sides = mccPoreH34_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85194 "instruments/plate49.c"
}   /* End of PoreH34=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH35'. */
  SIG_MESSAGE("PoreH35 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH35");
#define mccompcurname  PoreH35
#define mccompcurtype  Pore_h_group
#define mccompcurindex 138
#define nLeft mccPoreH35_nLeft
#define nRight mccPoreH35_nRight
#define nExit mccPoreH35_nExit
#define wLeft mccPoreH35_wLeft
#define wRight mccPoreH35_wRight
#define wExit mccPoreH35_wExit
#define wall mccPoreH35_wall
#define nTop mccPoreH35_nTop
#define nBottom mccPoreH35_nBottom
#define zexit mccPoreH35_zexit
#define zentry mccPoreH35_zentry
#define intersect_wolterI mccPoreH35_intersect_wolterI
#define reflec_side_table mccPoreH35_reflec_side_table
#define reflec_top_table mccPoreH35_reflec_top_table
#define reflec_bottom_table mccPoreH35_reflec_bottom_table
#define ref_prms mccPoreH35_ref_prms
{   /* Declarations of PoreH35=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH35_radius_m;
MCNUM radius_h = mccPoreH35_radius_h;
MCNUM Z0 = mccPoreH35_Z0;
MCNUM xwidth = mccPoreH35_xwidth;
MCNUM yheight = mccPoreH35_yheight;
MCNUM chamferwidth = mccPoreH35_chamferwidth;
char* mirror_reflec = mccPoreH35_mirror_reflec;
char* bottom_reflec = mccPoreH35_bottom_reflec;
char* side_reflec = mccPoreH35_side_reflec;
MCNUM R_d = mccPoreH35_R_d;
MCNUM absorb_sides = mccPoreH35_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85285 "instruments/plate49.c"
}   /* End of PoreH35=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH36'. */
  SIG_MESSAGE("PoreH36 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH36");
#define mccompcurname  PoreH36
#define mccompcurtype  Pore_h_group
#define mccompcurindex 139
#define nLeft mccPoreH36_nLeft
#define nRight mccPoreH36_nRight
#define nExit mccPoreH36_nExit
#define wLeft mccPoreH36_wLeft
#define wRight mccPoreH36_wRight
#define wExit mccPoreH36_wExit
#define wall mccPoreH36_wall
#define nTop mccPoreH36_nTop
#define nBottom mccPoreH36_nBottom
#define zexit mccPoreH36_zexit
#define zentry mccPoreH36_zentry
#define intersect_wolterI mccPoreH36_intersect_wolterI
#define reflec_side_table mccPoreH36_reflec_side_table
#define reflec_top_table mccPoreH36_reflec_top_table
#define reflec_bottom_table mccPoreH36_reflec_bottom_table
#define ref_prms mccPoreH36_ref_prms
{   /* Declarations of PoreH36=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH36_radius_m;
MCNUM radius_h = mccPoreH36_radius_h;
MCNUM Z0 = mccPoreH36_Z0;
MCNUM xwidth = mccPoreH36_xwidth;
MCNUM yheight = mccPoreH36_yheight;
MCNUM chamferwidth = mccPoreH36_chamferwidth;
char* mirror_reflec = mccPoreH36_mirror_reflec;
char* bottom_reflec = mccPoreH36_bottom_reflec;
char* side_reflec = mccPoreH36_side_reflec;
MCNUM R_d = mccPoreH36_R_d;
MCNUM absorb_sides = mccPoreH36_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85376 "instruments/plate49.c"
}   /* End of PoreH36=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH37'. */
  SIG_MESSAGE("PoreH37 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH37");
#define mccompcurname  PoreH37
#define mccompcurtype  Pore_h_group
#define mccompcurindex 140
#define nLeft mccPoreH37_nLeft
#define nRight mccPoreH37_nRight
#define nExit mccPoreH37_nExit
#define wLeft mccPoreH37_wLeft
#define wRight mccPoreH37_wRight
#define wExit mccPoreH37_wExit
#define wall mccPoreH37_wall
#define nTop mccPoreH37_nTop
#define nBottom mccPoreH37_nBottom
#define zexit mccPoreH37_zexit
#define zentry mccPoreH37_zentry
#define intersect_wolterI mccPoreH37_intersect_wolterI
#define reflec_side_table mccPoreH37_reflec_side_table
#define reflec_top_table mccPoreH37_reflec_top_table
#define reflec_bottom_table mccPoreH37_reflec_bottom_table
#define ref_prms mccPoreH37_ref_prms
{   /* Declarations of PoreH37=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH37_radius_m;
MCNUM radius_h = mccPoreH37_radius_h;
MCNUM Z0 = mccPoreH37_Z0;
MCNUM xwidth = mccPoreH37_xwidth;
MCNUM yheight = mccPoreH37_yheight;
MCNUM chamferwidth = mccPoreH37_chamferwidth;
char* mirror_reflec = mccPoreH37_mirror_reflec;
char* bottom_reflec = mccPoreH37_bottom_reflec;
char* side_reflec = mccPoreH37_side_reflec;
MCNUM R_d = mccPoreH37_R_d;
MCNUM absorb_sides = mccPoreH37_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85467 "instruments/plate49.c"
}   /* End of PoreH37=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH38'. */
  SIG_MESSAGE("PoreH38 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH38");
#define mccompcurname  PoreH38
#define mccompcurtype  Pore_h_group
#define mccompcurindex 141
#define nLeft mccPoreH38_nLeft
#define nRight mccPoreH38_nRight
#define nExit mccPoreH38_nExit
#define wLeft mccPoreH38_wLeft
#define wRight mccPoreH38_wRight
#define wExit mccPoreH38_wExit
#define wall mccPoreH38_wall
#define nTop mccPoreH38_nTop
#define nBottom mccPoreH38_nBottom
#define zexit mccPoreH38_zexit
#define zentry mccPoreH38_zentry
#define intersect_wolterI mccPoreH38_intersect_wolterI
#define reflec_side_table mccPoreH38_reflec_side_table
#define reflec_top_table mccPoreH38_reflec_top_table
#define reflec_bottom_table mccPoreH38_reflec_bottom_table
#define ref_prms mccPoreH38_ref_prms
{   /* Declarations of PoreH38=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH38_radius_m;
MCNUM radius_h = mccPoreH38_radius_h;
MCNUM Z0 = mccPoreH38_Z0;
MCNUM xwidth = mccPoreH38_xwidth;
MCNUM yheight = mccPoreH38_yheight;
MCNUM chamferwidth = mccPoreH38_chamferwidth;
char* mirror_reflec = mccPoreH38_mirror_reflec;
char* bottom_reflec = mccPoreH38_bottom_reflec;
char* side_reflec = mccPoreH38_side_reflec;
MCNUM R_d = mccPoreH38_R_d;
MCNUM absorb_sides = mccPoreH38_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85558 "instruments/plate49.c"
}   /* End of PoreH38=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH39'. */
  SIG_MESSAGE("PoreH39 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH39");
#define mccompcurname  PoreH39
#define mccompcurtype  Pore_h_group
#define mccompcurindex 142
#define nLeft mccPoreH39_nLeft
#define nRight mccPoreH39_nRight
#define nExit mccPoreH39_nExit
#define wLeft mccPoreH39_wLeft
#define wRight mccPoreH39_wRight
#define wExit mccPoreH39_wExit
#define wall mccPoreH39_wall
#define nTop mccPoreH39_nTop
#define nBottom mccPoreH39_nBottom
#define zexit mccPoreH39_zexit
#define zentry mccPoreH39_zentry
#define intersect_wolterI mccPoreH39_intersect_wolterI
#define reflec_side_table mccPoreH39_reflec_side_table
#define reflec_top_table mccPoreH39_reflec_top_table
#define reflec_bottom_table mccPoreH39_reflec_bottom_table
#define ref_prms mccPoreH39_ref_prms
{   /* Declarations of PoreH39=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH39_radius_m;
MCNUM radius_h = mccPoreH39_radius_h;
MCNUM Z0 = mccPoreH39_Z0;
MCNUM xwidth = mccPoreH39_xwidth;
MCNUM yheight = mccPoreH39_yheight;
MCNUM chamferwidth = mccPoreH39_chamferwidth;
char* mirror_reflec = mccPoreH39_mirror_reflec;
char* bottom_reflec = mccPoreH39_bottom_reflec;
char* side_reflec = mccPoreH39_side_reflec;
MCNUM R_d = mccPoreH39_R_d;
MCNUM absorb_sides = mccPoreH39_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85649 "instruments/plate49.c"
}   /* End of PoreH39=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH40'. */
  SIG_MESSAGE("PoreH40 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH40");
#define mccompcurname  PoreH40
#define mccompcurtype  Pore_h_group
#define mccompcurindex 143
#define nLeft mccPoreH40_nLeft
#define nRight mccPoreH40_nRight
#define nExit mccPoreH40_nExit
#define wLeft mccPoreH40_wLeft
#define wRight mccPoreH40_wRight
#define wExit mccPoreH40_wExit
#define wall mccPoreH40_wall
#define nTop mccPoreH40_nTop
#define nBottom mccPoreH40_nBottom
#define zexit mccPoreH40_zexit
#define zentry mccPoreH40_zentry
#define intersect_wolterI mccPoreH40_intersect_wolterI
#define reflec_side_table mccPoreH40_reflec_side_table
#define reflec_top_table mccPoreH40_reflec_top_table
#define reflec_bottom_table mccPoreH40_reflec_bottom_table
#define ref_prms mccPoreH40_ref_prms
{   /* Declarations of PoreH40=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH40_radius_m;
MCNUM radius_h = mccPoreH40_radius_h;
MCNUM Z0 = mccPoreH40_Z0;
MCNUM xwidth = mccPoreH40_xwidth;
MCNUM yheight = mccPoreH40_yheight;
MCNUM chamferwidth = mccPoreH40_chamferwidth;
char* mirror_reflec = mccPoreH40_mirror_reflec;
char* bottom_reflec = mccPoreH40_bottom_reflec;
char* side_reflec = mccPoreH40_side_reflec;
MCNUM R_d = mccPoreH40_R_d;
MCNUM absorb_sides = mccPoreH40_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85740 "instruments/plate49.c"
}   /* End of PoreH40=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH41'. */
  SIG_MESSAGE("PoreH41 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH41");
#define mccompcurname  PoreH41
#define mccompcurtype  Pore_h_group
#define mccompcurindex 144
#define nLeft mccPoreH41_nLeft
#define nRight mccPoreH41_nRight
#define nExit mccPoreH41_nExit
#define wLeft mccPoreH41_wLeft
#define wRight mccPoreH41_wRight
#define wExit mccPoreH41_wExit
#define wall mccPoreH41_wall
#define nTop mccPoreH41_nTop
#define nBottom mccPoreH41_nBottom
#define zexit mccPoreH41_zexit
#define zentry mccPoreH41_zentry
#define intersect_wolterI mccPoreH41_intersect_wolterI
#define reflec_side_table mccPoreH41_reflec_side_table
#define reflec_top_table mccPoreH41_reflec_top_table
#define reflec_bottom_table mccPoreH41_reflec_bottom_table
#define ref_prms mccPoreH41_ref_prms
{   /* Declarations of PoreH41=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH41_radius_m;
MCNUM radius_h = mccPoreH41_radius_h;
MCNUM Z0 = mccPoreH41_Z0;
MCNUM xwidth = mccPoreH41_xwidth;
MCNUM yheight = mccPoreH41_yheight;
MCNUM chamferwidth = mccPoreH41_chamferwidth;
char* mirror_reflec = mccPoreH41_mirror_reflec;
char* bottom_reflec = mccPoreH41_bottom_reflec;
char* side_reflec = mccPoreH41_side_reflec;
MCNUM R_d = mccPoreH41_R_d;
MCNUM absorb_sides = mccPoreH41_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85831 "instruments/plate49.c"
}   /* End of PoreH41=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH42'. */
  SIG_MESSAGE("PoreH42 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH42");
#define mccompcurname  PoreH42
#define mccompcurtype  Pore_h_group
#define mccompcurindex 145
#define nLeft mccPoreH42_nLeft
#define nRight mccPoreH42_nRight
#define nExit mccPoreH42_nExit
#define wLeft mccPoreH42_wLeft
#define wRight mccPoreH42_wRight
#define wExit mccPoreH42_wExit
#define wall mccPoreH42_wall
#define nTop mccPoreH42_nTop
#define nBottom mccPoreH42_nBottom
#define zexit mccPoreH42_zexit
#define zentry mccPoreH42_zentry
#define intersect_wolterI mccPoreH42_intersect_wolterI
#define reflec_side_table mccPoreH42_reflec_side_table
#define reflec_top_table mccPoreH42_reflec_top_table
#define reflec_bottom_table mccPoreH42_reflec_bottom_table
#define ref_prms mccPoreH42_ref_prms
{   /* Declarations of PoreH42=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH42_radius_m;
MCNUM radius_h = mccPoreH42_radius_h;
MCNUM Z0 = mccPoreH42_Z0;
MCNUM xwidth = mccPoreH42_xwidth;
MCNUM yheight = mccPoreH42_yheight;
MCNUM chamferwidth = mccPoreH42_chamferwidth;
char* mirror_reflec = mccPoreH42_mirror_reflec;
char* bottom_reflec = mccPoreH42_bottom_reflec;
char* side_reflec = mccPoreH42_side_reflec;
MCNUM R_d = mccPoreH42_R_d;
MCNUM absorb_sides = mccPoreH42_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 85922 "instruments/plate49.c"
}   /* End of PoreH42=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH43'. */
  SIG_MESSAGE("PoreH43 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH43");
#define mccompcurname  PoreH43
#define mccompcurtype  Pore_h_group
#define mccompcurindex 146
#define nLeft mccPoreH43_nLeft
#define nRight mccPoreH43_nRight
#define nExit mccPoreH43_nExit
#define wLeft mccPoreH43_wLeft
#define wRight mccPoreH43_wRight
#define wExit mccPoreH43_wExit
#define wall mccPoreH43_wall
#define nTop mccPoreH43_nTop
#define nBottom mccPoreH43_nBottom
#define zexit mccPoreH43_zexit
#define zentry mccPoreH43_zentry
#define intersect_wolterI mccPoreH43_intersect_wolterI
#define reflec_side_table mccPoreH43_reflec_side_table
#define reflec_top_table mccPoreH43_reflec_top_table
#define reflec_bottom_table mccPoreH43_reflec_bottom_table
#define ref_prms mccPoreH43_ref_prms
{   /* Declarations of PoreH43=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH43_radius_m;
MCNUM radius_h = mccPoreH43_radius_h;
MCNUM Z0 = mccPoreH43_Z0;
MCNUM xwidth = mccPoreH43_xwidth;
MCNUM yheight = mccPoreH43_yheight;
MCNUM chamferwidth = mccPoreH43_chamferwidth;
char* mirror_reflec = mccPoreH43_mirror_reflec;
char* bottom_reflec = mccPoreH43_bottom_reflec;
char* side_reflec = mccPoreH43_side_reflec;
MCNUM R_d = mccPoreH43_R_d;
MCNUM absorb_sides = mccPoreH43_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 86013 "instruments/plate49.c"
}   /* End of PoreH43=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH44'. */
  SIG_MESSAGE("PoreH44 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH44");
#define mccompcurname  PoreH44
#define mccompcurtype  Pore_h_group
#define mccompcurindex 147
#define nLeft mccPoreH44_nLeft
#define nRight mccPoreH44_nRight
#define nExit mccPoreH44_nExit
#define wLeft mccPoreH44_wLeft
#define wRight mccPoreH44_wRight
#define wExit mccPoreH44_wExit
#define wall mccPoreH44_wall
#define nTop mccPoreH44_nTop
#define nBottom mccPoreH44_nBottom
#define zexit mccPoreH44_zexit
#define zentry mccPoreH44_zentry
#define intersect_wolterI mccPoreH44_intersect_wolterI
#define reflec_side_table mccPoreH44_reflec_side_table
#define reflec_top_table mccPoreH44_reflec_top_table
#define reflec_bottom_table mccPoreH44_reflec_bottom_table
#define ref_prms mccPoreH44_ref_prms
{   /* Declarations of PoreH44=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH44_radius_m;
MCNUM radius_h = mccPoreH44_radius_h;
MCNUM Z0 = mccPoreH44_Z0;
MCNUM xwidth = mccPoreH44_xwidth;
MCNUM yheight = mccPoreH44_yheight;
MCNUM chamferwidth = mccPoreH44_chamferwidth;
char* mirror_reflec = mccPoreH44_mirror_reflec;
char* bottom_reflec = mccPoreH44_bottom_reflec;
char* side_reflec = mccPoreH44_side_reflec;
MCNUM R_d = mccPoreH44_R_d;
MCNUM absorb_sides = mccPoreH44_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 86104 "instruments/plate49.c"
}   /* End of PoreH44=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH45'. */
  SIG_MESSAGE("PoreH45 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH45");
#define mccompcurname  PoreH45
#define mccompcurtype  Pore_h_group
#define mccompcurindex 148
#define nLeft mccPoreH45_nLeft
#define nRight mccPoreH45_nRight
#define nExit mccPoreH45_nExit
#define wLeft mccPoreH45_wLeft
#define wRight mccPoreH45_wRight
#define wExit mccPoreH45_wExit
#define wall mccPoreH45_wall
#define nTop mccPoreH45_nTop
#define nBottom mccPoreH45_nBottom
#define zexit mccPoreH45_zexit
#define zentry mccPoreH45_zentry
#define intersect_wolterI mccPoreH45_intersect_wolterI
#define reflec_side_table mccPoreH45_reflec_side_table
#define reflec_top_table mccPoreH45_reflec_top_table
#define reflec_bottom_table mccPoreH45_reflec_bottom_table
#define ref_prms mccPoreH45_ref_prms
{   /* Declarations of PoreH45=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH45_radius_m;
MCNUM radius_h = mccPoreH45_radius_h;
MCNUM Z0 = mccPoreH45_Z0;
MCNUM xwidth = mccPoreH45_xwidth;
MCNUM yheight = mccPoreH45_yheight;
MCNUM chamferwidth = mccPoreH45_chamferwidth;
char* mirror_reflec = mccPoreH45_mirror_reflec;
char* bottom_reflec = mccPoreH45_bottom_reflec;
char* side_reflec = mccPoreH45_side_reflec;
MCNUM R_d = mccPoreH45_R_d;
MCNUM absorb_sides = mccPoreH45_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 86195 "instruments/plate49.c"
}   /* End of PoreH45=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH46'. */
  SIG_MESSAGE("PoreH46 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH46");
#define mccompcurname  PoreH46
#define mccompcurtype  Pore_h_group
#define mccompcurindex 149
#define nLeft mccPoreH46_nLeft
#define nRight mccPoreH46_nRight
#define nExit mccPoreH46_nExit
#define wLeft mccPoreH46_wLeft
#define wRight mccPoreH46_wRight
#define wExit mccPoreH46_wExit
#define wall mccPoreH46_wall
#define nTop mccPoreH46_nTop
#define nBottom mccPoreH46_nBottom
#define zexit mccPoreH46_zexit
#define zentry mccPoreH46_zentry
#define intersect_wolterI mccPoreH46_intersect_wolterI
#define reflec_side_table mccPoreH46_reflec_side_table
#define reflec_top_table mccPoreH46_reflec_top_table
#define reflec_bottom_table mccPoreH46_reflec_bottom_table
#define ref_prms mccPoreH46_ref_prms
{   /* Declarations of PoreH46=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH46_radius_m;
MCNUM radius_h = mccPoreH46_radius_h;
MCNUM Z0 = mccPoreH46_Z0;
MCNUM xwidth = mccPoreH46_xwidth;
MCNUM yheight = mccPoreH46_yheight;
MCNUM chamferwidth = mccPoreH46_chamferwidth;
char* mirror_reflec = mccPoreH46_mirror_reflec;
char* bottom_reflec = mccPoreH46_bottom_reflec;
char* side_reflec = mccPoreH46_side_reflec;
MCNUM R_d = mccPoreH46_R_d;
MCNUM absorb_sides = mccPoreH46_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 86286 "instruments/plate49.c"
}   /* End of PoreH46=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH47'. */
  SIG_MESSAGE("PoreH47 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH47");
#define mccompcurname  PoreH47
#define mccompcurtype  Pore_h_group
#define mccompcurindex 150
#define nLeft mccPoreH47_nLeft
#define nRight mccPoreH47_nRight
#define nExit mccPoreH47_nExit
#define wLeft mccPoreH47_wLeft
#define wRight mccPoreH47_wRight
#define wExit mccPoreH47_wExit
#define wall mccPoreH47_wall
#define nTop mccPoreH47_nTop
#define nBottom mccPoreH47_nBottom
#define zexit mccPoreH47_zexit
#define zentry mccPoreH47_zentry
#define intersect_wolterI mccPoreH47_intersect_wolterI
#define reflec_side_table mccPoreH47_reflec_side_table
#define reflec_top_table mccPoreH47_reflec_top_table
#define reflec_bottom_table mccPoreH47_reflec_bottom_table
#define ref_prms mccPoreH47_ref_prms
{   /* Declarations of PoreH47=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH47_radius_m;
MCNUM radius_h = mccPoreH47_radius_h;
MCNUM Z0 = mccPoreH47_Z0;
MCNUM xwidth = mccPoreH47_xwidth;
MCNUM yheight = mccPoreH47_yheight;
MCNUM chamferwidth = mccPoreH47_chamferwidth;
char* mirror_reflec = mccPoreH47_mirror_reflec;
char* bottom_reflec = mccPoreH47_bottom_reflec;
char* side_reflec = mccPoreH47_side_reflec;
MCNUM R_d = mccPoreH47_R_d;
MCNUM absorb_sides = mccPoreH47_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 86377 "instruments/plate49.c"
}   /* End of PoreH47=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PoreH48'. */
  SIG_MESSAGE("PoreH48 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PoreH48");
#define mccompcurname  PoreH48
#define mccompcurtype  Pore_h_group
#define mccompcurindex 151
#define nLeft mccPoreH48_nLeft
#define nRight mccPoreH48_nRight
#define nExit mccPoreH48_nExit
#define wLeft mccPoreH48_wLeft
#define wRight mccPoreH48_wRight
#define wExit mccPoreH48_wExit
#define wall mccPoreH48_wall
#define nTop mccPoreH48_nTop
#define nBottom mccPoreH48_nBottom
#define zexit mccPoreH48_zexit
#define zentry mccPoreH48_zentry
#define intersect_wolterI mccPoreH48_intersect_wolterI
#define reflec_side_table mccPoreH48_reflec_side_table
#define reflec_top_table mccPoreH48_reflec_top_table
#define reflec_bottom_table mccPoreH48_reflec_bottom_table
#define ref_prms mccPoreH48_ref_prms
{   /* Declarations of PoreH48=Pore_h_group() SETTING parameters. */
MCNUM radius_m = mccPoreH48_radius_m;
MCNUM radius_h = mccPoreH48_radius_h;
MCNUM Z0 = mccPoreH48_Z0;
MCNUM xwidth = mccPoreH48_xwidth;
MCNUM yheight = mccPoreH48_yheight;
MCNUM chamferwidth = mccPoreH48_chamferwidth;
char* mirror_reflec = mccPoreH48_mirror_reflec;
char* bottom_reflec = mccPoreH48_bottom_reflec;
char* side_reflec = mccPoreH48_side_reflec;
MCNUM R_d = mccPoreH48_R_d;
MCNUM absorb_sides = mccPoreH48_absorb_sides;
#line 366 "Pore_h_group.comp"
{
    int k;
    double dth,theta,t0,t1,inner_h,inner_m;
    const int N=20;

    theta=xwidth/2.0/radius_m;
    inner_m=radius_m-yheight;
    inner_h=radius_h-yheight;

    magnify("");
    line(0,0,0, 0,radius_h-radius_m,zexit); /*this extra line indicates the reflecting surface*/
    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit);

    line( sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    line( sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0,  sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line(-sin(theta)*radius_m, (cos(theta)-1)*radius_m, 0, -sin(theta)*inner_m, cos(theta)*inner_m-radius_m, 0);
    line( sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit,  sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);
    line(-sin(theta)*radius_h, cos(theta)*radius_h-radius_m, zexit, -sin(theta)*inner_h, cos(theta)*inner_h-radius_m, zexit);

    dth=2*theta/N;
    for (k=1;k<N+1;k++){
        t0=-theta+(k-1)*dth;
        t1=-theta+k*dth;
        line( sin(t0)*radius_m, cos(t0)*radius_m-radius_m, 0, sin(t1)*radius_m, cos(t1)*radius_m-radius_m, 0);
        line( sin(t0)*inner_m, cos(t0)*inner_m-radius_m, 0, sin(t1)*inner_m, cos(t1)*inner_m-radius_m, 0);

        line( sin(t0)*radius_h, cos(t0)*radius_h-radius_m, zexit, sin(t1)*radius_h, cos(t1)*radius_h-radius_m, zexit);
        line( sin(t0)*inner_h, cos(t0)*inner_h-radius_m, zexit, sin(t1)*inner_h, cos(t1)*inner_h-radius_m, zexit);
    }

}
#line 86468 "instruments/plate49.c"
}   /* End of PoreH48=Pore_h_group() SETTING parameter declarations. */
#undef ref_prms
#undef reflec_bottom_table
#undef reflec_top_table
#undef reflec_side_table
#undef intersect_wolterI
#undef zentry
#undef zexit
#undef nBottom
#undef nTop
#undef wall
#undef wExit
#undef wRight
#undef wLeft
#undef nExit
#undef nRight
#undef nLeft
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monitorAfter'. */
  SIG_MESSAGE("monitorAfter (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monitorAfter");
#define mccompcurname  monitorAfter
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 152
#define nx mccmonitorAfter_nx
#define ny mccmonitorAfter_ny
#define nr mccmonitorAfter_nr
#define filename mccmonitorAfter_filename
#define restore_xray mccmonitorAfter_restore_xray
#define PSD_N mccmonitorAfter_PSD_N
#define PSD_p mccmonitorAfter_PSD_p
#define PSD_p2 mccmonitorAfter_PSD_p2
#define posx mccmonitorAfter_posx
#define posy mccmonitorAfter_posy
{   /* Declarations of monitorAfter=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccmonitorAfter_xmin;
MCNUM xmax = mccmonitorAfter_xmax;
MCNUM ymin = mccmonitorAfter_ymin;
MCNUM ymax = mccmonitorAfter_ymax;
MCNUM xwidth = mccmonitorAfter_xwidth;
MCNUM yheight = mccmonitorAfter_yheight;
MCNUM radius = mccmonitorAfter_radius;
#line 168 "PSD_monitor_ext.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86523 "instruments/plate49.c"
}   /* End of monitorAfter=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'endMonitorWide'. */
  SIG_MESSAGE("endMonitorWide (McDisplay)");
  printf("MCDISPLAY: component %s\n", "endMonitorWide");
#define mccompcurname  endMonitorWide
#define mccompcurtype  PSD_monitor_ext
#define mccompcurindex 153
#define nx mccendMonitorWide_nx
#define ny mccendMonitorWide_ny
#define nr mccendMonitorWide_nr
#define filename mccendMonitorWide_filename
#define restore_xray mccendMonitorWide_restore_xray
#define PSD_N mccendMonitorWide_PSD_N
#define PSD_p mccendMonitorWide_PSD_p
#define PSD_p2 mccendMonitorWide_PSD_p2
#define posx mccendMonitorWide_posx
#define posy mccendMonitorWide_posy
{   /* Declarations of endMonitorWide=PSD_monitor_ext() SETTING parameters. */
MCNUM xmin = mccendMonitorWide_xmin;
MCNUM xmax = mccendMonitorWide_xmax;
MCNUM ymin = mccendMonitorWide_ymin;
MCNUM ymax = mccendMonitorWide_ymax;
MCNUM xwidth = mccendMonitorWide_xwidth;
MCNUM yheight = mccendMonitorWide_yheight;
MCNUM radius = mccendMonitorWide_radius;
#line 168 "PSD_monitor_ext.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86572 "instruments/plate49.c"
}   /* End of endMonitorWide=PSD_monitor_ext() SETTING parameter declarations. */
#undef posy
#undef posx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef restore_xray
#undef filename
#undef nr
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  printf("MCDISPLAY: end\n");
} /* end display */
#undef magnify
#undef line
#undef dashed_line
#undef multiline
#undef rectangle
#undef box
#undef circle
/* end of generated C code instruments/plate49.c */
